
FreeRTOS_SprintsChallenges_Sprint2_UserStory3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005a5e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000086  00800060  00005a5e  00005af2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000066b  008000e6  008000e6  00005b78  2**0
                  ALLOC
  3 .stab         00009570  00000000  00000000  00005b78  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004bef  00000000  00000000  0000f0e8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 d1 0e 	jmp	0x1da2	; 0x1da2 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e5       	ldi	r30, 0x5E	; 94
      68:	fa e5       	ldi	r31, 0x5A	; 90
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 3e       	cpi	r26, 0xE6	; 230
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a6 ee       	ldi	r26, 0xE6	; 230
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a1 35       	cpi	r26, 0x51	; 81
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <main>
      8a:	0c 94 2d 2d 	jmp	0x5a5a	; 0x5a5a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_WritePin>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_WritePin+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	89 83       	std	Y+1, r24	; 0x01
      9e:	6a 83       	std	Y+2, r22	; 0x02
      a0:	8a 81       	ldd	r24, Y+2	; 0x02
      a2:	81 30       	cpi	r24, 0x01	; 1
      a4:	09 f0       	breq	.+2      	; 0xa8 <DIO_WritePin+0x16>
      a6:	6d c0       	rjmp	.+218    	; 0x182 <DIO_WritePin+0xf0>
      a8:	89 81       	ldd	r24, Y+1	; 0x01
      aa:	88 30       	cpi	r24, 0x08	; 8
      ac:	a0 f4       	brcc	.+40     	; 0xd6 <DIO_WritePin+0x44>
      ae:	ab e3       	ldi	r26, 0x3B	; 59
      b0:	b0 e0       	ldi	r27, 0x00	; 0
      b2:	eb e3       	ldi	r30, 0x3B	; 59
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	80 81       	ld	r24, Z
      b8:	48 2f       	mov	r20, r24
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	28 2f       	mov	r18, r24
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	81 e0       	ldi	r24, 0x01	; 1
      c2:	90 e0       	ldi	r25, 0x00	; 0
      c4:	02 2e       	mov	r0, r18
      c6:	02 c0       	rjmp	.+4      	; 0xcc <DIO_WritePin+0x3a>
      c8:	88 0f       	add	r24, r24
      ca:	99 1f       	adc	r25, r25
      cc:	0a 94       	dec	r0
      ce:	e2 f7       	brpl	.-8      	; 0xc8 <DIO_WritePin+0x36>
      d0:	84 2b       	or	r24, r20
      d2:	8c 93       	st	X, r24
      d4:	c8 c0       	rjmp	.+400    	; 0x266 <DIO_WritePin+0x1d4>
      d6:	89 81       	ldd	r24, Y+1	; 0x01
      d8:	88 30       	cpi	r24, 0x08	; 8
      da:	c8 f0       	brcs	.+50     	; 0x10e <DIO_WritePin+0x7c>
      dc:	89 81       	ldd	r24, Y+1	; 0x01
      de:	80 31       	cpi	r24, 0x10	; 16
      e0:	b0 f4       	brcc	.+44     	; 0x10e <DIO_WritePin+0x7c>
      e2:	a8 e3       	ldi	r26, 0x38	; 56
      e4:	b0 e0       	ldi	r27, 0x00	; 0
      e6:	e8 e3       	ldi	r30, 0x38	; 56
      e8:	f0 e0       	ldi	r31, 0x00	; 0
      ea:	80 81       	ld	r24, Z
      ec:	48 2f       	mov	r20, r24
      ee:	89 81       	ldd	r24, Y+1	; 0x01
      f0:	88 2f       	mov	r24, r24
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	08 97       	sbiw	r24, 0x08	; 8
      f6:	9c 01       	movw	r18, r24
      f8:	81 e0       	ldi	r24, 0x01	; 1
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	02 2e       	mov	r0, r18
      fe:	02 c0       	rjmp	.+4      	; 0x104 <DIO_WritePin+0x72>
     100:	88 0f       	add	r24, r24
     102:	99 1f       	adc	r25, r25
     104:	0a 94       	dec	r0
     106:	e2 f7       	brpl	.-8      	; 0x100 <DIO_WritePin+0x6e>
     108:	84 2b       	or	r24, r20
     10a:	8c 93       	st	X, r24
     10c:	ac c0       	rjmp	.+344    	; 0x266 <DIO_WritePin+0x1d4>
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	80 31       	cpi	r24, 0x10	; 16
     112:	c8 f0       	brcs	.+50     	; 0x146 <DIO_WritePin+0xb4>
     114:	89 81       	ldd	r24, Y+1	; 0x01
     116:	88 31       	cpi	r24, 0x18	; 24
     118:	b0 f4       	brcc	.+44     	; 0x146 <DIO_WritePin+0xb4>
     11a:	a5 e3       	ldi	r26, 0x35	; 53
     11c:	b0 e0       	ldi	r27, 0x00	; 0
     11e:	e5 e3       	ldi	r30, 0x35	; 53
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	80 81       	ld	r24, Z
     124:	48 2f       	mov	r20, r24
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	88 2f       	mov	r24, r24
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	40 97       	sbiw	r24, 0x10	; 16
     12e:	9c 01       	movw	r18, r24
     130:	81 e0       	ldi	r24, 0x01	; 1
     132:	90 e0       	ldi	r25, 0x00	; 0
     134:	02 2e       	mov	r0, r18
     136:	02 c0       	rjmp	.+4      	; 0x13c <DIO_WritePin+0xaa>
     138:	88 0f       	add	r24, r24
     13a:	99 1f       	adc	r25, r25
     13c:	0a 94       	dec	r0
     13e:	e2 f7       	brpl	.-8      	; 0x138 <DIO_WritePin+0xa6>
     140:	84 2b       	or	r24, r20
     142:	8c 93       	st	X, r24
     144:	90 c0       	rjmp	.+288    	; 0x266 <DIO_WritePin+0x1d4>
     146:	89 81       	ldd	r24, Y+1	; 0x01
     148:	88 31       	cpi	r24, 0x18	; 24
     14a:	08 f4       	brcc	.+2      	; 0x14e <DIO_WritePin+0xbc>
     14c:	8c c0       	rjmp	.+280    	; 0x266 <DIO_WritePin+0x1d4>
     14e:	89 81       	ldd	r24, Y+1	; 0x01
     150:	80 32       	cpi	r24, 0x20	; 32
     152:	08 f0       	brcs	.+2      	; 0x156 <DIO_WritePin+0xc4>
     154:	88 c0       	rjmp	.+272    	; 0x266 <DIO_WritePin+0x1d4>
     156:	a2 e3       	ldi	r26, 0x32	; 50
     158:	b0 e0       	ldi	r27, 0x00	; 0
     15a:	e2 e3       	ldi	r30, 0x32	; 50
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	80 81       	ld	r24, Z
     160:	48 2f       	mov	r20, r24
     162:	89 81       	ldd	r24, Y+1	; 0x01
     164:	88 2f       	mov	r24, r24
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	48 97       	sbiw	r24, 0x18	; 24
     16a:	9c 01       	movw	r18, r24
     16c:	81 e0       	ldi	r24, 0x01	; 1
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	02 2e       	mov	r0, r18
     172:	02 c0       	rjmp	.+4      	; 0x178 <DIO_WritePin+0xe6>
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	0a 94       	dec	r0
     17a:	e2 f7       	brpl	.-8      	; 0x174 <DIO_WritePin+0xe2>
     17c:	84 2b       	or	r24, r20
     17e:	8c 93       	st	X, r24
     180:	72 c0       	rjmp	.+228    	; 0x266 <DIO_WritePin+0x1d4>
     182:	8a 81       	ldd	r24, Y+2	; 0x02
     184:	88 23       	and	r24, r24
     186:	09 f0       	breq	.+2      	; 0x18a <DIO_WritePin+0xf8>
     188:	6e c0       	rjmp	.+220    	; 0x266 <DIO_WritePin+0x1d4>
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	88 30       	cpi	r24, 0x08	; 8
     18e:	a8 f4       	brcc	.+42     	; 0x1ba <DIO_WritePin+0x128>
     190:	ab e3       	ldi	r26, 0x3B	; 59
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	eb e3       	ldi	r30, 0x3B	; 59
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	80 81       	ld	r24, Z
     19a:	48 2f       	mov	r20, r24
     19c:	89 81       	ldd	r24, Y+1	; 0x01
     19e:	28 2f       	mov	r18, r24
     1a0:	30 e0       	ldi	r19, 0x00	; 0
     1a2:	81 e0       	ldi	r24, 0x01	; 1
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	02 2e       	mov	r0, r18
     1a8:	02 c0       	rjmp	.+4      	; 0x1ae <DIO_WritePin+0x11c>
     1aa:	88 0f       	add	r24, r24
     1ac:	99 1f       	adc	r25, r25
     1ae:	0a 94       	dec	r0
     1b0:	e2 f7       	brpl	.-8      	; 0x1aa <DIO_WritePin+0x118>
     1b2:	80 95       	com	r24
     1b4:	84 23       	and	r24, r20
     1b6:	8c 93       	st	X, r24
     1b8:	56 c0       	rjmp	.+172    	; 0x266 <DIO_WritePin+0x1d4>
     1ba:	89 81       	ldd	r24, Y+1	; 0x01
     1bc:	88 30       	cpi	r24, 0x08	; 8
     1be:	d0 f0       	brcs	.+52     	; 0x1f4 <DIO_WritePin+0x162>
     1c0:	89 81       	ldd	r24, Y+1	; 0x01
     1c2:	80 31       	cpi	r24, 0x10	; 16
     1c4:	b8 f4       	brcc	.+46     	; 0x1f4 <DIO_WritePin+0x162>
     1c6:	a8 e3       	ldi	r26, 0x38	; 56
     1c8:	b0 e0       	ldi	r27, 0x00	; 0
     1ca:	e8 e3       	ldi	r30, 0x38	; 56
     1cc:	f0 e0       	ldi	r31, 0x00	; 0
     1ce:	80 81       	ld	r24, Z
     1d0:	48 2f       	mov	r20, r24
     1d2:	89 81       	ldd	r24, Y+1	; 0x01
     1d4:	88 2f       	mov	r24, r24
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	08 97       	sbiw	r24, 0x08	; 8
     1da:	9c 01       	movw	r18, r24
     1dc:	81 e0       	ldi	r24, 0x01	; 1
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	02 2e       	mov	r0, r18
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <DIO_WritePin+0x156>
     1e4:	88 0f       	add	r24, r24
     1e6:	99 1f       	adc	r25, r25
     1e8:	0a 94       	dec	r0
     1ea:	e2 f7       	brpl	.-8      	; 0x1e4 <DIO_WritePin+0x152>
     1ec:	80 95       	com	r24
     1ee:	84 23       	and	r24, r20
     1f0:	8c 93       	st	X, r24
     1f2:	39 c0       	rjmp	.+114    	; 0x266 <DIO_WritePin+0x1d4>
     1f4:	89 81       	ldd	r24, Y+1	; 0x01
     1f6:	80 31       	cpi	r24, 0x10	; 16
     1f8:	d0 f0       	brcs	.+52     	; 0x22e <DIO_WritePin+0x19c>
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	88 31       	cpi	r24, 0x18	; 24
     1fe:	b8 f4       	brcc	.+46     	; 0x22e <DIO_WritePin+0x19c>
     200:	a5 e3       	ldi	r26, 0x35	; 53
     202:	b0 e0       	ldi	r27, 0x00	; 0
     204:	e5 e3       	ldi	r30, 0x35	; 53
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	48 2f       	mov	r20, r24
     20c:	89 81       	ldd	r24, Y+1	; 0x01
     20e:	88 2f       	mov	r24, r24
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	40 97       	sbiw	r24, 0x10	; 16
     214:	9c 01       	movw	r18, r24
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	02 2e       	mov	r0, r18
     21c:	02 c0       	rjmp	.+4      	; 0x222 <DIO_WritePin+0x190>
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	0a 94       	dec	r0
     224:	e2 f7       	brpl	.-8      	; 0x21e <DIO_WritePin+0x18c>
     226:	80 95       	com	r24
     228:	84 23       	and	r24, r20
     22a:	8c 93       	st	X, r24
     22c:	1c c0       	rjmp	.+56     	; 0x266 <DIO_WritePin+0x1d4>
     22e:	89 81       	ldd	r24, Y+1	; 0x01
     230:	88 31       	cpi	r24, 0x18	; 24
     232:	c8 f0       	brcs	.+50     	; 0x266 <DIO_WritePin+0x1d4>
     234:	89 81       	ldd	r24, Y+1	; 0x01
     236:	80 32       	cpi	r24, 0x20	; 32
     238:	b0 f4       	brcc	.+44     	; 0x266 <DIO_WritePin+0x1d4>
     23a:	a2 e3       	ldi	r26, 0x32	; 50
     23c:	b0 e0       	ldi	r27, 0x00	; 0
     23e:	e2 e3       	ldi	r30, 0x32	; 50
     240:	f0 e0       	ldi	r31, 0x00	; 0
     242:	80 81       	ld	r24, Z
     244:	48 2f       	mov	r20, r24
     246:	89 81       	ldd	r24, Y+1	; 0x01
     248:	88 2f       	mov	r24, r24
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	48 97       	sbiw	r24, 0x18	; 24
     24e:	9c 01       	movw	r18, r24
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 2e       	mov	r0, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <DIO_WritePin+0x1ca>
     258:	88 0f       	add	r24, r24
     25a:	99 1f       	adc	r25, r25
     25c:	0a 94       	dec	r0
     25e:	e2 f7       	brpl	.-8      	; 0x258 <DIO_WritePin+0x1c6>
     260:	80 95       	com	r24
     262:	84 23       	and	r24, r20
     264:	8c 93       	st	X, r24
     266:	0f 90       	pop	r0
     268:	0f 90       	pop	r0
     26a:	cf 91       	pop	r28
     26c:	df 91       	pop	r29
     26e:	08 95       	ret

00000270 <DIO_ReadPin>:
		}
	}

}
uint8 DIO_ReadPin(uint8 PinNum)
{
     270:	df 93       	push	r29
     272:	cf 93       	push	r28
     274:	00 d0       	rcall	.+0      	; 0x276 <DIO_ReadPin+0x6>
     276:	cd b7       	in	r28, 0x3d	; 61
     278:	de b7       	in	r29, 0x3e	; 62
     27a:	89 83       	std	Y+1, r24	; 0x01
	if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     27c:	89 81       	ldd	r24, Y+1	; 0x01
     27e:	88 30       	cpi	r24, 0x08	; 8
     280:	98 f4       	brcc	.+38     	; 0x2a8 <DIO_ReadPin+0x38>
	{
		return GET_BIT(DIO_PINA,PinNum);
     282:	e9 e3       	ldi	r30, 0x39	; 57
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	80 81       	ld	r24, Z
     288:	28 2f       	mov	r18, r24
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	89 81       	ldd	r24, Y+1	; 0x01
     28e:	88 2f       	mov	r24, r24
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	a9 01       	movw	r20, r18
     294:	02 c0       	rjmp	.+4      	; 0x29a <DIO_ReadPin+0x2a>
     296:	55 95       	asr	r21
     298:	47 95       	ror	r20
     29a:	8a 95       	dec	r24
     29c:	e2 f7       	brpl	.-8      	; 0x296 <DIO_ReadPin+0x26>
     29e:	ca 01       	movw	r24, r20
     2a0:	58 2f       	mov	r21, r24
     2a2:	51 70       	andi	r21, 0x01	; 1
     2a4:	5a 83       	std	Y+2, r21	; 0x02
     2a6:	50 c0       	rjmp	.+160    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     2a8:	89 81       	ldd	r24, Y+1	; 0x01
     2aa:	88 30       	cpi	r24, 0x08	; 8
     2ac:	b8 f0       	brcs	.+46     	; 0x2dc <DIO_ReadPin+0x6c>
     2ae:	89 81       	ldd	r24, Y+1	; 0x01
     2b0:	80 31       	cpi	r24, 0x10	; 16
     2b2:	a0 f4       	brcc	.+40     	; 0x2dc <DIO_ReadPin+0x6c>
	{
		return GET_BIT(DIO_PINB,(PinNum-DIO_PIN8));
     2b4:	e6 e3       	ldi	r30, 0x36	; 54
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	80 81       	ld	r24, Z
     2ba:	28 2f       	mov	r18, r24
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	89 81       	ldd	r24, Y+1	; 0x01
     2c0:	88 2f       	mov	r24, r24
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	08 97       	sbiw	r24, 0x08	; 8
     2c6:	a9 01       	movw	r20, r18
     2c8:	02 c0       	rjmp	.+4      	; 0x2ce <DIO_ReadPin+0x5e>
     2ca:	55 95       	asr	r21
     2cc:	47 95       	ror	r20
     2ce:	8a 95       	dec	r24
     2d0:	e2 f7       	brpl	.-8      	; 0x2ca <DIO_ReadPin+0x5a>
     2d2:	ca 01       	movw	r24, r20
     2d4:	58 2f       	mov	r21, r24
     2d6:	51 70       	andi	r21, 0x01	; 1
     2d8:	5a 83       	std	Y+2, r21	; 0x02
     2da:	36 c0       	rjmp	.+108    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	80 31       	cpi	r24, 0x10	; 16
     2e0:	b8 f0       	brcs	.+46     	; 0x310 <DIO_ReadPin+0xa0>
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	88 31       	cpi	r24, 0x18	; 24
     2e6:	a0 f4       	brcc	.+40     	; 0x310 <DIO_ReadPin+0xa0>
	{
		return GET_BIT(DIO_PINC,(PinNum-DIO_PIN16));
     2e8:	e3 e3       	ldi	r30, 0x33	; 51
     2ea:	f0 e0       	ldi	r31, 0x00	; 0
     2ec:	80 81       	ld	r24, Z
     2ee:	28 2f       	mov	r18, r24
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	89 81       	ldd	r24, Y+1	; 0x01
     2f4:	88 2f       	mov	r24, r24
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	40 97       	sbiw	r24, 0x10	; 16
     2fa:	a9 01       	movw	r20, r18
     2fc:	02 c0       	rjmp	.+4      	; 0x302 <DIO_ReadPin+0x92>
     2fe:	55 95       	asr	r21
     300:	47 95       	ror	r20
     302:	8a 95       	dec	r24
     304:	e2 f7       	brpl	.-8      	; 0x2fe <DIO_ReadPin+0x8e>
     306:	ca 01       	movw	r24, r20
     308:	58 2f       	mov	r21, r24
     30a:	51 70       	andi	r21, 0x01	; 1
     30c:	5a 83       	std	Y+2, r21	; 0x02
     30e:	1c c0       	rjmp	.+56     	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     310:	89 81       	ldd	r24, Y+1	; 0x01
     312:	88 31       	cpi	r24, 0x18	; 24
     314:	b8 f0       	brcs	.+46     	; 0x344 <DIO_ReadPin+0xd4>
     316:	89 81       	ldd	r24, Y+1	; 0x01
     318:	80 32       	cpi	r24, 0x20	; 32
     31a:	a0 f4       	brcc	.+40     	; 0x344 <DIO_ReadPin+0xd4>
	{
		return GET_BIT(DIO_PIND,(PinNum-DIO_PIN24));
     31c:	e0 e3       	ldi	r30, 0x30	; 48
     31e:	f0 e0       	ldi	r31, 0x00	; 0
     320:	80 81       	ld	r24, Z
     322:	28 2f       	mov	r18, r24
     324:	30 e0       	ldi	r19, 0x00	; 0
     326:	89 81       	ldd	r24, Y+1	; 0x01
     328:	88 2f       	mov	r24, r24
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	48 97       	sbiw	r24, 0x18	; 24
     32e:	a9 01       	movw	r20, r18
     330:	02 c0       	rjmp	.+4      	; 0x336 <DIO_ReadPin+0xc6>
     332:	55 95       	asr	r21
     334:	47 95       	ror	r20
     336:	8a 95       	dec	r24
     338:	e2 f7       	brpl	.-8      	; 0x332 <DIO_ReadPin+0xc2>
     33a:	ca 01       	movw	r24, r20
     33c:	58 2f       	mov	r21, r24
     33e:	51 70       	andi	r21, 0x01	; 1
     340:	5a 83       	std	Y+2, r21	; 0x02
     342:	02 c0       	rjmp	.+4      	; 0x348 <DIO_ReadPin+0xd8>
	}
	return DIO_PIN8;
     344:	88 e0       	ldi	r24, 0x08	; 8
     346:	8a 83       	std	Y+2, r24	; 0x02
     348:	8a 81       	ldd	r24, Y+2	; 0x02
}
     34a:	0f 90       	pop	r0
     34c:	0f 90       	pop	r0
     34e:	cf 91       	pop	r28
     350:	df 91       	pop	r29
     352:	08 95       	ret

00000354 <DIO_SetPinDirection>:
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection)
{
     354:	df 93       	push	r29
     356:	cf 93       	push	r28
     358:	00 d0       	rcall	.+0      	; 0x35a <DIO_SetPinDirection+0x6>
     35a:	cd b7       	in	r28, 0x3d	; 61
     35c:	de b7       	in	r29, 0x3e	; 62
     35e:	89 83       	std	Y+1, r24	; 0x01
     360:	6a 83       	std	Y+2, r22	; 0x02
	if(PinDirection==INPUT)
     362:	8a 81       	ldd	r24, Y+2	; 0x02
     364:	88 23       	and	r24, r24
     366:	09 f0       	breq	.+2      	; 0x36a <DIO_SetPinDirection+0x16>
     368:	71 c0       	rjmp	.+226    	; 0x44c <DIO_SetPinDirection+0xf8>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     36a:	89 81       	ldd	r24, Y+1	; 0x01
     36c:	88 30       	cpi	r24, 0x08	; 8
     36e:	a8 f4       	brcc	.+42     	; 0x39a <DIO_SetPinDirection+0x46>
		{
			CLEAR_BIT(DIO_DDRA,PinNum);
     370:	aa e3       	ldi	r26, 0x3A	; 58
     372:	b0 e0       	ldi	r27, 0x00	; 0
     374:	ea e3       	ldi	r30, 0x3A	; 58
     376:	f0 e0       	ldi	r31, 0x00	; 0
     378:	80 81       	ld	r24, Z
     37a:	48 2f       	mov	r20, r24
     37c:	89 81       	ldd	r24, Y+1	; 0x01
     37e:	28 2f       	mov	r18, r24
     380:	30 e0       	ldi	r19, 0x00	; 0
     382:	81 e0       	ldi	r24, 0x01	; 1
     384:	90 e0       	ldi	r25, 0x00	; 0
     386:	02 2e       	mov	r0, r18
     388:	02 c0       	rjmp	.+4      	; 0x38e <DIO_SetPinDirection+0x3a>
     38a:	88 0f       	add	r24, r24
     38c:	99 1f       	adc	r25, r25
     38e:	0a 94       	dec	r0
     390:	e2 f7       	brpl	.-8      	; 0x38a <DIO_SetPinDirection+0x36>
     392:	80 95       	com	r24
     394:	84 23       	and	r24, r20
     396:	8c 93       	st	X, r24
     398:	c7 c0       	rjmp	.+398    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     39a:	89 81       	ldd	r24, Y+1	; 0x01
     39c:	88 30       	cpi	r24, 0x08	; 8
     39e:	d0 f0       	brcs	.+52     	; 0x3d4 <DIO_SetPinDirection+0x80>
     3a0:	89 81       	ldd	r24, Y+1	; 0x01
     3a2:	80 31       	cpi	r24, 0x10	; 16
     3a4:	b8 f4       	brcc	.+46     	; 0x3d4 <DIO_SetPinDirection+0x80>
		{
			CLEAR_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     3a6:	a7 e3       	ldi	r26, 0x37	; 55
     3a8:	b0 e0       	ldi	r27, 0x00	; 0
     3aa:	e7 e3       	ldi	r30, 0x37	; 55
     3ac:	f0 e0       	ldi	r31, 0x00	; 0
     3ae:	80 81       	ld	r24, Z
     3b0:	48 2f       	mov	r20, r24
     3b2:	89 81       	ldd	r24, Y+1	; 0x01
     3b4:	88 2f       	mov	r24, r24
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	08 97       	sbiw	r24, 0x08	; 8
     3ba:	9c 01       	movw	r18, r24
     3bc:	81 e0       	ldi	r24, 0x01	; 1
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	02 2e       	mov	r0, r18
     3c2:	02 c0       	rjmp	.+4      	; 0x3c8 <DIO_SetPinDirection+0x74>
     3c4:	88 0f       	add	r24, r24
     3c6:	99 1f       	adc	r25, r25
     3c8:	0a 94       	dec	r0
     3ca:	e2 f7       	brpl	.-8      	; 0x3c4 <DIO_SetPinDirection+0x70>
     3cc:	80 95       	com	r24
     3ce:	84 23       	and	r24, r20
     3d0:	8c 93       	st	X, r24
     3d2:	aa c0       	rjmp	.+340    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     3d4:	89 81       	ldd	r24, Y+1	; 0x01
     3d6:	80 31       	cpi	r24, 0x10	; 16
     3d8:	d0 f0       	brcs	.+52     	; 0x40e <DIO_SetPinDirection+0xba>
     3da:	89 81       	ldd	r24, Y+1	; 0x01
     3dc:	88 31       	cpi	r24, 0x18	; 24
     3de:	b8 f4       	brcc	.+46     	; 0x40e <DIO_SetPinDirection+0xba>
		{
			CLEAR_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     3e0:	a4 e3       	ldi	r26, 0x34	; 52
     3e2:	b0 e0       	ldi	r27, 0x00	; 0
     3e4:	e4 e3       	ldi	r30, 0x34	; 52
     3e6:	f0 e0       	ldi	r31, 0x00	; 0
     3e8:	80 81       	ld	r24, Z
     3ea:	48 2f       	mov	r20, r24
     3ec:	89 81       	ldd	r24, Y+1	; 0x01
     3ee:	88 2f       	mov	r24, r24
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	40 97       	sbiw	r24, 0x10	; 16
     3f4:	9c 01       	movw	r18, r24
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	02 2e       	mov	r0, r18
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <DIO_SetPinDirection+0xae>
     3fe:	88 0f       	add	r24, r24
     400:	99 1f       	adc	r25, r25
     402:	0a 94       	dec	r0
     404:	e2 f7       	brpl	.-8      	; 0x3fe <DIO_SetPinDirection+0xaa>
     406:	80 95       	com	r24
     408:	84 23       	and	r24, r20
     40a:	8c 93       	st	X, r24
     40c:	8d c0       	rjmp	.+282    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     40e:	89 81       	ldd	r24, Y+1	; 0x01
     410:	88 31       	cpi	r24, 0x18	; 24
     412:	08 f4       	brcc	.+2      	; 0x416 <DIO_SetPinDirection+0xc2>
     414:	89 c0       	rjmp	.+274    	; 0x528 <DIO_SetPinDirection+0x1d4>
     416:	89 81       	ldd	r24, Y+1	; 0x01
     418:	80 32       	cpi	r24, 0x20	; 32
     41a:	08 f0       	brcs	.+2      	; 0x41e <DIO_SetPinDirection+0xca>
     41c:	85 c0       	rjmp	.+266    	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			CLEAR_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     41e:	a1 e3       	ldi	r26, 0x31	; 49
     420:	b0 e0       	ldi	r27, 0x00	; 0
     422:	e1 e3       	ldi	r30, 0x31	; 49
     424:	f0 e0       	ldi	r31, 0x00	; 0
     426:	80 81       	ld	r24, Z
     428:	48 2f       	mov	r20, r24
     42a:	89 81       	ldd	r24, Y+1	; 0x01
     42c:	88 2f       	mov	r24, r24
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	48 97       	sbiw	r24, 0x18	; 24
     432:	9c 01       	movw	r18, r24
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	02 2e       	mov	r0, r18
     43a:	02 c0       	rjmp	.+4      	; 0x440 <DIO_SetPinDirection+0xec>
     43c:	88 0f       	add	r24, r24
     43e:	99 1f       	adc	r25, r25
     440:	0a 94       	dec	r0
     442:	e2 f7       	brpl	.-8      	; 0x43c <DIO_SetPinDirection+0xe8>
     444:	80 95       	com	r24
     446:	84 23       	and	r24, r20
     448:	8c 93       	st	X, r24
     44a:	6e c0       	rjmp	.+220    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
	}
	else if(PinDirection==OUTPUT)
     44c:	8a 81       	ldd	r24, Y+2	; 0x02
     44e:	81 30       	cpi	r24, 0x01	; 1
     450:	09 f0       	breq	.+2      	; 0x454 <DIO_SetPinDirection+0x100>
     452:	6a c0       	rjmp	.+212    	; 0x528 <DIO_SetPinDirection+0x1d4>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	88 30       	cpi	r24, 0x08	; 8
     458:	a0 f4       	brcc	.+40     	; 0x482 <DIO_SetPinDirection+0x12e>
		{
			SET_BIT(DIO_DDRA,PinNum);
     45a:	aa e3       	ldi	r26, 0x3A	; 58
     45c:	b0 e0       	ldi	r27, 0x00	; 0
     45e:	ea e3       	ldi	r30, 0x3A	; 58
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	80 81       	ld	r24, Z
     464:	48 2f       	mov	r20, r24
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	28 2f       	mov	r18, r24
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	02 2e       	mov	r0, r18
     472:	02 c0       	rjmp	.+4      	; 0x478 <DIO_SetPinDirection+0x124>
     474:	88 0f       	add	r24, r24
     476:	99 1f       	adc	r25, r25
     478:	0a 94       	dec	r0
     47a:	e2 f7       	brpl	.-8      	; 0x474 <DIO_SetPinDirection+0x120>
     47c:	84 2b       	or	r24, r20
     47e:	8c 93       	st	X, r24
     480:	53 c0       	rjmp	.+166    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     482:	89 81       	ldd	r24, Y+1	; 0x01
     484:	88 30       	cpi	r24, 0x08	; 8
     486:	c8 f0       	brcs	.+50     	; 0x4ba <DIO_SetPinDirection+0x166>
     488:	89 81       	ldd	r24, Y+1	; 0x01
     48a:	80 31       	cpi	r24, 0x10	; 16
     48c:	b0 f4       	brcc	.+44     	; 0x4ba <DIO_SetPinDirection+0x166>
		{
			SET_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     48e:	a7 e3       	ldi	r26, 0x37	; 55
     490:	b0 e0       	ldi	r27, 0x00	; 0
     492:	e7 e3       	ldi	r30, 0x37	; 55
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	80 81       	ld	r24, Z
     498:	48 2f       	mov	r20, r24
     49a:	89 81       	ldd	r24, Y+1	; 0x01
     49c:	88 2f       	mov	r24, r24
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	08 97       	sbiw	r24, 0x08	; 8
     4a2:	9c 01       	movw	r18, r24
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	02 2e       	mov	r0, r18
     4aa:	02 c0       	rjmp	.+4      	; 0x4b0 <DIO_SetPinDirection+0x15c>
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	0a 94       	dec	r0
     4b2:	e2 f7       	brpl	.-8      	; 0x4ac <DIO_SetPinDirection+0x158>
     4b4:	84 2b       	or	r24, r20
     4b6:	8c 93       	st	X, r24
     4b8:	37 c0       	rjmp	.+110    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     4ba:	89 81       	ldd	r24, Y+1	; 0x01
     4bc:	80 31       	cpi	r24, 0x10	; 16
     4be:	c8 f0       	brcs	.+50     	; 0x4f2 <DIO_SetPinDirection+0x19e>
     4c0:	89 81       	ldd	r24, Y+1	; 0x01
     4c2:	88 31       	cpi	r24, 0x18	; 24
     4c4:	b0 f4       	brcc	.+44     	; 0x4f2 <DIO_SetPinDirection+0x19e>
		{
			SET_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     4c6:	a4 e3       	ldi	r26, 0x34	; 52
     4c8:	b0 e0       	ldi	r27, 0x00	; 0
     4ca:	e4 e3       	ldi	r30, 0x34	; 52
     4cc:	f0 e0       	ldi	r31, 0x00	; 0
     4ce:	80 81       	ld	r24, Z
     4d0:	48 2f       	mov	r20, r24
     4d2:	89 81       	ldd	r24, Y+1	; 0x01
     4d4:	88 2f       	mov	r24, r24
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	40 97       	sbiw	r24, 0x10	; 16
     4da:	9c 01       	movw	r18, r24
     4dc:	81 e0       	ldi	r24, 0x01	; 1
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	02 2e       	mov	r0, r18
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_SetPinDirection+0x194>
     4e4:	88 0f       	add	r24, r24
     4e6:	99 1f       	adc	r25, r25
     4e8:	0a 94       	dec	r0
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_SetPinDirection+0x190>
     4ec:	84 2b       	or	r24, r20
     4ee:	8c 93       	st	X, r24
     4f0:	1b c0       	rjmp	.+54     	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     4f2:	89 81       	ldd	r24, Y+1	; 0x01
     4f4:	88 31       	cpi	r24, 0x18	; 24
     4f6:	c0 f0       	brcs	.+48     	; 0x528 <DIO_SetPinDirection+0x1d4>
     4f8:	89 81       	ldd	r24, Y+1	; 0x01
     4fa:	80 32       	cpi	r24, 0x20	; 32
     4fc:	a8 f4       	brcc	.+42     	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			SET_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     4fe:	a1 e3       	ldi	r26, 0x31	; 49
     500:	b0 e0       	ldi	r27, 0x00	; 0
     502:	e1 e3       	ldi	r30, 0x31	; 49
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	48 2f       	mov	r20, r24
     50a:	89 81       	ldd	r24, Y+1	; 0x01
     50c:	88 2f       	mov	r24, r24
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	48 97       	sbiw	r24, 0x18	; 24
     512:	9c 01       	movw	r18, r24
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 2e       	mov	r0, r18
     51a:	02 c0       	rjmp	.+4      	; 0x520 <DIO_SetPinDirection+0x1cc>
     51c:	88 0f       	add	r24, r24
     51e:	99 1f       	adc	r25, r25
     520:	0a 94       	dec	r0
     522:	e2 f7       	brpl	.-8      	; 0x51c <DIO_SetPinDirection+0x1c8>
     524:	84 2b       	or	r24, r20
     526:	8c 93       	st	X, r24
		}
	}


}
     528:	0f 90       	pop	r0
     52a:	0f 90       	pop	r0
     52c:	cf 91       	pop	r28
     52e:	df 91       	pop	r29
     530:	08 95       	ret

00000532 <PushButton_Init>:
 * Outputs:         NULL
 *
 * Return:          NULL
 *******************************************************************************/
void PushButton_Init(void)
{
     532:	df 93       	push	r29
     534:	cf 93       	push	r28
     536:	cd b7       	in	r28, 0x3d	; 61
     538:	de b7       	in	r29, 0x3e	; 62
    /*set Pins Of Push Button*/
    DIO_SetPinDirection(DIO_PIN10 , INPUT);
     53a:	8a e0       	ldi	r24, 0x0A	; 10
     53c:	60 e0       	ldi	r22, 0x00	; 0
     53e:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
    DIO_SetPinDirection(DIO_PIN20 , INPUT);
     542:	84 e1       	ldi	r24, 0x14	; 20
     544:	60 e0       	ldi	r22, 0x00	; 0
     546:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>


}
     54a:	cf 91       	pop	r28
     54c:	df 91       	pop	r29
     54e:	08 95       	ret

00000550 <Buttons_getPressedButton>:
 * Outputs:         NULL
 *
 * Return:          pressed Push Button (uint8_t)
 *******************************************************************************/
uint8 Buttons_getPressedButton(void)
{
     550:	df 93       	push	r29
     552:	cf 93       	push	r28
     554:	0f 92       	push	r0
     556:	cd b7       	in	r28, 0x3d	; 61
     558:	de b7       	in	r29, 0x3e	; 62
    /*return value*/
    uint8 ReturnVal=10;
     55a:	8a e0       	ldi	r24, 0x0A	; 10
     55c:	89 83       	std	Y+1, r24	; 0x01


    /*Loop to check if button is pressed to return its value*/

    if(DIO_ReadPin(DIO_PIN10) == 1)
     55e:	8a e0       	ldi	r24, 0x0A	; 10
     560:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     564:	81 30       	cpi	r24, 0x01	; 1
     566:	19 f4       	brne	.+6      	; 0x56e <Buttons_getPressedButton+0x1e>
    {
        ReturnVal = 2;
     568:	82 e0       	ldi	r24, 0x02	; 2
     56a:	89 83       	std	Y+1, r24	; 0x01
     56c:	07 c0       	rjmp	.+14     	; 0x57c <Buttons_getPressedButton+0x2c>
    }
    else if(DIO_ReadPin(DIO_PIN20) == 1)
     56e:	84 e1       	ldi	r24, 0x14	; 20
     570:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     574:	81 30       	cpi	r24, 0x01	; 1
     576:	11 f4       	brne	.+4      	; 0x57c <Buttons_getPressedButton+0x2c>
    {
        ReturnVal = 1;
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	89 83       	std	Y+1, r24	; 0x01
    }
    else
    {
        /*Do Nothing*/
    }
    return ReturnVal;
     57c:	89 81       	ldd	r24, Y+1	; 0x01
}
     57e:	0f 90       	pop	r0
     580:	cf 91       	pop	r28
     582:	df 91       	pop	r29
     584:	08 95       	ret

00000586 <init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void init_Task(void * a_Task_ptr)
{
     586:	ef 92       	push	r14
     588:	ff 92       	push	r15
     58a:	0f 93       	push	r16
     58c:	df 93       	push	r29
     58e:	cf 93       	push	r28
     590:	00 d0       	rcall	.+0      	; 0x592 <init_Task+0xc>
     592:	cd b7       	in	r28, 0x3d	; 61
     594:	de b7       	in	r29, 0x3e	; 62
     596:	9a 83       	std	Y+2, r25	; 0x02
     598:	89 83       	std	Y+1, r24	; 0x01
	/*Create Queues*/
	Queue_PushButton_A = xQueueCreate( 3 , sizeof(uint8) );
     59a:	83 e0       	ldi	r24, 0x03	; 3
     59c:	61 e0       	ldi	r22, 0x01	; 1
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <xQueueGenericCreate>
     5a4:	90 93 eb 00 	sts	0x00EB, r25
     5a8:	80 93 ea 00 	sts	0x00EA, r24
	Queue_PushButton_B = xQueueCreate( 3 , sizeof(uint8) );
     5ac:	83 e0       	ldi	r24, 0x03	; 3
     5ae:	61 e0       	ldi	r22, 0x01	; 1
     5b0:	40 e0       	ldi	r20, 0x00	; 0
     5b2:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <xQueueGenericCreate>
     5b6:	90 93 ed 00 	sts	0x00ED, r25
     5ba:	80 93 ec 00 	sts	0x00EC, r24

	/**/
	FirstButtonPressed = xSemaphoreCreateMutex();
     5be:	81 e0       	ldi	r24, 0x01	; 1
     5c0:	0e 94 0a 10 	call	0x2014	; 0x2014 <xQueueCreateMutex>
     5c4:	90 93 50 07 	sts	0x0750, r25
     5c8:	80 93 4f 07 	sts	0x074F, r24



	/*Create 3 Tasks*/
	xTaskCreate(All_Hardware_Init_Task  , "InitTasks" , configMINIMAL_STACK_SIZE ,
     5cc:	8d e2       	ldi	r24, 0x2D	; 45
     5ce:	93 e0       	ldi	r25, 0x03	; 3
     5d0:	20 e6       	ldi	r18, 0x60	; 96
     5d2:	30 e0       	ldi	r19, 0x00	; 0
     5d4:	e6 ee       	ldi	r30, 0xE6	; 230
     5d6:	f0 e0       	ldi	r31, 0x00	; 0
     5d8:	b9 01       	movw	r22, r18
     5da:	46 e9       	ldi	r20, 0x96	; 150
     5dc:	50 e0       	ldi	r21, 0x00	; 0
     5de:	20 e0       	ldi	r18, 0x00	; 0
     5e0:	30 e0       	ldi	r19, 0x00	; 0
     5e2:	06 e0       	ldi	r16, 0x06	; 6
     5e4:	7f 01       	movw	r14, r30
     5e6:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskCreate>
			NULL , (6 | portPRIVILEGE_BIT) , &AllHardwareInit_Flag);
	xTaskCreate(PushButtonA_Task  , "PushButtonA_Task" , configMINIMAL_STACK_SIZE ,
     5ea:	83 e4       	ldi	r24, 0x43	; 67
     5ec:	93 e0       	ldi	r25, 0x03	; 3
     5ee:	2a e6       	ldi	r18, 0x6A	; 106
     5f0:	30 e0       	ldi	r19, 0x00	; 0
     5f2:	b9 01       	movw	r22, r18
     5f4:	46 e9       	ldi	r20, 0x96	; 150
     5f6:	50 e0       	ldi	r21, 0x00	; 0
     5f8:	20 e0       	ldi	r18, 0x00	; 0
     5fa:	30 e0       	ldi	r19, 0x00	; 0
     5fc:	04 e0       	ldi	r16, 0x04	; 4
     5fe:	ee 24       	eor	r14, r14
     600:	ff 24       	eor	r15, r15
     602:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskCreate>
			NULL , (4 | portPRIVILEGE_BIT) , NULL);
	xTaskCreate(PushButtonB_Task  , "PushButtonB_Task" , configMINIMAL_STACK_SIZE ,
     606:	8a ec       	ldi	r24, 0xCA	; 202
     608:	93 e0       	ldi	r25, 0x03	; 3
     60a:	2b e7       	ldi	r18, 0x7B	; 123
     60c:	30 e0       	ldi	r19, 0x00	; 0
     60e:	b9 01       	movw	r22, r18
     610:	46 e9       	ldi	r20, 0x96	; 150
     612:	50 e0       	ldi	r21, 0x00	; 0
     614:	20 e0       	ldi	r18, 0x00	; 0
     616:	30 e0       	ldi	r19, 0x00	; 0
     618:	03 e0       	ldi	r16, 0x03	; 3
     61a:	ee 24       	eor	r14, r14
     61c:	ff 24       	eor	r15, r15
     61e:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskCreate>
			NULL , (3 | portPRIVILEGE_BIT) , NULL);
	/*xTaskCreate(LED_Task  , "LED_Task" , 50 ,
			NULL , (2 | portPRIVILEGE_BIT) , NULL);*/
	xTaskCreate(LCD_Task  , "LCD_Task" , configMINIMAL_STACK_SIZE ,
     622:	81 e5       	ldi	r24, 0x51	; 81
     624:	94 e0       	ldi	r25, 0x04	; 4
     626:	2c e8       	ldi	r18, 0x8C	; 140
     628:	30 e0       	ldi	r19, 0x00	; 0
     62a:	b9 01       	movw	r22, r18
     62c:	46 e9       	ldi	r20, 0x96	; 150
     62e:	50 e0       	ldi	r21, 0x00	; 0
     630:	20 e0       	ldi	r18, 0x00	; 0
     632:	30 e0       	ldi	r19, 0x00	; 0
     634:	02 e0       	ldi	r16, 0x02	; 2
     636:	ee 24       	eor	r14, r14
     638:	ff 24       	eor	r15, r15
     63a:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskCreate>
			NULL , (2 | portPRIVILEGE_BIT) , NULL);
	vTaskSuspend( InitTask_Flag);
     63e:	80 91 e8 00 	lds	r24, 0x00E8
     642:	90 91 e9 00 	lds	r25, 0x00E9
     646:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <vTaskSuspend>
}
     64a:	0f 90       	pop	r0
     64c:	0f 90       	pop	r0
     64e:	cf 91       	pop	r28
     650:	df 91       	pop	r29
     652:	0f 91       	pop	r16
     654:	ff 90       	pop	r15
     656:	ef 90       	pop	r14
     658:	08 95       	ret

0000065a <All_Hardware_Init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void All_Hardware_Init_Task(void * a_Task_ptr)
{
     65a:	df 93       	push	r29
     65c:	cf 93       	push	r28
     65e:	00 d0       	rcall	.+0      	; 0x660 <All_Hardware_Init_Task+0x6>
     660:	cd b7       	in	r28, 0x3d	; 61
     662:	de b7       	in	r29, 0x3e	; 62
     664:	9a 83       	std	Y+2, r25	; 0x02
     666:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		PushButton_Init();
     668:	0e 94 99 02 	call	0x532	; 0x532 <PushButton_Init>
		LCD_init();
     66c:	0e 94 24 09 	call	0x1248	; 0x1248 <LCD_init>
		DIO_SetPinDirection(DIO_PIN13,OUTPUT);
     670:	8d e0       	ldi	r24, 0x0D	; 13
     672:	61 e0       	ldi	r22, 0x01	; 1
     674:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>

		vTaskSuspend( AllHardwareInit_Flag);
     678:	80 91 e6 00 	lds	r24, 0x00E6
     67c:	90 91 e7 00 	lds	r25, 0x00E7
     680:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <vTaskSuspend>
     684:	f1 cf       	rjmp	.-30     	; 0x668 <All_Hardware_Init_Task+0xe>

00000686 <PushButtonA_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void PushButtonA_Task(void * a_Task_ptr)
{
     686:	df 93       	push	r29
     688:	cf 93       	push	r28
     68a:	00 d0       	rcall	.+0      	; 0x68c <PushButtonA_Task+0x6>
     68c:	00 d0       	rcall	.+0      	; 0x68e <PushButtonA_Task+0x8>
     68e:	0f 92       	push	r0
     690:	cd b7       	in	r28, 0x3d	; 61
     692:	de b7       	in	r29, 0x3e	; 62
     694:	9d 83       	std	Y+5, r25	; 0x05
     696:	8c 83       	std	Y+4, r24	; 0x04
	vTaskDelay(50);
     698:	82 e3       	ldi	r24, 0x32	; 50
     69a:	90 e0       	ldi	r25, 0x00	; 0
     69c:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 1;
     6a0:	81 e0       	ldi	r24, 0x01	; 1
     6a2:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     6a4:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     6a6:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*Check if Button is pressed and enable de_bouncing*/
		if(Debouncing == 0 && Buttons_getPressedButton()==2)
     6a8:	8a 81       	ldd	r24, Y+2	; 0x02
     6aa:	88 23       	and	r24, r24
     6ac:	79 f4       	brne	.+30     	; 0x6cc <PushButtonA_Task+0x46>
     6ae:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     6b2:	82 30       	cpi	r24, 0x02	; 2
     6b4:	59 f4       	brne	.+22     	; 0x6cc <PushButtonA_Task+0x46>
		{
			OldPressedValue =  Buttons_getPressedButton();
     6b6:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     6ba:	89 83       	std	Y+1, r24	; 0x01
			Debouncing++;
     6bc:	8a 81       	ldd	r24, Y+2	; 0x02
     6be:	8f 5f       	subi	r24, 0xFF	; 255
     6c0:	8a 83       	std	Y+2, r24	; 0x02
			/*de_bouncing Delay*/
			vTaskDelay(10);
     6c2:	8a e0       	ldi	r24, 0x0A	; 10
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
     6ca:	ee cf       	rjmp	.-36     	; 0x6a8 <PushButtonA_Task+0x22>
		}
		else if(Debouncing == 1)
     6cc:	8a 81       	ldd	r24, Y+2	; 0x02
     6ce:	81 30       	cpi	r24, 0x01	; 1
     6d0:	59 f5       	brne	.+86     	; 0x728 <PushButtonA_Task+0xa2>
     6d2:	1d c0       	rjmp	.+58     	; 0x70e <PushButtonA_Task+0x88>
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
			{
				if (xSemaphoreTake(FirstButtonPressed , 10))
     6d4:	80 91 4f 07 	lds	r24, 0x074F
     6d8:	90 91 50 07 	lds	r25, 0x0750
     6dc:	6a e0       	ldi	r22, 0x0A	; 10
     6de:	70 e0       	ldi	r23, 0x00	; 0
     6e0:	0e 94 2a 12 	call	0x2454	; 0x2454 <xQueueSemaphoreTake>
     6e4:	88 23       	and	r24, r24
     6e6:	99 f0       	breq	.+38     	; 0x70e <PushButtonA_Task+0x88>
				{

					SendData = 1;
     6e8:	81 e0       	ldi	r24, 0x01	; 1
     6ea:	8b 83       	std	Y+3, r24	; 0x03
					/*Send push Button was pressed to Lcd by queue*/
					xQueueSend(Queue_PushButton_A , &SendData , 100);
     6ec:	80 91 ea 00 	lds	r24, 0x00EA
     6f0:	90 91 eb 00 	lds	r25, 0x00EB
     6f4:	9e 01       	movw	r18, r28
     6f6:	2d 5f       	subi	r18, 0xFD	; 253
     6f8:	3f 4f       	sbci	r19, 0xFF	; 255
     6fa:	b9 01       	movw	r22, r18
     6fc:	44 e6       	ldi	r20, 0x64	; 100
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	20 e0       	ldi	r18, 0x00	; 0
     702:	0e 94 2a 10 	call	0x2054	; 0x2054 <xQueueGenericSend>
					vTaskDelay(20);
     706:	84 e1       	ldi	r24, 0x14	; 20
     708:	90 e0       	ldi	r25, 0x00	; 0
     70a:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
			vTaskDelay(10);
		}
		else if(Debouncing == 1)
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
     70e:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     712:	98 2f       	mov	r25, r24
     714:	89 81       	ldd	r24, Y+1	; 0x01
     716:	98 17       	cp	r25, r24
     718:	e9 f2       	breq	.-70     	; 0x6d4 <PushButtonA_Task+0x4e>
					/*Send push Button was pressed to Lcd by queue*/
					xQueueSend(Queue_PushButton_A , &SendData , 100);
					vTaskDelay(20);
				}
			}
			Debouncing = 2;
     71a:	82 e0       	ldi	r24, 0x02	; 2
     71c:	8a 83       	std	Y+2, r24	; 0x02
			vTaskDelay(20);
     71e:	84 e1       	ldi	r24, 0x14	; 20
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
     726:	c0 cf       	rjmp	.-128    	; 0x6a8 <PushButtonA_Task+0x22>
		}
		else if(Debouncing == 2)
     728:	8a 81       	ldd	r24, Y+2	; 0x02
     72a:	82 30       	cpi	r24, 0x02	; 2
     72c:	f9 f4       	brne	.+62     	; 0x76c <PushButtonA_Task+0xe6>
		{
			xSemaphoreGive(FirstButtonPressed);
     72e:	80 91 4f 07 	lds	r24, 0x074F
     732:	90 91 50 07 	lds	r25, 0x0750
     736:	60 e0       	ldi	r22, 0x00	; 0
     738:	70 e0       	ldi	r23, 0x00	; 0
     73a:	40 e0       	ldi	r20, 0x00	; 0
     73c:	50 e0       	ldi	r21, 0x00	; 0
     73e:	20 e0       	ldi	r18, 0x00	; 0
     740:	0e 94 2a 10 	call	0x2054	; 0x2054 <xQueueGenericSend>
			SendData = 0;
     744:	1b 82       	std	Y+3, r1	; 0x03
			/*Send push Button was released to Lcd by queue*/
			xQueueSend(Queue_PushButton_A , &SendData , 100);
     746:	80 91 ea 00 	lds	r24, 0x00EA
     74a:	90 91 eb 00 	lds	r25, 0x00EB
     74e:	9e 01       	movw	r18, r28
     750:	2d 5f       	subi	r18, 0xFD	; 253
     752:	3f 4f       	sbci	r19, 0xFF	; 255
     754:	b9 01       	movw	r22, r18
     756:	44 e6       	ldi	r20, 0x64	; 100
     758:	50 e0       	ldi	r21, 0x00	; 0
     75a:	20 e0       	ldi	r18, 0x00	; 0
     75c:	0e 94 2a 10 	call	0x2054	; 0x2054 <xQueueGenericSend>
			Debouncing = 0;
     760:	1a 82       	std	Y+2, r1	; 0x02
			vTaskDelay(20);
     762:	84 e1       	ldi	r24, 0x14	; 20
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
     76a:	9e cf       	rjmp	.-196    	; 0x6a8 <PushButtonA_Task+0x22>
		}
		else
		{
			/*Send push Button is in Idle state to Lcd by queue*/
			SendData = 3;
     76c:	83 e0       	ldi	r24, 0x03	; 3
     76e:	8b 83       	std	Y+3, r24	; 0x03
			xQueueSend(Queue_PushButton_A , &SendData , 100);
     770:	80 91 ea 00 	lds	r24, 0x00EA
     774:	90 91 eb 00 	lds	r25, 0x00EB
     778:	9e 01       	movw	r18, r28
     77a:	2d 5f       	subi	r18, 0xFD	; 253
     77c:	3f 4f       	sbci	r19, 0xFF	; 255
     77e:	b9 01       	movw	r22, r18
     780:	44 e6       	ldi	r20, 0x64	; 100
     782:	50 e0       	ldi	r21, 0x00	; 0
     784:	20 e0       	ldi	r18, 0x00	; 0
     786:	0e 94 2a 10 	call	0x2054	; 0x2054 <xQueueGenericSend>
			vTaskDelay(20);
     78a:	84 e1       	ldi	r24, 0x14	; 20
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
     792:	8a cf       	rjmp	.-236    	; 0x6a8 <PushButtonA_Task+0x22>

00000794 <PushButtonB_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void PushButtonB_Task(void * a_Task_ptr)
{
     794:	df 93       	push	r29
     796:	cf 93       	push	r28
     798:	00 d0       	rcall	.+0      	; 0x79a <PushButtonB_Task+0x6>
     79a:	00 d0       	rcall	.+0      	; 0x79c <PushButtonB_Task+0x8>
     79c:	0f 92       	push	r0
     79e:	cd b7       	in	r28, 0x3d	; 61
     7a0:	de b7       	in	r29, 0x3e	; 62
     7a2:	9d 83       	std	Y+5, r25	; 0x05
     7a4:	8c 83       	std	Y+4, r24	; 0x04
	vTaskDelay(60);
     7a6:	8c e3       	ldi	r24, 0x3C	; 60
     7a8:	90 e0       	ldi	r25, 0x00	; 0
     7aa:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 1;
     7ae:	81 e0       	ldi	r24, 0x01	; 1
     7b0:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     7b2:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     7b4:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*Check if Button is pressed and enable de_bouncing*/
		if(Debouncing == 0 && Buttons_getPressedButton()==1)
     7b6:	8a 81       	ldd	r24, Y+2	; 0x02
     7b8:	88 23       	and	r24, r24
     7ba:	79 f4       	brne	.+30     	; 0x7da <PushButtonB_Task+0x46>
     7bc:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     7c0:	81 30       	cpi	r24, 0x01	; 1
     7c2:	59 f4       	brne	.+22     	; 0x7da <PushButtonB_Task+0x46>
		{
			OldPressedValue =  Buttons_getPressedButton();
     7c4:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     7c8:	89 83       	std	Y+1, r24	; 0x01
			Debouncing++;
     7ca:	8a 81       	ldd	r24, Y+2	; 0x02
     7cc:	8f 5f       	subi	r24, 0xFF	; 255
     7ce:	8a 83       	std	Y+2, r24	; 0x02
			/*de_bouncing Delay*/
			vTaskDelay(10);
     7d0:	8a e0       	ldi	r24, 0x0A	; 10
     7d2:	90 e0       	ldi	r25, 0x00	; 0
     7d4:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
     7d8:	ee cf       	rjmp	.-36     	; 0x7b6 <PushButtonB_Task+0x22>
		}
		else if(Debouncing == 1)
     7da:	8a 81       	ldd	r24, Y+2	; 0x02
     7dc:	81 30       	cpi	r24, 0x01	; 1
     7de:	59 f5       	brne	.+86     	; 0x836 <PushButtonB_Task+0xa2>
     7e0:	1d c0       	rjmp	.+58     	; 0x81c <PushButtonB_Task+0x88>
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
			{

				if (xSemaphoreTake(FirstButtonPressed , 10))
     7e2:	80 91 4f 07 	lds	r24, 0x074F
     7e6:	90 91 50 07 	lds	r25, 0x0750
     7ea:	6a e0       	ldi	r22, 0x0A	; 10
     7ec:	70 e0       	ldi	r23, 0x00	; 0
     7ee:	0e 94 2a 12 	call	0x2454	; 0x2454 <xQueueSemaphoreTake>
     7f2:	88 23       	and	r24, r24
     7f4:	99 f0       	breq	.+38     	; 0x81c <PushButtonB_Task+0x88>
				{
					SendData = 1;
     7f6:	81 e0       	ldi	r24, 0x01	; 1
     7f8:	8b 83       	std	Y+3, r24	; 0x03
					/*Send push Button was pressed to Lcd by queue*/
					xQueueSend(Queue_PushButton_B , &SendData , 100);
     7fa:	80 91 ec 00 	lds	r24, 0x00EC
     7fe:	90 91 ed 00 	lds	r25, 0x00ED
     802:	9e 01       	movw	r18, r28
     804:	2d 5f       	subi	r18, 0xFD	; 253
     806:	3f 4f       	sbci	r19, 0xFF	; 255
     808:	b9 01       	movw	r22, r18
     80a:	44 e6       	ldi	r20, 0x64	; 100
     80c:	50 e0       	ldi	r21, 0x00	; 0
     80e:	20 e0       	ldi	r18, 0x00	; 0
     810:	0e 94 2a 10 	call	0x2054	; 0x2054 <xQueueGenericSend>
					vTaskDelay(20);
     814:	84 e1       	ldi	r24, 0x14	; 20
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
			vTaskDelay(10);
		}
		else if(Debouncing == 1)
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
     81c:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     820:	98 2f       	mov	r25, r24
     822:	89 81       	ldd	r24, Y+1	; 0x01
     824:	98 17       	cp	r25, r24
     826:	e9 f2       	breq	.-70     	; 0x7e2 <PushButtonB_Task+0x4e>
					/*Send push Button was pressed to Lcd by queue*/
					xQueueSend(Queue_PushButton_B , &SendData , 100);
					vTaskDelay(20);
				}
			}
			Debouncing = 2;
     828:	82 e0       	ldi	r24, 0x02	; 2
     82a:	8a 83       	std	Y+2, r24	; 0x02
			vTaskDelay(20);
     82c:	84 e1       	ldi	r24, 0x14	; 20
     82e:	90 e0       	ldi	r25, 0x00	; 0
     830:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
     834:	c0 cf       	rjmp	.-128    	; 0x7b6 <PushButtonB_Task+0x22>
		}
		else if(Debouncing == 2)
     836:	8a 81       	ldd	r24, Y+2	; 0x02
     838:	82 30       	cpi	r24, 0x02	; 2
     83a:	f9 f4       	brne	.+62     	; 0x87a <__stack+0x1b>
		{
			xSemaphoreGive(FirstButtonPressed);
     83c:	80 91 4f 07 	lds	r24, 0x074F
     840:	90 91 50 07 	lds	r25, 0x0750
     844:	60 e0       	ldi	r22, 0x00	; 0
     846:	70 e0       	ldi	r23, 0x00	; 0
     848:	40 e0       	ldi	r20, 0x00	; 0
     84a:	50 e0       	ldi	r21, 0x00	; 0
     84c:	20 e0       	ldi	r18, 0x00	; 0
     84e:	0e 94 2a 10 	call	0x2054	; 0x2054 <xQueueGenericSend>
			SendData = 0;
     852:	1b 82       	std	Y+3, r1	; 0x03
			/*Send push Button was released to Lcd by queue*/
			xQueueSend(Queue_PushButton_B , &SendData , 100);
     854:	80 91 ec 00 	lds	r24, 0x00EC
     858:	90 91 ed 00 	lds	r25, 0x00ED
     85c:	9e 01       	movw	r18, r28
     85e:	2d 5f       	subi	r18, 0xFD	; 253
     860:	3f 4f       	sbci	r19, 0xFF	; 255
     862:	b9 01       	movw	r22, r18
     864:	44 e6       	ldi	r20, 0x64	; 100
     866:	50 e0       	ldi	r21, 0x00	; 0
     868:	20 e0       	ldi	r18, 0x00	; 0
     86a:	0e 94 2a 10 	call	0x2054	; 0x2054 <xQueueGenericSend>
			Debouncing = 0;
     86e:	1a 82       	std	Y+2, r1	; 0x02
			vTaskDelay(20);
     870:	84 e1       	ldi	r24, 0x14	; 20
     872:	90 e0       	ldi	r25, 0x00	; 0
     874:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
     878:	9e cf       	rjmp	.-196    	; 0x7b6 <PushButtonB_Task+0x22>
		}
		else
		{
			/*Send push Button is in Idle state to Lcd by queue*/
			SendData = 3;
     87a:	83 e0       	ldi	r24, 0x03	; 3
     87c:	8b 83       	std	Y+3, r24	; 0x03
			xQueueSend(Queue_PushButton_B , &SendData , 100);
     87e:	80 91 ec 00 	lds	r24, 0x00EC
     882:	90 91 ed 00 	lds	r25, 0x00ED
     886:	9e 01       	movw	r18, r28
     888:	2d 5f       	subi	r18, 0xFD	; 253
     88a:	3f 4f       	sbci	r19, 0xFF	; 255
     88c:	b9 01       	movw	r22, r18
     88e:	44 e6       	ldi	r20, 0x64	; 100
     890:	50 e0       	ldi	r21, 0x00	; 0
     892:	20 e0       	ldi	r18, 0x00	; 0
     894:	0e 94 2a 10 	call	0x2054	; 0x2054 <xQueueGenericSend>
			vTaskDelay(20);
     898:	84 e1       	ldi	r24, 0x14	; 20
     89a:	90 e0       	ldi	r25, 0x00	; 0
     89c:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
     8a0:	8a cf       	rjmp	.-236    	; 0x7b6 <PushButtonB_Task+0x22>

000008a2 <LCD_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_Task(void * a_Task_ptr)
{
     8a2:	df 93       	push	r29
     8a4:	cf 93       	push	r28
     8a6:	cd b7       	in	r28, 0x3d	; 61
     8a8:	de b7       	in	r29, 0x3e	; 62
     8aa:	27 97       	sbiw	r28, 0x07	; 7
     8ac:	0f b6       	in	r0, 0x3f	; 63
     8ae:	f8 94       	cli
     8b0:	de bf       	out	0x3e, r29	; 62
     8b2:	0f be       	out	0x3f, r0	; 63
     8b4:	cd bf       	out	0x3d, r28	; 61
     8b6:	9f 83       	std	Y+7, r25	; 0x07
     8b8:	8e 83       	std	Y+6, r24	; 0x06

	vTaskDelay(100);
     8ba:	84 e6       	ldi	r24, 0x64	; 100
     8bc:	90 e0       	ldi	r25, 0x00	; 0
     8be:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	/*received data from Push Button Task to display button state on LCD*/
	uint8 PushButton_A_Task_Data = 0;
     8c2:	1c 82       	std	Y+4, r1	; 0x04

	/*received message from Hello Task to display button state on LCD*/
	uint8 PushButton_B_Task_Data = 0;
     8c4:	1d 82       	std	Y+5, r1	; 0x05

	/*Synchronize between displaying of Push Button task and hello task*/
	uint8 Flag = 0;
     8c6:	1b 82       	std	Y+3, r1	; 0x03
	uint8 PlayerOne = 0;
     8c8:	1a 82       	std	Y+2, r1	; 0x02
	uint8 PlayerTwo = 0;
     8ca:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		if(PlayerOne ==50 || PlayerTwo==50)
     8cc:	8a 81       	ldd	r24, Y+2	; 0x02
     8ce:	82 33       	cpi	r24, 0x32	; 50
     8d0:	19 f0       	breq	.+6      	; 0x8d8 <LCD_Task+0x36>
     8d2:	89 81       	ldd	r24, Y+1	; 0x01
     8d4:	82 33       	cpi	r24, 0x32	; 50
     8d6:	39 f5       	brne	.+78     	; 0x926 <LCD_Task+0x84>
		{
			if(PlayerOne == 50)
     8d8:	8a 81       	ldd	r24, Y+2	; 0x02
     8da:	82 33       	cpi	r24, 0x32	; 50
     8dc:	71 f4       	brne	.+28     	; 0x8fa <LCD_Task+0x58>
			{
				LCD_clearScreen();
     8de:	0e 94 a3 0a 	call	0x1546	; 0x1546 <LCD_clearScreen>
				LCD_displayString("Congratulations");
     8e2:	85 e9       	ldi	r24, 0x95	; 149
     8e4:	90 e0       	ldi	r25, 0x00	; 0
     8e6:	0e 94 1f 0a 	call	0x143e	; 0x143e <LCD_displayString>
				LCD_displayStringRowColumn(1 , 0 , "Player 1 Won");
     8ea:	25 ea       	ldi	r18, 0xA5	; 165
     8ec:	30 e0       	ldi	r19, 0x00	; 0
     8ee:	81 e0       	ldi	r24, 0x01	; 1
     8f0:	60 e0       	ldi	r22, 0x00	; 0
     8f2:	a9 01       	movw	r20, r18
     8f4:	0e 94 8a 0a 	call	0x1514	; 0x1514 <LCD_displayStringRowColumn>
     8f8:	0d c0       	rjmp	.+26     	; 0x914 <LCD_Task+0x72>
			}
			else
			{
				LCD_clearScreen();
     8fa:	0e 94 a3 0a 	call	0x1546	; 0x1546 <LCD_clearScreen>
				LCD_displayString("Congratulations");
     8fe:	85 e9       	ldi	r24, 0x95	; 149
     900:	90 e0       	ldi	r25, 0x00	; 0
     902:	0e 94 1f 0a 	call	0x143e	; 0x143e <LCD_displayString>
				LCD_displayStringRowColumn(1 , 0 , "Player 2 Won");
     906:	22 eb       	ldi	r18, 0xB2	; 178
     908:	30 e0       	ldi	r19, 0x00	; 0
     90a:	81 e0       	ldi	r24, 0x01	; 1
     90c:	60 e0       	ldi	r22, 0x00	; 0
     90e:	a9 01       	movw	r20, r18
     910:	0e 94 8a 0a 	call	0x1514	; 0x1514 <LCD_displayStringRowColumn>
			}
			vTaskDelay(5000);
     914:	88 e8       	ldi	r24, 0x88	; 136
     916:	93 e1       	ldi	r25, 0x13	; 19
     918:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
			PlayerOne = 0;
     91c:	1a 82       	std	Y+2, r1	; 0x02
			PlayerTwo = 0;
     91e:	19 82       	std	Y+1, r1	; 0x01
			LCD_clearScreen();
     920:	0e 94 a3 0a 	call	0x1546	; 0x1546 <LCD_clearScreen>
     924:	d3 cf       	rjmp	.-90     	; 0x8cc <LCD_Task+0x2a>
		}
		else
		{
			/*receive messages fro other tasks by queues*/
			xQueueReceive(Queue_PushButton_A , &PushButton_A_Task_Data , 10);
     926:	80 91 ea 00 	lds	r24, 0x00EA
     92a:	90 91 eb 00 	lds	r25, 0x00EB
     92e:	9e 01       	movw	r18, r28
     930:	2c 5f       	subi	r18, 0xFC	; 252
     932:	3f 4f       	sbci	r19, 0xFF	; 255
     934:	b9 01       	movw	r22, r18
     936:	4a e0       	ldi	r20, 0x0A	; 10
     938:	50 e0       	ldi	r21, 0x00	; 0
     93a:	0e 94 7f 11 	call	0x22fe	; 0x22fe <xQueueReceive>
			xQueueReceive(Queue_PushButton_B , &PushButton_B_Task_Data , 10);
     93e:	80 91 ec 00 	lds	r24, 0x00EC
     942:	90 91 ed 00 	lds	r25, 0x00ED
     946:	9e 01       	movw	r18, r28
     948:	2b 5f       	subi	r18, 0xFB	; 251
     94a:	3f 4f       	sbci	r19, 0xFF	; 255
     94c:	b9 01       	movw	r22, r18
     94e:	4a e0       	ldi	r20, 0x0A	; 10
     950:	50 e0       	ldi	r21, 0x00	; 0
     952:	0e 94 7f 11 	call	0x22fe	; 0x22fe <xQueueReceive>

			/*Increment counter to Display Hello message for specific time*/
			if(PushButton_A_Task_Data == 1)
     956:	8c 81       	ldd	r24, Y+4	; 0x04
     958:	81 30       	cpi	r24, 0x01	; 1
     95a:	09 f0       	breq	.+2      	; 0x95e <LCD_Task+0xbc>
     95c:	41 c0       	rjmp	.+130    	; 0x9e0 <LCD_Task+0x13e>
			{
				if(Flag == 1)
     95e:	8b 81       	ldd	r24, Y+3	; 0x03
     960:	81 30       	cpi	r24, 0x01	; 1
     962:	11 f4       	brne	.+4      	; 0x968 <LCD_Task+0xc6>
				{
					LCD_clearScreen();
     964:	0e 94 a3 0a 	call	0x1546	; 0x1546 <LCD_clearScreen>
				}
				PlayerOne++;
     968:	8a 81       	ldd	r24, Y+2	; 0x02
     96a:	8f 5f       	subi	r24, 0xFF	; 255
     96c:	8a 83       	std	Y+2, r24	; 0x02
				if(PlayerTwo>0)
     96e:	89 81       	ldd	r24, Y+1	; 0x01
     970:	88 23       	and	r24, r24
     972:	19 f0       	breq	.+6      	; 0x97a <LCD_Task+0xd8>
				{
					PlayerTwo--;
     974:	89 81       	ldd	r24, Y+1	; 0x01
     976:	81 50       	subi	r24, 0x01	; 1
     978:	89 83       	std	Y+1, r24	; 0x01
				}
				LCD_displayStringRowColumn(0 , 0 ,"Player One ");
     97a:	2f eb       	ldi	r18, 0xBF	; 191
     97c:	30 e0       	ldi	r19, 0x00	; 0
     97e:	80 e0       	ldi	r24, 0x00	; 0
     980:	60 e0       	ldi	r22, 0x00	; 0
     982:	a9 01       	movw	r20, r18
     984:	0e 94 8a 0a 	call	0x1514	; 0x1514 <LCD_displayStringRowColumn>
				LCD_displayCharacter((PlayerOne/10)+48);
     988:	8a 81       	ldd	r24, Y+2	; 0x02
     98a:	9a e0       	ldi	r25, 0x0A	; 10
     98c:	69 2f       	mov	r22, r25
     98e:	0e 94 11 2d 	call	0x5a22	; 0x5a22 <__udivmodqi4>
     992:	80 5d       	subi	r24, 0xD0	; 208
     994:	0e 94 b2 09 	call	0x1364	; 0x1364 <LCD_displayCharacter>
				LCD_displayCharacter((PlayerOne % 10)+48);
     998:	8a 81       	ldd	r24, Y+2	; 0x02
     99a:	9a e0       	ldi	r25, 0x0A	; 10
     99c:	69 2f       	mov	r22, r25
     99e:	0e 94 11 2d 	call	0x5a22	; 0x5a22 <__udivmodqi4>
     9a2:	89 2f       	mov	r24, r25
     9a4:	80 5d       	subi	r24, 0xD0	; 208
     9a6:	0e 94 b2 09 	call	0x1364	; 0x1364 <LCD_displayCharacter>
				LCD_displayStringRowColumn(1 , 0 ,"Player Two ");
     9aa:	2b ec       	ldi	r18, 0xCB	; 203
     9ac:	30 e0       	ldi	r19, 0x00	; 0
     9ae:	81 e0       	ldi	r24, 0x01	; 1
     9b0:	60 e0       	ldi	r22, 0x00	; 0
     9b2:	a9 01       	movw	r20, r18
     9b4:	0e 94 8a 0a 	call	0x1514	; 0x1514 <LCD_displayStringRowColumn>
				LCD_displayCharacter((PlayerTwo/10)+48);
     9b8:	89 81       	ldd	r24, Y+1	; 0x01
     9ba:	9a e0       	ldi	r25, 0x0A	; 10
     9bc:	69 2f       	mov	r22, r25
     9be:	0e 94 11 2d 	call	0x5a22	; 0x5a22 <__udivmodqi4>
     9c2:	80 5d       	subi	r24, 0xD0	; 208
     9c4:	0e 94 b2 09 	call	0x1364	; 0x1364 <LCD_displayCharacter>
				LCD_displayCharacter((PlayerTwo % 10)+48);
     9c8:	89 81       	ldd	r24, Y+1	; 0x01
     9ca:	9a e0       	ldi	r25, 0x0A	; 10
     9cc:	69 2f       	mov	r22, r25
     9ce:	0e 94 11 2d 	call	0x5a22	; 0x5a22 <__udivmodqi4>
     9d2:	89 2f       	mov	r24, r25
     9d4:	80 5d       	subi	r24, 0xD0	; 208
     9d6:	0e 94 b2 09 	call	0x1364	; 0x1364 <LCD_displayCharacter>
				PushButton_A_Task_Data = 0;
     9da:	1c 82       	std	Y+4, r1	; 0x04
				Flag = 0;
     9dc:	1b 82       	std	Y+3, r1	; 0x03
     9de:	44 c0       	rjmp	.+136    	; 0xa68 <LCD_Task+0x1c6>
			}
			else if(PushButton_B_Task_Data == 1)
     9e0:	8d 81       	ldd	r24, Y+5	; 0x05
     9e2:	81 30       	cpi	r24, 0x01	; 1
     9e4:	09 f0       	breq	.+2      	; 0x9e8 <LCD_Task+0x146>
     9e6:	40 c0       	rjmp	.+128    	; 0xa68 <LCD_Task+0x1c6>
			{
				if(Flag == 1)
     9e8:	8b 81       	ldd	r24, Y+3	; 0x03
     9ea:	81 30       	cpi	r24, 0x01	; 1
     9ec:	11 f4       	brne	.+4      	; 0x9f2 <LCD_Task+0x150>
				{
					LCD_clearScreen();
     9ee:	0e 94 a3 0a 	call	0x1546	; 0x1546 <LCD_clearScreen>
				}
				PlayerTwo++;
     9f2:	89 81       	ldd	r24, Y+1	; 0x01
     9f4:	8f 5f       	subi	r24, 0xFF	; 255
     9f6:	89 83       	std	Y+1, r24	; 0x01
				if(PlayerOne>0)
     9f8:	8a 81       	ldd	r24, Y+2	; 0x02
     9fa:	88 23       	and	r24, r24
     9fc:	19 f0       	breq	.+6      	; 0xa04 <LCD_Task+0x162>
				{
					PlayerOne--;
     9fe:	8a 81       	ldd	r24, Y+2	; 0x02
     a00:	81 50       	subi	r24, 0x01	; 1
     a02:	8a 83       	std	Y+2, r24	; 0x02
				}
				LCD_displayStringRowColumn(0 , 0 ,"Player One ");
     a04:	2f eb       	ldi	r18, 0xBF	; 191
     a06:	30 e0       	ldi	r19, 0x00	; 0
     a08:	80 e0       	ldi	r24, 0x00	; 0
     a0a:	60 e0       	ldi	r22, 0x00	; 0
     a0c:	a9 01       	movw	r20, r18
     a0e:	0e 94 8a 0a 	call	0x1514	; 0x1514 <LCD_displayStringRowColumn>
				LCD_displayCharacter((PlayerOne/10)+48);
     a12:	8a 81       	ldd	r24, Y+2	; 0x02
     a14:	9a e0       	ldi	r25, 0x0A	; 10
     a16:	69 2f       	mov	r22, r25
     a18:	0e 94 11 2d 	call	0x5a22	; 0x5a22 <__udivmodqi4>
     a1c:	80 5d       	subi	r24, 0xD0	; 208
     a1e:	0e 94 b2 09 	call	0x1364	; 0x1364 <LCD_displayCharacter>
				LCD_displayCharacter((PlayerOne % 10)+48);
     a22:	8a 81       	ldd	r24, Y+2	; 0x02
     a24:	9a e0       	ldi	r25, 0x0A	; 10
     a26:	69 2f       	mov	r22, r25
     a28:	0e 94 11 2d 	call	0x5a22	; 0x5a22 <__udivmodqi4>
     a2c:	89 2f       	mov	r24, r25
     a2e:	80 5d       	subi	r24, 0xD0	; 208
     a30:	0e 94 b2 09 	call	0x1364	; 0x1364 <LCD_displayCharacter>
				LCD_displayStringRowColumn(1 , 0 ,"Player Two ");
     a34:	2b ec       	ldi	r18, 0xCB	; 203
     a36:	30 e0       	ldi	r19, 0x00	; 0
     a38:	81 e0       	ldi	r24, 0x01	; 1
     a3a:	60 e0       	ldi	r22, 0x00	; 0
     a3c:	a9 01       	movw	r20, r18
     a3e:	0e 94 8a 0a 	call	0x1514	; 0x1514 <LCD_displayStringRowColumn>
				LCD_displayCharacter((PlayerTwo/10)+48);
     a42:	89 81       	ldd	r24, Y+1	; 0x01
     a44:	9a e0       	ldi	r25, 0x0A	; 10
     a46:	69 2f       	mov	r22, r25
     a48:	0e 94 11 2d 	call	0x5a22	; 0x5a22 <__udivmodqi4>
     a4c:	80 5d       	subi	r24, 0xD0	; 208
     a4e:	0e 94 b2 09 	call	0x1364	; 0x1364 <LCD_displayCharacter>
				LCD_displayCharacter((PlayerTwo % 10)+48);
     a52:	89 81       	ldd	r24, Y+1	; 0x01
     a54:	9a e0       	ldi	r25, 0x0A	; 10
     a56:	69 2f       	mov	r22, r25
     a58:	0e 94 11 2d 	call	0x5a22	; 0x5a22 <__udivmodqi4>
     a5c:	89 2f       	mov	r24, r25
     a5e:	80 5d       	subi	r24, 0xD0	; 208
     a60:	0e 94 b2 09 	call	0x1364	; 0x1364 <LCD_displayCharacter>
				PushButton_B_Task_Data = 0;
     a64:	1d 82       	std	Y+5, r1	; 0x05
				Flag = 0;
     a66:	1b 82       	std	Y+3, r1	; 0x03
			}
			else
			{
			}
			vTaskDelay(20);
     a68:	84 e1       	ldi	r24, 0x14	; 20
     a6a:	90 e0       	ldi	r25, 0x00	; 0
     a6c:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
     a70:	2d cf       	rjmp	.-422    	; 0x8cc <LCD_Task+0x2a>

00000a72 <LED_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LED_Task(void * a_Task_ptr)
{
     a72:	df 93       	push	r29
     a74:	cf 93       	push	r28
     a76:	00 d0       	rcall	.+0      	; 0xa78 <LED_Task+0x6>
     a78:	cd b7       	in	r28, 0x3d	; 61
     a7a:	de b7       	in	r29, 0x3e	; 62
     a7c:	9a 83       	std	Y+2, r25	; 0x02
     a7e:	89 83       	std	Y+1, r24	; 0x01


	while(1)
	{
		/* Data is sent to LCD by Queue*/
		if (xSemaphoreTake(FirstButtonPressed , 10))
     a80:	80 91 4f 07 	lds	r24, 0x074F
     a84:	90 91 50 07 	lds	r25, 0x0750
     a88:	6a e0       	ldi	r22, 0x0A	; 10
     a8a:	70 e0       	ldi	r23, 0x00	; 0
     a8c:	0e 94 2a 12 	call	0x2454	; 0x2454 <xQueueSemaphoreTake>
     a90:	88 23       	and	r24, r24
     a92:	81 f0       	breq	.+32     	; 0xab4 <LED_Task+0x42>
		{
			DIO_WritePin(DIO_PIN13 , LOW);
     a94:	8d e0       	ldi	r24, 0x0D	; 13
     a96:	60 e0       	ldi	r22, 0x00	; 0
     a98:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
			xSemaphoreGive(FirstButtonPressed);
     a9c:	80 91 4f 07 	lds	r24, 0x074F
     aa0:	90 91 50 07 	lds	r25, 0x0750
     aa4:	60 e0       	ldi	r22, 0x00	; 0
     aa6:	70 e0       	ldi	r23, 0x00	; 0
     aa8:	40 e0       	ldi	r20, 0x00	; 0
     aaa:	50 e0       	ldi	r21, 0x00	; 0
     aac:	20 e0       	ldi	r18, 0x00	; 0
     aae:	0e 94 2a 10 	call	0x2054	; 0x2054 <xQueueGenericSend>
     ab2:	04 c0       	rjmp	.+8      	; 0xabc <LED_Task+0x4a>
		}
		else
		{
			DIO_WritePin(DIO_PIN13 , HIGH);
     ab4:	8d e0       	ldi	r24, 0x0D	; 13
     ab6:	61 e0       	ldi	r22, 0x01	; 1
     ab8:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
		}
		vTaskDelay(10);
     abc:	8a e0       	ldi	r24, 0x0A	; 10
     abe:	90 e0       	ldi	r25, 0x00	; 0
     ac0:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
     ac4:	dd cf       	rjmp	.-70     	; 0xa80 <LED_Task+0xe>

00000ac6 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     ac6:	df 93       	push	r29
     ac8:	cf 93       	push	r28
     aca:	00 d0       	rcall	.+0      	; 0xacc <xEventGroupCreate+0x6>
     acc:	cd b7       	in	r28, 0x3d	; 61
     ace:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     ad0:	8b e0       	ldi	r24, 0x0B	; 11
     ad2:	90 e0       	ldi	r25, 0x00	; 0
     ad4:	0e 94 a8 08 	call	0x1150	; 0x1150 <pvPortMalloc>
     ad8:	9a 83       	std	Y+2, r25	; 0x02
     ada:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     adc:	89 81       	ldd	r24, Y+1	; 0x01
     ade:	9a 81       	ldd	r25, Y+2	; 0x02
     ae0:	00 97       	sbiw	r24, 0x00	; 0
     ae2:	49 f0       	breq	.+18     	; 0xaf6 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     ae4:	e9 81       	ldd	r30, Y+1	; 0x01
     ae6:	fa 81       	ldd	r31, Y+2	; 0x02
     ae8:	11 82       	std	Z+1, r1	; 0x01
     aea:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     aec:	89 81       	ldd	r24, Y+1	; 0x01
     aee:	9a 81       	ldd	r25, Y+2	; 0x02
     af0:	02 96       	adiw	r24, 0x02	; 2
     af2:	0e 94 ad 0a 	call	0x155a	; 0x155a <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     af6:	89 81       	ldd	r24, Y+1	; 0x01
     af8:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     afa:	0f 90       	pop	r0
     afc:	0f 90       	pop	r0
     afe:	cf 91       	pop	r28
     b00:	df 91       	pop	r29
     b02:	08 95       	ret

00000b04 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     b04:	df 93       	push	r29
     b06:	cf 93       	push	r28
     b08:	cd b7       	in	r28, 0x3d	; 61
     b0a:	de b7       	in	r29, 0x3e	; 62
     b0c:	60 97       	sbiw	r28, 0x10	; 16
     b0e:	0f b6       	in	r0, 0x3f	; 63
     b10:	f8 94       	cli
     b12:	de bf       	out	0x3e, r29	; 62
     b14:	0f be       	out	0x3f, r0	; 63
     b16:	cd bf       	out	0x3d, r28	; 61
     b18:	9a 87       	std	Y+10, r25	; 0x0a
     b1a:	89 87       	std	Y+9, r24	; 0x09
     b1c:	7c 87       	std	Y+12, r23	; 0x0c
     b1e:	6b 87       	std	Y+11, r22	; 0x0b
     b20:	5e 87       	std	Y+14, r21	; 0x0e
     b22:	4d 87       	std	Y+13, r20	; 0x0d
     b24:	38 8b       	std	Y+16, r19	; 0x10
     b26:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     b28:	89 85       	ldd	r24, Y+9	; 0x09
     b2a:	9a 85       	ldd	r25, Y+10	; 0x0a
     b2c:	9c 83       	std	Y+4, r25	; 0x04
     b2e:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     b30:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     b32:	0e 94 26 22 	call	0x444c	; 0x444c <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     b36:	eb 81       	ldd	r30, Y+3	; 0x03
     b38:	fc 81       	ldd	r31, Y+4	; 0x04
     b3a:	80 81       	ld	r24, Z
     b3c:	91 81       	ldd	r25, Z+1	; 0x01
     b3e:	98 87       	std	Y+8, r25	; 0x08
     b40:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     b42:	89 85       	ldd	r24, Y+9	; 0x09
     b44:	9a 85       	ldd	r25, Y+10	; 0x0a
     b46:	2b 85       	ldd	r18, Y+11	; 0x0b
     b48:	3c 85       	ldd	r19, Y+12	; 0x0c
     b4a:	b9 01       	movw	r22, r18
     b4c:	0e 94 59 07 	call	0xeb2	; 0xeb2 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     b50:	2f 81       	ldd	r18, Y+7	; 0x07
     b52:	38 85       	ldd	r19, Y+8	; 0x08
     b54:	8b 85       	ldd	r24, Y+11	; 0x0b
     b56:	9c 85       	ldd	r25, Y+12	; 0x0c
     b58:	28 2b       	or	r18, r24
     b5a:	39 2b       	or	r19, r25
     b5c:	8d 85       	ldd	r24, Y+13	; 0x0d
     b5e:	9e 85       	ldd	r25, Y+14	; 0x0e
     b60:	28 23       	and	r18, r24
     b62:	39 23       	and	r19, r25
     b64:	8d 85       	ldd	r24, Y+13	; 0x0d
     b66:	9e 85       	ldd	r25, Y+14	; 0x0e
     b68:	28 17       	cp	r18, r24
     b6a:	39 07       	cpc	r19, r25
     b6c:	c9 f4       	brne	.+50     	; 0xba0 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     b6e:	2f 81       	ldd	r18, Y+7	; 0x07
     b70:	38 85       	ldd	r19, Y+8	; 0x08
     b72:	8b 85       	ldd	r24, Y+11	; 0x0b
     b74:	9c 85       	ldd	r25, Y+12	; 0x0c
     b76:	82 2b       	or	r24, r18
     b78:	93 2b       	or	r25, r19
     b7a:	9e 83       	std	Y+6, r25	; 0x06
     b7c:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     b7e:	eb 81       	ldd	r30, Y+3	; 0x03
     b80:	fc 81       	ldd	r31, Y+4	; 0x04
     b82:	20 81       	ld	r18, Z
     b84:	31 81       	ldd	r19, Z+1	; 0x01
     b86:	8d 85       	ldd	r24, Y+13	; 0x0d
     b88:	9e 85       	ldd	r25, Y+14	; 0x0e
     b8a:	80 95       	com	r24
     b8c:	90 95       	com	r25
     b8e:	82 23       	and	r24, r18
     b90:	93 23       	and	r25, r19
     b92:	eb 81       	ldd	r30, Y+3	; 0x03
     b94:	fc 81       	ldd	r31, Y+4	; 0x04
     b96:	91 83       	std	Z+1, r25	; 0x01
     b98:	80 83       	st	Z, r24

			xTicksToWait = 0;
     b9a:	18 8a       	std	Y+16, r1	; 0x10
     b9c:	1f 86       	std	Y+15, r1	; 0x0f
     b9e:	1e c0       	rjmp	.+60     	; 0xbdc <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     ba0:	8f 85       	ldd	r24, Y+15	; 0x0f
     ba2:	98 89       	ldd	r25, Y+16	; 0x10
     ba4:	00 97       	sbiw	r24, 0x00	; 0
     ba6:	91 f0       	breq	.+36     	; 0xbcc <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     ba8:	8b 81       	ldd	r24, Y+3	; 0x03
     baa:	9c 81       	ldd	r25, Y+4	; 0x04
     bac:	bc 01       	movw	r22, r24
     bae:	6e 5f       	subi	r22, 0xFE	; 254
     bb0:	7f 4f       	sbci	r23, 0xFF	; 255
     bb2:	8d 85       	ldd	r24, Y+13	; 0x0d
     bb4:	9e 85       	ldd	r25, Y+14	; 0x0e
     bb6:	9c 01       	movw	r18, r24
     bb8:	35 60       	ori	r19, 0x05	; 5
     bba:	4f 85       	ldd	r20, Y+15	; 0x0f
     bbc:	58 89       	ldd	r21, Y+16	; 0x10
     bbe:	cb 01       	movw	r24, r22
     bc0:	b9 01       	movw	r22, r18
     bc2:	0e 94 96 24 	call	0x492c	; 0x492c <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     bc6:	1e 82       	std	Y+6, r1	; 0x06
     bc8:	1d 82       	std	Y+5, r1	; 0x05
     bca:	08 c0       	rjmp	.+16     	; 0xbdc <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     bcc:	eb 81       	ldd	r30, Y+3	; 0x03
     bce:	fc 81       	ldd	r31, Y+4	; 0x04
     bd0:	80 81       	ld	r24, Z
     bd2:	91 81       	ldd	r25, Z+1	; 0x01
     bd4:	9e 83       	std	Y+6, r25	; 0x06
     bd6:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     bd8:	81 e0       	ldi	r24, 0x01	; 1
     bda:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     bdc:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
     be0:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     be2:	8f 85       	ldd	r24, Y+15	; 0x0f
     be4:	98 89       	ldd	r25, Y+16	; 0x10
     be6:	00 97       	sbiw	r24, 0x00	; 0
     be8:	09 f4       	brne	.+2      	; 0xbec <xEventGroupSync+0xe8>
     bea:	3a c0       	rjmp	.+116    	; 0xc60 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     bec:	8a 81       	ldd	r24, Y+2	; 0x02
     bee:	88 23       	and	r24, r24
     bf0:	11 f4       	brne	.+4      	; 0xbf6 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     bf2:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     bf6:	0e 94 ae 28 	call	0x515c	; 0x515c <uxTaskResetEventItemValue>
     bfa:	9e 83       	std	Y+6, r25	; 0x06
     bfc:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     bfe:	8d 81       	ldd	r24, Y+5	; 0x05
     c00:	9e 81       	ldd	r25, Y+6	; 0x06
     c02:	80 70       	andi	r24, 0x00	; 0
     c04:	92 70       	andi	r25, 0x02	; 2
     c06:	00 97       	sbiw	r24, 0x00	; 0
     c08:	31 f5       	brne	.+76     	; 0xc56 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     c0a:	0f b6       	in	r0, 0x3f	; 63
     c0c:	f8 94       	cli
     c0e:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     c10:	eb 81       	ldd	r30, Y+3	; 0x03
     c12:	fc 81       	ldd	r31, Y+4	; 0x04
     c14:	80 81       	ld	r24, Z
     c16:	91 81       	ldd	r25, Z+1	; 0x01
     c18:	9e 83       	std	Y+6, r25	; 0x06
     c1a:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     c1c:	2d 81       	ldd	r18, Y+5	; 0x05
     c1e:	3e 81       	ldd	r19, Y+6	; 0x06
     c20:	8d 85       	ldd	r24, Y+13	; 0x0d
     c22:	9e 85       	ldd	r25, Y+14	; 0x0e
     c24:	28 23       	and	r18, r24
     c26:	39 23       	and	r19, r25
     c28:	8d 85       	ldd	r24, Y+13	; 0x0d
     c2a:	9e 85       	ldd	r25, Y+14	; 0x0e
     c2c:	28 17       	cp	r18, r24
     c2e:	39 07       	cpc	r19, r25
     c30:	71 f4       	brne	.+28     	; 0xc4e <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     c32:	eb 81       	ldd	r30, Y+3	; 0x03
     c34:	fc 81       	ldd	r31, Y+4	; 0x04
     c36:	20 81       	ld	r18, Z
     c38:	31 81       	ldd	r19, Z+1	; 0x01
     c3a:	8d 85       	ldd	r24, Y+13	; 0x0d
     c3c:	9e 85       	ldd	r25, Y+14	; 0x0e
     c3e:	80 95       	com	r24
     c40:	90 95       	com	r25
     c42:	82 23       	and	r24, r18
     c44:	93 23       	and	r25, r19
     c46:	eb 81       	ldd	r30, Y+3	; 0x03
     c48:	fc 81       	ldd	r31, Y+4	; 0x04
     c4a:	91 83       	std	Z+1, r25	; 0x01
     c4c:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     c4e:	0f 90       	pop	r0
     c50:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     c52:	81 e0       	ldi	r24, 0x01	; 1
     c54:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     c56:	8d 81       	ldd	r24, Y+5	; 0x05
     c58:	9e 81       	ldd	r25, Y+6	; 0x06
     c5a:	90 70       	andi	r25, 0x00	; 0
     c5c:	9e 83       	std	Y+6, r25	; 0x06
     c5e:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     c60:	8d 81       	ldd	r24, Y+5	; 0x05
     c62:	9e 81       	ldd	r25, Y+6	; 0x06
}
     c64:	60 96       	adiw	r28, 0x10	; 16
     c66:	0f b6       	in	r0, 0x3f	; 63
     c68:	f8 94       	cli
     c6a:	de bf       	out	0x3e, r29	; 62
     c6c:	0f be       	out	0x3f, r0	; 63
     c6e:	cd bf       	out	0x3d, r28	; 61
     c70:	cf 91       	pop	r28
     c72:	df 91       	pop	r29
     c74:	08 95       	ret

00000c76 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     c76:	0f 93       	push	r16
     c78:	1f 93       	push	r17
     c7a:	df 93       	push	r29
     c7c:	cf 93       	push	r28
     c7e:	cd b7       	in	r28, 0x3d	; 61
     c80:	de b7       	in	r29, 0x3e	; 62
     c82:	63 97       	sbiw	r28, 0x13	; 19
     c84:	0f b6       	in	r0, 0x3f	; 63
     c86:	f8 94       	cli
     c88:	de bf       	out	0x3e, r29	; 62
     c8a:	0f be       	out	0x3f, r0	; 63
     c8c:	cd bf       	out	0x3d, r28	; 61
     c8e:	9d 87       	std	Y+13, r25	; 0x0d
     c90:	8c 87       	std	Y+12, r24	; 0x0c
     c92:	7f 87       	std	Y+15, r23	; 0x0f
     c94:	6e 87       	std	Y+14, r22	; 0x0e
     c96:	48 8b       	std	Y+16, r20	; 0x10
     c98:	29 8b       	std	Y+17, r18	; 0x11
     c9a:	1b 8b       	std	Y+19, r17	; 0x13
     c9c:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     c9e:	8c 85       	ldd	r24, Y+12	; 0x0c
     ca0:	9d 85       	ldd	r25, Y+13	; 0x0d
     ca2:	9b 87       	std	Y+11, r25	; 0x0b
     ca4:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     ca6:	1f 82       	std	Y+7, r1	; 0x07
     ca8:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     caa:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     cac:	0e 94 26 22 	call	0x444c	; 0x444c <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     cb0:	ea 85       	ldd	r30, Y+10	; 0x0a
     cb2:	fb 85       	ldd	r31, Y+11	; 0x0b
     cb4:	80 81       	ld	r24, Z
     cb6:	91 81       	ldd	r25, Z+1	; 0x01
     cb8:	9a 83       	std	Y+2, r25	; 0x02
     cba:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     cbc:	89 81       	ldd	r24, Y+1	; 0x01
     cbe:	9a 81       	ldd	r25, Y+2	; 0x02
     cc0:	2e 85       	ldd	r18, Y+14	; 0x0e
     cc2:	3f 85       	ldd	r19, Y+15	; 0x0f
     cc4:	b9 01       	movw	r22, r18
     cc6:	49 89       	ldd	r20, Y+17	; 0x11
     cc8:	0e 94 76 08 	call	0x10ec	; 0x10ec <prvTestWaitCondition>
     ccc:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     cce:	8d 81       	ldd	r24, Y+5	; 0x05
     cd0:	88 23       	and	r24, r24
     cd2:	c1 f0       	breq	.+48     	; 0xd04 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     cd4:	89 81       	ldd	r24, Y+1	; 0x01
     cd6:	9a 81       	ldd	r25, Y+2	; 0x02
     cd8:	99 87       	std	Y+9, r25	; 0x09
     cda:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     cdc:	1b 8a       	std	Y+19, r1	; 0x13
     cde:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     ce0:	88 89       	ldd	r24, Y+16	; 0x10
     ce2:	88 23       	and	r24, r24
     ce4:	e9 f1       	breq	.+122    	; 0xd60 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     ce6:	ea 85       	ldd	r30, Y+10	; 0x0a
     ce8:	fb 85       	ldd	r31, Y+11	; 0x0b
     cea:	20 81       	ld	r18, Z
     cec:	31 81       	ldd	r19, Z+1	; 0x01
     cee:	8e 85       	ldd	r24, Y+14	; 0x0e
     cf0:	9f 85       	ldd	r25, Y+15	; 0x0f
     cf2:	80 95       	com	r24
     cf4:	90 95       	com	r25
     cf6:	82 23       	and	r24, r18
     cf8:	93 23       	and	r25, r19
     cfa:	ea 85       	ldd	r30, Y+10	; 0x0a
     cfc:	fb 85       	ldd	r31, Y+11	; 0x0b
     cfe:	91 83       	std	Z+1, r25	; 0x01
     d00:	80 83       	st	Z, r24
     d02:	2e c0       	rjmp	.+92     	; 0xd60 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     d04:	8a 89       	ldd	r24, Y+18	; 0x12
     d06:	9b 89       	ldd	r25, Y+19	; 0x13
     d08:	00 97       	sbiw	r24, 0x00	; 0
     d0a:	39 f4       	brne	.+14     	; 0xd1a <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     d0c:	89 81       	ldd	r24, Y+1	; 0x01
     d0e:	9a 81       	ldd	r25, Y+2	; 0x02
     d10:	99 87       	std	Y+9, r25	; 0x09
     d12:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     d14:	81 e0       	ldi	r24, 0x01	; 1
     d16:	8b 83       	std	Y+3, r24	; 0x03
     d18:	23 c0       	rjmp	.+70     	; 0xd60 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     d1a:	88 89       	ldd	r24, Y+16	; 0x10
     d1c:	88 23       	and	r24, r24
     d1e:	29 f0       	breq	.+10     	; 0xd2a <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     d20:	8e 81       	ldd	r24, Y+6	; 0x06
     d22:	9f 81       	ldd	r25, Y+7	; 0x07
     d24:	91 60       	ori	r25, 0x01	; 1
     d26:	9f 83       	std	Y+7, r25	; 0x07
     d28:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     d2a:	89 89       	ldd	r24, Y+17	; 0x11
     d2c:	88 23       	and	r24, r24
     d2e:	29 f0       	breq	.+10     	; 0xd3a <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     d30:	8e 81       	ldd	r24, Y+6	; 0x06
     d32:	9f 81       	ldd	r25, Y+7	; 0x07
     d34:	94 60       	ori	r25, 0x04	; 4
     d36:	9f 83       	std	Y+7, r25	; 0x07
     d38:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     d3a:	8a 85       	ldd	r24, Y+10	; 0x0a
     d3c:	9b 85       	ldd	r25, Y+11	; 0x0b
     d3e:	bc 01       	movw	r22, r24
     d40:	6e 5f       	subi	r22, 0xFE	; 254
     d42:	7f 4f       	sbci	r23, 0xFF	; 255
     d44:	2e 85       	ldd	r18, Y+14	; 0x0e
     d46:	3f 85       	ldd	r19, Y+15	; 0x0f
     d48:	8e 81       	ldd	r24, Y+6	; 0x06
     d4a:	9f 81       	ldd	r25, Y+7	; 0x07
     d4c:	28 2b       	or	r18, r24
     d4e:	39 2b       	or	r19, r25
     d50:	4a 89       	ldd	r20, Y+18	; 0x12
     d52:	5b 89       	ldd	r21, Y+19	; 0x13
     d54:	cb 01       	movw	r24, r22
     d56:	b9 01       	movw	r22, r18
     d58:	0e 94 96 24 	call	0x492c	; 0x492c <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     d5c:	19 86       	std	Y+9, r1	; 0x09
     d5e:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     d60:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
     d64:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     d66:	8a 89       	ldd	r24, Y+18	; 0x12
     d68:	9b 89       	ldd	r25, Y+19	; 0x13
     d6a:	00 97       	sbiw	r24, 0x00	; 0
     d6c:	09 f4       	brne	.+2      	; 0xd70 <xEventGroupWaitBits+0xfa>
     d6e:	3c c0       	rjmp	.+120    	; 0xde8 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     d70:	8c 81       	ldd	r24, Y+4	; 0x04
     d72:	88 23       	and	r24, r24
     d74:	11 f4       	brne	.+4      	; 0xd7a <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     d76:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     d7a:	0e 94 ae 28 	call	0x515c	; 0x515c <uxTaskResetEventItemValue>
     d7e:	99 87       	std	Y+9, r25	; 0x09
     d80:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     d82:	88 85       	ldd	r24, Y+8	; 0x08
     d84:	99 85       	ldd	r25, Y+9	; 0x09
     d86:	80 70       	andi	r24, 0x00	; 0
     d88:	92 70       	andi	r25, 0x02	; 2
     d8a:	00 97       	sbiw	r24, 0x00	; 0
     d8c:	41 f5       	brne	.+80     	; 0xdde <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     d8e:	0f b6       	in	r0, 0x3f	; 63
     d90:	f8 94       	cli
     d92:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     d94:	ea 85       	ldd	r30, Y+10	; 0x0a
     d96:	fb 85       	ldd	r31, Y+11	; 0x0b
     d98:	80 81       	ld	r24, Z
     d9a:	91 81       	ldd	r25, Z+1	; 0x01
     d9c:	99 87       	std	Y+9, r25	; 0x09
     d9e:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     da0:	88 85       	ldd	r24, Y+8	; 0x08
     da2:	99 85       	ldd	r25, Y+9	; 0x09
     da4:	2e 85       	ldd	r18, Y+14	; 0x0e
     da6:	3f 85       	ldd	r19, Y+15	; 0x0f
     da8:	b9 01       	movw	r22, r18
     daa:	49 89       	ldd	r20, Y+17	; 0x11
     dac:	0e 94 76 08 	call	0x10ec	; 0x10ec <prvTestWaitCondition>
     db0:	88 23       	and	r24, r24
     db2:	89 f0       	breq	.+34     	; 0xdd6 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     db4:	88 89       	ldd	r24, Y+16	; 0x10
     db6:	88 23       	and	r24, r24
     db8:	71 f0       	breq	.+28     	; 0xdd6 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     dba:	ea 85       	ldd	r30, Y+10	; 0x0a
     dbc:	fb 85       	ldd	r31, Y+11	; 0x0b
     dbe:	20 81       	ld	r18, Z
     dc0:	31 81       	ldd	r19, Z+1	; 0x01
     dc2:	8e 85       	ldd	r24, Y+14	; 0x0e
     dc4:	9f 85       	ldd	r25, Y+15	; 0x0f
     dc6:	80 95       	com	r24
     dc8:	90 95       	com	r25
     dca:	82 23       	and	r24, r18
     dcc:	93 23       	and	r25, r19
     dce:	ea 85       	ldd	r30, Y+10	; 0x0a
     dd0:	fb 85       	ldd	r31, Y+11	; 0x0b
     dd2:	91 83       	std	Z+1, r25	; 0x01
     dd4:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     dda:	0f 90       	pop	r0
     ddc:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     dde:	88 85       	ldd	r24, Y+8	; 0x08
     de0:	99 85       	ldd	r25, Y+9	; 0x09
     de2:	90 70       	andi	r25, 0x00	; 0
     de4:	99 87       	std	Y+9, r25	; 0x09
     de6:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     de8:	88 85       	ldd	r24, Y+8	; 0x08
     dea:	99 85       	ldd	r25, Y+9	; 0x09
}
     dec:	63 96       	adiw	r28, 0x13	; 19
     dee:	0f b6       	in	r0, 0x3f	; 63
     df0:	f8 94       	cli
     df2:	de bf       	out	0x3e, r29	; 62
     df4:	0f be       	out	0x3f, r0	; 63
     df6:	cd bf       	out	0x3d, r28	; 61
     df8:	cf 91       	pop	r28
     dfa:	df 91       	pop	r29
     dfc:	1f 91       	pop	r17
     dfe:	0f 91       	pop	r16
     e00:	08 95       	ret

00000e02 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     e02:	df 93       	push	r29
     e04:	cf 93       	push	r28
     e06:	cd b7       	in	r28, 0x3d	; 61
     e08:	de b7       	in	r29, 0x3e	; 62
     e0a:	28 97       	sbiw	r28, 0x08	; 8
     e0c:	0f b6       	in	r0, 0x3f	; 63
     e0e:	f8 94       	cli
     e10:	de bf       	out	0x3e, r29	; 62
     e12:	0f be       	out	0x3f, r0	; 63
     e14:	cd bf       	out	0x3d, r28	; 61
     e16:	9e 83       	std	Y+6, r25	; 0x06
     e18:	8d 83       	std	Y+5, r24	; 0x05
     e1a:	78 87       	std	Y+8, r23	; 0x08
     e1c:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     e1e:	8d 81       	ldd	r24, Y+5	; 0x05
     e20:	9e 81       	ldd	r25, Y+6	; 0x06
     e22:	9c 83       	std	Y+4, r25	; 0x04
     e24:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     e26:	0f b6       	in	r0, 0x3f	; 63
     e28:	f8 94       	cli
     e2a:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     e2c:	eb 81       	ldd	r30, Y+3	; 0x03
     e2e:	fc 81       	ldd	r31, Y+4	; 0x04
     e30:	80 81       	ld	r24, Z
     e32:	91 81       	ldd	r25, Z+1	; 0x01
     e34:	9a 83       	std	Y+2, r25	; 0x02
     e36:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     e38:	eb 81       	ldd	r30, Y+3	; 0x03
     e3a:	fc 81       	ldd	r31, Y+4	; 0x04
     e3c:	20 81       	ld	r18, Z
     e3e:	31 81       	ldd	r19, Z+1	; 0x01
     e40:	8f 81       	ldd	r24, Y+7	; 0x07
     e42:	98 85       	ldd	r25, Y+8	; 0x08
     e44:	80 95       	com	r24
     e46:	90 95       	com	r25
     e48:	82 23       	and	r24, r18
     e4a:	93 23       	and	r25, r19
     e4c:	eb 81       	ldd	r30, Y+3	; 0x03
     e4e:	fc 81       	ldd	r31, Y+4	; 0x04
     e50:	91 83       	std	Z+1, r25	; 0x01
     e52:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     e54:	0f 90       	pop	r0
     e56:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     e58:	89 81       	ldd	r24, Y+1	; 0x01
     e5a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     e5c:	28 96       	adiw	r28, 0x08	; 8
     e5e:	0f b6       	in	r0, 0x3f	; 63
     e60:	f8 94       	cli
     e62:	de bf       	out	0x3e, r29	; 62
     e64:	0f be       	out	0x3f, r0	; 63
     e66:	cd bf       	out	0x3d, r28	; 61
     e68:	cf 91       	pop	r28
     e6a:	df 91       	pop	r29
     e6c:	08 95       	ret

00000e6e <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     e6e:	df 93       	push	r29
     e70:	cf 93       	push	r28
     e72:	cd b7       	in	r28, 0x3d	; 61
     e74:	de b7       	in	r29, 0x3e	; 62
     e76:	27 97       	sbiw	r28, 0x07	; 7
     e78:	0f b6       	in	r0, 0x3f	; 63
     e7a:	f8 94       	cli
     e7c:	de bf       	out	0x3e, r29	; 62
     e7e:	0f be       	out	0x3f, r0	; 63
     e80:	cd bf       	out	0x3d, r28	; 61
     e82:	9f 83       	std	Y+7, r25	; 0x07
     e84:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     e86:	8e 81       	ldd	r24, Y+6	; 0x06
     e88:	9f 81       	ldd	r25, Y+7	; 0x07
     e8a:	9c 83       	std	Y+4, r25	; 0x04
     e8c:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     e8e:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     e90:	eb 81       	ldd	r30, Y+3	; 0x03
     e92:	fc 81       	ldd	r31, Y+4	; 0x04
     e94:	80 81       	ld	r24, Z
     e96:	91 81       	ldd	r25, Z+1	; 0x01
     e98:	9a 83       	std	Y+2, r25	; 0x02
     e9a:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     e9c:	89 81       	ldd	r24, Y+1	; 0x01
     e9e:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     ea0:	27 96       	adiw	r28, 0x07	; 7
     ea2:	0f b6       	in	r0, 0x3f	; 63
     ea4:	f8 94       	cli
     ea6:	de bf       	out	0x3e, r29	; 62
     ea8:	0f be       	out	0x3f, r0	; 63
     eaa:	cd bf       	out	0x3d, r28	; 61
     eac:	cf 91       	pop	r28
     eae:	df 91       	pop	r29
     eb0:	08 95       	ret

00000eb2 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     eb2:	df 93       	push	r29
     eb4:	cf 93       	push	r28
     eb6:	cd b7       	in	r28, 0x3d	; 61
     eb8:	de b7       	in	r29, 0x3e	; 62
     eba:	65 97       	sbiw	r28, 0x15	; 21
     ebc:	0f b6       	in	r0, 0x3f	; 63
     ebe:	f8 94       	cli
     ec0:	de bf       	out	0x3e, r29	; 62
     ec2:	0f be       	out	0x3f, r0	; 63
     ec4:	cd bf       	out	0x3d, r28	; 61
     ec6:	9b 8b       	std	Y+19, r25	; 0x13
     ec8:	8a 8b       	std	Y+18, r24	; 0x12
     eca:	7d 8b       	std	Y+21, r23	; 0x15
     ecc:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     ece:	19 86       	std	Y+9, r1	; 0x09
     ed0:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     ed2:	8a 89       	ldd	r24, Y+18	; 0x12
     ed4:	9b 89       	ldd	r25, Y+19	; 0x13
     ed6:	9b 83       	std	Y+3, r25	; 0x03
     ed8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     eda:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     edc:	8a 81       	ldd	r24, Y+2	; 0x02
     ede:	9b 81       	ldd	r25, Y+3	; 0x03
     ee0:	02 96       	adiw	r24, 0x02	; 2
     ee2:	9b 87       	std	Y+11, r25	; 0x0b
     ee4:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ee6:	8a 85       	ldd	r24, Y+10	; 0x0a
     ee8:	9b 85       	ldd	r25, Y+11	; 0x0b
     eea:	03 96       	adiw	r24, 0x03	; 3
     eec:	9d 87       	std	Y+13, r25	; 0x0d
     eee:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     ef0:	0e 94 26 22 	call	0x444c	; 0x444c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     ef4:	ea 85       	ldd	r30, Y+10	; 0x0a
     ef6:	fb 85       	ldd	r31, Y+11	; 0x0b
     ef8:	85 81       	ldd	r24, Z+5	; 0x05
     efa:	96 81       	ldd	r25, Z+6	; 0x06
     efc:	99 8b       	std	Y+17, r25	; 0x11
     efe:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     f00:	ea 81       	ldd	r30, Y+2	; 0x02
     f02:	fb 81       	ldd	r31, Y+3	; 0x03
     f04:	20 81       	ld	r18, Z
     f06:	31 81       	ldd	r19, Z+1	; 0x01
     f08:	8c 89       	ldd	r24, Y+20	; 0x14
     f0a:	9d 89       	ldd	r25, Y+21	; 0x15
     f0c:	82 2b       	or	r24, r18
     f0e:	93 2b       	or	r25, r19
     f10:	ea 81       	ldd	r30, Y+2	; 0x02
     f12:	fb 81       	ldd	r31, Y+3	; 0x03
     f14:	91 83       	std	Z+1, r25	; 0x01
     f16:	80 83       	st	Z, r24
     f18:	59 c0       	rjmp	.+178    	; 0xfcc <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     f1a:	e8 89       	ldd	r30, Y+16	; 0x10
     f1c:	f9 89       	ldd	r31, Y+17	; 0x11
     f1e:	82 81       	ldd	r24, Z+2	; 0x02
     f20:	93 81       	ldd	r25, Z+3	; 0x03
     f22:	9f 87       	std	Y+15, r25	; 0x0f
     f24:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     f26:	e8 89       	ldd	r30, Y+16	; 0x10
     f28:	f9 89       	ldd	r31, Y+17	; 0x11
     f2a:	80 81       	ld	r24, Z
     f2c:	91 81       	ldd	r25, Z+1	; 0x01
     f2e:	9f 83       	std	Y+7, r25	; 0x07
     f30:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     f32:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     f34:	8e 81       	ldd	r24, Y+6	; 0x06
     f36:	9f 81       	ldd	r25, Y+7	; 0x07
     f38:	80 70       	andi	r24, 0x00	; 0
     f3a:	9d 83       	std	Y+5, r25	; 0x05
     f3c:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     f3e:	8e 81       	ldd	r24, Y+6	; 0x06
     f40:	9f 81       	ldd	r25, Y+7	; 0x07
     f42:	90 70       	andi	r25, 0x00	; 0
     f44:	9f 83       	std	Y+7, r25	; 0x07
     f46:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     f48:	8c 81       	ldd	r24, Y+4	; 0x04
     f4a:	9d 81       	ldd	r25, Y+5	; 0x05
     f4c:	80 70       	andi	r24, 0x00	; 0
     f4e:	94 70       	andi	r25, 0x04	; 4
     f50:	00 97       	sbiw	r24, 0x00	; 0
     f52:	69 f4       	brne	.+26     	; 0xf6e <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     f54:	ea 81       	ldd	r30, Y+2	; 0x02
     f56:	fb 81       	ldd	r31, Y+3	; 0x03
     f58:	20 81       	ld	r18, Z
     f5a:	31 81       	ldd	r19, Z+1	; 0x01
     f5c:	8e 81       	ldd	r24, Y+6	; 0x06
     f5e:	9f 81       	ldd	r25, Y+7	; 0x07
     f60:	82 23       	and	r24, r18
     f62:	93 23       	and	r25, r19
     f64:	00 97       	sbiw	r24, 0x00	; 0
     f66:	91 f0       	breq	.+36     	; 0xf8c <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     f68:	81 e0       	ldi	r24, 0x01	; 1
     f6a:	89 83       	std	Y+1, r24	; 0x01
     f6c:	0f c0       	rjmp	.+30     	; 0xf8c <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     f6e:	ea 81       	ldd	r30, Y+2	; 0x02
     f70:	fb 81       	ldd	r31, Y+3	; 0x03
     f72:	20 81       	ld	r18, Z
     f74:	31 81       	ldd	r19, Z+1	; 0x01
     f76:	8e 81       	ldd	r24, Y+6	; 0x06
     f78:	9f 81       	ldd	r25, Y+7	; 0x07
     f7a:	28 23       	and	r18, r24
     f7c:	39 23       	and	r19, r25
     f7e:	8e 81       	ldd	r24, Y+6	; 0x06
     f80:	9f 81       	ldd	r25, Y+7	; 0x07
     f82:	28 17       	cp	r18, r24
     f84:	39 07       	cpc	r19, r25
     f86:	11 f4       	brne	.+4      	; 0xf8c <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     f88:	81 e0       	ldi	r24, 0x01	; 1
     f8a:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     f8c:	89 81       	ldd	r24, Y+1	; 0x01
     f8e:	88 23       	and	r24, r24
     f90:	c9 f0       	breq	.+50     	; 0xfc4 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     f92:	8c 81       	ldd	r24, Y+4	; 0x04
     f94:	9d 81       	ldd	r25, Y+5	; 0x05
     f96:	80 70       	andi	r24, 0x00	; 0
     f98:	91 70       	andi	r25, 0x01	; 1
     f9a:	00 97       	sbiw	r24, 0x00	; 0
     f9c:	41 f0       	breq	.+16     	; 0xfae <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     f9e:	88 85       	ldd	r24, Y+8	; 0x08
     fa0:	99 85       	ldd	r25, Y+9	; 0x09
     fa2:	2e 81       	ldd	r18, Y+6	; 0x06
     fa4:	3f 81       	ldd	r19, Y+7	; 0x07
     fa6:	82 2b       	or	r24, r18
     fa8:	93 2b       	or	r25, r19
     faa:	99 87       	std	Y+9, r25	; 0x09
     fac:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     fae:	ea 81       	ldd	r30, Y+2	; 0x02
     fb0:	fb 81       	ldd	r31, Y+3	; 0x03
     fb2:	80 81       	ld	r24, Z
     fb4:	91 81       	ldd	r25, Z+1	; 0x01
     fb6:	9c 01       	movw	r18, r24
     fb8:	32 60       	ori	r19, 0x02	; 2
     fba:	88 89       	ldd	r24, Y+16	; 0x10
     fbc:	99 89       	ldd	r25, Y+17	; 0x11
     fbe:	b9 01       	movw	r22, r18
     fc0:	0e 94 31 25 	call	0x4a62	; 0x4a62 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     fc4:	8e 85       	ldd	r24, Y+14	; 0x0e
     fc6:	9f 85       	ldd	r25, Y+15	; 0x0f
     fc8:	99 8b       	std	Y+17, r25	; 0x11
     fca:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     fcc:	28 89       	ldd	r18, Y+16	; 0x10
     fce:	39 89       	ldd	r19, Y+17	; 0x11
     fd0:	8c 85       	ldd	r24, Y+12	; 0x0c
     fd2:	9d 85       	ldd	r25, Y+13	; 0x0d
     fd4:	28 17       	cp	r18, r24
     fd6:	39 07       	cpc	r19, r25
     fd8:	09 f0       	breq	.+2      	; 0xfdc <xEventGroupSetBits+0x12a>
     fda:	9f cf       	rjmp	.-194    	; 0xf1a <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     fdc:	ea 81       	ldd	r30, Y+2	; 0x02
     fde:	fb 81       	ldd	r31, Y+3	; 0x03
     fe0:	20 81       	ld	r18, Z
     fe2:	31 81       	ldd	r19, Z+1	; 0x01
     fe4:	88 85       	ldd	r24, Y+8	; 0x08
     fe6:	99 85       	ldd	r25, Y+9	; 0x09
     fe8:	80 95       	com	r24
     fea:	90 95       	com	r25
     fec:	82 23       	and	r24, r18
     fee:	93 23       	and	r25, r19
     ff0:	ea 81       	ldd	r30, Y+2	; 0x02
     ff2:	fb 81       	ldd	r31, Y+3	; 0x03
     ff4:	91 83       	std	Z+1, r25	; 0x01
     ff6:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     ff8:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     ffc:	ea 81       	ldd	r30, Y+2	; 0x02
     ffe:	fb 81       	ldd	r31, Y+3	; 0x03
    1000:	80 81       	ld	r24, Z
    1002:	91 81       	ldd	r25, Z+1	; 0x01
}
    1004:	65 96       	adiw	r28, 0x15	; 21
    1006:	0f b6       	in	r0, 0x3f	; 63
    1008:	f8 94       	cli
    100a:	de bf       	out	0x3e, r29	; 62
    100c:	0f be       	out	0x3f, r0	; 63
    100e:	cd bf       	out	0x3d, r28	; 61
    1010:	cf 91       	pop	r28
    1012:	df 91       	pop	r29
    1014:	08 95       	ret

00001016 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1016:	df 93       	push	r29
    1018:	cf 93       	push	r28
    101a:	00 d0       	rcall	.+0      	; 0x101c <vEventGroupDelete+0x6>
    101c:	00 d0       	rcall	.+0      	; 0x101e <vEventGroupDelete+0x8>
    101e:	00 d0       	rcall	.+0      	; 0x1020 <vEventGroupDelete+0xa>
    1020:	cd b7       	in	r28, 0x3d	; 61
    1022:	de b7       	in	r29, 0x3e	; 62
    1024:	9e 83       	std	Y+6, r25	; 0x06
    1026:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    1028:	8d 81       	ldd	r24, Y+5	; 0x05
    102a:	9e 81       	ldd	r25, Y+6	; 0x06
    102c:	9c 83       	std	Y+4, r25	; 0x04
    102e:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1030:	8b 81       	ldd	r24, Y+3	; 0x03
    1032:	9c 81       	ldd	r25, Y+4	; 0x04
    1034:	02 96       	adiw	r24, 0x02	; 2
    1036:	9a 83       	std	Y+2, r25	; 0x02
    1038:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    103a:	0e 94 26 22 	call	0x444c	; 0x444c <vTaskSuspendAll>
    103e:	08 c0       	rjmp	.+16     	; 0x1050 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1040:	e9 81       	ldd	r30, Y+1	; 0x01
    1042:	fa 81       	ldd	r31, Y+2	; 0x02
    1044:	85 81       	ldd	r24, Z+5	; 0x05
    1046:	96 81       	ldd	r25, Z+6	; 0x06
    1048:	60 e0       	ldi	r22, 0x00	; 0
    104a:	72 e0       	ldi	r23, 0x02	; 2
    104c:	0e 94 31 25 	call	0x4a62	; 0x4a62 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1050:	e9 81       	ldd	r30, Y+1	; 0x01
    1052:	fa 81       	ldd	r31, Y+2	; 0x02
    1054:	80 81       	ld	r24, Z
    1056:	88 23       	and	r24, r24
    1058:	99 f7       	brne	.-26     	; 0x1040 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    105a:	8b 81       	ldd	r24, Y+3	; 0x03
    105c:	9c 81       	ldd	r25, Y+4	; 0x04
    105e:	0e 94 fe 08 	call	0x11fc	; 0x11fc <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    1062:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
}
    1066:	26 96       	adiw	r28, 0x06	; 6
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	f8 94       	cli
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	0f be       	out	0x3f, r0	; 63
    1070:	cd bf       	out	0x3d, r28	; 61
    1072:	cf 91       	pop	r28
    1074:	df 91       	pop	r29
    1076:	08 95       	ret

00001078 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    1078:	df 93       	push	r29
    107a:	cf 93       	push	r28
    107c:	00 d0       	rcall	.+0      	; 0x107e <vEventGroupSetBitsCallback+0x6>
    107e:	00 d0       	rcall	.+0      	; 0x1080 <vEventGroupSetBitsCallback+0x8>
    1080:	00 d0       	rcall	.+0      	; 0x1082 <vEventGroupSetBitsCallback+0xa>
    1082:	cd b7       	in	r28, 0x3d	; 61
    1084:	de b7       	in	r29, 0x3e	; 62
    1086:	9a 83       	std	Y+2, r25	; 0x02
    1088:	89 83       	std	Y+1, r24	; 0x01
    108a:	4b 83       	std	Y+3, r20	; 0x03
    108c:	5c 83       	std	Y+4, r21	; 0x04
    108e:	6d 83       	std	Y+5, r22	; 0x05
    1090:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1092:	89 81       	ldd	r24, Y+1	; 0x01
    1094:	9a 81       	ldd	r25, Y+2	; 0x02
    1096:	2b 81       	ldd	r18, Y+3	; 0x03
    1098:	3c 81       	ldd	r19, Y+4	; 0x04
    109a:	b9 01       	movw	r22, r18
    109c:	0e 94 59 07 	call	0xeb2	; 0xeb2 <xEventGroupSetBits>
}
    10a0:	26 96       	adiw	r28, 0x06	; 6
    10a2:	0f b6       	in	r0, 0x3f	; 63
    10a4:	f8 94       	cli
    10a6:	de bf       	out	0x3e, r29	; 62
    10a8:	0f be       	out	0x3f, r0	; 63
    10aa:	cd bf       	out	0x3d, r28	; 61
    10ac:	cf 91       	pop	r28
    10ae:	df 91       	pop	r29
    10b0:	08 95       	ret

000010b2 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    10b2:	df 93       	push	r29
    10b4:	cf 93       	push	r28
    10b6:	00 d0       	rcall	.+0      	; 0x10b8 <vEventGroupClearBitsCallback+0x6>
    10b8:	00 d0       	rcall	.+0      	; 0x10ba <vEventGroupClearBitsCallback+0x8>
    10ba:	00 d0       	rcall	.+0      	; 0x10bc <vEventGroupClearBitsCallback+0xa>
    10bc:	cd b7       	in	r28, 0x3d	; 61
    10be:	de b7       	in	r29, 0x3e	; 62
    10c0:	9a 83       	std	Y+2, r25	; 0x02
    10c2:	89 83       	std	Y+1, r24	; 0x01
    10c4:	4b 83       	std	Y+3, r20	; 0x03
    10c6:	5c 83       	std	Y+4, r21	; 0x04
    10c8:	6d 83       	std	Y+5, r22	; 0x05
    10ca:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    10cc:	89 81       	ldd	r24, Y+1	; 0x01
    10ce:	9a 81       	ldd	r25, Y+2	; 0x02
    10d0:	2b 81       	ldd	r18, Y+3	; 0x03
    10d2:	3c 81       	ldd	r19, Y+4	; 0x04
    10d4:	b9 01       	movw	r22, r18
    10d6:	0e 94 01 07 	call	0xe02	; 0xe02 <xEventGroupClearBits>
}
    10da:	26 96       	adiw	r28, 0x06	; 6
    10dc:	0f b6       	in	r0, 0x3f	; 63
    10de:	f8 94       	cli
    10e0:	de bf       	out	0x3e, r29	; 62
    10e2:	0f be       	out	0x3f, r0	; 63
    10e4:	cd bf       	out	0x3d, r28	; 61
    10e6:	cf 91       	pop	r28
    10e8:	df 91       	pop	r29
    10ea:	08 95       	ret

000010ec <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    10ec:	df 93       	push	r29
    10ee:	cf 93       	push	r28
    10f0:	00 d0       	rcall	.+0      	; 0x10f2 <prvTestWaitCondition+0x6>
    10f2:	00 d0       	rcall	.+0      	; 0x10f4 <prvTestWaitCondition+0x8>
    10f4:	00 d0       	rcall	.+0      	; 0x10f6 <prvTestWaitCondition+0xa>
    10f6:	cd b7       	in	r28, 0x3d	; 61
    10f8:	de b7       	in	r29, 0x3e	; 62
    10fa:	9b 83       	std	Y+3, r25	; 0x03
    10fc:	8a 83       	std	Y+2, r24	; 0x02
    10fe:	7d 83       	std	Y+5, r23	; 0x05
    1100:	6c 83       	std	Y+4, r22	; 0x04
    1102:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    1104:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    1106:	8e 81       	ldd	r24, Y+6	; 0x06
    1108:	88 23       	and	r24, r24
    110a:	59 f4       	brne	.+22     	; 0x1122 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    110c:	8a 81       	ldd	r24, Y+2	; 0x02
    110e:	9b 81       	ldd	r25, Y+3	; 0x03
    1110:	2c 81       	ldd	r18, Y+4	; 0x04
    1112:	3d 81       	ldd	r19, Y+5	; 0x05
    1114:	82 23       	and	r24, r18
    1116:	93 23       	and	r25, r19
    1118:	00 97       	sbiw	r24, 0x00	; 0
    111a:	81 f0       	breq	.+32     	; 0x113c <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    111c:	81 e0       	ldi	r24, 0x01	; 1
    111e:	89 83       	std	Y+1, r24	; 0x01
    1120:	0d c0       	rjmp	.+26     	; 0x113c <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1122:	2a 81       	ldd	r18, Y+2	; 0x02
    1124:	3b 81       	ldd	r19, Y+3	; 0x03
    1126:	8c 81       	ldd	r24, Y+4	; 0x04
    1128:	9d 81       	ldd	r25, Y+5	; 0x05
    112a:	28 23       	and	r18, r24
    112c:	39 23       	and	r19, r25
    112e:	8c 81       	ldd	r24, Y+4	; 0x04
    1130:	9d 81       	ldd	r25, Y+5	; 0x05
    1132:	28 17       	cp	r18, r24
    1134:	39 07       	cpc	r19, r25
    1136:	11 f4       	brne	.+4      	; 0x113c <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1138:	81 e0       	ldi	r24, 0x01	; 1
    113a:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    113c:	89 81       	ldd	r24, Y+1	; 0x01
}
    113e:	26 96       	adiw	r28, 0x06	; 6
    1140:	0f b6       	in	r0, 0x3f	; 63
    1142:	f8 94       	cli
    1144:	de bf       	out	0x3e, r29	; 62
    1146:	0f be       	out	0x3f, r0	; 63
    1148:	cd bf       	out	0x3d, r28	; 61
    114a:	cf 91       	pop	r28
    114c:	df 91       	pop	r29
    114e:	08 95       	ret

00001150 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1150:	df 93       	push	r29
    1152:	cf 93       	push	r28
    1154:	00 d0       	rcall	.+0      	; 0x1156 <pvPortMalloc+0x6>
    1156:	00 d0       	rcall	.+0      	; 0x1158 <pvPortMalloc+0x8>
    1158:	cd b7       	in	r28, 0x3d	; 61
    115a:	de b7       	in	r29, 0x3e	; 62
    115c:	9c 83       	std	Y+4, r25	; 0x04
    115e:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    1160:	1a 82       	std	Y+2, r1	; 0x02
    1162:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1164:	0e 94 26 22 	call	0x444c	; 0x444c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1168:	80 91 f0 00 	lds	r24, 0x00F0
    116c:	90 91 f1 00 	lds	r25, 0x00F1
    1170:	00 97       	sbiw	r24, 0x00	; 0
    1172:	31 f4       	brne	.+12     	; 0x1180 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1174:	83 ef       	ldi	r24, 0xF3	; 243
    1176:	90 e0       	ldi	r25, 0x00	; 0
    1178:	90 93 f1 00 	sts	0x00F1, r25
    117c:	80 93 f0 00 	sts	0x00F0, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1180:	80 91 ee 00 	lds	r24, 0x00EE
    1184:	90 91 ef 00 	lds	r25, 0x00EF
    1188:	2b 81       	ldd	r18, Y+3	; 0x03
    118a:	3c 81       	ldd	r19, Y+4	; 0x04
    118c:	82 0f       	add	r24, r18
    118e:	93 1f       	adc	r25, r19
    1190:	25 e0       	ldi	r18, 0x05	; 5
    1192:	8b 3d       	cpi	r24, 0xDB	; 219
    1194:	92 07       	cpc	r25, r18
    1196:	38 f5       	brcc	.+78     	; 0x11e6 <pvPortMalloc+0x96>
    1198:	20 91 ee 00 	lds	r18, 0x00EE
    119c:	30 91 ef 00 	lds	r19, 0x00EF
    11a0:	8b 81       	ldd	r24, Y+3	; 0x03
    11a2:	9c 81       	ldd	r25, Y+4	; 0x04
    11a4:	28 0f       	add	r18, r24
    11a6:	39 1f       	adc	r19, r25
    11a8:	80 91 ee 00 	lds	r24, 0x00EE
    11ac:	90 91 ef 00 	lds	r25, 0x00EF
    11b0:	82 17       	cp	r24, r18
    11b2:	93 07       	cpc	r25, r19
    11b4:	c0 f4       	brcc	.+48     	; 0x11e6 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    11b6:	20 91 f0 00 	lds	r18, 0x00F0
    11ba:	30 91 f1 00 	lds	r19, 0x00F1
    11be:	80 91 ee 00 	lds	r24, 0x00EE
    11c2:	90 91 ef 00 	lds	r25, 0x00EF
    11c6:	82 0f       	add	r24, r18
    11c8:	93 1f       	adc	r25, r19
    11ca:	9a 83       	std	Y+2, r25	; 0x02
    11cc:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    11ce:	20 91 ee 00 	lds	r18, 0x00EE
    11d2:	30 91 ef 00 	lds	r19, 0x00EF
    11d6:	8b 81       	ldd	r24, Y+3	; 0x03
    11d8:	9c 81       	ldd	r25, Y+4	; 0x04
    11da:	82 0f       	add	r24, r18
    11dc:	93 1f       	adc	r25, r19
    11de:	90 93 ef 00 	sts	0x00EF, r25
    11e2:	80 93 ee 00 	sts	0x00EE, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    11e6:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    11ea:	89 81       	ldd	r24, Y+1	; 0x01
    11ec:	9a 81       	ldd	r25, Y+2	; 0x02
}
    11ee:	0f 90       	pop	r0
    11f0:	0f 90       	pop	r0
    11f2:	0f 90       	pop	r0
    11f4:	0f 90       	pop	r0
    11f6:	cf 91       	pop	r28
    11f8:	df 91       	pop	r29
    11fa:	08 95       	ret

000011fc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    11fc:	df 93       	push	r29
    11fe:	cf 93       	push	r28
    1200:	00 d0       	rcall	.+0      	; 0x1202 <vPortFree+0x6>
    1202:	cd b7       	in	r28, 0x3d	; 61
    1204:	de b7       	in	r29, 0x3e	; 62
    1206:	9a 83       	std	Y+2, r25	; 0x02
    1208:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    120a:	0f 90       	pop	r0
    120c:	0f 90       	pop	r0
    120e:	cf 91       	pop	r28
    1210:	df 91       	pop	r29
    1212:	08 95       	ret

00001214 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1214:	df 93       	push	r29
    1216:	cf 93       	push	r28
    1218:	cd b7       	in	r28, 0x3d	; 61
    121a:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    121c:	10 92 ef 00 	sts	0x00EF, r1
    1220:	10 92 ee 00 	sts	0x00EE, r1
}
    1224:	cf 91       	pop	r28
    1226:	df 91       	pop	r29
    1228:	08 95       	ret

0000122a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    122a:	df 93       	push	r29
    122c:	cf 93       	push	r28
    122e:	cd b7       	in	r28, 0x3d	; 61
    1230:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1232:	20 91 ee 00 	lds	r18, 0x00EE
    1236:	30 91 ef 00 	lds	r19, 0x00EF
    123a:	8b ed       	ldi	r24, 0xDB	; 219
    123c:	95 e0       	ldi	r25, 0x05	; 5
    123e:	82 1b       	sub	r24, r18
    1240:	93 0b       	sbc	r25, r19
}
    1242:	cf 91       	pop	r28
    1244:	df 91       	pop	r29
    1246:	08 95       	ret

00001248 <LCD_init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_init(void)
{
    1248:	df 93       	push	r29
    124a:	cf 93       	push	r28
    124c:	cd b7       	in	r28, 0x3d	; 61
    124e:	de b7       	in	r29, 0x3e	; 62

	LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW); /* Configure the control pins(E,RS,RW) as output pins */
    1250:	aa e3       	ldi	r26, 0x3A	; 58
    1252:	b0 e0       	ldi	r27, 0x00	; 0
    1254:	ea e3       	ldi	r30, 0x3A	; 58
    1256:	f0 e0       	ldi	r31, 0x00	; 0
    1258:	80 81       	ld	r24, Z
    125a:	8e 60       	ori	r24, 0x0E	; 14
    125c:	8c 93       	st	X, r24

#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT_DIR |= 0xF0; /* Configure the highest 4 bits of the data port as output pins */
    125e:	aa e3       	ldi	r26, 0x3A	; 58
    1260:	b0 e0       	ldi	r27, 0x00	; 0
    1262:	ea e3       	ldi	r30, 0x3A	; 58
    1264:	f0 e0       	ldi	r31, 0x00	; 0
    1266:	80 81       	ld	r24, Z
    1268:	80 6f       	ori	r24, 0xF0	; 240
    126a:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT_DIR |= 0x0F; /* Configure the lowest 4 bits of the data port as output pins */
#endif

	LCD_sendCommand(FOUR_BITS_DATA_MODE); /* initialize LCD in 4-bit mode */
    126c:	82 e0       	ldi	r24, 0x02	; 2
    126e:	0e 94 45 09 	call	0x128a	; 0x128a <LCD_sendCommand>

	LCD_sendCommand(TWO_LINE_LCD_Four_BIT_MODE); /* use 2-line lcd + 4-bit Data Mode + 5*7 dot display Mode */
    1272:	88 e2       	ldi	r24, 0x28	; 40
    1274:	0e 94 45 09 	call	0x128a	; 0x128a <LCD_sendCommand>
#elif (DATA_BITS_MODE == 8)
	LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
	LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
#endif

	LCD_sendCommand(CURSOR_OFF); /* cursor off */
    1278:	8c e0       	ldi	r24, 0x0C	; 12
    127a:	0e 94 45 09 	call	0x128a	; 0x128a <LCD_sendCommand>
	LCD_sendCommand(CLEAR_COMMAND); /* clear LCD at the beginning */
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	0e 94 45 09 	call	0x128a	; 0x128a <LCD_sendCommand>

}
    1284:	cf 91       	pop	r28
    1286:	df 91       	pop	r29
    1288:	08 95       	ret

0000128a <LCD_sendCommand>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_sendCommand(uint8 command)
{
    128a:	df 93       	push	r29
    128c:	cf 93       	push	r28
    128e:	0f 92       	push	r0
    1290:	cd b7       	in	r28, 0x3d	; 61
    1292:	de b7       	in	r29, 0x3e	; 62
    1294:	89 83       	std	Y+1, r24	; 0x01
	CLEAR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
    1296:	ab e3       	ldi	r26, 0x3B	; 59
    1298:	b0 e0       	ldi	r27, 0x00	; 0
    129a:	eb e3       	ldi	r30, 0x3B	; 59
    129c:	f0 e0       	ldi	r31, 0x00	; 0
    129e:	80 81       	ld	r24, Z
    12a0:	8d 7f       	andi	r24, 0xFD	; 253
    12a2:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    12a4:	ab e3       	ldi	r26, 0x3B	; 59
    12a6:	b0 e0       	ldi	r27, 0x00	; 0
    12a8:	eb e3       	ldi	r30, 0x3B	; 59
    12aa:	f0 e0       	ldi	r31, 0x00	; 0
    12ac:	80 81       	ld	r24, Z
    12ae:	8b 7f       	andi	r24, 0xFB	; 251
    12b0:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    12b2:	81 e0       	ldi	r24, 0x01	; 1
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    12ba:	ab e3       	ldi	r26, 0x3B	; 59
    12bc:	b0 e0       	ldi	r27, 0x00	; 0
    12be:	eb e3       	ldi	r30, 0x3B	; 59
    12c0:	f0 e0       	ldi	r31, 0x00	; 0
    12c2:	80 81       	ld	r24, Z
    12c4:	88 60       	ori	r24, 0x08	; 8
    12c6:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    12c8:	81 e0       	ldi	r24, 0x01	; 1
    12ca:	90 e0       	ldi	r25, 0x00	; 0
    12cc:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (command & 0xF0);
    12d0:	ab e3       	ldi	r26, 0x3B	; 59
    12d2:	b0 e0       	ldi	r27, 0x00	; 0
    12d4:	eb e3       	ldi	r30, 0x3B	; 59
    12d6:	f0 e0       	ldi	r31, 0x00	; 0
    12d8:	80 81       	ld	r24, Z
    12da:	98 2f       	mov	r25, r24
    12dc:	9f 70       	andi	r25, 0x0F	; 15
    12de:	89 81       	ldd	r24, Y+1	; 0x01
    12e0:	80 7f       	andi	r24, 0xF0	; 240
    12e2:	89 2b       	or	r24, r25
    12e4:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((command & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    12e6:	81 e0       	ldi	r24, 0x01	; 1
    12e8:	90 e0       	ldi	r25, 0x00	; 0
    12ea:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    12ee:	ab e3       	ldi	r26, 0x3B	; 59
    12f0:	b0 e0       	ldi	r27, 0x00	; 0
    12f2:	eb e3       	ldi	r30, 0x3B	; 59
    12f4:	f0 e0       	ldi	r31, 0x00	; 0
    12f6:	80 81       	ld	r24, Z
    12f8:	87 7f       	andi	r24, 0xF7	; 247
    12fa:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    12fc:	81 e0       	ldi	r24, 0x01	; 1
    12fe:	90 e0       	ldi	r25, 0x00	; 0
    1300:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    1304:	ab e3       	ldi	r26, 0x3B	; 59
    1306:	b0 e0       	ldi	r27, 0x00	; 0
    1308:	eb e3       	ldi	r30, 0x3B	; 59
    130a:	f0 e0       	ldi	r31, 0x00	; 0
    130c:	80 81       	ld	r24, Z
    130e:	88 60       	ori	r24, 0x08	; 8
    1310:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1312:	81 e0       	ldi	r24, 0x01	; 1
    1314:	90 e0       	ldi	r25, 0x00	; 0
    1316:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>

	/* out the lowest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((command & 0x0F) << 4);
    131a:	ab e3       	ldi	r26, 0x3B	; 59
    131c:	b0 e0       	ldi	r27, 0x00	; 0
    131e:	eb e3       	ldi	r30, 0x3B	; 59
    1320:	f0 e0       	ldi	r31, 0x00	; 0
    1322:	80 81       	ld	r24, Z
    1324:	28 2f       	mov	r18, r24
    1326:	2f 70       	andi	r18, 0x0F	; 15
    1328:	89 81       	ldd	r24, Y+1	; 0x01
    132a:	88 2f       	mov	r24, r24
    132c:	90 e0       	ldi	r25, 0x00	; 0
    132e:	82 95       	swap	r24
    1330:	92 95       	swap	r25
    1332:	90 7f       	andi	r25, 0xF0	; 240
    1334:	98 27       	eor	r25, r24
    1336:	80 7f       	andi	r24, 0xF0	; 240
    1338:	98 27       	eor	r25, r24
    133a:	82 2b       	or	r24, r18
    133c:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (command & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    133e:	81 e0       	ldi	r24, 0x01	; 1
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1346:	ab e3       	ldi	r26, 0x3B	; 59
    1348:	b0 e0       	ldi	r27, 0x00	; 0
    134a:	eb e3       	ldi	r30, 0x3B	; 59
    134c:	f0 e0       	ldi	r31, 0x00	; 0
    134e:	80 81       	ld	r24, Z
    1350:	87 7f       	andi	r24, 0xF7	; 247
    1352:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1354:	81 e0       	ldi	r24, 0x01	; 1
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    135c:	0f 90       	pop	r0
    135e:	cf 91       	pop	r28
    1360:	df 91       	pop	r29
    1362:	08 95       	ret

00001364 <LCD_displayCharacter>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayCharacter(uint8 data)
{
    1364:	df 93       	push	r29
    1366:	cf 93       	push	r28
    1368:	0f 92       	push	r0
    136a:	cd b7       	in	r28, 0x3d	; 61
    136c:	de b7       	in	r29, 0x3e	; 62
    136e:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
    1370:	ab e3       	ldi	r26, 0x3B	; 59
    1372:	b0 e0       	ldi	r27, 0x00	; 0
    1374:	eb e3       	ldi	r30, 0x3B	; 59
    1376:	f0 e0       	ldi	r31, 0x00	; 0
    1378:	80 81       	ld	r24, Z
    137a:	82 60       	ori	r24, 0x02	; 2
    137c:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    137e:	ab e3       	ldi	r26, 0x3B	; 59
    1380:	b0 e0       	ldi	r27, 0x00	; 0
    1382:	eb e3       	ldi	r30, 0x3B	; 59
    1384:	f0 e0       	ldi	r31, 0x00	; 0
    1386:	80 81       	ld	r24, Z
    1388:	8b 7f       	andi	r24, 0xFB	; 251
    138a:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    138c:	81 e0       	ldi	r24, 0x01	; 1
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    1394:	ab e3       	ldi	r26, 0x3B	; 59
    1396:	b0 e0       	ldi	r27, 0x00	; 0
    1398:	eb e3       	ldi	r30, 0x3B	; 59
    139a:	f0 e0       	ldi	r31, 0x00	; 0
    139c:	80 81       	ld	r24, Z
    139e:	88 60       	ori	r24, 0x08	; 8
    13a0:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    13a2:	81 e0       	ldi	r24, 0x01	; 1
    13a4:	90 e0       	ldi	r25, 0x00	; 0
    13a6:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (data & 0xF0);
    13aa:	ab e3       	ldi	r26, 0x3B	; 59
    13ac:	b0 e0       	ldi	r27, 0x00	; 0
    13ae:	eb e3       	ldi	r30, 0x3B	; 59
    13b0:	f0 e0       	ldi	r31, 0x00	; 0
    13b2:	80 81       	ld	r24, Z
    13b4:	98 2f       	mov	r25, r24
    13b6:	9f 70       	andi	r25, 0x0F	; 15
    13b8:	89 81       	ldd	r24, Y+1	; 0x01
    13ba:	80 7f       	andi	r24, 0xF0	; 240
    13bc:	89 2b       	or	r24, r25
    13be:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((data & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    13c0:	81 e0       	ldi	r24, 0x01	; 1
    13c2:	90 e0       	ldi	r25, 0x00	; 0
    13c4:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    13c8:	ab e3       	ldi	r26, 0x3B	; 59
    13ca:	b0 e0       	ldi	r27, 0x00	; 0
    13cc:	eb e3       	ldi	r30, 0x3B	; 59
    13ce:	f0 e0       	ldi	r31, 0x00	; 0
    13d0:	80 81       	ld	r24, Z
    13d2:	87 7f       	andi	r24, 0xF7	; 247
    13d4:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    13d6:	81 e0       	ldi	r24, 0x01	; 1
    13d8:	90 e0       	ldi	r25, 0x00	; 0
    13da:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    13de:	ab e3       	ldi	r26, 0x3B	; 59
    13e0:	b0 e0       	ldi	r27, 0x00	; 0
    13e2:	eb e3       	ldi	r30, 0x3B	; 59
    13e4:	f0 e0       	ldi	r31, 0x00	; 0
    13e6:	80 81       	ld	r24, Z
    13e8:	88 60       	ori	r24, 0x08	; 8
    13ea:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	90 e0       	ldi	r25, 0x00	; 0
    13f0:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>

	/* out the lowest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((data & 0x0F) << 4);
    13f4:	ab e3       	ldi	r26, 0x3B	; 59
    13f6:	b0 e0       	ldi	r27, 0x00	; 0
    13f8:	eb e3       	ldi	r30, 0x3B	; 59
    13fa:	f0 e0       	ldi	r31, 0x00	; 0
    13fc:	80 81       	ld	r24, Z
    13fe:	28 2f       	mov	r18, r24
    1400:	2f 70       	andi	r18, 0x0F	; 15
    1402:	89 81       	ldd	r24, Y+1	; 0x01
    1404:	88 2f       	mov	r24, r24
    1406:	90 e0       	ldi	r25, 0x00	; 0
    1408:	82 95       	swap	r24
    140a:	92 95       	swap	r25
    140c:	90 7f       	andi	r25, 0xF0	; 240
    140e:	98 27       	eor	r25, r24
    1410:	80 7f       	andi	r24, 0xF0	; 240
    1412:	98 27       	eor	r25, r24
    1414:	82 2b       	or	r24, r18
    1416:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (data & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1418:	81 e0       	ldi	r24, 0x01	; 1
    141a:	90 e0       	ldi	r25, 0x00	; 0
    141c:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1420:	ab e3       	ldi	r26, 0x3B	; 59
    1422:	b0 e0       	ldi	r27, 0x00	; 0
    1424:	eb e3       	ldi	r30, 0x3B	; 59
    1426:	f0 e0       	ldi	r31, 0x00	; 0
    1428:	80 81       	ld	r24, Z
    142a:	87 7f       	andi	r24, 0xF7	; 247
    142c:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    142e:	81 e0       	ldi	r24, 0x01	; 1
    1430:	90 e0       	ldi	r25, 0x00	; 0
    1432:	0e 94 59 20 	call	0x40b2	; 0x40b2 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    1436:	0f 90       	pop	r0
    1438:	cf 91       	pop	r28
    143a:	df 91       	pop	r29
    143c:	08 95       	ret

0000143e <LCD_displayString>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
    143e:	df 93       	push	r29
    1440:	cf 93       	push	r28
    1442:	00 d0       	rcall	.+0      	; 0x1444 <LCD_displayString+0x6>
    1444:	0f 92       	push	r0
    1446:	cd b7       	in	r28, 0x3d	; 61
    1448:	de b7       	in	r29, 0x3e	; 62
    144a:	9b 83       	std	Y+3, r25	; 0x03
    144c:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    144e:	19 82       	std	Y+1, r1	; 0x01
    1450:	0e c0       	rjmp	.+28     	; 0x146e <LCD_displayString+0x30>
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    1452:	89 81       	ldd	r24, Y+1	; 0x01
    1454:	28 2f       	mov	r18, r24
    1456:	30 e0       	ldi	r19, 0x00	; 0
    1458:	8a 81       	ldd	r24, Y+2	; 0x02
    145a:	9b 81       	ldd	r25, Y+3	; 0x03
    145c:	fc 01       	movw	r30, r24
    145e:	e2 0f       	add	r30, r18
    1460:	f3 1f       	adc	r31, r19
    1462:	80 81       	ld	r24, Z
    1464:	0e 94 b2 09 	call	0x1364	; 0x1364 <LCD_displayCharacter>
		i++;
    1468:	89 81       	ldd	r24, Y+1	; 0x01
    146a:	8f 5f       	subi	r24, 0xFF	; 255
    146c:	89 83       	std	Y+1, r24	; 0x01
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
	uint8 i = 0;
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
    146e:	89 81       	ldd	r24, Y+1	; 0x01
    1470:	28 2f       	mov	r18, r24
    1472:	30 e0       	ldi	r19, 0x00	; 0
    1474:	8a 81       	ldd	r24, Y+2	; 0x02
    1476:	9b 81       	ldd	r25, Y+3	; 0x03
    1478:	fc 01       	movw	r30, r24
    147a:	e2 0f       	add	r30, r18
    147c:	f3 1f       	adc	r31, r19
    147e:	80 81       	ld	r24, Z
    1480:	88 23       	and	r24, r24
    1482:	39 f7       	brne	.-50     	; 0x1452 <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	 *********************************************************/
}
    1484:	0f 90       	pop	r0
    1486:	0f 90       	pop	r0
    1488:	0f 90       	pop	r0
    148a:	cf 91       	pop	r28
    148c:	df 91       	pop	r29
    148e:	08 95       	ret

00001490 <LCD_goToRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_goToRowColumn(uint8 row,uint8 col)
{
    1490:	df 93       	push	r29
    1492:	cf 93       	push	r28
    1494:	00 d0       	rcall	.+0      	; 0x1496 <LCD_goToRowColumn+0x6>
    1496:	00 d0       	rcall	.+0      	; 0x1498 <LCD_goToRowColumn+0x8>
    1498:	0f 92       	push	r0
    149a:	cd b7       	in	r28, 0x3d	; 61
    149c:	de b7       	in	r29, 0x3e	; 62
    149e:	8a 83       	std	Y+2, r24	; 0x02
    14a0:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;

	/* first of all calculate the required address */
	switch(row)
    14a2:	8a 81       	ldd	r24, Y+2	; 0x02
    14a4:	28 2f       	mov	r18, r24
    14a6:	30 e0       	ldi	r19, 0x00	; 0
    14a8:	3d 83       	std	Y+5, r19	; 0x05
    14aa:	2c 83       	std	Y+4, r18	; 0x04
    14ac:	8c 81       	ldd	r24, Y+4	; 0x04
    14ae:	9d 81       	ldd	r25, Y+5	; 0x05
    14b0:	81 30       	cpi	r24, 0x01	; 1
    14b2:	91 05       	cpc	r25, r1
    14b4:	c1 f0       	breq	.+48     	; 0x14e6 <LCD_goToRowColumn+0x56>
    14b6:	2c 81       	ldd	r18, Y+4	; 0x04
    14b8:	3d 81       	ldd	r19, Y+5	; 0x05
    14ba:	22 30       	cpi	r18, 0x02	; 2
    14bc:	31 05       	cpc	r19, r1
    14be:	2c f4       	brge	.+10     	; 0x14ca <LCD_goToRowColumn+0x3a>
    14c0:	8c 81       	ldd	r24, Y+4	; 0x04
    14c2:	9d 81       	ldd	r25, Y+5	; 0x05
    14c4:	00 97       	sbiw	r24, 0x00	; 0
    14c6:	61 f0       	breq	.+24     	; 0x14e0 <LCD_goToRowColumn+0x50>
    14c8:	19 c0       	rjmp	.+50     	; 0x14fc <LCD_goToRowColumn+0x6c>
    14ca:	2c 81       	ldd	r18, Y+4	; 0x04
    14cc:	3d 81       	ldd	r19, Y+5	; 0x05
    14ce:	22 30       	cpi	r18, 0x02	; 2
    14d0:	31 05       	cpc	r19, r1
    14d2:	69 f0       	breq	.+26     	; 0x14ee <LCD_goToRowColumn+0x5e>
    14d4:	8c 81       	ldd	r24, Y+4	; 0x04
    14d6:	9d 81       	ldd	r25, Y+5	; 0x05
    14d8:	83 30       	cpi	r24, 0x03	; 3
    14da:	91 05       	cpc	r25, r1
    14dc:	61 f0       	breq	.+24     	; 0x14f6 <LCD_goToRowColumn+0x66>
    14de:	0e c0       	rjmp	.+28     	; 0x14fc <LCD_goToRowColumn+0x6c>
	{
	case 0:
		Address=col;
    14e0:	8b 81       	ldd	r24, Y+3	; 0x03
    14e2:	89 83       	std	Y+1, r24	; 0x01
    14e4:	0b c0       	rjmp	.+22     	; 0x14fc <LCD_goToRowColumn+0x6c>
		break;
	case 1:
		Address=col+0x40;
    14e6:	8b 81       	ldd	r24, Y+3	; 0x03
    14e8:	80 5c       	subi	r24, 0xC0	; 192
    14ea:	89 83       	std	Y+1, r24	; 0x01
    14ec:	07 c0       	rjmp	.+14     	; 0x14fc <LCD_goToRowColumn+0x6c>
		break;
	case 2:
		Address=col+0x10;
    14ee:	8b 81       	ldd	r24, Y+3	; 0x03
    14f0:	80 5f       	subi	r24, 0xF0	; 240
    14f2:	89 83       	std	Y+1, r24	; 0x01
    14f4:	03 c0       	rjmp	.+6      	; 0x14fc <LCD_goToRowColumn+0x6c>
		break;
	case 3:
		Address=col+0x50;
    14f6:	8b 81       	ldd	r24, Y+3	; 0x03
    14f8:	80 5b       	subi	r24, 0xB0	; 176
    14fa:	89 83       	std	Y+1, r24	; 0x01
		break;
	}					
	/* to write to a specific address in the LCD 
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION); 
    14fc:	89 81       	ldd	r24, Y+1	; 0x01
    14fe:	80 68       	ori	r24, 0x80	; 128
    1500:	0e 94 45 09 	call	0x128a	; 0x128a <LCD_sendCommand>
}
    1504:	0f 90       	pop	r0
    1506:	0f 90       	pop	r0
    1508:	0f 90       	pop	r0
    150a:	0f 90       	pop	r0
    150c:	0f 90       	pop	r0
    150e:	cf 91       	pop	r28
    1510:	df 91       	pop	r29
    1512:	08 95       	ret

00001514 <LCD_displayStringRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayStringRowColumn(uint8 row,uint8 col,const uint8 *Str)
{
    1514:	df 93       	push	r29
    1516:	cf 93       	push	r28
    1518:	00 d0       	rcall	.+0      	; 0x151a <LCD_displayStringRowColumn+0x6>
    151a:	00 d0       	rcall	.+0      	; 0x151c <LCD_displayStringRowColumn+0x8>
    151c:	cd b7       	in	r28, 0x3d	; 61
    151e:	de b7       	in	r29, 0x3e	; 62
    1520:	89 83       	std	Y+1, r24	; 0x01
    1522:	6a 83       	std	Y+2, r22	; 0x02
    1524:	5c 83       	std	Y+4, r21	; 0x04
    1526:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    1528:	89 81       	ldd	r24, Y+1	; 0x01
    152a:	6a 81       	ldd	r22, Y+2	; 0x02
    152c:	0e 94 48 0a 	call	0x1490	; 0x1490 <LCD_goToRowColumn>
	LCD_displayString(Str); /* display the string */
    1530:	8b 81       	ldd	r24, Y+3	; 0x03
    1532:	9c 81       	ldd	r25, Y+4	; 0x04
    1534:	0e 94 1f 0a 	call	0x143e	; 0x143e <LCD_displayString>
}
    1538:	0f 90       	pop	r0
    153a:	0f 90       	pop	r0
    153c:	0f 90       	pop	r0
    153e:	0f 90       	pop	r0
    1540:	cf 91       	pop	r28
    1542:	df 91       	pop	r29
    1544:	08 95       	ret

00001546 <LCD_clearScreen>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_clearScreen(void)
{
    1546:	df 93       	push	r29
    1548:	cf 93       	push	r28
    154a:	cd b7       	in	r28, 0x3d	; 61
    154c:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(CLEAR_COMMAND); //clear display 
    154e:	81 e0       	ldi	r24, 0x01	; 1
    1550:	0e 94 45 09 	call	0x128a	; 0x128a <LCD_sendCommand>
}
    1554:	cf 91       	pop	r28
    1556:	df 91       	pop	r29
    1558:	08 95       	ret

0000155a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    155a:	df 93       	push	r29
    155c:	cf 93       	push	r28
    155e:	00 d0       	rcall	.+0      	; 0x1560 <vListInitialise+0x6>
    1560:	cd b7       	in	r28, 0x3d	; 61
    1562:	de b7       	in	r29, 0x3e	; 62
    1564:	9a 83       	std	Y+2, r25	; 0x02
    1566:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1568:	89 81       	ldd	r24, Y+1	; 0x01
    156a:	9a 81       	ldd	r25, Y+2	; 0x02
    156c:	03 96       	adiw	r24, 0x03	; 3
    156e:	e9 81       	ldd	r30, Y+1	; 0x01
    1570:	fa 81       	ldd	r31, Y+2	; 0x02
    1572:	92 83       	std	Z+2, r25	; 0x02
    1574:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1576:	e9 81       	ldd	r30, Y+1	; 0x01
    1578:	fa 81       	ldd	r31, Y+2	; 0x02
    157a:	8f ef       	ldi	r24, 0xFF	; 255
    157c:	9f ef       	ldi	r25, 0xFF	; 255
    157e:	94 83       	std	Z+4, r25	; 0x04
    1580:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1582:	89 81       	ldd	r24, Y+1	; 0x01
    1584:	9a 81       	ldd	r25, Y+2	; 0x02
    1586:	03 96       	adiw	r24, 0x03	; 3
    1588:	e9 81       	ldd	r30, Y+1	; 0x01
    158a:	fa 81       	ldd	r31, Y+2	; 0x02
    158c:	96 83       	std	Z+6, r25	; 0x06
    158e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1590:	89 81       	ldd	r24, Y+1	; 0x01
    1592:	9a 81       	ldd	r25, Y+2	; 0x02
    1594:	03 96       	adiw	r24, 0x03	; 3
    1596:	e9 81       	ldd	r30, Y+1	; 0x01
    1598:	fa 81       	ldd	r31, Y+2	; 0x02
    159a:	90 87       	std	Z+8, r25	; 0x08
    159c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    159e:	e9 81       	ldd	r30, Y+1	; 0x01
    15a0:	fa 81       	ldd	r31, Y+2	; 0x02
    15a2:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    15a4:	0f 90       	pop	r0
    15a6:	0f 90       	pop	r0
    15a8:	cf 91       	pop	r28
    15aa:	df 91       	pop	r29
    15ac:	08 95       	ret

000015ae <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    15ae:	df 93       	push	r29
    15b0:	cf 93       	push	r28
    15b2:	00 d0       	rcall	.+0      	; 0x15b4 <vListInitialiseItem+0x6>
    15b4:	cd b7       	in	r28, 0x3d	; 61
    15b6:	de b7       	in	r29, 0x3e	; 62
    15b8:	9a 83       	std	Y+2, r25	; 0x02
    15ba:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    15bc:	e9 81       	ldd	r30, Y+1	; 0x01
    15be:	fa 81       	ldd	r31, Y+2	; 0x02
    15c0:	11 86       	std	Z+9, r1	; 0x09
    15c2:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    15c4:	0f 90       	pop	r0
    15c6:	0f 90       	pop	r0
    15c8:	cf 91       	pop	r28
    15ca:	df 91       	pop	r29
    15cc:	08 95       	ret

000015ce <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    15ce:	df 93       	push	r29
    15d0:	cf 93       	push	r28
    15d2:	00 d0       	rcall	.+0      	; 0x15d4 <vListInsertEnd+0x6>
    15d4:	00 d0       	rcall	.+0      	; 0x15d6 <vListInsertEnd+0x8>
    15d6:	00 d0       	rcall	.+0      	; 0x15d8 <vListInsertEnd+0xa>
    15d8:	cd b7       	in	r28, 0x3d	; 61
    15da:	de b7       	in	r29, 0x3e	; 62
    15dc:	9c 83       	std	Y+4, r25	; 0x04
    15de:	8b 83       	std	Y+3, r24	; 0x03
    15e0:	7e 83       	std	Y+6, r23	; 0x06
    15e2:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    15e4:	eb 81       	ldd	r30, Y+3	; 0x03
    15e6:	fc 81       	ldd	r31, Y+4	; 0x04
    15e8:	81 81       	ldd	r24, Z+1	; 0x01
    15ea:	92 81       	ldd	r25, Z+2	; 0x02
    15ec:	9a 83       	std	Y+2, r25	; 0x02
    15ee:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    15f0:	ed 81       	ldd	r30, Y+5	; 0x05
    15f2:	fe 81       	ldd	r31, Y+6	; 0x06
    15f4:	89 81       	ldd	r24, Y+1	; 0x01
    15f6:	9a 81       	ldd	r25, Y+2	; 0x02
    15f8:	93 83       	std	Z+3, r25	; 0x03
    15fa:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    15fc:	e9 81       	ldd	r30, Y+1	; 0x01
    15fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1600:	84 81       	ldd	r24, Z+4	; 0x04
    1602:	95 81       	ldd	r25, Z+5	; 0x05
    1604:	ed 81       	ldd	r30, Y+5	; 0x05
    1606:	fe 81       	ldd	r31, Y+6	; 0x06
    1608:	95 83       	std	Z+5, r25	; 0x05
    160a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    160c:	e9 81       	ldd	r30, Y+1	; 0x01
    160e:	fa 81       	ldd	r31, Y+2	; 0x02
    1610:	04 80       	ldd	r0, Z+4	; 0x04
    1612:	f5 81       	ldd	r31, Z+5	; 0x05
    1614:	e0 2d       	mov	r30, r0
    1616:	8d 81       	ldd	r24, Y+5	; 0x05
    1618:	9e 81       	ldd	r25, Y+6	; 0x06
    161a:	93 83       	std	Z+3, r25	; 0x03
    161c:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    161e:	e9 81       	ldd	r30, Y+1	; 0x01
    1620:	fa 81       	ldd	r31, Y+2	; 0x02
    1622:	8d 81       	ldd	r24, Y+5	; 0x05
    1624:	9e 81       	ldd	r25, Y+6	; 0x06
    1626:	95 83       	std	Z+5, r25	; 0x05
    1628:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    162a:	ed 81       	ldd	r30, Y+5	; 0x05
    162c:	fe 81       	ldd	r31, Y+6	; 0x06
    162e:	8b 81       	ldd	r24, Y+3	; 0x03
    1630:	9c 81       	ldd	r25, Y+4	; 0x04
    1632:	91 87       	std	Z+9, r25	; 0x09
    1634:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1636:	eb 81       	ldd	r30, Y+3	; 0x03
    1638:	fc 81       	ldd	r31, Y+4	; 0x04
    163a:	80 81       	ld	r24, Z
    163c:	8f 5f       	subi	r24, 0xFF	; 255
    163e:	eb 81       	ldd	r30, Y+3	; 0x03
    1640:	fc 81       	ldd	r31, Y+4	; 0x04
    1642:	80 83       	st	Z, r24
}
    1644:	26 96       	adiw	r28, 0x06	; 6
    1646:	0f b6       	in	r0, 0x3f	; 63
    1648:	f8 94       	cli
    164a:	de bf       	out	0x3e, r29	; 62
    164c:	0f be       	out	0x3f, r0	; 63
    164e:	cd bf       	out	0x3d, r28	; 61
    1650:	cf 91       	pop	r28
    1652:	df 91       	pop	r29
    1654:	08 95       	ret

00001656 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1656:	df 93       	push	r29
    1658:	cf 93       	push	r28
    165a:	cd b7       	in	r28, 0x3d	; 61
    165c:	de b7       	in	r29, 0x3e	; 62
    165e:	28 97       	sbiw	r28, 0x08	; 8
    1660:	0f b6       	in	r0, 0x3f	; 63
    1662:	f8 94       	cli
    1664:	de bf       	out	0x3e, r29	; 62
    1666:	0f be       	out	0x3f, r0	; 63
    1668:	cd bf       	out	0x3d, r28	; 61
    166a:	9e 83       	std	Y+6, r25	; 0x06
    166c:	8d 83       	std	Y+5, r24	; 0x05
    166e:	78 87       	std	Y+8, r23	; 0x08
    1670:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1672:	ef 81       	ldd	r30, Y+7	; 0x07
    1674:	f8 85       	ldd	r31, Y+8	; 0x08
    1676:	80 81       	ld	r24, Z
    1678:	91 81       	ldd	r25, Z+1	; 0x01
    167a:	9a 83       	std	Y+2, r25	; 0x02
    167c:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    167e:	89 81       	ldd	r24, Y+1	; 0x01
    1680:	9a 81       	ldd	r25, Y+2	; 0x02
    1682:	2f ef       	ldi	r18, 0xFF	; 255
    1684:	8f 3f       	cpi	r24, 0xFF	; 255
    1686:	92 07       	cpc	r25, r18
    1688:	39 f4       	brne	.+14     	; 0x1698 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    168a:	ed 81       	ldd	r30, Y+5	; 0x05
    168c:	fe 81       	ldd	r31, Y+6	; 0x06
    168e:	87 81       	ldd	r24, Z+7	; 0x07
    1690:	90 85       	ldd	r25, Z+8	; 0x08
    1692:	9c 83       	std	Y+4, r25	; 0x04
    1694:	8b 83       	std	Y+3, r24	; 0x03
    1696:	18 c0       	rjmp	.+48     	; 0x16c8 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1698:	8d 81       	ldd	r24, Y+5	; 0x05
    169a:	9e 81       	ldd	r25, Y+6	; 0x06
    169c:	03 96       	adiw	r24, 0x03	; 3
    169e:	9c 83       	std	Y+4, r25	; 0x04
    16a0:	8b 83       	std	Y+3, r24	; 0x03
    16a2:	06 c0       	rjmp	.+12     	; 0x16b0 <vListInsert+0x5a>
    16a4:	eb 81       	ldd	r30, Y+3	; 0x03
    16a6:	fc 81       	ldd	r31, Y+4	; 0x04
    16a8:	82 81       	ldd	r24, Z+2	; 0x02
    16aa:	93 81       	ldd	r25, Z+3	; 0x03
    16ac:	9c 83       	std	Y+4, r25	; 0x04
    16ae:	8b 83       	std	Y+3, r24	; 0x03
    16b0:	eb 81       	ldd	r30, Y+3	; 0x03
    16b2:	fc 81       	ldd	r31, Y+4	; 0x04
    16b4:	02 80       	ldd	r0, Z+2	; 0x02
    16b6:	f3 81       	ldd	r31, Z+3	; 0x03
    16b8:	e0 2d       	mov	r30, r0
    16ba:	20 81       	ld	r18, Z
    16bc:	31 81       	ldd	r19, Z+1	; 0x01
    16be:	89 81       	ldd	r24, Y+1	; 0x01
    16c0:	9a 81       	ldd	r25, Y+2	; 0x02
    16c2:	82 17       	cp	r24, r18
    16c4:	93 07       	cpc	r25, r19
    16c6:	70 f7       	brcc	.-36     	; 0x16a4 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    16c8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ca:	fc 81       	ldd	r31, Y+4	; 0x04
    16cc:	82 81       	ldd	r24, Z+2	; 0x02
    16ce:	93 81       	ldd	r25, Z+3	; 0x03
    16d0:	ef 81       	ldd	r30, Y+7	; 0x07
    16d2:	f8 85       	ldd	r31, Y+8	; 0x08
    16d4:	93 83       	std	Z+3, r25	; 0x03
    16d6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    16d8:	ef 81       	ldd	r30, Y+7	; 0x07
    16da:	f8 85       	ldd	r31, Y+8	; 0x08
    16dc:	02 80       	ldd	r0, Z+2	; 0x02
    16de:	f3 81       	ldd	r31, Z+3	; 0x03
    16e0:	e0 2d       	mov	r30, r0
    16e2:	8f 81       	ldd	r24, Y+7	; 0x07
    16e4:	98 85       	ldd	r25, Y+8	; 0x08
    16e6:	95 83       	std	Z+5, r25	; 0x05
    16e8:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    16ea:	ef 81       	ldd	r30, Y+7	; 0x07
    16ec:	f8 85       	ldd	r31, Y+8	; 0x08
    16ee:	8b 81       	ldd	r24, Y+3	; 0x03
    16f0:	9c 81       	ldd	r25, Y+4	; 0x04
    16f2:	95 83       	std	Z+5, r25	; 0x05
    16f4:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    16f6:	eb 81       	ldd	r30, Y+3	; 0x03
    16f8:	fc 81       	ldd	r31, Y+4	; 0x04
    16fa:	8f 81       	ldd	r24, Y+7	; 0x07
    16fc:	98 85       	ldd	r25, Y+8	; 0x08
    16fe:	93 83       	std	Z+3, r25	; 0x03
    1700:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1702:	ef 81       	ldd	r30, Y+7	; 0x07
    1704:	f8 85       	ldd	r31, Y+8	; 0x08
    1706:	8d 81       	ldd	r24, Y+5	; 0x05
    1708:	9e 81       	ldd	r25, Y+6	; 0x06
    170a:	91 87       	std	Z+9, r25	; 0x09
    170c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    170e:	ed 81       	ldd	r30, Y+5	; 0x05
    1710:	fe 81       	ldd	r31, Y+6	; 0x06
    1712:	80 81       	ld	r24, Z
    1714:	8f 5f       	subi	r24, 0xFF	; 255
    1716:	ed 81       	ldd	r30, Y+5	; 0x05
    1718:	fe 81       	ldd	r31, Y+6	; 0x06
    171a:	80 83       	st	Z, r24
}
    171c:	28 96       	adiw	r28, 0x08	; 8
    171e:	0f b6       	in	r0, 0x3f	; 63
    1720:	f8 94       	cli
    1722:	de bf       	out	0x3e, r29	; 62
    1724:	0f be       	out	0x3f, r0	; 63
    1726:	cd bf       	out	0x3d, r28	; 61
    1728:	cf 91       	pop	r28
    172a:	df 91       	pop	r29
    172c:	08 95       	ret

0000172e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    172e:	df 93       	push	r29
    1730:	cf 93       	push	r28
    1732:	00 d0       	rcall	.+0      	; 0x1734 <uxListRemove+0x6>
    1734:	00 d0       	rcall	.+0      	; 0x1736 <uxListRemove+0x8>
    1736:	cd b7       	in	r28, 0x3d	; 61
    1738:	de b7       	in	r29, 0x3e	; 62
    173a:	9c 83       	std	Y+4, r25	; 0x04
    173c:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    173e:	eb 81       	ldd	r30, Y+3	; 0x03
    1740:	fc 81       	ldd	r31, Y+4	; 0x04
    1742:	80 85       	ldd	r24, Z+8	; 0x08
    1744:	91 85       	ldd	r25, Z+9	; 0x09
    1746:	9a 83       	std	Y+2, r25	; 0x02
    1748:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    174a:	eb 81       	ldd	r30, Y+3	; 0x03
    174c:	fc 81       	ldd	r31, Y+4	; 0x04
    174e:	a2 81       	ldd	r26, Z+2	; 0x02
    1750:	b3 81       	ldd	r27, Z+3	; 0x03
    1752:	eb 81       	ldd	r30, Y+3	; 0x03
    1754:	fc 81       	ldd	r31, Y+4	; 0x04
    1756:	84 81       	ldd	r24, Z+4	; 0x04
    1758:	95 81       	ldd	r25, Z+5	; 0x05
    175a:	15 96       	adiw	r26, 0x05	; 5
    175c:	9c 93       	st	X, r25
    175e:	8e 93       	st	-X, r24
    1760:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1762:	eb 81       	ldd	r30, Y+3	; 0x03
    1764:	fc 81       	ldd	r31, Y+4	; 0x04
    1766:	a4 81       	ldd	r26, Z+4	; 0x04
    1768:	b5 81       	ldd	r27, Z+5	; 0x05
    176a:	eb 81       	ldd	r30, Y+3	; 0x03
    176c:	fc 81       	ldd	r31, Y+4	; 0x04
    176e:	82 81       	ldd	r24, Z+2	; 0x02
    1770:	93 81       	ldd	r25, Z+3	; 0x03
    1772:	13 96       	adiw	r26, 0x03	; 3
    1774:	9c 93       	st	X, r25
    1776:	8e 93       	st	-X, r24
    1778:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    177a:	e9 81       	ldd	r30, Y+1	; 0x01
    177c:	fa 81       	ldd	r31, Y+2	; 0x02
    177e:	21 81       	ldd	r18, Z+1	; 0x01
    1780:	32 81       	ldd	r19, Z+2	; 0x02
    1782:	8b 81       	ldd	r24, Y+3	; 0x03
    1784:	9c 81       	ldd	r25, Y+4	; 0x04
    1786:	28 17       	cp	r18, r24
    1788:	39 07       	cpc	r19, r25
    178a:	41 f4       	brne	.+16     	; 0x179c <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    178c:	eb 81       	ldd	r30, Y+3	; 0x03
    178e:	fc 81       	ldd	r31, Y+4	; 0x04
    1790:	84 81       	ldd	r24, Z+4	; 0x04
    1792:	95 81       	ldd	r25, Z+5	; 0x05
    1794:	e9 81       	ldd	r30, Y+1	; 0x01
    1796:	fa 81       	ldd	r31, Y+2	; 0x02
    1798:	92 83       	std	Z+2, r25	; 0x02
    179a:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    179c:	eb 81       	ldd	r30, Y+3	; 0x03
    179e:	fc 81       	ldd	r31, Y+4	; 0x04
    17a0:	11 86       	std	Z+9, r1	; 0x09
    17a2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    17a4:	e9 81       	ldd	r30, Y+1	; 0x01
    17a6:	fa 81       	ldd	r31, Y+2	; 0x02
    17a8:	80 81       	ld	r24, Z
    17aa:	81 50       	subi	r24, 0x01	; 1
    17ac:	e9 81       	ldd	r30, Y+1	; 0x01
    17ae:	fa 81       	ldd	r31, Y+2	; 0x02
    17b0:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    17b2:	e9 81       	ldd	r30, Y+1	; 0x01
    17b4:	fa 81       	ldd	r31, Y+2	; 0x02
    17b6:	80 81       	ld	r24, Z
}
    17b8:	0f 90       	pop	r0
    17ba:	0f 90       	pop	r0
    17bc:	0f 90       	pop	r0
    17be:	0f 90       	pop	r0
    17c0:	cf 91       	pop	r28
    17c2:	df 91       	pop	r29
    17c4:	08 95       	ret

000017c6 <main>:

#include "UserTasks.h"


void main(void)
{
    17c6:	ef 92       	push	r14
    17c8:	ff 92       	push	r15
    17ca:	0f 93       	push	r16
    17cc:	df 93       	push	r29
    17ce:	cf 93       	push	r28
    17d0:	cd b7       	in	r28, 0x3d	; 61
    17d2:	de b7       	in	r29, 0x3e	; 62
	xTaskCreate(init_Task  , "Init_Task" , configMINIMAL_STACK_SIZE ,
    17d4:	83 ec       	ldi	r24, 0xC3	; 195
    17d6:	92 e0       	ldi	r25, 0x02	; 2
    17d8:	27 ed       	ldi	r18, 0xD7	; 215
    17da:	30 e0       	ldi	r19, 0x00	; 0
    17dc:	e8 ee       	ldi	r30, 0xE8	; 232
    17de:	f0 e0       	ldi	r31, 0x00	; 0
    17e0:	b9 01       	movw	r22, r18
    17e2:	46 e9       	ldi	r20, 0x96	; 150
    17e4:	50 e0       	ldi	r21, 0x00	; 0
    17e6:	20 e0       	ldi	r18, 0x00	; 0
    17e8:	30 e0       	ldi	r19, 0x00	; 0
    17ea:	05 e0       	ldi	r16, 0x05	; 5
    17ec:	7f 01       	movw	r14, r30
    17ee:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskCreate>
			NULL , (5 | portPRIVILEGE_BIT) , &InitTask_Flag);

	/* Start Scheduler */
	DIO_SetPinDirection(DIO_PIN12,OUTPUT);
    17f2:	8c e0       	ldi	r24, 0x0C	; 12
    17f4:	61 e0       	ldi	r22, 0x01	; 1
    17f6:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	vTaskStartScheduler();
    17fa:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <vTaskStartScheduler>
    17fe:	ff cf       	rjmp	.-2      	; 0x17fe <main+0x38>

00001800 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1800:	df 93       	push	r29
    1802:	cf 93       	push	r28
    1804:	cd b7       	in	r28, 0x3d	; 61
    1806:	de b7       	in	r29, 0x3e	; 62
    1808:	28 97       	sbiw	r28, 0x08	; 8
    180a:	0f b6       	in	r0, 0x3f	; 63
    180c:	f8 94       	cli
    180e:	de bf       	out	0x3e, r29	; 62
    1810:	0f be       	out	0x3f, r0	; 63
    1812:	cd bf       	out	0x3d, r28	; 61
    1814:	9c 83       	std	Y+4, r25	; 0x04
    1816:	8b 83       	std	Y+3, r24	; 0x03
    1818:	7e 83       	std	Y+6, r23	; 0x06
    181a:	6d 83       	std	Y+5, r22	; 0x05
    181c:	58 87       	std	Y+8, r21	; 0x08
    181e:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1820:	eb 81       	ldd	r30, Y+3	; 0x03
    1822:	fc 81       	ldd	r31, Y+4	; 0x04
    1824:	81 e1       	ldi	r24, 0x11	; 17
    1826:	80 83       	st	Z, r24
	pxTopOfStack--;
    1828:	8b 81       	ldd	r24, Y+3	; 0x03
    182a:	9c 81       	ldd	r25, Y+4	; 0x04
    182c:	01 97       	sbiw	r24, 0x01	; 1
    182e:	9c 83       	std	Y+4, r25	; 0x04
    1830:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1832:	eb 81       	ldd	r30, Y+3	; 0x03
    1834:	fc 81       	ldd	r31, Y+4	; 0x04
    1836:	82 e2       	ldi	r24, 0x22	; 34
    1838:	80 83       	st	Z, r24
	pxTopOfStack--;
    183a:	8b 81       	ldd	r24, Y+3	; 0x03
    183c:	9c 81       	ldd	r25, Y+4	; 0x04
    183e:	01 97       	sbiw	r24, 0x01	; 1
    1840:	9c 83       	std	Y+4, r25	; 0x04
    1842:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1844:	eb 81       	ldd	r30, Y+3	; 0x03
    1846:	fc 81       	ldd	r31, Y+4	; 0x04
    1848:	83 e3       	ldi	r24, 0x33	; 51
    184a:	80 83       	st	Z, r24
	pxTopOfStack--;
    184c:	8b 81       	ldd	r24, Y+3	; 0x03
    184e:	9c 81       	ldd	r25, Y+4	; 0x04
    1850:	01 97       	sbiw	r24, 0x01	; 1
    1852:	9c 83       	std	Y+4, r25	; 0x04
    1854:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1856:	8d 81       	ldd	r24, Y+5	; 0x05
    1858:	9e 81       	ldd	r25, Y+6	; 0x06
    185a:	9a 83       	std	Y+2, r25	; 0x02
    185c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    185e:	89 81       	ldd	r24, Y+1	; 0x01
    1860:	eb 81       	ldd	r30, Y+3	; 0x03
    1862:	fc 81       	ldd	r31, Y+4	; 0x04
    1864:	80 83       	st	Z, r24
	pxTopOfStack--;
    1866:	8b 81       	ldd	r24, Y+3	; 0x03
    1868:	9c 81       	ldd	r25, Y+4	; 0x04
    186a:	01 97       	sbiw	r24, 0x01	; 1
    186c:	9c 83       	std	Y+4, r25	; 0x04
    186e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1870:	89 81       	ldd	r24, Y+1	; 0x01
    1872:	9a 81       	ldd	r25, Y+2	; 0x02
    1874:	89 2f       	mov	r24, r25
    1876:	99 27       	eor	r25, r25
    1878:	9a 83       	std	Y+2, r25	; 0x02
    187a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    187c:	89 81       	ldd	r24, Y+1	; 0x01
    187e:	eb 81       	ldd	r30, Y+3	; 0x03
    1880:	fc 81       	ldd	r31, Y+4	; 0x04
    1882:	80 83       	st	Z, r24
	pxTopOfStack--;
    1884:	8b 81       	ldd	r24, Y+3	; 0x03
    1886:	9c 81       	ldd	r25, Y+4	; 0x04
    1888:	01 97       	sbiw	r24, 0x01	; 1
    188a:	9c 83       	std	Y+4, r25	; 0x04
    188c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    188e:	eb 81       	ldd	r30, Y+3	; 0x03
    1890:	fc 81       	ldd	r31, Y+4	; 0x04
    1892:	10 82       	st	Z, r1
	pxTopOfStack--;
    1894:	8b 81       	ldd	r24, Y+3	; 0x03
    1896:	9c 81       	ldd	r25, Y+4	; 0x04
    1898:	01 97       	sbiw	r24, 0x01	; 1
    189a:	9c 83       	std	Y+4, r25	; 0x04
    189c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    189e:	eb 81       	ldd	r30, Y+3	; 0x03
    18a0:	fc 81       	ldd	r31, Y+4	; 0x04
    18a2:	80 e8       	ldi	r24, 0x80	; 128
    18a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    18a6:	8b 81       	ldd	r24, Y+3	; 0x03
    18a8:	9c 81       	ldd	r25, Y+4	; 0x04
    18aa:	01 97       	sbiw	r24, 0x01	; 1
    18ac:	9c 83       	std	Y+4, r25	; 0x04
    18ae:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    18b0:	eb 81       	ldd	r30, Y+3	; 0x03
    18b2:	fc 81       	ldd	r31, Y+4	; 0x04
    18b4:	10 82       	st	Z, r1
	pxTopOfStack--;
    18b6:	8b 81       	ldd	r24, Y+3	; 0x03
    18b8:	9c 81       	ldd	r25, Y+4	; 0x04
    18ba:	01 97       	sbiw	r24, 0x01	; 1
    18bc:	9c 83       	std	Y+4, r25	; 0x04
    18be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    18c0:	eb 81       	ldd	r30, Y+3	; 0x03
    18c2:	fc 81       	ldd	r31, Y+4	; 0x04
    18c4:	82 e0       	ldi	r24, 0x02	; 2
    18c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    18c8:	8b 81       	ldd	r24, Y+3	; 0x03
    18ca:	9c 81       	ldd	r25, Y+4	; 0x04
    18cc:	01 97       	sbiw	r24, 0x01	; 1
    18ce:	9c 83       	std	Y+4, r25	; 0x04
    18d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    18d2:	eb 81       	ldd	r30, Y+3	; 0x03
    18d4:	fc 81       	ldd	r31, Y+4	; 0x04
    18d6:	83 e0       	ldi	r24, 0x03	; 3
    18d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    18da:	8b 81       	ldd	r24, Y+3	; 0x03
    18dc:	9c 81       	ldd	r25, Y+4	; 0x04
    18de:	01 97       	sbiw	r24, 0x01	; 1
    18e0:	9c 83       	std	Y+4, r25	; 0x04
    18e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    18e4:	eb 81       	ldd	r30, Y+3	; 0x03
    18e6:	fc 81       	ldd	r31, Y+4	; 0x04
    18e8:	84 e0       	ldi	r24, 0x04	; 4
    18ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    18ec:	8b 81       	ldd	r24, Y+3	; 0x03
    18ee:	9c 81       	ldd	r25, Y+4	; 0x04
    18f0:	01 97       	sbiw	r24, 0x01	; 1
    18f2:	9c 83       	std	Y+4, r25	; 0x04
    18f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    18f6:	eb 81       	ldd	r30, Y+3	; 0x03
    18f8:	fc 81       	ldd	r31, Y+4	; 0x04
    18fa:	85 e0       	ldi	r24, 0x05	; 5
    18fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    18fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1900:	9c 81       	ldd	r25, Y+4	; 0x04
    1902:	01 97       	sbiw	r24, 0x01	; 1
    1904:	9c 83       	std	Y+4, r25	; 0x04
    1906:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1908:	eb 81       	ldd	r30, Y+3	; 0x03
    190a:	fc 81       	ldd	r31, Y+4	; 0x04
    190c:	86 e0       	ldi	r24, 0x06	; 6
    190e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1910:	8b 81       	ldd	r24, Y+3	; 0x03
    1912:	9c 81       	ldd	r25, Y+4	; 0x04
    1914:	01 97       	sbiw	r24, 0x01	; 1
    1916:	9c 83       	std	Y+4, r25	; 0x04
    1918:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    191a:	eb 81       	ldd	r30, Y+3	; 0x03
    191c:	fc 81       	ldd	r31, Y+4	; 0x04
    191e:	87 e0       	ldi	r24, 0x07	; 7
    1920:	80 83       	st	Z, r24
	pxTopOfStack--;
    1922:	8b 81       	ldd	r24, Y+3	; 0x03
    1924:	9c 81       	ldd	r25, Y+4	; 0x04
    1926:	01 97       	sbiw	r24, 0x01	; 1
    1928:	9c 83       	std	Y+4, r25	; 0x04
    192a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    192c:	eb 81       	ldd	r30, Y+3	; 0x03
    192e:	fc 81       	ldd	r31, Y+4	; 0x04
    1930:	88 e0       	ldi	r24, 0x08	; 8
    1932:	80 83       	st	Z, r24
	pxTopOfStack--;
    1934:	8b 81       	ldd	r24, Y+3	; 0x03
    1936:	9c 81       	ldd	r25, Y+4	; 0x04
    1938:	01 97       	sbiw	r24, 0x01	; 1
    193a:	9c 83       	std	Y+4, r25	; 0x04
    193c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    193e:	eb 81       	ldd	r30, Y+3	; 0x03
    1940:	fc 81       	ldd	r31, Y+4	; 0x04
    1942:	89 e0       	ldi	r24, 0x09	; 9
    1944:	80 83       	st	Z, r24
	pxTopOfStack--;
    1946:	8b 81       	ldd	r24, Y+3	; 0x03
    1948:	9c 81       	ldd	r25, Y+4	; 0x04
    194a:	01 97       	sbiw	r24, 0x01	; 1
    194c:	9c 83       	std	Y+4, r25	; 0x04
    194e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1950:	eb 81       	ldd	r30, Y+3	; 0x03
    1952:	fc 81       	ldd	r31, Y+4	; 0x04
    1954:	80 e1       	ldi	r24, 0x10	; 16
    1956:	80 83       	st	Z, r24
	pxTopOfStack--;
    1958:	8b 81       	ldd	r24, Y+3	; 0x03
    195a:	9c 81       	ldd	r25, Y+4	; 0x04
    195c:	01 97       	sbiw	r24, 0x01	; 1
    195e:	9c 83       	std	Y+4, r25	; 0x04
    1960:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1962:	eb 81       	ldd	r30, Y+3	; 0x03
    1964:	fc 81       	ldd	r31, Y+4	; 0x04
    1966:	81 e1       	ldi	r24, 0x11	; 17
    1968:	80 83       	st	Z, r24
	pxTopOfStack--;
    196a:	8b 81       	ldd	r24, Y+3	; 0x03
    196c:	9c 81       	ldd	r25, Y+4	; 0x04
    196e:	01 97       	sbiw	r24, 0x01	; 1
    1970:	9c 83       	std	Y+4, r25	; 0x04
    1972:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1974:	eb 81       	ldd	r30, Y+3	; 0x03
    1976:	fc 81       	ldd	r31, Y+4	; 0x04
    1978:	82 e1       	ldi	r24, 0x12	; 18
    197a:	80 83       	st	Z, r24
	pxTopOfStack--;
    197c:	8b 81       	ldd	r24, Y+3	; 0x03
    197e:	9c 81       	ldd	r25, Y+4	; 0x04
    1980:	01 97       	sbiw	r24, 0x01	; 1
    1982:	9c 83       	std	Y+4, r25	; 0x04
    1984:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1986:	eb 81       	ldd	r30, Y+3	; 0x03
    1988:	fc 81       	ldd	r31, Y+4	; 0x04
    198a:	83 e1       	ldi	r24, 0x13	; 19
    198c:	80 83       	st	Z, r24
	pxTopOfStack--;
    198e:	8b 81       	ldd	r24, Y+3	; 0x03
    1990:	9c 81       	ldd	r25, Y+4	; 0x04
    1992:	01 97       	sbiw	r24, 0x01	; 1
    1994:	9c 83       	std	Y+4, r25	; 0x04
    1996:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1998:	eb 81       	ldd	r30, Y+3	; 0x03
    199a:	fc 81       	ldd	r31, Y+4	; 0x04
    199c:	84 e1       	ldi	r24, 0x14	; 20
    199e:	80 83       	st	Z, r24
	pxTopOfStack--;
    19a0:	8b 81       	ldd	r24, Y+3	; 0x03
    19a2:	9c 81       	ldd	r25, Y+4	; 0x04
    19a4:	01 97       	sbiw	r24, 0x01	; 1
    19a6:	9c 83       	std	Y+4, r25	; 0x04
    19a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    19aa:	eb 81       	ldd	r30, Y+3	; 0x03
    19ac:	fc 81       	ldd	r31, Y+4	; 0x04
    19ae:	85 e1       	ldi	r24, 0x15	; 21
    19b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    19b2:	8b 81       	ldd	r24, Y+3	; 0x03
    19b4:	9c 81       	ldd	r25, Y+4	; 0x04
    19b6:	01 97       	sbiw	r24, 0x01	; 1
    19b8:	9c 83       	std	Y+4, r25	; 0x04
    19ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    19bc:	eb 81       	ldd	r30, Y+3	; 0x03
    19be:	fc 81       	ldd	r31, Y+4	; 0x04
    19c0:	86 e1       	ldi	r24, 0x16	; 22
    19c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    19c4:	8b 81       	ldd	r24, Y+3	; 0x03
    19c6:	9c 81       	ldd	r25, Y+4	; 0x04
    19c8:	01 97       	sbiw	r24, 0x01	; 1
    19ca:	9c 83       	std	Y+4, r25	; 0x04
    19cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    19ce:	eb 81       	ldd	r30, Y+3	; 0x03
    19d0:	fc 81       	ldd	r31, Y+4	; 0x04
    19d2:	87 e1       	ldi	r24, 0x17	; 23
    19d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    19d6:	8b 81       	ldd	r24, Y+3	; 0x03
    19d8:	9c 81       	ldd	r25, Y+4	; 0x04
    19da:	01 97       	sbiw	r24, 0x01	; 1
    19dc:	9c 83       	std	Y+4, r25	; 0x04
    19de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    19e0:	eb 81       	ldd	r30, Y+3	; 0x03
    19e2:	fc 81       	ldd	r31, Y+4	; 0x04
    19e4:	88 e1       	ldi	r24, 0x18	; 24
    19e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    19e8:	8b 81       	ldd	r24, Y+3	; 0x03
    19ea:	9c 81       	ldd	r25, Y+4	; 0x04
    19ec:	01 97       	sbiw	r24, 0x01	; 1
    19ee:	9c 83       	std	Y+4, r25	; 0x04
    19f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    19f2:	eb 81       	ldd	r30, Y+3	; 0x03
    19f4:	fc 81       	ldd	r31, Y+4	; 0x04
    19f6:	89 e1       	ldi	r24, 0x19	; 25
    19f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    19fa:	8b 81       	ldd	r24, Y+3	; 0x03
    19fc:	9c 81       	ldd	r25, Y+4	; 0x04
    19fe:	01 97       	sbiw	r24, 0x01	; 1
    1a00:	9c 83       	std	Y+4, r25	; 0x04
    1a02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1a04:	eb 81       	ldd	r30, Y+3	; 0x03
    1a06:	fc 81       	ldd	r31, Y+4	; 0x04
    1a08:	80 e2       	ldi	r24, 0x20	; 32
    1a0a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a10:	01 97       	sbiw	r24, 0x01	; 1
    1a12:	9c 83       	std	Y+4, r25	; 0x04
    1a14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1a16:	eb 81       	ldd	r30, Y+3	; 0x03
    1a18:	fc 81       	ldd	r31, Y+4	; 0x04
    1a1a:	81 e2       	ldi	r24, 0x21	; 33
    1a1c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a20:	9c 81       	ldd	r25, Y+4	; 0x04
    1a22:	01 97       	sbiw	r24, 0x01	; 1
    1a24:	9c 83       	std	Y+4, r25	; 0x04
    1a26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1a28:	eb 81       	ldd	r30, Y+3	; 0x03
    1a2a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a2c:	82 e2       	ldi	r24, 0x22	; 34
    1a2e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a30:	8b 81       	ldd	r24, Y+3	; 0x03
    1a32:	9c 81       	ldd	r25, Y+4	; 0x04
    1a34:	01 97       	sbiw	r24, 0x01	; 1
    1a36:	9c 83       	std	Y+4, r25	; 0x04
    1a38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1a3a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a3c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a3e:	83 e2       	ldi	r24, 0x23	; 35
    1a40:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a42:	8b 81       	ldd	r24, Y+3	; 0x03
    1a44:	9c 81       	ldd	r25, Y+4	; 0x04
    1a46:	01 97       	sbiw	r24, 0x01	; 1
    1a48:	9c 83       	std	Y+4, r25	; 0x04
    1a4a:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1a4c:	8f 81       	ldd	r24, Y+7	; 0x07
    1a4e:	98 85       	ldd	r25, Y+8	; 0x08
    1a50:	9a 83       	std	Y+2, r25	; 0x02
    1a52:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1a54:	89 81       	ldd	r24, Y+1	; 0x01
    1a56:	eb 81       	ldd	r30, Y+3	; 0x03
    1a58:	fc 81       	ldd	r31, Y+4	; 0x04
    1a5a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a60:	01 97       	sbiw	r24, 0x01	; 1
    1a62:	9c 83       	std	Y+4, r25	; 0x04
    1a64:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1a66:	89 81       	ldd	r24, Y+1	; 0x01
    1a68:	9a 81       	ldd	r25, Y+2	; 0x02
    1a6a:	89 2f       	mov	r24, r25
    1a6c:	99 27       	eor	r25, r25
    1a6e:	9a 83       	std	Y+2, r25	; 0x02
    1a70:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1a72:	89 81       	ldd	r24, Y+1	; 0x01
    1a74:	eb 81       	ldd	r30, Y+3	; 0x03
    1a76:	fc 81       	ldd	r31, Y+4	; 0x04
    1a78:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a7e:	01 97       	sbiw	r24, 0x01	; 1
    1a80:	9c 83       	std	Y+4, r25	; 0x04
    1a82:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1a84:	eb 81       	ldd	r30, Y+3	; 0x03
    1a86:	fc 81       	ldd	r31, Y+4	; 0x04
    1a88:	86 e2       	ldi	r24, 0x26	; 38
    1a8a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a8c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a8e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a90:	01 97       	sbiw	r24, 0x01	; 1
    1a92:	9c 83       	std	Y+4, r25	; 0x04
    1a94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1a96:	eb 81       	ldd	r30, Y+3	; 0x03
    1a98:	fc 81       	ldd	r31, Y+4	; 0x04
    1a9a:	87 e2       	ldi	r24, 0x27	; 39
    1a9c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1aa0:	9c 81       	ldd	r25, Y+4	; 0x04
    1aa2:	01 97       	sbiw	r24, 0x01	; 1
    1aa4:	9c 83       	std	Y+4, r25	; 0x04
    1aa6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1aa8:	eb 81       	ldd	r30, Y+3	; 0x03
    1aaa:	fc 81       	ldd	r31, Y+4	; 0x04
    1aac:	88 e2       	ldi	r24, 0x28	; 40
    1aae:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ab0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab4:	01 97       	sbiw	r24, 0x01	; 1
    1ab6:	9c 83       	std	Y+4, r25	; 0x04
    1ab8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1aba:	eb 81       	ldd	r30, Y+3	; 0x03
    1abc:	fc 81       	ldd	r31, Y+4	; 0x04
    1abe:	89 e2       	ldi	r24, 0x29	; 41
    1ac0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ac2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ac6:	01 97       	sbiw	r24, 0x01	; 1
    1ac8:	9c 83       	std	Y+4, r25	; 0x04
    1aca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1acc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ace:	fc 81       	ldd	r31, Y+4	; 0x04
    1ad0:	80 e3       	ldi	r24, 0x30	; 48
    1ad2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ad4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad8:	01 97       	sbiw	r24, 0x01	; 1
    1ada:	9c 83       	std	Y+4, r25	; 0x04
    1adc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1ade:	eb 81       	ldd	r30, Y+3	; 0x03
    1ae0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ae2:	81 e3       	ldi	r24, 0x31	; 49
    1ae4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ae6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae8:	9c 81       	ldd	r25, Y+4	; 0x04
    1aea:	01 97       	sbiw	r24, 0x01	; 1
    1aec:	9c 83       	std	Y+4, r25	; 0x04
    1aee:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1af0:	8b 81       	ldd	r24, Y+3	; 0x03
    1af2:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1af4:	28 96       	adiw	r28, 0x08	; 8
    1af6:	0f b6       	in	r0, 0x3f	; 63
    1af8:	f8 94       	cli
    1afa:	de bf       	out	0x3e, r29	; 62
    1afc:	0f be       	out	0x3f, r0	; 63
    1afe:	cd bf       	out	0x3d, r28	; 61
    1b00:	cf 91       	pop	r28
    1b02:	df 91       	pop	r29
    1b04:	08 95       	ret

00001b06 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1b06:	df 93       	push	r29
    1b08:	cf 93       	push	r28
    1b0a:	cd b7       	in	r28, 0x3d	; 61
    1b0c:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1b0e:	0e 94 75 0e 	call	0x1cea	; 0x1cea <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1b12:	a0 91 ce 06 	lds	r26, 0x06CE
    1b16:	b0 91 cf 06 	lds	r27, 0x06CF
    1b1a:	cd 91       	ld	r28, X+
    1b1c:	cd bf       	out	0x3d, r28	; 61
    1b1e:	dd 91       	ld	r29, X+
    1b20:	de bf       	out	0x3e, r29	; 62
    1b22:	ff 91       	pop	r31
    1b24:	ef 91       	pop	r30
    1b26:	df 91       	pop	r29
    1b28:	cf 91       	pop	r28
    1b2a:	bf 91       	pop	r27
    1b2c:	af 91       	pop	r26
    1b2e:	9f 91       	pop	r25
    1b30:	8f 91       	pop	r24
    1b32:	7f 91       	pop	r23
    1b34:	6f 91       	pop	r22
    1b36:	5f 91       	pop	r21
    1b38:	4f 91       	pop	r20
    1b3a:	3f 91       	pop	r19
    1b3c:	2f 91       	pop	r18
    1b3e:	1f 91       	pop	r17
    1b40:	0f 91       	pop	r16
    1b42:	ff 90       	pop	r15
    1b44:	ef 90       	pop	r14
    1b46:	df 90       	pop	r13
    1b48:	cf 90       	pop	r12
    1b4a:	bf 90       	pop	r11
    1b4c:	af 90       	pop	r10
    1b4e:	9f 90       	pop	r9
    1b50:	8f 90       	pop	r8
    1b52:	7f 90       	pop	r7
    1b54:	6f 90       	pop	r6
    1b56:	5f 90       	pop	r5
    1b58:	4f 90       	pop	r4
    1b5a:	3f 90       	pop	r3
    1b5c:	2f 90       	pop	r2
    1b5e:	1f 90       	pop	r1
    1b60:	0f 90       	pop	r0
    1b62:	0f be       	out	0x3f, r0	; 63
    1b64:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1b66:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1b68:	81 e0       	ldi	r24, 0x01	; 1
}
    1b6a:	cf 91       	pop	r28
    1b6c:	df 91       	pop	r29
    1b6e:	08 95       	ret

00001b70 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1b70:	df 93       	push	r29
    1b72:	cf 93       	push	r28
    1b74:	cd b7       	in	r28, 0x3d	; 61
    1b76:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1b78:	cf 91       	pop	r28
    1b7a:	df 91       	pop	r29
    1b7c:	08 95       	ret

00001b7e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1b7e:	0f 92       	push	r0
    1b80:	0f b6       	in	r0, 0x3f	; 63
    1b82:	f8 94       	cli
    1b84:	0f 92       	push	r0
    1b86:	1f 92       	push	r1
    1b88:	11 24       	eor	r1, r1
    1b8a:	2f 92       	push	r2
    1b8c:	3f 92       	push	r3
    1b8e:	4f 92       	push	r4
    1b90:	5f 92       	push	r5
    1b92:	6f 92       	push	r6
    1b94:	7f 92       	push	r7
    1b96:	8f 92       	push	r8
    1b98:	9f 92       	push	r9
    1b9a:	af 92       	push	r10
    1b9c:	bf 92       	push	r11
    1b9e:	cf 92       	push	r12
    1ba0:	df 92       	push	r13
    1ba2:	ef 92       	push	r14
    1ba4:	ff 92       	push	r15
    1ba6:	0f 93       	push	r16
    1ba8:	1f 93       	push	r17
    1baa:	2f 93       	push	r18
    1bac:	3f 93       	push	r19
    1bae:	4f 93       	push	r20
    1bb0:	5f 93       	push	r21
    1bb2:	6f 93       	push	r22
    1bb4:	7f 93       	push	r23
    1bb6:	8f 93       	push	r24
    1bb8:	9f 93       	push	r25
    1bba:	af 93       	push	r26
    1bbc:	bf 93       	push	r27
    1bbe:	cf 93       	push	r28
    1bc0:	df 93       	push	r29
    1bc2:	ef 93       	push	r30
    1bc4:	ff 93       	push	r31
    1bc6:	a0 91 ce 06 	lds	r26, 0x06CE
    1bca:	b0 91 cf 06 	lds	r27, 0x06CF
    1bce:	0d b6       	in	r0, 0x3d	; 61
    1bd0:	0d 92       	st	X+, r0
    1bd2:	0e b6       	in	r0, 0x3e	; 62
    1bd4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1bd6:	0e 94 07 24 	call	0x480e	; 0x480e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1bda:	a0 91 ce 06 	lds	r26, 0x06CE
    1bde:	b0 91 cf 06 	lds	r27, 0x06CF
    1be2:	cd 91       	ld	r28, X+
    1be4:	cd bf       	out	0x3d, r28	; 61
    1be6:	dd 91       	ld	r29, X+
    1be8:	de bf       	out	0x3e, r29	; 62
    1bea:	ff 91       	pop	r31
    1bec:	ef 91       	pop	r30
    1bee:	df 91       	pop	r29
    1bf0:	cf 91       	pop	r28
    1bf2:	bf 91       	pop	r27
    1bf4:	af 91       	pop	r26
    1bf6:	9f 91       	pop	r25
    1bf8:	8f 91       	pop	r24
    1bfa:	7f 91       	pop	r23
    1bfc:	6f 91       	pop	r22
    1bfe:	5f 91       	pop	r21
    1c00:	4f 91       	pop	r20
    1c02:	3f 91       	pop	r19
    1c04:	2f 91       	pop	r18
    1c06:	1f 91       	pop	r17
    1c08:	0f 91       	pop	r16
    1c0a:	ff 90       	pop	r15
    1c0c:	ef 90       	pop	r14
    1c0e:	df 90       	pop	r13
    1c10:	cf 90       	pop	r12
    1c12:	bf 90       	pop	r11
    1c14:	af 90       	pop	r10
    1c16:	9f 90       	pop	r9
    1c18:	8f 90       	pop	r8
    1c1a:	7f 90       	pop	r7
    1c1c:	6f 90       	pop	r6
    1c1e:	5f 90       	pop	r5
    1c20:	4f 90       	pop	r4
    1c22:	3f 90       	pop	r3
    1c24:	2f 90       	pop	r2
    1c26:	1f 90       	pop	r1
    1c28:	0f 90       	pop	r0
    1c2a:	0f be       	out	0x3f, r0	; 63
    1c2c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c2e:	08 95       	ret

00001c30 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1c30:	0f 92       	push	r0
    1c32:	0f b6       	in	r0, 0x3f	; 63
    1c34:	f8 94       	cli
    1c36:	0f 92       	push	r0
    1c38:	1f 92       	push	r1
    1c3a:	11 24       	eor	r1, r1
    1c3c:	2f 92       	push	r2
    1c3e:	3f 92       	push	r3
    1c40:	4f 92       	push	r4
    1c42:	5f 92       	push	r5
    1c44:	6f 92       	push	r6
    1c46:	7f 92       	push	r7
    1c48:	8f 92       	push	r8
    1c4a:	9f 92       	push	r9
    1c4c:	af 92       	push	r10
    1c4e:	bf 92       	push	r11
    1c50:	cf 92       	push	r12
    1c52:	df 92       	push	r13
    1c54:	ef 92       	push	r14
    1c56:	ff 92       	push	r15
    1c58:	0f 93       	push	r16
    1c5a:	1f 93       	push	r17
    1c5c:	2f 93       	push	r18
    1c5e:	3f 93       	push	r19
    1c60:	4f 93       	push	r20
    1c62:	5f 93       	push	r21
    1c64:	6f 93       	push	r22
    1c66:	7f 93       	push	r23
    1c68:	8f 93       	push	r24
    1c6a:	9f 93       	push	r25
    1c6c:	af 93       	push	r26
    1c6e:	bf 93       	push	r27
    1c70:	cf 93       	push	r28
    1c72:	df 93       	push	r29
    1c74:	ef 93       	push	r30
    1c76:	ff 93       	push	r31
    1c78:	a0 91 ce 06 	lds	r26, 0x06CE
    1c7c:	b0 91 cf 06 	lds	r27, 0x06CF
    1c80:	0d b6       	in	r0, 0x3d	; 61
    1c82:	0d 92       	st	X+, r0
    1c84:	0e b6       	in	r0, 0x3e	; 62
    1c86:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1c88:	0e 94 22 23 	call	0x4644	; 0x4644 <xTaskIncrementTick>
    1c8c:	88 23       	and	r24, r24
    1c8e:	11 f0       	breq	.+4      	; 0x1c94 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1c90:	0e 94 07 24 	call	0x480e	; 0x480e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1c94:	a0 91 ce 06 	lds	r26, 0x06CE
    1c98:	b0 91 cf 06 	lds	r27, 0x06CF
    1c9c:	cd 91       	ld	r28, X+
    1c9e:	cd bf       	out	0x3d, r28	; 61
    1ca0:	dd 91       	ld	r29, X+
    1ca2:	de bf       	out	0x3e, r29	; 62
    1ca4:	ff 91       	pop	r31
    1ca6:	ef 91       	pop	r30
    1ca8:	df 91       	pop	r29
    1caa:	cf 91       	pop	r28
    1cac:	bf 91       	pop	r27
    1cae:	af 91       	pop	r26
    1cb0:	9f 91       	pop	r25
    1cb2:	8f 91       	pop	r24
    1cb4:	7f 91       	pop	r23
    1cb6:	6f 91       	pop	r22
    1cb8:	5f 91       	pop	r21
    1cba:	4f 91       	pop	r20
    1cbc:	3f 91       	pop	r19
    1cbe:	2f 91       	pop	r18
    1cc0:	1f 91       	pop	r17
    1cc2:	0f 91       	pop	r16
    1cc4:	ff 90       	pop	r15
    1cc6:	ef 90       	pop	r14
    1cc8:	df 90       	pop	r13
    1cca:	cf 90       	pop	r12
    1ccc:	bf 90       	pop	r11
    1cce:	af 90       	pop	r10
    1cd0:	9f 90       	pop	r9
    1cd2:	8f 90       	pop	r8
    1cd4:	7f 90       	pop	r7
    1cd6:	6f 90       	pop	r6
    1cd8:	5f 90       	pop	r5
    1cda:	4f 90       	pop	r4
    1cdc:	3f 90       	pop	r3
    1cde:	2f 90       	pop	r2
    1ce0:	1f 90       	pop	r1
    1ce2:	0f 90       	pop	r0
    1ce4:	0f be       	out	0x3f, r0	; 63
    1ce6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1ce8:	08 95       	ret

00001cea <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1cea:	df 93       	push	r29
    1cec:	cf 93       	push	r28
    1cee:	00 d0       	rcall	.+0      	; 0x1cf0 <prvSetupTimerInterrupt+0x6>
    1cf0:	00 d0       	rcall	.+0      	; 0x1cf2 <prvSetupTimerInterrupt+0x8>
    1cf2:	00 d0       	rcall	.+0      	; 0x1cf4 <prvSetupTimerInterrupt+0xa>
    1cf4:	cd b7       	in	r28, 0x3d	; 61
    1cf6:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1cf8:	80 e4       	ldi	r24, 0x40	; 64
    1cfa:	9f e1       	ldi	r25, 0x1F	; 31
    1cfc:	a0 e0       	ldi	r26, 0x00	; 0
    1cfe:	b0 e0       	ldi	r27, 0x00	; 0
    1d00:	8b 83       	std	Y+3, r24	; 0x03
    1d02:	9c 83       	std	Y+4, r25	; 0x04
    1d04:	ad 83       	std	Y+5, r26	; 0x05
    1d06:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1d08:	8b 81       	ldd	r24, Y+3	; 0x03
    1d0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d0c:	ad 81       	ldd	r26, Y+5	; 0x05
    1d0e:	be 81       	ldd	r27, Y+6	; 0x06
    1d10:	68 94       	set
    1d12:	15 f8       	bld	r1, 5
    1d14:	b6 95       	lsr	r27
    1d16:	a7 95       	ror	r26
    1d18:	97 95       	ror	r25
    1d1a:	87 95       	ror	r24
    1d1c:	16 94       	lsr	r1
    1d1e:	d1 f7       	brne	.-12     	; 0x1d14 <prvSetupTimerInterrupt+0x2a>
    1d20:	8b 83       	std	Y+3, r24	; 0x03
    1d22:	9c 83       	std	Y+4, r25	; 0x04
    1d24:	ad 83       	std	Y+5, r26	; 0x05
    1d26:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1d28:	8b 81       	ldd	r24, Y+3	; 0x03
    1d2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d2c:	ad 81       	ldd	r26, Y+5	; 0x05
    1d2e:	be 81       	ldd	r27, Y+6	; 0x06
    1d30:	01 97       	sbiw	r24, 0x01	; 1
    1d32:	a1 09       	sbc	r26, r1
    1d34:	b1 09       	sbc	r27, r1
    1d36:	8b 83       	std	Y+3, r24	; 0x03
    1d38:	9c 83       	std	Y+4, r25	; 0x04
    1d3a:	ad 83       	std	Y+5, r26	; 0x05
    1d3c:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1d3e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d40:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1d42:	8b 81       	ldd	r24, Y+3	; 0x03
    1d44:	9c 81       	ldd	r25, Y+4	; 0x04
    1d46:	ad 81       	ldd	r26, Y+5	; 0x05
    1d48:	be 81       	ldd	r27, Y+6	; 0x06
    1d4a:	89 2f       	mov	r24, r25
    1d4c:	9a 2f       	mov	r25, r26
    1d4e:	ab 2f       	mov	r26, r27
    1d50:	bb 27       	eor	r27, r27
    1d52:	8b 83       	std	Y+3, r24	; 0x03
    1d54:	9c 83       	std	Y+4, r25	; 0x04
    1d56:	ad 83       	std	Y+5, r26	; 0x05
    1d58:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1d5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d5c:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1d5e:	eb e4       	ldi	r30, 0x4B	; 75
    1d60:	f0 e0       	ldi	r31, 0x00	; 0
    1d62:	8a 81       	ldd	r24, Y+2	; 0x02
    1d64:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1d66:	ea e4       	ldi	r30, 0x4A	; 74
    1d68:	f0 e0       	ldi	r31, 0x00	; 0
    1d6a:	89 81       	ldd	r24, Y+1	; 0x01
    1d6c:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1d6e:	8b e0       	ldi	r24, 0x0B	; 11
    1d70:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1d72:	ee e4       	ldi	r30, 0x4E	; 78
    1d74:	f0 e0       	ldi	r31, 0x00	; 0
    1d76:	89 81       	ldd	r24, Y+1	; 0x01
    1d78:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1d7a:	e9 e5       	ldi	r30, 0x59	; 89
    1d7c:	f0 e0       	ldi	r31, 0x00	; 0
    1d7e:	80 81       	ld	r24, Z
    1d80:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1d82:	89 81       	ldd	r24, Y+1	; 0x01
    1d84:	80 61       	ori	r24, 0x10	; 16
    1d86:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1d88:	e9 e5       	ldi	r30, 0x59	; 89
    1d8a:	f0 e0       	ldi	r31, 0x00	; 0
    1d8c:	89 81       	ldd	r24, Y+1	; 0x01
    1d8e:	80 83       	st	Z, r24
}
    1d90:	26 96       	adiw	r28, 0x06	; 6
    1d92:	0f b6       	in	r0, 0x3f	; 63
    1d94:	f8 94       	cli
    1d96:	de bf       	out	0x3e, r29	; 62
    1d98:	0f be       	out	0x3f, r0	; 63
    1d9a:	cd bf       	out	0x3d, r28	; 61
    1d9c:	cf 91       	pop	r28
    1d9e:	df 91       	pop	r29
    1da0:	08 95       	ret

00001da2 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1da2:	0e 94 18 0e 	call	0x1c30	; 0x1c30 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1da6:	18 95       	reti

00001da8 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1da8:	df 93       	push	r29
    1daa:	cf 93       	push	r28
    1dac:	00 d0       	rcall	.+0      	; 0x1dae <xQueueGenericReset+0x6>
    1dae:	00 d0       	rcall	.+0      	; 0x1db0 <xQueueGenericReset+0x8>
    1db0:	0f 92       	push	r0
    1db2:	cd b7       	in	r28, 0x3d	; 61
    1db4:	de b7       	in	r29, 0x3e	; 62
    1db6:	9c 83       	std	Y+4, r25	; 0x04
    1db8:	8b 83       	std	Y+3, r24	; 0x03
    1dba:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1dbc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dbe:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc0:	9a 83       	std	Y+2, r25	; 0x02
    1dc2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1dc4:	0f b6       	in	r0, 0x3f	; 63
    1dc6:	f8 94       	cli
    1dc8:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1dca:	e9 81       	ldd	r30, Y+1	; 0x01
    1dcc:	fa 81       	ldd	r31, Y+2	; 0x02
    1dce:	40 81       	ld	r20, Z
    1dd0:	51 81       	ldd	r21, Z+1	; 0x01
    1dd2:	e9 81       	ldd	r30, Y+1	; 0x01
    1dd4:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1dd8:	28 2f       	mov	r18, r24
    1dda:	30 e0       	ldi	r19, 0x00	; 0
    1ddc:	e9 81       	ldd	r30, Y+1	; 0x01
    1dde:	fa 81       	ldd	r31, Y+2	; 0x02
    1de0:	84 8d       	ldd	r24, Z+28	; 0x1c
    1de2:	88 2f       	mov	r24, r24
    1de4:	90 e0       	ldi	r25, 0x00	; 0
    1de6:	bc 01       	movw	r22, r24
    1de8:	26 9f       	mul	r18, r22
    1dea:	c0 01       	movw	r24, r0
    1dec:	27 9f       	mul	r18, r23
    1dee:	90 0d       	add	r25, r0
    1df0:	36 9f       	mul	r19, r22
    1df2:	90 0d       	add	r25, r0
    1df4:	11 24       	eor	r1, r1
    1df6:	84 0f       	add	r24, r20
    1df8:	95 1f       	adc	r25, r21
    1dfa:	e9 81       	ldd	r30, Y+1	; 0x01
    1dfc:	fa 81       	ldd	r31, Y+2	; 0x02
    1dfe:	95 83       	std	Z+5, r25	; 0x05
    1e00:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1e02:	e9 81       	ldd	r30, Y+1	; 0x01
    1e04:	fa 81       	ldd	r31, Y+2	; 0x02
    1e06:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1e08:	e9 81       	ldd	r30, Y+1	; 0x01
    1e0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e0c:	80 81       	ld	r24, Z
    1e0e:	91 81       	ldd	r25, Z+1	; 0x01
    1e10:	e9 81       	ldd	r30, Y+1	; 0x01
    1e12:	fa 81       	ldd	r31, Y+2	; 0x02
    1e14:	93 83       	std	Z+3, r25	; 0x03
    1e16:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e18:	e9 81       	ldd	r30, Y+1	; 0x01
    1e1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e1c:	40 81       	ld	r20, Z
    1e1e:	51 81       	ldd	r21, Z+1	; 0x01
    1e20:	e9 81       	ldd	r30, Y+1	; 0x01
    1e22:	fa 81       	ldd	r31, Y+2	; 0x02
    1e24:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e26:	88 2f       	mov	r24, r24
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	9c 01       	movw	r18, r24
    1e2c:	21 50       	subi	r18, 0x01	; 1
    1e2e:	30 40       	sbci	r19, 0x00	; 0
    1e30:	e9 81       	ldd	r30, Y+1	; 0x01
    1e32:	fa 81       	ldd	r31, Y+2	; 0x02
    1e34:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e36:	88 2f       	mov	r24, r24
    1e38:	90 e0       	ldi	r25, 0x00	; 0
    1e3a:	bc 01       	movw	r22, r24
    1e3c:	26 9f       	mul	r18, r22
    1e3e:	c0 01       	movw	r24, r0
    1e40:	27 9f       	mul	r18, r23
    1e42:	90 0d       	add	r25, r0
    1e44:	36 9f       	mul	r19, r22
    1e46:	90 0d       	add	r25, r0
    1e48:	11 24       	eor	r1, r1
    1e4a:	84 0f       	add	r24, r20
    1e4c:	95 1f       	adc	r25, r21
    1e4e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e50:	fa 81       	ldd	r31, Y+2	; 0x02
    1e52:	97 83       	std	Z+7, r25	; 0x07
    1e54:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1e56:	e9 81       	ldd	r30, Y+1	; 0x01
    1e58:	fa 81       	ldd	r31, Y+2	; 0x02
    1e5a:	8f ef       	ldi	r24, 0xFF	; 255
    1e5c:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1e5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e60:	fa 81       	ldd	r31, Y+2	; 0x02
    1e62:	8f ef       	ldi	r24, 0xFF	; 255
    1e64:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1e66:	8d 81       	ldd	r24, Y+5	; 0x05
    1e68:	88 23       	and	r24, r24
    1e6a:	79 f4       	brne	.+30     	; 0x1e8a <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e6c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e6e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e70:	80 85       	ldd	r24, Z+8	; 0x08
    1e72:	88 23       	and	r24, r24
    1e74:	a1 f0       	breq	.+40     	; 0x1e9e <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e76:	89 81       	ldd	r24, Y+1	; 0x01
    1e78:	9a 81       	ldd	r25, Y+2	; 0x02
    1e7a:	08 96       	adiw	r24, 0x08	; 8
    1e7c:	0e 94 c6 24 	call	0x498c	; 0x498c <xTaskRemoveFromEventList>
    1e80:	88 23       	and	r24, r24
    1e82:	69 f0       	breq	.+26     	; 0x1e9e <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1e84:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
    1e88:	0a c0       	rjmp	.+20     	; 0x1e9e <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1e8a:	89 81       	ldd	r24, Y+1	; 0x01
    1e8c:	9a 81       	ldd	r25, Y+2	; 0x02
    1e8e:	08 96       	adiw	r24, 0x08	; 8
    1e90:	0e 94 ad 0a 	call	0x155a	; 0x155a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1e94:	89 81       	ldd	r24, Y+1	; 0x01
    1e96:	9a 81       	ldd	r25, Y+2	; 0x02
    1e98:	41 96       	adiw	r24, 0x11	; 17
    1e9a:	0e 94 ad 0a 	call	0x155a	; 0x155a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1e9e:	0f 90       	pop	r0
    1ea0:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1ea2:	81 e0       	ldi	r24, 0x01	; 1
}
    1ea4:	0f 90       	pop	r0
    1ea6:	0f 90       	pop	r0
    1ea8:	0f 90       	pop	r0
    1eaa:	0f 90       	pop	r0
    1eac:	0f 90       	pop	r0
    1eae:	cf 91       	pop	r28
    1eb0:	df 91       	pop	r29
    1eb2:	08 95       	ret

00001eb4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1eb4:	0f 93       	push	r16
    1eb6:	1f 93       	push	r17
    1eb8:	df 93       	push	r29
    1eba:	cf 93       	push	r28
    1ebc:	cd b7       	in	r28, 0x3d	; 61
    1ebe:	de b7       	in	r29, 0x3e	; 62
    1ec0:	29 97       	sbiw	r28, 0x09	; 9
    1ec2:	0f b6       	in	r0, 0x3f	; 63
    1ec4:	f8 94       	cli
    1ec6:	de bf       	out	0x3e, r29	; 62
    1ec8:	0f be       	out	0x3f, r0	; 63
    1eca:	cd bf       	out	0x3d, r28	; 61
    1ecc:	8f 83       	std	Y+7, r24	; 0x07
    1ece:	68 87       	std	Y+8, r22	; 0x08
    1ed0:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1ed2:	88 85       	ldd	r24, Y+8	; 0x08
    1ed4:	88 23       	and	r24, r24
    1ed6:	19 f4       	brne	.+6      	; 0x1ede <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1ed8:	1c 82       	std	Y+4, r1	; 0x04
    1eda:	1b 82       	std	Y+3, r1	; 0x03
    1edc:	10 c0       	rjmp	.+32     	; 0x1efe <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1ede:	8f 81       	ldd	r24, Y+7	; 0x07
    1ee0:	28 2f       	mov	r18, r24
    1ee2:	30 e0       	ldi	r19, 0x00	; 0
    1ee4:	88 85       	ldd	r24, Y+8	; 0x08
    1ee6:	88 2f       	mov	r24, r24
    1ee8:	90 e0       	ldi	r25, 0x00	; 0
    1eea:	ac 01       	movw	r20, r24
    1eec:	24 9f       	mul	r18, r20
    1eee:	c0 01       	movw	r24, r0
    1ef0:	25 9f       	mul	r18, r21
    1ef2:	90 0d       	add	r25, r0
    1ef4:	34 9f       	mul	r19, r20
    1ef6:	90 0d       	add	r25, r0
    1ef8:	11 24       	eor	r1, r1
    1efa:	9c 83       	std	Y+4, r25	; 0x04
    1efc:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1efe:	8b 81       	ldd	r24, Y+3	; 0x03
    1f00:	9c 81       	ldd	r25, Y+4	; 0x04
    1f02:	4f 96       	adiw	r24, 0x1f	; 31
    1f04:	0e 94 a8 08 	call	0x1150	; 0x1150 <pvPortMalloc>
    1f08:	9e 83       	std	Y+6, r25	; 0x06
    1f0a:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1f0c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f0e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f10:	00 97       	sbiw	r24, 0x00	; 0
    1f12:	a1 f0       	breq	.+40     	; 0x1f3c <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1f14:	8d 81       	ldd	r24, Y+5	; 0x05
    1f16:	9e 81       	ldd	r25, Y+6	; 0x06
    1f18:	9a 83       	std	Y+2, r25	; 0x02
    1f1a:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1f1c:	89 81       	ldd	r24, Y+1	; 0x01
    1f1e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f20:	4f 96       	adiw	r24, 0x1f	; 31
    1f22:	9a 83       	std	Y+2, r25	; 0x02
    1f24:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1f26:	29 81       	ldd	r18, Y+1	; 0x01
    1f28:	3a 81       	ldd	r19, Y+2	; 0x02
    1f2a:	ed 81       	ldd	r30, Y+5	; 0x05
    1f2c:	fe 81       	ldd	r31, Y+6	; 0x06
    1f2e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f30:	68 85       	ldd	r22, Y+8	; 0x08
    1f32:	a9 01       	movw	r20, r18
    1f34:	29 85       	ldd	r18, Y+9	; 0x09
    1f36:	8f 01       	movw	r16, r30
    1f38:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1f3c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f3e:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1f40:	29 96       	adiw	r28, 0x09	; 9
    1f42:	0f b6       	in	r0, 0x3f	; 63
    1f44:	f8 94       	cli
    1f46:	de bf       	out	0x3e, r29	; 62
    1f48:	0f be       	out	0x3f, r0	; 63
    1f4a:	cd bf       	out	0x3d, r28	; 61
    1f4c:	cf 91       	pop	r28
    1f4e:	df 91       	pop	r29
    1f50:	1f 91       	pop	r17
    1f52:	0f 91       	pop	r16
    1f54:	08 95       	ret

00001f56 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1f56:	0f 93       	push	r16
    1f58:	1f 93       	push	r17
    1f5a:	df 93       	push	r29
    1f5c:	cf 93       	push	r28
    1f5e:	cd b7       	in	r28, 0x3d	; 61
    1f60:	de b7       	in	r29, 0x3e	; 62
    1f62:	27 97       	sbiw	r28, 0x07	; 7
    1f64:	0f b6       	in	r0, 0x3f	; 63
    1f66:	f8 94       	cli
    1f68:	de bf       	out	0x3e, r29	; 62
    1f6a:	0f be       	out	0x3f, r0	; 63
    1f6c:	cd bf       	out	0x3d, r28	; 61
    1f6e:	89 83       	std	Y+1, r24	; 0x01
    1f70:	6a 83       	std	Y+2, r22	; 0x02
    1f72:	5c 83       	std	Y+4, r21	; 0x04
    1f74:	4b 83       	std	Y+3, r20	; 0x03
    1f76:	2d 83       	std	Y+5, r18	; 0x05
    1f78:	1f 83       	std	Y+7, r17	; 0x07
    1f7a:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1f7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f7e:	88 23       	and	r24, r24
    1f80:	39 f4       	brne	.+14     	; 0x1f90 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1f82:	8e 81       	ldd	r24, Y+6	; 0x06
    1f84:	9f 81       	ldd	r25, Y+7	; 0x07
    1f86:	ee 81       	ldd	r30, Y+6	; 0x06
    1f88:	ff 81       	ldd	r31, Y+7	; 0x07
    1f8a:	91 83       	std	Z+1, r25	; 0x01
    1f8c:	80 83       	st	Z, r24
    1f8e:	06 c0       	rjmp	.+12     	; 0x1f9c <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1f90:	8b 81       	ldd	r24, Y+3	; 0x03
    1f92:	9c 81       	ldd	r25, Y+4	; 0x04
    1f94:	ee 81       	ldd	r30, Y+6	; 0x06
    1f96:	ff 81       	ldd	r31, Y+7	; 0x07
    1f98:	91 83       	std	Z+1, r25	; 0x01
    1f9a:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1f9c:	ee 81       	ldd	r30, Y+6	; 0x06
    1f9e:	ff 81       	ldd	r31, Y+7	; 0x07
    1fa0:	89 81       	ldd	r24, Y+1	; 0x01
    1fa2:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1fa4:	ee 81       	ldd	r30, Y+6	; 0x06
    1fa6:	ff 81       	ldd	r31, Y+7	; 0x07
    1fa8:	8a 81       	ldd	r24, Y+2	; 0x02
    1faa:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1fac:	8e 81       	ldd	r24, Y+6	; 0x06
    1fae:	9f 81       	ldd	r25, Y+7	; 0x07
    1fb0:	61 e0       	ldi	r22, 0x01	; 1
    1fb2:	0e 94 d4 0e 	call	0x1da8	; 0x1da8 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1fb6:	27 96       	adiw	r28, 0x07	; 7
    1fb8:	0f b6       	in	r0, 0x3f	; 63
    1fba:	f8 94       	cli
    1fbc:	de bf       	out	0x3e, r29	; 62
    1fbe:	0f be       	out	0x3f, r0	; 63
    1fc0:	cd bf       	out	0x3d, r28	; 61
    1fc2:	cf 91       	pop	r28
    1fc4:	df 91       	pop	r29
    1fc6:	1f 91       	pop	r17
    1fc8:	0f 91       	pop	r16
    1fca:	08 95       	ret

00001fcc <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    1fcc:	df 93       	push	r29
    1fce:	cf 93       	push	r28
    1fd0:	00 d0       	rcall	.+0      	; 0x1fd2 <prvInitialiseMutex+0x6>
    1fd2:	cd b7       	in	r28, 0x3d	; 61
    1fd4:	de b7       	in	r29, 0x3e	; 62
    1fd6:	9a 83       	std	Y+2, r25	; 0x02
    1fd8:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    1fda:	89 81       	ldd	r24, Y+1	; 0x01
    1fdc:	9a 81       	ldd	r25, Y+2	; 0x02
    1fde:	00 97       	sbiw	r24, 0x00	; 0
    1fe0:	a1 f0       	breq	.+40     	; 0x200a <prvInitialiseMutex+0x3e>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    1fe2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fe4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fe6:	15 82       	std	Z+5, r1	; 0x05
    1fe8:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1fea:	e9 81       	ldd	r30, Y+1	; 0x01
    1fec:	fa 81       	ldd	r31, Y+2	; 0x02
    1fee:	11 82       	std	Z+1, r1	; 0x01
    1ff0:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    1ff2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ff4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ff6:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1ff8:	89 81       	ldd	r24, Y+1	; 0x01
    1ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    1ffc:	60 e0       	ldi	r22, 0x00	; 0
    1ffe:	70 e0       	ldi	r23, 0x00	; 0
    2000:	40 e0       	ldi	r20, 0x00	; 0
    2002:	50 e0       	ldi	r21, 0x00	; 0
    2004:	20 e0       	ldi	r18, 0x00	; 0
    2006:	0e 94 2a 10 	call	0x2054	; 0x2054 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    200a:	0f 90       	pop	r0
    200c:	0f 90       	pop	r0
    200e:	cf 91       	pop	r28
    2010:	df 91       	pop	r29
    2012:	08 95       	ret

00002014 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    2014:	df 93       	push	r29
    2016:	cf 93       	push	r28
    2018:	00 d0       	rcall	.+0      	; 0x201a <xQueueCreateMutex+0x6>
    201a:	00 d0       	rcall	.+0      	; 0x201c <xQueueCreateMutex+0x8>
    201c:	0f 92       	push	r0
    201e:	cd b7       	in	r28, 0x3d	; 61
    2020:	de b7       	in	r29, 0x3e	; 62
    2022:	8d 83       	std	Y+5, r24	; 0x05
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    2024:	81 e0       	ldi	r24, 0x01	; 1
    2026:	8a 83       	std	Y+2, r24	; 0x02
    2028:	19 82       	std	Y+1, r1	; 0x01

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    202a:	8a 81       	ldd	r24, Y+2	; 0x02
    202c:	69 81       	ldd	r22, Y+1	; 0x01
    202e:	4d 81       	ldd	r20, Y+5	; 0x05
    2030:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <xQueueGenericCreate>
    2034:	9c 83       	std	Y+4, r25	; 0x04
    2036:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    2038:	8b 81       	ldd	r24, Y+3	; 0x03
    203a:	9c 81       	ldd	r25, Y+4	; 0x04
    203c:	0e 94 e6 0f 	call	0x1fcc	; 0x1fcc <prvInitialiseMutex>

		return xNewQueue;
    2040:	8b 81       	ldd	r24, Y+3	; 0x03
    2042:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    2044:	0f 90       	pop	r0
    2046:	0f 90       	pop	r0
    2048:	0f 90       	pop	r0
    204a:	0f 90       	pop	r0
    204c:	0f 90       	pop	r0
    204e:	cf 91       	pop	r28
    2050:	df 91       	pop	r29
    2052:	08 95       	ret

00002054 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2054:	df 93       	push	r29
    2056:	cf 93       	push	r28
    2058:	cd b7       	in	r28, 0x3d	; 61
    205a:	de b7       	in	r29, 0x3e	; 62
    205c:	2f 97       	sbiw	r28, 0x0f	; 15
    205e:	0f b6       	in	r0, 0x3f	; 63
    2060:	f8 94       	cli
    2062:	de bf       	out	0x3e, r29	; 62
    2064:	0f be       	out	0x3f, r0	; 63
    2066:	cd bf       	out	0x3d, r28	; 61
    2068:	99 87       	std	Y+9, r25	; 0x09
    206a:	88 87       	std	Y+8, r24	; 0x08
    206c:	7b 87       	std	Y+11, r23	; 0x0b
    206e:	6a 87       	std	Y+10, r22	; 0x0a
    2070:	5d 87       	std	Y+13, r21	; 0x0d
    2072:	4c 87       	std	Y+12, r20	; 0x0c
    2074:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2076:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2078:	88 85       	ldd	r24, Y+8	; 0x08
    207a:	99 85       	ldd	r25, Y+9	; 0x09
    207c:	9a 83       	std	Y+2, r25	; 0x02
    207e:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2080:	0f b6       	in	r0, 0x3f	; 63
    2082:	f8 94       	cli
    2084:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2086:	e9 81       	ldd	r30, Y+1	; 0x01
    2088:	fa 81       	ldd	r31, Y+2	; 0x02
    208a:	92 8d       	ldd	r25, Z+26	; 0x1a
    208c:	e9 81       	ldd	r30, Y+1	; 0x01
    208e:	fa 81       	ldd	r31, Y+2	; 0x02
    2090:	83 8d       	ldd	r24, Z+27	; 0x1b
    2092:	98 17       	cp	r25, r24
    2094:	18 f0       	brcs	.+6      	; 0x209c <xQueueGenericSend+0x48>
    2096:	8e 85       	ldd	r24, Y+14	; 0x0e
    2098:	82 30       	cpi	r24, 0x02	; 2
    209a:	11 f5       	brne	.+68     	; 0x20e0 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    209c:	89 81       	ldd	r24, Y+1	; 0x01
    209e:	9a 81       	ldd	r25, Y+2	; 0x02
    20a0:	2a 85       	ldd	r18, Y+10	; 0x0a
    20a2:	3b 85       	ldd	r19, Y+11	; 0x0b
    20a4:	b9 01       	movw	r22, r18
    20a6:	4e 85       	ldd	r20, Y+14	; 0x0e
    20a8:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvCopyDataToQueue>
    20ac:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20ae:	e9 81       	ldd	r30, Y+1	; 0x01
    20b0:	fa 81       	ldd	r31, Y+2	; 0x02
    20b2:	81 89       	ldd	r24, Z+17	; 0x11
    20b4:	88 23       	and	r24, r24
    20b6:	51 f0       	breq	.+20     	; 0x20cc <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20b8:	89 81       	ldd	r24, Y+1	; 0x01
    20ba:	9a 81       	ldd	r25, Y+2	; 0x02
    20bc:	41 96       	adiw	r24, 0x11	; 17
    20be:	0e 94 c6 24 	call	0x498c	; 0x498c <xTaskRemoveFromEventList>
    20c2:	88 23       	and	r24, r24
    20c4:	41 f0       	breq	.+16     	; 0x20d6 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    20c6:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
    20ca:	05 c0       	rjmp	.+10     	; 0x20d6 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    20cc:	8b 81       	ldd	r24, Y+3	; 0x03
    20ce:	88 23       	and	r24, r24
    20d0:	11 f0       	breq	.+4      	; 0x20d6 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    20d2:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    20d6:	0f 90       	pop	r0
    20d8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    20da:	81 e0       	ldi	r24, 0x01	; 1
    20dc:	8f 87       	std	Y+15, r24	; 0x0f
    20de:	5c c0       	rjmp	.+184    	; 0x2198 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    20e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    20e2:	9d 85       	ldd	r25, Y+13	; 0x0d
    20e4:	00 97       	sbiw	r24, 0x00	; 0
    20e6:	21 f4       	brne	.+8      	; 0x20f0 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    20e8:	0f 90       	pop	r0
    20ea:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    20ec:	1f 86       	std	Y+15, r1	; 0x0f
    20ee:	54 c0       	rjmp	.+168    	; 0x2198 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    20f0:	8c 81       	ldd	r24, Y+4	; 0x04
    20f2:	88 23       	and	r24, r24
    20f4:	31 f4       	brne	.+12     	; 0x2102 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    20f6:	ce 01       	movw	r24, r28
    20f8:	05 96       	adiw	r24, 0x05	; 5
    20fa:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    20fe:	81 e0       	ldi	r24, 0x01	; 1
    2100:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2102:	0f 90       	pop	r0
    2104:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2106:	0e 94 26 22 	call	0x444c	; 0x444c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    210a:	0f b6       	in	r0, 0x3f	; 63
    210c:	f8 94       	cli
    210e:	0f 92       	push	r0
    2110:	e9 81       	ldd	r30, Y+1	; 0x01
    2112:	fa 81       	ldd	r31, Y+2	; 0x02
    2114:	85 8d       	ldd	r24, Z+29	; 0x1d
    2116:	8f 3f       	cpi	r24, 0xFF	; 255
    2118:	19 f4       	brne	.+6      	; 0x2120 <xQueueGenericSend+0xcc>
    211a:	e9 81       	ldd	r30, Y+1	; 0x01
    211c:	fa 81       	ldd	r31, Y+2	; 0x02
    211e:	15 8e       	std	Z+29, r1	; 0x1d
    2120:	e9 81       	ldd	r30, Y+1	; 0x01
    2122:	fa 81       	ldd	r31, Y+2	; 0x02
    2124:	86 8d       	ldd	r24, Z+30	; 0x1e
    2126:	8f 3f       	cpi	r24, 0xFF	; 255
    2128:	19 f4       	brne	.+6      	; 0x2130 <xQueueGenericSend+0xdc>
    212a:	e9 81       	ldd	r30, Y+1	; 0x01
    212c:	fa 81       	ldd	r31, Y+2	; 0x02
    212e:	16 8e       	std	Z+30, r1	; 0x1e
    2130:	0f 90       	pop	r0
    2132:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2134:	ce 01       	movw	r24, r28
    2136:	05 96       	adiw	r24, 0x05	; 5
    2138:	9e 01       	movw	r18, r28
    213a:	24 5f       	subi	r18, 0xF4	; 244
    213c:	3f 4f       	sbci	r19, 0xFF	; 255
    213e:	b9 01       	movw	r22, r18
    2140:	0e 94 c5 25 	call	0x4b8a	; 0x4b8a <xTaskCheckForTimeOut>
    2144:	88 23       	and	r24, r24
    2146:	09 f5       	brne	.+66     	; 0x218a <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2148:	89 81       	ldd	r24, Y+1	; 0x01
    214a:	9a 81       	ldd	r25, Y+2	; 0x02
    214c:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <prvIsQueueFull>
    2150:	88 23       	and	r24, r24
    2152:	a1 f0       	breq	.+40     	; 0x217c <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2154:	89 81       	ldd	r24, Y+1	; 0x01
    2156:	9a 81       	ldd	r25, Y+2	; 0x02
    2158:	08 96       	adiw	r24, 0x08	; 8
    215a:	2c 85       	ldd	r18, Y+12	; 0x0c
    215c:	3d 85       	ldd	r19, Y+13	; 0x0d
    215e:	b9 01       	movw	r22, r18
    2160:	0e 94 74 24 	call	0x48e8	; 0x48e8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2164:	89 81       	ldd	r24, Y+1	; 0x01
    2166:	9a 81       	ldd	r25, Y+2	; 0x02
    2168:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    216c:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
    2170:	88 23       	and	r24, r24
    2172:	09 f0       	breq	.+2      	; 0x2176 <xQueueGenericSend+0x122>
    2174:	85 cf       	rjmp	.-246    	; 0x2080 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2176:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
    217a:	82 cf       	rjmp	.-252    	; 0x2080 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    217c:	89 81       	ldd	r24, Y+1	; 0x01
    217e:	9a 81       	ldd	r25, Y+2	; 0x02
    2180:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2184:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
    2188:	7b cf       	rjmp	.-266    	; 0x2080 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    218a:	89 81       	ldd	r24, Y+1	; 0x01
    218c:	9a 81       	ldd	r25, Y+2	; 0x02
    218e:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2192:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2196:	1f 86       	std	Y+15, r1	; 0x0f
    2198:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    219a:	2f 96       	adiw	r28, 0x0f	; 15
    219c:	0f b6       	in	r0, 0x3f	; 63
    219e:	f8 94       	cli
    21a0:	de bf       	out	0x3e, r29	; 62
    21a2:	0f be       	out	0x3f, r0	; 63
    21a4:	cd bf       	out	0x3d, r28	; 61
    21a6:	cf 91       	pop	r28
    21a8:	df 91       	pop	r29
    21aa:	08 95       	ret

000021ac <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    21ac:	df 93       	push	r29
    21ae:	cf 93       	push	r28
    21b0:	cd b7       	in	r28, 0x3d	; 61
    21b2:	de b7       	in	r29, 0x3e	; 62
    21b4:	2c 97       	sbiw	r28, 0x0c	; 12
    21b6:	0f b6       	in	r0, 0x3f	; 63
    21b8:	f8 94       	cli
    21ba:	de bf       	out	0x3e, r29	; 62
    21bc:	0f be       	out	0x3f, r0	; 63
    21be:	cd bf       	out	0x3d, r28	; 61
    21c0:	9f 83       	std	Y+7, r25	; 0x07
    21c2:	8e 83       	std	Y+6, r24	; 0x06
    21c4:	79 87       	std	Y+9, r23	; 0x09
    21c6:	68 87       	std	Y+8, r22	; 0x08
    21c8:	5b 87       	std	Y+11, r21	; 0x0b
    21ca:	4a 87       	std	Y+10, r20	; 0x0a
    21cc:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    21ce:	8e 81       	ldd	r24, Y+6	; 0x06
    21d0:	9f 81       	ldd	r25, Y+7	; 0x07
    21d2:	9b 83       	std	Y+3, r25	; 0x03
    21d4:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    21d6:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    21d8:	ea 81       	ldd	r30, Y+2	; 0x02
    21da:	fb 81       	ldd	r31, Y+3	; 0x03
    21dc:	92 8d       	ldd	r25, Z+26	; 0x1a
    21de:	ea 81       	ldd	r30, Y+2	; 0x02
    21e0:	fb 81       	ldd	r31, Y+3	; 0x03
    21e2:	83 8d       	ldd	r24, Z+27	; 0x1b
    21e4:	98 17       	cp	r25, r24
    21e6:	18 f0       	brcs	.+6      	; 0x21ee <xQueueGenericSendFromISR+0x42>
    21e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    21ea:	82 30       	cpi	r24, 0x02	; 2
    21ec:	61 f5       	brne	.+88     	; 0x2246 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    21ee:	ea 81       	ldd	r30, Y+2	; 0x02
    21f0:	fb 81       	ldd	r31, Y+3	; 0x03
    21f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    21f4:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    21f6:	8a 81       	ldd	r24, Y+2	; 0x02
    21f8:	9b 81       	ldd	r25, Y+3	; 0x03
    21fa:	28 85       	ldd	r18, Y+8	; 0x08
    21fc:	39 85       	ldd	r19, Y+9	; 0x09
    21fe:	b9 01       	movw	r22, r18
    2200:	4c 85       	ldd	r20, Y+12	; 0x0c
    2202:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2206:	89 81       	ldd	r24, Y+1	; 0x01
    2208:	8f 3f       	cpi	r24, 0xFF	; 255
    220a:	a9 f4       	brne	.+42     	; 0x2236 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    220c:	ea 81       	ldd	r30, Y+2	; 0x02
    220e:	fb 81       	ldd	r31, Y+3	; 0x03
    2210:	81 89       	ldd	r24, Z+17	; 0x11
    2212:	88 23       	and	r24, r24
    2214:	a9 f0       	breq	.+42     	; 0x2240 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2216:	8a 81       	ldd	r24, Y+2	; 0x02
    2218:	9b 81       	ldd	r25, Y+3	; 0x03
    221a:	41 96       	adiw	r24, 0x11	; 17
    221c:	0e 94 c6 24 	call	0x498c	; 0x498c <xTaskRemoveFromEventList>
    2220:	88 23       	and	r24, r24
    2222:	71 f0       	breq	.+28     	; 0x2240 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2224:	8a 85       	ldd	r24, Y+10	; 0x0a
    2226:	9b 85       	ldd	r25, Y+11	; 0x0b
    2228:	00 97       	sbiw	r24, 0x00	; 0
    222a:	51 f0       	breq	.+20     	; 0x2240 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    222c:	ea 85       	ldd	r30, Y+10	; 0x0a
    222e:	fb 85       	ldd	r31, Y+11	; 0x0b
    2230:	81 e0       	ldi	r24, 0x01	; 1
    2232:	80 83       	st	Z, r24
    2234:	05 c0       	rjmp	.+10     	; 0x2240 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2236:	89 81       	ldd	r24, Y+1	; 0x01
    2238:	8f 5f       	subi	r24, 0xFF	; 255
    223a:	ea 81       	ldd	r30, Y+2	; 0x02
    223c:	fb 81       	ldd	r31, Y+3	; 0x03
    223e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2240:	81 e0       	ldi	r24, 0x01	; 1
    2242:	8d 83       	std	Y+5, r24	; 0x05
    2244:	01 c0       	rjmp	.+2      	; 0x2248 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2246:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2248:	8d 81       	ldd	r24, Y+5	; 0x05
}
    224a:	2c 96       	adiw	r28, 0x0c	; 12
    224c:	0f b6       	in	r0, 0x3f	; 63
    224e:	f8 94       	cli
    2250:	de bf       	out	0x3e, r29	; 62
    2252:	0f be       	out	0x3f, r0	; 63
    2254:	cd bf       	out	0x3d, r28	; 61
    2256:	cf 91       	pop	r28
    2258:	df 91       	pop	r29
    225a:	08 95       	ret

0000225c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    225c:	df 93       	push	r29
    225e:	cf 93       	push	r28
    2260:	cd b7       	in	r28, 0x3d	; 61
    2262:	de b7       	in	r29, 0x3e	; 62
    2264:	2a 97       	sbiw	r28, 0x0a	; 10
    2266:	0f b6       	in	r0, 0x3f	; 63
    2268:	f8 94       	cli
    226a:	de bf       	out	0x3e, r29	; 62
    226c:	0f be       	out	0x3f, r0	; 63
    226e:	cd bf       	out	0x3d, r28	; 61
    2270:	98 87       	std	Y+8, r25	; 0x08
    2272:	8f 83       	std	Y+7, r24	; 0x07
    2274:	7a 87       	std	Y+10, r23	; 0x0a
    2276:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2278:	8f 81       	ldd	r24, Y+7	; 0x07
    227a:	98 85       	ldd	r25, Y+8	; 0x08
    227c:	9c 83       	std	Y+4, r25	; 0x04
    227e:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2280:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2282:	eb 81       	ldd	r30, Y+3	; 0x03
    2284:	fc 81       	ldd	r31, Y+4	; 0x04
    2286:	82 8d       	ldd	r24, Z+26	; 0x1a
    2288:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    228a:	eb 81       	ldd	r30, Y+3	; 0x03
    228c:	fc 81       	ldd	r31, Y+4	; 0x04
    228e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2290:	8a 81       	ldd	r24, Y+2	; 0x02
    2292:	89 17       	cp	r24, r25
    2294:	48 f5       	brcc	.+82     	; 0x22e8 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2296:	eb 81       	ldd	r30, Y+3	; 0x03
    2298:	fc 81       	ldd	r31, Y+4	; 0x04
    229a:	86 8d       	ldd	r24, Z+30	; 0x1e
    229c:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    229e:	8a 81       	ldd	r24, Y+2	; 0x02
    22a0:	8f 5f       	subi	r24, 0xFF	; 255
    22a2:	eb 81       	ldd	r30, Y+3	; 0x03
    22a4:	fc 81       	ldd	r31, Y+4	; 0x04
    22a6:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    22a8:	89 81       	ldd	r24, Y+1	; 0x01
    22aa:	8f 3f       	cpi	r24, 0xFF	; 255
    22ac:	a9 f4       	brne	.+42     	; 0x22d8 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22ae:	eb 81       	ldd	r30, Y+3	; 0x03
    22b0:	fc 81       	ldd	r31, Y+4	; 0x04
    22b2:	81 89       	ldd	r24, Z+17	; 0x11
    22b4:	88 23       	and	r24, r24
    22b6:	a9 f0       	breq	.+42     	; 0x22e2 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22b8:	8b 81       	ldd	r24, Y+3	; 0x03
    22ba:	9c 81       	ldd	r25, Y+4	; 0x04
    22bc:	41 96       	adiw	r24, 0x11	; 17
    22be:	0e 94 c6 24 	call	0x498c	; 0x498c <xTaskRemoveFromEventList>
    22c2:	88 23       	and	r24, r24
    22c4:	71 f0       	breq	.+28     	; 0x22e2 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    22c6:	89 85       	ldd	r24, Y+9	; 0x09
    22c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    22ca:	00 97       	sbiw	r24, 0x00	; 0
    22cc:	51 f0       	breq	.+20     	; 0x22e2 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    22ce:	e9 85       	ldd	r30, Y+9	; 0x09
    22d0:	fa 85       	ldd	r31, Y+10	; 0x0a
    22d2:	81 e0       	ldi	r24, 0x01	; 1
    22d4:	80 83       	st	Z, r24
    22d6:	05 c0       	rjmp	.+10     	; 0x22e2 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    22d8:	89 81       	ldd	r24, Y+1	; 0x01
    22da:	8f 5f       	subi	r24, 0xFF	; 255
    22dc:	eb 81       	ldd	r30, Y+3	; 0x03
    22de:	fc 81       	ldd	r31, Y+4	; 0x04
    22e0:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    22e2:	81 e0       	ldi	r24, 0x01	; 1
    22e4:	8e 83       	std	Y+6, r24	; 0x06
    22e6:	01 c0       	rjmp	.+2      	; 0x22ea <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    22e8:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    22ea:	8e 81       	ldd	r24, Y+6	; 0x06
}
    22ec:	2a 96       	adiw	r28, 0x0a	; 10
    22ee:	0f b6       	in	r0, 0x3f	; 63
    22f0:	f8 94       	cli
    22f2:	de bf       	out	0x3e, r29	; 62
    22f4:	0f be       	out	0x3f, r0	; 63
    22f6:	cd bf       	out	0x3d, r28	; 61
    22f8:	cf 91       	pop	r28
    22fa:	df 91       	pop	r29
    22fc:	08 95       	ret

000022fe <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    22fe:	df 93       	push	r29
    2300:	cf 93       	push	r28
    2302:	cd b7       	in	r28, 0x3d	; 61
    2304:	de b7       	in	r29, 0x3e	; 62
    2306:	2e 97       	sbiw	r28, 0x0e	; 14
    2308:	0f b6       	in	r0, 0x3f	; 63
    230a:	f8 94       	cli
    230c:	de bf       	out	0x3e, r29	; 62
    230e:	0f be       	out	0x3f, r0	; 63
    2310:	cd bf       	out	0x3d, r28	; 61
    2312:	99 87       	std	Y+9, r25	; 0x09
    2314:	88 87       	std	Y+8, r24	; 0x08
    2316:	7b 87       	std	Y+11, r23	; 0x0b
    2318:	6a 87       	std	Y+10, r22	; 0x0a
    231a:	5d 87       	std	Y+13, r21	; 0x0d
    231c:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    231e:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2320:	88 85       	ldd	r24, Y+8	; 0x08
    2322:	99 85       	ldd	r25, Y+9	; 0x09
    2324:	9b 83       	std	Y+3, r25	; 0x03
    2326:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2328:	0f b6       	in	r0, 0x3f	; 63
    232a:	f8 94       	cli
    232c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    232e:	ea 81       	ldd	r30, Y+2	; 0x02
    2330:	fb 81       	ldd	r31, Y+3	; 0x03
    2332:	82 8d       	ldd	r24, Z+26	; 0x1a
    2334:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2336:	89 81       	ldd	r24, Y+1	; 0x01
    2338:	88 23       	and	r24, r24
    233a:	f9 f0       	breq	.+62     	; 0x237a <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    233c:	8a 81       	ldd	r24, Y+2	; 0x02
    233e:	9b 81       	ldd	r25, Y+3	; 0x03
    2340:	2a 85       	ldd	r18, Y+10	; 0x0a
    2342:	3b 85       	ldd	r19, Y+11	; 0x0b
    2344:	b9 01       	movw	r22, r18
    2346:	0e 94 88 15 	call	0x2b10	; 0x2b10 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    234a:	89 81       	ldd	r24, Y+1	; 0x01
    234c:	81 50       	subi	r24, 0x01	; 1
    234e:	ea 81       	ldd	r30, Y+2	; 0x02
    2350:	fb 81       	ldd	r31, Y+3	; 0x03
    2352:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2354:	ea 81       	ldd	r30, Y+2	; 0x02
    2356:	fb 81       	ldd	r31, Y+3	; 0x03
    2358:	80 85       	ldd	r24, Z+8	; 0x08
    235a:	88 23       	and	r24, r24
    235c:	49 f0       	breq	.+18     	; 0x2370 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    235e:	8a 81       	ldd	r24, Y+2	; 0x02
    2360:	9b 81       	ldd	r25, Y+3	; 0x03
    2362:	08 96       	adiw	r24, 0x08	; 8
    2364:	0e 94 c6 24 	call	0x498c	; 0x498c <xTaskRemoveFromEventList>
    2368:	88 23       	and	r24, r24
    236a:	11 f0       	breq	.+4      	; 0x2370 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    236c:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2370:	0f 90       	pop	r0
    2372:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2374:	81 e0       	ldi	r24, 0x01	; 1
    2376:	8e 87       	std	Y+14, r24	; 0x0e
    2378:	63 c0       	rjmp	.+198    	; 0x2440 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    237a:	8c 85       	ldd	r24, Y+12	; 0x0c
    237c:	9d 85       	ldd	r25, Y+13	; 0x0d
    237e:	00 97       	sbiw	r24, 0x00	; 0
    2380:	21 f4       	brne	.+8      	; 0x238a <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2382:	0f 90       	pop	r0
    2384:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2386:	1e 86       	std	Y+14, r1	; 0x0e
    2388:	5b c0       	rjmp	.+182    	; 0x2440 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    238a:	8c 81       	ldd	r24, Y+4	; 0x04
    238c:	88 23       	and	r24, r24
    238e:	31 f4       	brne	.+12     	; 0x239c <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2390:	ce 01       	movw	r24, r28
    2392:	05 96       	adiw	r24, 0x05	; 5
    2394:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2398:	81 e0       	ldi	r24, 0x01	; 1
    239a:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    239c:	0f 90       	pop	r0
    239e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    23a0:	0e 94 26 22 	call	0x444c	; 0x444c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    23a4:	0f b6       	in	r0, 0x3f	; 63
    23a6:	f8 94       	cli
    23a8:	0f 92       	push	r0
    23aa:	ea 81       	ldd	r30, Y+2	; 0x02
    23ac:	fb 81       	ldd	r31, Y+3	; 0x03
    23ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    23b0:	8f 3f       	cpi	r24, 0xFF	; 255
    23b2:	19 f4       	brne	.+6      	; 0x23ba <xQueueReceive+0xbc>
    23b4:	ea 81       	ldd	r30, Y+2	; 0x02
    23b6:	fb 81       	ldd	r31, Y+3	; 0x03
    23b8:	15 8e       	std	Z+29, r1	; 0x1d
    23ba:	ea 81       	ldd	r30, Y+2	; 0x02
    23bc:	fb 81       	ldd	r31, Y+3	; 0x03
    23be:	86 8d       	ldd	r24, Z+30	; 0x1e
    23c0:	8f 3f       	cpi	r24, 0xFF	; 255
    23c2:	19 f4       	brne	.+6      	; 0x23ca <xQueueReceive+0xcc>
    23c4:	ea 81       	ldd	r30, Y+2	; 0x02
    23c6:	fb 81       	ldd	r31, Y+3	; 0x03
    23c8:	16 8e       	std	Z+30, r1	; 0x1e
    23ca:	0f 90       	pop	r0
    23cc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    23ce:	ce 01       	movw	r24, r28
    23d0:	05 96       	adiw	r24, 0x05	; 5
    23d2:	9e 01       	movw	r18, r28
    23d4:	24 5f       	subi	r18, 0xF4	; 244
    23d6:	3f 4f       	sbci	r19, 0xFF	; 255
    23d8:	b9 01       	movw	r22, r18
    23da:	0e 94 c5 25 	call	0x4b8a	; 0x4b8a <xTaskCheckForTimeOut>
    23de:	88 23       	and	r24, r24
    23e0:	09 f5       	brne	.+66     	; 0x2424 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23e2:	8a 81       	ldd	r24, Y+2	; 0x02
    23e4:	9b 81       	ldd	r25, Y+3	; 0x03
    23e6:	0e 94 22 16 	call	0x2c44	; 0x2c44 <prvIsQueueEmpty>
    23ea:	88 23       	and	r24, r24
    23ec:	a1 f0       	breq	.+40     	; 0x2416 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    23ee:	8a 81       	ldd	r24, Y+2	; 0x02
    23f0:	9b 81       	ldd	r25, Y+3	; 0x03
    23f2:	41 96       	adiw	r24, 0x11	; 17
    23f4:	2c 85       	ldd	r18, Y+12	; 0x0c
    23f6:	3d 85       	ldd	r19, Y+13	; 0x0d
    23f8:	b9 01       	movw	r22, r18
    23fa:	0e 94 74 24 	call	0x48e8	; 0x48e8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    23fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2400:	9b 81       	ldd	r25, Y+3	; 0x03
    2402:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2406:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
    240a:	88 23       	and	r24, r24
    240c:	09 f0       	breq	.+2      	; 0x2410 <xQueueReceive+0x112>
    240e:	8c cf       	rjmp	.-232    	; 0x2328 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    2410:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
    2414:	89 cf       	rjmp	.-238    	; 0x2328 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    2416:	8a 81       	ldd	r24, Y+2	; 0x02
    2418:	9b 81       	ldd	r25, Y+3	; 0x03
    241a:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    241e:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
    2422:	82 cf       	rjmp	.-252    	; 0x2328 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    2424:	8a 81       	ldd	r24, Y+2	; 0x02
    2426:	9b 81       	ldd	r25, Y+3	; 0x03
    2428:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    242c:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2430:	8a 81       	ldd	r24, Y+2	; 0x02
    2432:	9b 81       	ldd	r25, Y+3	; 0x03
    2434:	0e 94 22 16 	call	0x2c44	; 0x2c44 <prvIsQueueEmpty>
    2438:	88 23       	and	r24, r24
    243a:	09 f4       	brne	.+2      	; 0x243e <xQueueReceive+0x140>
    243c:	75 cf       	rjmp	.-278    	; 0x2328 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    243e:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2440:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2442:	2e 96       	adiw	r28, 0x0e	; 14
    2444:	0f b6       	in	r0, 0x3f	; 63
    2446:	f8 94       	cli
    2448:	de bf       	out	0x3e, r29	; 62
    244a:	0f be       	out	0x3f, r0	; 63
    244c:	cd bf       	out	0x3d, r28	; 61
    244e:	cf 91       	pop	r28
    2450:	df 91       	pop	r29
    2452:	08 95       	ret

00002454 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    2454:	df 93       	push	r29
    2456:	cf 93       	push	r28
    2458:	cd b7       	in	r28, 0x3d	; 61
    245a:	de b7       	in	r29, 0x3e	; 62
    245c:	2e 97       	sbiw	r28, 0x0e	; 14
    245e:	0f b6       	in	r0, 0x3f	; 63
    2460:	f8 94       	cli
    2462:	de bf       	out	0x3e, r29	; 62
    2464:	0f be       	out	0x3f, r0	; 63
    2466:	cd bf       	out	0x3d, r28	; 61
    2468:	9b 87       	std	Y+11, r25	; 0x0b
    246a:	8a 87       	std	Y+10, r24	; 0x0a
    246c:	7d 87       	std	Y+13, r23	; 0x0d
    246e:	6c 87       	std	Y+12, r22	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    2470:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2472:	8a 85       	ldd	r24, Y+10	; 0x0a
    2474:	9b 85       	ldd	r25, Y+11	; 0x0b
    2476:	9d 83       	std	Y+5, r25	; 0x05
    2478:	8c 83       	std	Y+4, r24	; 0x04

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    247a:	1b 82       	std	Y+3, r1	; 0x03
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    247c:	0f b6       	in	r0, 0x3f	; 63
    247e:	f8 94       	cli
    2480:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2482:	ec 81       	ldd	r30, Y+4	; 0x04
    2484:	fd 81       	ldd	r31, Y+5	; 0x05
    2486:	82 8d       	ldd	r24, Z+26	; 0x1a
    2488:	8a 83       	std	Y+2, r24	; 0x02

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    248a:	8a 81       	ldd	r24, Y+2	; 0x02
    248c:	88 23       	and	r24, r24
    248e:	21 f1       	breq	.+72     	; 0x24d8 <xQueueSemaphoreTake+0x84>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2490:	8a 81       	ldd	r24, Y+2	; 0x02
    2492:	81 50       	subi	r24, 0x01	; 1
    2494:	ec 81       	ldd	r30, Y+4	; 0x04
    2496:	fd 81       	ldd	r31, Y+5	; 0x05
    2498:	82 8f       	std	Z+26, r24	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    249a:	ec 81       	ldd	r30, Y+4	; 0x04
    249c:	fd 81       	ldd	r31, Y+5	; 0x05
    249e:	80 81       	ld	r24, Z
    24a0:	91 81       	ldd	r25, Z+1	; 0x01
    24a2:	00 97       	sbiw	r24, 0x00	; 0
    24a4:	31 f4       	brne	.+12     	; 0x24b2 <xQueueSemaphoreTake+0x5e>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    24a6:	0e 94 d5 28 	call	0x51aa	; 0x51aa <pvTaskIncrementMutexHeldCount>
    24aa:	ec 81       	ldd	r30, Y+4	; 0x04
    24ac:	fd 81       	ldd	r31, Y+5	; 0x05
    24ae:	95 83       	std	Z+5, r25	; 0x05
    24b0:	84 83       	std	Z+4, r24	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24b2:	ec 81       	ldd	r30, Y+4	; 0x04
    24b4:	fd 81       	ldd	r31, Y+5	; 0x05
    24b6:	80 85       	ldd	r24, Z+8	; 0x08
    24b8:	88 23       	and	r24, r24
    24ba:	49 f0       	breq	.+18     	; 0x24ce <xQueueSemaphoreTake+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24bc:	8c 81       	ldd	r24, Y+4	; 0x04
    24be:	9d 81       	ldd	r25, Y+5	; 0x05
    24c0:	08 96       	adiw	r24, 0x08	; 8
    24c2:	0e 94 c6 24 	call	0x498c	; 0x498c <xTaskRemoveFromEventList>
    24c6:	88 23       	and	r24, r24
    24c8:	11 f0       	breq	.+4      	; 0x24ce <xQueueSemaphoreTake+0x7a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    24ca:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    24ce:	0f 90       	pop	r0
    24d0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    24d2:	81 e0       	ldi	r24, 0x01	; 1
    24d4:	8e 87       	std	Y+14, r24	; 0x0e
    24d6:	89 c0       	rjmp	.+274    	; 0x25ea <xQueueSemaphoreTake+0x196>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    24d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    24da:	9d 85       	ldd	r25, Y+13	; 0x0d
    24dc:	00 97       	sbiw	r24, 0x00	; 0
    24de:	21 f4       	brne	.+8      	; 0x24e8 <xQueueSemaphoreTake+0x94>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    24e0:	0f 90       	pop	r0
    24e2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    24e4:	1e 86       	std	Y+14, r1	; 0x0e
    24e6:	81 c0       	rjmp	.+258    	; 0x25ea <xQueueSemaphoreTake+0x196>
				}
				else if( xEntryTimeSet == pdFALSE )
    24e8:	8e 81       	ldd	r24, Y+6	; 0x06
    24ea:	88 23       	and	r24, r24
    24ec:	31 f4       	brne	.+12     	; 0x24fa <xQueueSemaphoreTake+0xa6>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    24ee:	ce 01       	movw	r24, r28
    24f0:	07 96       	adiw	r24, 0x07	; 7
    24f2:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    24f6:	81 e0       	ldi	r24, 0x01	; 1
    24f8:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    24fa:	0f 90       	pop	r0
    24fc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    24fe:	0e 94 26 22 	call	0x444c	; 0x444c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2502:	0f b6       	in	r0, 0x3f	; 63
    2504:	f8 94       	cli
    2506:	0f 92       	push	r0
    2508:	ec 81       	ldd	r30, Y+4	; 0x04
    250a:	fd 81       	ldd	r31, Y+5	; 0x05
    250c:	85 8d       	ldd	r24, Z+29	; 0x1d
    250e:	8f 3f       	cpi	r24, 0xFF	; 255
    2510:	19 f4       	brne	.+6      	; 0x2518 <xQueueSemaphoreTake+0xc4>
    2512:	ec 81       	ldd	r30, Y+4	; 0x04
    2514:	fd 81       	ldd	r31, Y+5	; 0x05
    2516:	15 8e       	std	Z+29, r1	; 0x1d
    2518:	ec 81       	ldd	r30, Y+4	; 0x04
    251a:	fd 81       	ldd	r31, Y+5	; 0x05
    251c:	86 8d       	ldd	r24, Z+30	; 0x1e
    251e:	8f 3f       	cpi	r24, 0xFF	; 255
    2520:	19 f4       	brne	.+6      	; 0x2528 <xQueueSemaphoreTake+0xd4>
    2522:	ec 81       	ldd	r30, Y+4	; 0x04
    2524:	fd 81       	ldd	r31, Y+5	; 0x05
    2526:	16 8e       	std	Z+30, r1	; 0x1e
    2528:	0f 90       	pop	r0
    252a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    252c:	ce 01       	movw	r24, r28
    252e:	07 96       	adiw	r24, 0x07	; 7
    2530:	9e 01       	movw	r18, r28
    2532:	24 5f       	subi	r18, 0xF4	; 244
    2534:	3f 4f       	sbci	r19, 0xFF	; 255
    2536:	b9 01       	movw	r22, r18
    2538:	0e 94 c5 25 	call	0x4b8a	; 0x4b8a <xTaskCheckForTimeOut>
    253c:	88 23       	and	r24, r24
    253e:	99 f5       	brne	.+102    	; 0x25a6 <xQueueSemaphoreTake+0x152>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2540:	8c 81       	ldd	r24, Y+4	; 0x04
    2542:	9d 81       	ldd	r25, Y+5	; 0x05
    2544:	0e 94 22 16 	call	0x2c44	; 0x2c44 <prvIsQueueEmpty>
    2548:	88 23       	and	r24, r24
    254a:	31 f1       	breq	.+76     	; 0x2598 <xQueueSemaphoreTake+0x144>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    254c:	ec 81       	ldd	r30, Y+4	; 0x04
    254e:	fd 81       	ldd	r31, Y+5	; 0x05
    2550:	80 81       	ld	r24, Z
    2552:	91 81       	ldd	r25, Z+1	; 0x01
    2554:	00 97       	sbiw	r24, 0x00	; 0
    2556:	61 f4       	brne	.+24     	; 0x2570 <xQueueSemaphoreTake+0x11c>
					{
						taskENTER_CRITICAL();
    2558:	0f b6       	in	r0, 0x3f	; 63
    255a:	f8 94       	cli
    255c:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    255e:	ec 81       	ldd	r30, Y+4	; 0x04
    2560:	fd 81       	ldd	r31, Y+5	; 0x05
    2562:	84 81       	ldd	r24, Z+4	; 0x04
    2564:	95 81       	ldd	r25, Z+5	; 0x05
    2566:	0e 94 09 27 	call	0x4e12	; 0x4e12 <xTaskPriorityInherit>
    256a:	8b 83       	std	Y+3, r24	; 0x03
						}
						taskEXIT_CRITICAL();
    256c:	0f 90       	pop	r0
    256e:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2570:	8c 81       	ldd	r24, Y+4	; 0x04
    2572:	9d 81       	ldd	r25, Y+5	; 0x05
    2574:	41 96       	adiw	r24, 0x11	; 17
    2576:	2c 85       	ldd	r18, Y+12	; 0x0c
    2578:	3d 85       	ldd	r19, Y+13	; 0x0d
    257a:	b9 01       	movw	r22, r18
    257c:	0e 94 74 24 	call	0x48e8	; 0x48e8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2580:	8c 81       	ldd	r24, Y+4	; 0x04
    2582:	9d 81       	ldd	r25, Y+5	; 0x05
    2584:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2588:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
    258c:	88 23       	and	r24, r24
    258e:	09 f0       	breq	.+2      	; 0x2592 <xQueueSemaphoreTake+0x13e>
    2590:	75 cf       	rjmp	.-278    	; 0x247c <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
    2592:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
    2596:	72 cf       	rjmp	.-284    	; 0x247c <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    2598:	8c 81       	ldd	r24, Y+4	; 0x04
    259a:	9d 81       	ldd	r25, Y+5	; 0x05
    259c:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    25a0:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
    25a4:	6b cf       	rjmp	.-298    	; 0x247c <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    25a6:	8c 81       	ldd	r24, Y+4	; 0x04
    25a8:	9d 81       	ldd	r25, Y+5	; 0x05
    25aa:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    25ae:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    25b2:	8c 81       	ldd	r24, Y+4	; 0x04
    25b4:	9d 81       	ldd	r25, Y+5	; 0x05
    25b6:	0e 94 22 16 	call	0x2c44	; 0x2c44 <prvIsQueueEmpty>
    25ba:	88 23       	and	r24, r24
    25bc:	09 f4       	brne	.+2      	; 0x25c0 <xQueueSemaphoreTake+0x16c>
    25be:	5e cf       	rjmp	.-324    	; 0x247c <xQueueSemaphoreTake+0x28>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    25c0:	8b 81       	ldd	r24, Y+3	; 0x03
    25c2:	88 23       	and	r24, r24
    25c4:	89 f0       	breq	.+34     	; 0x25e8 <xQueueSemaphoreTake+0x194>
					{
						taskENTER_CRITICAL();
    25c6:	0f b6       	in	r0, 0x3f	; 63
    25c8:	f8 94       	cli
    25ca:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    25cc:	8c 81       	ldd	r24, Y+4	; 0x04
    25ce:	9d 81       	ldd	r25, Y+5	; 0x05
    25d0:	0e 94 af 14 	call	0x295e	; 0x295e <prvGetDisinheritPriorityAfterTimeout>
    25d4:	89 83       	std	Y+1, r24	; 0x01
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    25d6:	ec 81       	ldd	r30, Y+4	; 0x04
    25d8:	fd 81       	ldd	r31, Y+5	; 0x05
    25da:	84 81       	ldd	r24, Z+4	; 0x04
    25dc:	95 81       	ldd	r25, Z+5	; 0x05
    25de:	69 81       	ldd	r22, Y+1	; 0x01
    25e0:	0e 94 19 28 	call	0x5032	; 0x5032 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    25e4:	0f 90       	pop	r0
    25e6:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    25e8:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    25ea:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    25ec:	2e 96       	adiw	r28, 0x0e	; 14
    25ee:	0f b6       	in	r0, 0x3f	; 63
    25f0:	f8 94       	cli
    25f2:	de bf       	out	0x3e, r29	; 62
    25f4:	0f be       	out	0x3f, r0	; 63
    25f6:	cd bf       	out	0x3d, r28	; 61
    25f8:	cf 91       	pop	r28
    25fa:	df 91       	pop	r29
    25fc:	08 95       	ret

000025fe <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    25fe:	df 93       	push	r29
    2600:	cf 93       	push	r28
    2602:	cd b7       	in	r28, 0x3d	; 61
    2604:	de b7       	in	r29, 0x3e	; 62
    2606:	60 97       	sbiw	r28, 0x10	; 16
    2608:	0f b6       	in	r0, 0x3f	; 63
    260a:	f8 94       	cli
    260c:	de bf       	out	0x3e, r29	; 62
    260e:	0f be       	out	0x3f, r0	; 63
    2610:	cd bf       	out	0x3d, r28	; 61
    2612:	9b 87       	std	Y+11, r25	; 0x0b
    2614:	8a 87       	std	Y+10, r24	; 0x0a
    2616:	7d 87       	std	Y+13, r23	; 0x0d
    2618:	6c 87       	std	Y+12, r22	; 0x0c
    261a:	5f 87       	std	Y+15, r21	; 0x0f
    261c:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    261e:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2620:	8a 85       	ldd	r24, Y+10	; 0x0a
    2622:	9b 85       	ldd	r25, Y+11	; 0x0b
    2624:	9b 83       	std	Y+3, r25	; 0x03
    2626:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2628:	0f b6       	in	r0, 0x3f	; 63
    262a:	f8 94       	cli
    262c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    262e:	ea 81       	ldd	r30, Y+2	; 0x02
    2630:	fb 81       	ldd	r31, Y+3	; 0x03
    2632:	82 8d       	ldd	r24, Z+26	; 0x1a
    2634:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2636:	89 81       	ldd	r24, Y+1	; 0x01
    2638:	88 23       	and	r24, r24
    263a:	31 f1       	breq	.+76     	; 0x2688 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    263c:	ea 81       	ldd	r30, Y+2	; 0x02
    263e:	fb 81       	ldd	r31, Y+3	; 0x03
    2640:	86 81       	ldd	r24, Z+6	; 0x06
    2642:	97 81       	ldd	r25, Z+7	; 0x07
    2644:	9d 83       	std	Y+5, r25	; 0x05
    2646:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2648:	8a 81       	ldd	r24, Y+2	; 0x02
    264a:	9b 81       	ldd	r25, Y+3	; 0x03
    264c:	2c 85       	ldd	r18, Y+12	; 0x0c
    264e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2650:	b9 01       	movw	r22, r18
    2652:	0e 94 88 15 	call	0x2b10	; 0x2b10 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2656:	ea 81       	ldd	r30, Y+2	; 0x02
    2658:	fb 81       	ldd	r31, Y+3	; 0x03
    265a:	8c 81       	ldd	r24, Y+4	; 0x04
    265c:	9d 81       	ldd	r25, Y+5	; 0x05
    265e:	97 83       	std	Z+7, r25	; 0x07
    2660:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2662:	ea 81       	ldd	r30, Y+2	; 0x02
    2664:	fb 81       	ldd	r31, Y+3	; 0x03
    2666:	81 89       	ldd	r24, Z+17	; 0x11
    2668:	88 23       	and	r24, r24
    266a:	49 f0       	breq	.+18     	; 0x267e <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    266c:	8a 81       	ldd	r24, Y+2	; 0x02
    266e:	9b 81       	ldd	r25, Y+3	; 0x03
    2670:	41 96       	adiw	r24, 0x11	; 17
    2672:	0e 94 c6 24 	call	0x498c	; 0x498c <xTaskRemoveFromEventList>
    2676:	88 23       	and	r24, r24
    2678:	11 f0       	breq	.+4      	; 0x267e <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    267a:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    267e:	0f 90       	pop	r0
    2680:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2682:	81 e0       	ldi	r24, 0x01	; 1
    2684:	88 8b       	std	Y+16, r24	; 0x10
    2686:	63 c0       	rjmp	.+198    	; 0x274e <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2688:	8e 85       	ldd	r24, Y+14	; 0x0e
    268a:	9f 85       	ldd	r25, Y+15	; 0x0f
    268c:	00 97       	sbiw	r24, 0x00	; 0
    268e:	21 f4       	brne	.+8      	; 0x2698 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2690:	0f 90       	pop	r0
    2692:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2694:	18 8a       	std	Y+16, r1	; 0x10
    2696:	5b c0       	rjmp	.+182    	; 0x274e <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    2698:	8e 81       	ldd	r24, Y+6	; 0x06
    269a:	88 23       	and	r24, r24
    269c:	31 f4       	brne	.+12     	; 0x26aa <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    269e:	ce 01       	movw	r24, r28
    26a0:	07 96       	adiw	r24, 0x07	; 7
    26a2:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    26a6:	81 e0       	ldi	r24, 0x01	; 1
    26a8:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    26aa:	0f 90       	pop	r0
    26ac:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    26ae:	0e 94 26 22 	call	0x444c	; 0x444c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    26b2:	0f b6       	in	r0, 0x3f	; 63
    26b4:	f8 94       	cli
    26b6:	0f 92       	push	r0
    26b8:	ea 81       	ldd	r30, Y+2	; 0x02
    26ba:	fb 81       	ldd	r31, Y+3	; 0x03
    26bc:	85 8d       	ldd	r24, Z+29	; 0x1d
    26be:	8f 3f       	cpi	r24, 0xFF	; 255
    26c0:	19 f4       	brne	.+6      	; 0x26c8 <xQueuePeek+0xca>
    26c2:	ea 81       	ldd	r30, Y+2	; 0x02
    26c4:	fb 81       	ldd	r31, Y+3	; 0x03
    26c6:	15 8e       	std	Z+29, r1	; 0x1d
    26c8:	ea 81       	ldd	r30, Y+2	; 0x02
    26ca:	fb 81       	ldd	r31, Y+3	; 0x03
    26cc:	86 8d       	ldd	r24, Z+30	; 0x1e
    26ce:	8f 3f       	cpi	r24, 0xFF	; 255
    26d0:	19 f4       	brne	.+6      	; 0x26d8 <xQueuePeek+0xda>
    26d2:	ea 81       	ldd	r30, Y+2	; 0x02
    26d4:	fb 81       	ldd	r31, Y+3	; 0x03
    26d6:	16 8e       	std	Z+30, r1	; 0x1e
    26d8:	0f 90       	pop	r0
    26da:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    26dc:	ce 01       	movw	r24, r28
    26de:	07 96       	adiw	r24, 0x07	; 7
    26e0:	9e 01       	movw	r18, r28
    26e2:	22 5f       	subi	r18, 0xF2	; 242
    26e4:	3f 4f       	sbci	r19, 0xFF	; 255
    26e6:	b9 01       	movw	r22, r18
    26e8:	0e 94 c5 25 	call	0x4b8a	; 0x4b8a <xTaskCheckForTimeOut>
    26ec:	88 23       	and	r24, r24
    26ee:	09 f5       	brne	.+66     	; 0x2732 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    26f0:	8a 81       	ldd	r24, Y+2	; 0x02
    26f2:	9b 81       	ldd	r25, Y+3	; 0x03
    26f4:	0e 94 22 16 	call	0x2c44	; 0x2c44 <prvIsQueueEmpty>
    26f8:	88 23       	and	r24, r24
    26fa:	a1 f0       	breq	.+40     	; 0x2724 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    26fc:	8a 81       	ldd	r24, Y+2	; 0x02
    26fe:	9b 81       	ldd	r25, Y+3	; 0x03
    2700:	41 96       	adiw	r24, 0x11	; 17
    2702:	2e 85       	ldd	r18, Y+14	; 0x0e
    2704:	3f 85       	ldd	r19, Y+15	; 0x0f
    2706:	b9 01       	movw	r22, r18
    2708:	0e 94 74 24 	call	0x48e8	; 0x48e8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    270c:	8a 81       	ldd	r24, Y+2	; 0x02
    270e:	9b 81       	ldd	r25, Y+3	; 0x03
    2710:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2714:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
    2718:	88 23       	and	r24, r24
    271a:	09 f0       	breq	.+2      	; 0x271e <xQueuePeek+0x120>
    271c:	85 cf       	rjmp	.-246    	; 0x2628 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    271e:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
    2722:	82 cf       	rjmp	.-252    	; 0x2628 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    2724:	8a 81       	ldd	r24, Y+2	; 0x02
    2726:	9b 81       	ldd	r25, Y+3	; 0x03
    2728:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    272c:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
    2730:	7b cf       	rjmp	.-266    	; 0x2628 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    2732:	8a 81       	ldd	r24, Y+2	; 0x02
    2734:	9b 81       	ldd	r25, Y+3	; 0x03
    2736:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    273a:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    273e:	8a 81       	ldd	r24, Y+2	; 0x02
    2740:	9b 81       	ldd	r25, Y+3	; 0x03
    2742:	0e 94 22 16 	call	0x2c44	; 0x2c44 <prvIsQueueEmpty>
    2746:	88 23       	and	r24, r24
    2748:	09 f4       	brne	.+2      	; 0x274c <xQueuePeek+0x14e>
    274a:	6e cf       	rjmp	.-292    	; 0x2628 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    274c:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    274e:	88 89       	ldd	r24, Y+16	; 0x10
}
    2750:	60 96       	adiw	r28, 0x10	; 16
    2752:	0f b6       	in	r0, 0x3f	; 63
    2754:	f8 94       	cli
    2756:	de bf       	out	0x3e, r29	; 62
    2758:	0f be       	out	0x3f, r0	; 63
    275a:	cd bf       	out	0x3d, r28	; 61
    275c:	cf 91       	pop	r28
    275e:	df 91       	pop	r29
    2760:	08 95       	ret

00002762 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2762:	df 93       	push	r29
    2764:	cf 93       	push	r28
    2766:	cd b7       	in	r28, 0x3d	; 61
    2768:	de b7       	in	r29, 0x3e	; 62
    276a:	2c 97       	sbiw	r28, 0x0c	; 12
    276c:	0f b6       	in	r0, 0x3f	; 63
    276e:	f8 94       	cli
    2770:	de bf       	out	0x3e, r29	; 62
    2772:	0f be       	out	0x3f, r0	; 63
    2774:	cd bf       	out	0x3d, r28	; 61
    2776:	98 87       	std	Y+8, r25	; 0x08
    2778:	8f 83       	std	Y+7, r24	; 0x07
    277a:	7a 87       	std	Y+10, r23	; 0x0a
    277c:	69 87       	std	Y+9, r22	; 0x09
    277e:	5c 87       	std	Y+12, r21	; 0x0c
    2780:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2782:	8f 81       	ldd	r24, Y+7	; 0x07
    2784:	98 85       	ldd	r25, Y+8	; 0x08
    2786:	9c 83       	std	Y+4, r25	; 0x04
    2788:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    278a:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    278c:	eb 81       	ldd	r30, Y+3	; 0x03
    278e:	fc 81       	ldd	r31, Y+4	; 0x04
    2790:	82 8d       	ldd	r24, Z+26	; 0x1a
    2792:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2794:	8a 81       	ldd	r24, Y+2	; 0x02
    2796:	88 23       	and	r24, r24
    2798:	81 f1       	breq	.+96     	; 0x27fa <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    279a:	eb 81       	ldd	r30, Y+3	; 0x03
    279c:	fc 81       	ldd	r31, Y+4	; 0x04
    279e:	85 8d       	ldd	r24, Z+29	; 0x1d
    27a0:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    27a2:	8b 81       	ldd	r24, Y+3	; 0x03
    27a4:	9c 81       	ldd	r25, Y+4	; 0x04
    27a6:	29 85       	ldd	r18, Y+9	; 0x09
    27a8:	3a 85       	ldd	r19, Y+10	; 0x0a
    27aa:	b9 01       	movw	r22, r18
    27ac:	0e 94 88 15 	call	0x2b10	; 0x2b10 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    27b0:	8a 81       	ldd	r24, Y+2	; 0x02
    27b2:	81 50       	subi	r24, 0x01	; 1
    27b4:	eb 81       	ldd	r30, Y+3	; 0x03
    27b6:	fc 81       	ldd	r31, Y+4	; 0x04
    27b8:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    27ba:	89 81       	ldd	r24, Y+1	; 0x01
    27bc:	8f 3f       	cpi	r24, 0xFF	; 255
    27be:	a9 f4       	brne	.+42     	; 0x27ea <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    27c0:	eb 81       	ldd	r30, Y+3	; 0x03
    27c2:	fc 81       	ldd	r31, Y+4	; 0x04
    27c4:	80 85       	ldd	r24, Z+8	; 0x08
    27c6:	88 23       	and	r24, r24
    27c8:	a9 f0       	breq	.+42     	; 0x27f4 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    27ca:	8b 81       	ldd	r24, Y+3	; 0x03
    27cc:	9c 81       	ldd	r25, Y+4	; 0x04
    27ce:	08 96       	adiw	r24, 0x08	; 8
    27d0:	0e 94 c6 24 	call	0x498c	; 0x498c <xTaskRemoveFromEventList>
    27d4:	88 23       	and	r24, r24
    27d6:	71 f0       	breq	.+28     	; 0x27f4 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    27d8:	8b 85       	ldd	r24, Y+11	; 0x0b
    27da:	9c 85       	ldd	r25, Y+12	; 0x0c
    27dc:	00 97       	sbiw	r24, 0x00	; 0
    27de:	51 f0       	breq	.+20     	; 0x27f4 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    27e0:	eb 85       	ldd	r30, Y+11	; 0x0b
    27e2:	fc 85       	ldd	r31, Y+12	; 0x0c
    27e4:	81 e0       	ldi	r24, 0x01	; 1
    27e6:	80 83       	st	Z, r24
    27e8:	05 c0       	rjmp	.+10     	; 0x27f4 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    27ea:	89 81       	ldd	r24, Y+1	; 0x01
    27ec:	8f 5f       	subi	r24, 0xFF	; 255
    27ee:	eb 81       	ldd	r30, Y+3	; 0x03
    27f0:	fc 81       	ldd	r31, Y+4	; 0x04
    27f2:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    27f4:	81 e0       	ldi	r24, 0x01	; 1
    27f6:	8e 83       	std	Y+6, r24	; 0x06
    27f8:	01 c0       	rjmp	.+2      	; 0x27fc <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    27fa:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    27fc:	8e 81       	ldd	r24, Y+6	; 0x06
}
    27fe:	2c 96       	adiw	r28, 0x0c	; 12
    2800:	0f b6       	in	r0, 0x3f	; 63
    2802:	f8 94       	cli
    2804:	de bf       	out	0x3e, r29	; 62
    2806:	0f be       	out	0x3f, r0	; 63
    2808:	cd bf       	out	0x3d, r28	; 61
    280a:	cf 91       	pop	r28
    280c:	df 91       	pop	r29
    280e:	08 95       	ret

00002810 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2810:	df 93       	push	r29
    2812:	cf 93       	push	r28
    2814:	cd b7       	in	r28, 0x3d	; 61
    2816:	de b7       	in	r29, 0x3e	; 62
    2818:	2a 97       	sbiw	r28, 0x0a	; 10
    281a:	0f b6       	in	r0, 0x3f	; 63
    281c:	f8 94       	cli
    281e:	de bf       	out	0x3e, r29	; 62
    2820:	0f be       	out	0x3f, r0	; 63
    2822:	cd bf       	out	0x3d, r28	; 61
    2824:	98 87       	std	Y+8, r25	; 0x08
    2826:	8f 83       	std	Y+7, r24	; 0x07
    2828:	7a 87       	std	Y+10, r23	; 0x0a
    282a:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    282c:	8f 81       	ldd	r24, Y+7	; 0x07
    282e:	98 85       	ldd	r25, Y+8	; 0x08
    2830:	9a 83       	std	Y+2, r25	; 0x02
    2832:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2834:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2836:	e9 81       	ldd	r30, Y+1	; 0x01
    2838:	fa 81       	ldd	r31, Y+2	; 0x02
    283a:	82 8d       	ldd	r24, Z+26	; 0x1a
    283c:	88 23       	and	r24, r24
    283e:	b1 f0       	breq	.+44     	; 0x286c <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2840:	e9 81       	ldd	r30, Y+1	; 0x01
    2842:	fa 81       	ldd	r31, Y+2	; 0x02
    2844:	86 81       	ldd	r24, Z+6	; 0x06
    2846:	97 81       	ldd	r25, Z+7	; 0x07
    2848:	9c 83       	std	Y+4, r25	; 0x04
    284a:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    284c:	89 81       	ldd	r24, Y+1	; 0x01
    284e:	9a 81       	ldd	r25, Y+2	; 0x02
    2850:	29 85       	ldd	r18, Y+9	; 0x09
    2852:	3a 85       	ldd	r19, Y+10	; 0x0a
    2854:	b9 01       	movw	r22, r18
    2856:	0e 94 88 15 	call	0x2b10	; 0x2b10 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    285a:	e9 81       	ldd	r30, Y+1	; 0x01
    285c:	fa 81       	ldd	r31, Y+2	; 0x02
    285e:	8b 81       	ldd	r24, Y+3	; 0x03
    2860:	9c 81       	ldd	r25, Y+4	; 0x04
    2862:	97 83       	std	Z+7, r25	; 0x07
    2864:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2866:	81 e0       	ldi	r24, 0x01	; 1
    2868:	8e 83       	std	Y+6, r24	; 0x06
    286a:	01 c0       	rjmp	.+2      	; 0x286e <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    286c:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    286e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2870:	2a 96       	adiw	r28, 0x0a	; 10
    2872:	0f b6       	in	r0, 0x3f	; 63
    2874:	f8 94       	cli
    2876:	de bf       	out	0x3e, r29	; 62
    2878:	0f be       	out	0x3f, r0	; 63
    287a:	cd bf       	out	0x3d, r28	; 61
    287c:	cf 91       	pop	r28
    287e:	df 91       	pop	r29
    2880:	08 95       	ret

00002882 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2882:	df 93       	push	r29
    2884:	cf 93       	push	r28
    2886:	00 d0       	rcall	.+0      	; 0x2888 <uxQueueMessagesWaiting+0x6>
    2888:	0f 92       	push	r0
    288a:	cd b7       	in	r28, 0x3d	; 61
    288c:	de b7       	in	r29, 0x3e	; 62
    288e:	9b 83       	std	Y+3, r25	; 0x03
    2890:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2892:	0f b6       	in	r0, 0x3f	; 63
    2894:	f8 94       	cli
    2896:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2898:	ea 81       	ldd	r30, Y+2	; 0x02
    289a:	fb 81       	ldd	r31, Y+3	; 0x03
    289c:	82 8d       	ldd	r24, Z+26	; 0x1a
    289e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    28a0:	0f 90       	pop	r0
    28a2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    28a4:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    28a6:	0f 90       	pop	r0
    28a8:	0f 90       	pop	r0
    28aa:	0f 90       	pop	r0
    28ac:	cf 91       	pop	r28
    28ae:	df 91       	pop	r29
    28b0:	08 95       	ret

000028b2 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    28b2:	df 93       	push	r29
    28b4:	cf 93       	push	r28
    28b6:	00 d0       	rcall	.+0      	; 0x28b8 <uxQueueSpacesAvailable+0x6>
    28b8:	00 d0       	rcall	.+0      	; 0x28ba <uxQueueSpacesAvailable+0x8>
    28ba:	0f 92       	push	r0
    28bc:	cd b7       	in	r28, 0x3d	; 61
    28be:	de b7       	in	r29, 0x3e	; 62
    28c0:	9d 83       	std	Y+5, r25	; 0x05
    28c2:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    28c4:	8c 81       	ldd	r24, Y+4	; 0x04
    28c6:	9d 81       	ldd	r25, Y+5	; 0x05
    28c8:	9a 83       	std	Y+2, r25	; 0x02
    28ca:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    28cc:	0f b6       	in	r0, 0x3f	; 63
    28ce:	f8 94       	cli
    28d0:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    28d2:	e9 81       	ldd	r30, Y+1	; 0x01
    28d4:	fa 81       	ldd	r31, Y+2	; 0x02
    28d6:	93 8d       	ldd	r25, Z+27	; 0x1b
    28d8:	e9 81       	ldd	r30, Y+1	; 0x01
    28da:	fa 81       	ldd	r31, Y+2	; 0x02
    28dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    28de:	29 2f       	mov	r18, r25
    28e0:	28 1b       	sub	r18, r24
    28e2:	82 2f       	mov	r24, r18
    28e4:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    28e6:	0f 90       	pop	r0
    28e8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    28ea:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    28ec:	0f 90       	pop	r0
    28ee:	0f 90       	pop	r0
    28f0:	0f 90       	pop	r0
    28f2:	0f 90       	pop	r0
    28f4:	0f 90       	pop	r0
    28f6:	cf 91       	pop	r28
    28f8:	df 91       	pop	r29
    28fa:	08 95       	ret

000028fc <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    28fc:	df 93       	push	r29
    28fe:	cf 93       	push	r28
    2900:	00 d0       	rcall	.+0      	; 0x2902 <uxQueueMessagesWaitingFromISR+0x6>
    2902:	00 d0       	rcall	.+0      	; 0x2904 <uxQueueMessagesWaitingFromISR+0x8>
    2904:	0f 92       	push	r0
    2906:	cd b7       	in	r28, 0x3d	; 61
    2908:	de b7       	in	r29, 0x3e	; 62
    290a:	9d 83       	std	Y+5, r25	; 0x05
    290c:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    290e:	8c 81       	ldd	r24, Y+4	; 0x04
    2910:	9d 81       	ldd	r25, Y+5	; 0x05
    2912:	9a 83       	std	Y+2, r25	; 0x02
    2914:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2916:	e9 81       	ldd	r30, Y+1	; 0x01
    2918:	fa 81       	ldd	r31, Y+2	; 0x02
    291a:	82 8d       	ldd	r24, Z+26	; 0x1a
    291c:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    291e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2920:	0f 90       	pop	r0
    2922:	0f 90       	pop	r0
    2924:	0f 90       	pop	r0
    2926:	0f 90       	pop	r0
    2928:	0f 90       	pop	r0
    292a:	cf 91       	pop	r28
    292c:	df 91       	pop	r29
    292e:	08 95       	ret

00002930 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2930:	df 93       	push	r29
    2932:	cf 93       	push	r28
    2934:	00 d0       	rcall	.+0      	; 0x2936 <vQueueDelete+0x6>
    2936:	00 d0       	rcall	.+0      	; 0x2938 <vQueueDelete+0x8>
    2938:	cd b7       	in	r28, 0x3d	; 61
    293a:	de b7       	in	r29, 0x3e	; 62
    293c:	9c 83       	std	Y+4, r25	; 0x04
    293e:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    2940:	8b 81       	ldd	r24, Y+3	; 0x03
    2942:	9c 81       	ldd	r25, Y+4	; 0x04
    2944:	9a 83       	std	Y+2, r25	; 0x02
    2946:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2948:	89 81       	ldd	r24, Y+1	; 0x01
    294a:	9a 81       	ldd	r25, Y+2	; 0x02
    294c:	0e 94 fe 08 	call	0x11fc	; 0x11fc <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2950:	0f 90       	pop	r0
    2952:	0f 90       	pop	r0
    2954:	0f 90       	pop	r0
    2956:	0f 90       	pop	r0
    2958:	cf 91       	pop	r28
    295a:	df 91       	pop	r29
    295c:	08 95       	ret

0000295e <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    295e:	df 93       	push	r29
    2960:	cf 93       	push	r28
    2962:	00 d0       	rcall	.+0      	; 0x2964 <prvGetDisinheritPriorityAfterTimeout+0x6>
    2964:	0f 92       	push	r0
    2966:	cd b7       	in	r28, 0x3d	; 61
    2968:	de b7       	in	r29, 0x3e	; 62
    296a:	9b 83       	std	Y+3, r25	; 0x03
    296c:	8a 83       	std	Y+2, r24	; 0x02
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    296e:	ea 81       	ldd	r30, Y+2	; 0x02
    2970:	fb 81       	ldd	r31, Y+3	; 0x03
    2972:	81 89       	ldd	r24, Z+17	; 0x11
    2974:	88 23       	and	r24, r24
    2976:	61 f0       	breq	.+24     	; 0x2990 <prvGetDisinheritPriorityAfterTimeout+0x32>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    2978:	ea 81       	ldd	r30, Y+2	; 0x02
    297a:	fb 81       	ldd	r31, Y+3	; 0x03
    297c:	06 88       	ldd	r0, Z+22	; 0x16
    297e:	f7 89       	ldd	r31, Z+23	; 0x17
    2980:	e0 2d       	mov	r30, r0
    2982:	80 81       	ld	r24, Z
    2984:	91 81       	ldd	r25, Z+1	; 0x01
    2986:	98 2f       	mov	r25, r24
    2988:	87 e0       	ldi	r24, 0x07	; 7
    298a:	89 1b       	sub	r24, r25
    298c:	89 83       	std	Y+1, r24	; 0x01
    298e:	01 c0       	rjmp	.+2      	; 0x2992 <prvGetDisinheritPriorityAfterTimeout+0x34>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    2990:	19 82       	std	Y+1, r1	; 0x01
		}

		return uxHighestPriorityOfWaitingTasks;
    2992:	89 81       	ldd	r24, Y+1	; 0x01
	}
    2994:	0f 90       	pop	r0
    2996:	0f 90       	pop	r0
    2998:	0f 90       	pop	r0
    299a:	cf 91       	pop	r28
    299c:	df 91       	pop	r29
    299e:	08 95       	ret

000029a0 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    29a0:	df 93       	push	r29
    29a2:	cf 93       	push	r28
    29a4:	cd b7       	in	r28, 0x3d	; 61
    29a6:	de b7       	in	r29, 0x3e	; 62
    29a8:	27 97       	sbiw	r28, 0x07	; 7
    29aa:	0f b6       	in	r0, 0x3f	; 63
    29ac:	f8 94       	cli
    29ae:	de bf       	out	0x3e, r29	; 62
    29b0:	0f be       	out	0x3f, r0	; 63
    29b2:	cd bf       	out	0x3d, r28	; 61
    29b4:	9c 83       	std	Y+4, r25	; 0x04
    29b6:	8b 83       	std	Y+3, r24	; 0x03
    29b8:	7e 83       	std	Y+6, r23	; 0x06
    29ba:	6d 83       	std	Y+5, r22	; 0x05
    29bc:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    29be:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    29c0:	eb 81       	ldd	r30, Y+3	; 0x03
    29c2:	fc 81       	ldd	r31, Y+4	; 0x04
    29c4:	82 8d       	ldd	r24, Z+26	; 0x1a
    29c6:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    29c8:	eb 81       	ldd	r30, Y+3	; 0x03
    29ca:	fc 81       	ldd	r31, Y+4	; 0x04
    29cc:	84 8d       	ldd	r24, Z+28	; 0x1c
    29ce:	88 23       	and	r24, r24
    29d0:	99 f4       	brne	.+38     	; 0x29f8 <prvCopyDataToQueue+0x58>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    29d2:	eb 81       	ldd	r30, Y+3	; 0x03
    29d4:	fc 81       	ldd	r31, Y+4	; 0x04
    29d6:	80 81       	ld	r24, Z
    29d8:	91 81       	ldd	r25, Z+1	; 0x01
    29da:	00 97       	sbiw	r24, 0x00	; 0
    29dc:	09 f0       	breq	.+2      	; 0x29e0 <prvCopyDataToQueue+0x40>
    29de:	89 c0       	rjmp	.+274    	; 0x2af2 <prvCopyDataToQueue+0x152>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    29e0:	eb 81       	ldd	r30, Y+3	; 0x03
    29e2:	fc 81       	ldd	r31, Y+4	; 0x04
    29e4:	84 81       	ldd	r24, Z+4	; 0x04
    29e6:	95 81       	ldd	r25, Z+5	; 0x05
    29e8:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <xTaskPriorityDisinherit>
    29ec:	8a 83       	std	Y+2, r24	; 0x02
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    29ee:	eb 81       	ldd	r30, Y+3	; 0x03
    29f0:	fc 81       	ldd	r31, Y+4	; 0x04
    29f2:	15 82       	std	Z+5, r1	; 0x05
    29f4:	14 82       	std	Z+4, r1	; 0x04
    29f6:	7d c0       	rjmp	.+250    	; 0x2af2 <prvCopyDataToQueue+0x152>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    29f8:	8f 81       	ldd	r24, Y+7	; 0x07
    29fa:	88 23       	and	r24, r24
    29fc:	99 f5       	brne	.+102    	; 0x2a64 <prvCopyDataToQueue+0xc4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    29fe:	eb 81       	ldd	r30, Y+3	; 0x03
    2a00:	fc 81       	ldd	r31, Y+4	; 0x04
    2a02:	62 81       	ldd	r22, Z+2	; 0x02
    2a04:	73 81       	ldd	r23, Z+3	; 0x03
    2a06:	eb 81       	ldd	r30, Y+3	; 0x03
    2a08:	fc 81       	ldd	r31, Y+4	; 0x04
    2a0a:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a0c:	48 2f       	mov	r20, r24
    2a0e:	50 e0       	ldi	r21, 0x00	; 0
    2a10:	2d 81       	ldd	r18, Y+5	; 0x05
    2a12:	3e 81       	ldd	r19, Y+6	; 0x06
    2a14:	cb 01       	movw	r24, r22
    2a16:	b9 01       	movw	r22, r18
    2a18:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2a1c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a1e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a20:	22 81       	ldd	r18, Z+2	; 0x02
    2a22:	33 81       	ldd	r19, Z+3	; 0x03
    2a24:	eb 81       	ldd	r30, Y+3	; 0x03
    2a26:	fc 81       	ldd	r31, Y+4	; 0x04
    2a28:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a2a:	88 2f       	mov	r24, r24
    2a2c:	90 e0       	ldi	r25, 0x00	; 0
    2a2e:	82 0f       	add	r24, r18
    2a30:	93 1f       	adc	r25, r19
    2a32:	eb 81       	ldd	r30, Y+3	; 0x03
    2a34:	fc 81       	ldd	r31, Y+4	; 0x04
    2a36:	93 83       	std	Z+3, r25	; 0x03
    2a38:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2a3a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a3c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a3e:	22 81       	ldd	r18, Z+2	; 0x02
    2a40:	33 81       	ldd	r19, Z+3	; 0x03
    2a42:	eb 81       	ldd	r30, Y+3	; 0x03
    2a44:	fc 81       	ldd	r31, Y+4	; 0x04
    2a46:	84 81       	ldd	r24, Z+4	; 0x04
    2a48:	95 81       	ldd	r25, Z+5	; 0x05
    2a4a:	28 17       	cp	r18, r24
    2a4c:	39 07       	cpc	r19, r25
    2a4e:	08 f4       	brcc	.+2      	; 0x2a52 <prvCopyDataToQueue+0xb2>
    2a50:	50 c0       	rjmp	.+160    	; 0x2af2 <prvCopyDataToQueue+0x152>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2a52:	eb 81       	ldd	r30, Y+3	; 0x03
    2a54:	fc 81       	ldd	r31, Y+4	; 0x04
    2a56:	80 81       	ld	r24, Z
    2a58:	91 81       	ldd	r25, Z+1	; 0x01
    2a5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a5e:	93 83       	std	Z+3, r25	; 0x03
    2a60:	82 83       	std	Z+2, r24	; 0x02
    2a62:	47 c0       	rjmp	.+142    	; 0x2af2 <prvCopyDataToQueue+0x152>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2a64:	eb 81       	ldd	r30, Y+3	; 0x03
    2a66:	fc 81       	ldd	r31, Y+4	; 0x04
    2a68:	66 81       	ldd	r22, Z+6	; 0x06
    2a6a:	77 81       	ldd	r23, Z+7	; 0x07
    2a6c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a6e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a70:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a72:	48 2f       	mov	r20, r24
    2a74:	50 e0       	ldi	r21, 0x00	; 0
    2a76:	2d 81       	ldd	r18, Y+5	; 0x05
    2a78:	3e 81       	ldd	r19, Y+6	; 0x06
    2a7a:	cb 01       	movw	r24, r22
    2a7c:	b9 01       	movw	r22, r18
    2a7e:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2a82:	eb 81       	ldd	r30, Y+3	; 0x03
    2a84:	fc 81       	ldd	r31, Y+4	; 0x04
    2a86:	26 81       	ldd	r18, Z+6	; 0x06
    2a88:	37 81       	ldd	r19, Z+7	; 0x07
    2a8a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a8c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a8e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a90:	88 2f       	mov	r24, r24
    2a92:	90 e0       	ldi	r25, 0x00	; 0
    2a94:	90 95       	com	r25
    2a96:	81 95       	neg	r24
    2a98:	9f 4f       	sbci	r25, 0xFF	; 255
    2a9a:	82 0f       	add	r24, r18
    2a9c:	93 1f       	adc	r25, r19
    2a9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2aa0:	fc 81       	ldd	r31, Y+4	; 0x04
    2aa2:	97 83       	std	Z+7, r25	; 0x07
    2aa4:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2aa6:	eb 81       	ldd	r30, Y+3	; 0x03
    2aa8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aaa:	26 81       	ldd	r18, Z+6	; 0x06
    2aac:	37 81       	ldd	r19, Z+7	; 0x07
    2aae:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ab2:	80 81       	ld	r24, Z
    2ab4:	91 81       	ldd	r25, Z+1	; 0x01
    2ab6:	28 17       	cp	r18, r24
    2ab8:	39 07       	cpc	r19, r25
    2aba:	90 f4       	brcc	.+36     	; 0x2ae0 <prvCopyDataToQueue+0x140>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2abc:	eb 81       	ldd	r30, Y+3	; 0x03
    2abe:	fc 81       	ldd	r31, Y+4	; 0x04
    2ac0:	24 81       	ldd	r18, Z+4	; 0x04
    2ac2:	35 81       	ldd	r19, Z+5	; 0x05
    2ac4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ac6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ac8:	84 8d       	ldd	r24, Z+28	; 0x1c
    2aca:	88 2f       	mov	r24, r24
    2acc:	90 e0       	ldi	r25, 0x00	; 0
    2ace:	90 95       	com	r25
    2ad0:	81 95       	neg	r24
    2ad2:	9f 4f       	sbci	r25, 0xFF	; 255
    2ad4:	82 0f       	add	r24, r18
    2ad6:	93 1f       	adc	r25, r19
    2ad8:	eb 81       	ldd	r30, Y+3	; 0x03
    2ada:	fc 81       	ldd	r31, Y+4	; 0x04
    2adc:	97 83       	std	Z+7, r25	; 0x07
    2ade:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2ae0:	8f 81       	ldd	r24, Y+7	; 0x07
    2ae2:	82 30       	cpi	r24, 0x02	; 2
    2ae4:	31 f4       	brne	.+12     	; 0x2af2 <prvCopyDataToQueue+0x152>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2ae6:	89 81       	ldd	r24, Y+1	; 0x01
    2ae8:	88 23       	and	r24, r24
    2aea:	19 f0       	breq	.+6      	; 0x2af2 <prvCopyDataToQueue+0x152>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    2aec:	89 81       	ldd	r24, Y+1	; 0x01
    2aee:	81 50       	subi	r24, 0x01	; 1
    2af0:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2af2:	89 81       	ldd	r24, Y+1	; 0x01
    2af4:	8f 5f       	subi	r24, 0xFF	; 255
    2af6:	eb 81       	ldd	r30, Y+3	; 0x03
    2af8:	fc 81       	ldd	r31, Y+4	; 0x04
    2afa:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2afc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2afe:	27 96       	adiw	r28, 0x07	; 7
    2b00:	0f b6       	in	r0, 0x3f	; 63
    2b02:	f8 94       	cli
    2b04:	de bf       	out	0x3e, r29	; 62
    2b06:	0f be       	out	0x3f, r0	; 63
    2b08:	cd bf       	out	0x3d, r28	; 61
    2b0a:	cf 91       	pop	r28
    2b0c:	df 91       	pop	r29
    2b0e:	08 95       	ret

00002b10 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2b10:	df 93       	push	r29
    2b12:	cf 93       	push	r28
    2b14:	00 d0       	rcall	.+0      	; 0x2b16 <prvCopyDataFromQueue+0x6>
    2b16:	00 d0       	rcall	.+0      	; 0x2b18 <prvCopyDataFromQueue+0x8>
    2b18:	cd b7       	in	r28, 0x3d	; 61
    2b1a:	de b7       	in	r29, 0x3e	; 62
    2b1c:	9a 83       	std	Y+2, r25	; 0x02
    2b1e:	89 83       	std	Y+1, r24	; 0x01
    2b20:	7c 83       	std	Y+4, r23	; 0x04
    2b22:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2b24:	e9 81       	ldd	r30, Y+1	; 0x01
    2b26:	fa 81       	ldd	r31, Y+2	; 0x02
    2b28:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b2a:	88 23       	and	r24, r24
    2b2c:	89 f1       	breq	.+98     	; 0x2b90 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2b2e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b30:	fa 81       	ldd	r31, Y+2	; 0x02
    2b32:	26 81       	ldd	r18, Z+6	; 0x06
    2b34:	37 81       	ldd	r19, Z+7	; 0x07
    2b36:	e9 81       	ldd	r30, Y+1	; 0x01
    2b38:	fa 81       	ldd	r31, Y+2	; 0x02
    2b3a:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b3c:	88 2f       	mov	r24, r24
    2b3e:	90 e0       	ldi	r25, 0x00	; 0
    2b40:	82 0f       	add	r24, r18
    2b42:	93 1f       	adc	r25, r19
    2b44:	e9 81       	ldd	r30, Y+1	; 0x01
    2b46:	fa 81       	ldd	r31, Y+2	; 0x02
    2b48:	97 83       	std	Z+7, r25	; 0x07
    2b4a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2b4c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b4e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b50:	26 81       	ldd	r18, Z+6	; 0x06
    2b52:	37 81       	ldd	r19, Z+7	; 0x07
    2b54:	e9 81       	ldd	r30, Y+1	; 0x01
    2b56:	fa 81       	ldd	r31, Y+2	; 0x02
    2b58:	84 81       	ldd	r24, Z+4	; 0x04
    2b5a:	95 81       	ldd	r25, Z+5	; 0x05
    2b5c:	28 17       	cp	r18, r24
    2b5e:	39 07       	cpc	r19, r25
    2b60:	40 f0       	brcs	.+16     	; 0x2b72 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2b62:	e9 81       	ldd	r30, Y+1	; 0x01
    2b64:	fa 81       	ldd	r31, Y+2	; 0x02
    2b66:	80 81       	ld	r24, Z
    2b68:	91 81       	ldd	r25, Z+1	; 0x01
    2b6a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b6c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b6e:	97 83       	std	Z+7, r25	; 0x07
    2b70:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2b72:	e9 81       	ldd	r30, Y+1	; 0x01
    2b74:	fa 81       	ldd	r31, Y+2	; 0x02
    2b76:	46 81       	ldd	r20, Z+6	; 0x06
    2b78:	57 81       	ldd	r21, Z+7	; 0x07
    2b7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b7e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b80:	28 2f       	mov	r18, r24
    2b82:	30 e0       	ldi	r19, 0x00	; 0
    2b84:	8b 81       	ldd	r24, Y+3	; 0x03
    2b86:	9c 81       	ldd	r25, Y+4	; 0x04
    2b88:	ba 01       	movw	r22, r20
    2b8a:	a9 01       	movw	r20, r18
    2b8c:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <memcpy>
	}
}
    2b90:	0f 90       	pop	r0
    2b92:	0f 90       	pop	r0
    2b94:	0f 90       	pop	r0
    2b96:	0f 90       	pop	r0
    2b98:	cf 91       	pop	r28
    2b9a:	df 91       	pop	r29
    2b9c:	08 95       	ret

00002b9e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2b9e:	df 93       	push	r29
    2ba0:	cf 93       	push	r28
    2ba2:	00 d0       	rcall	.+0      	; 0x2ba4 <prvUnlockQueue+0x6>
    2ba4:	00 d0       	rcall	.+0      	; 0x2ba6 <prvUnlockQueue+0x8>
    2ba6:	cd b7       	in	r28, 0x3d	; 61
    2ba8:	de b7       	in	r29, 0x3e	; 62
    2baa:	9c 83       	std	Y+4, r25	; 0x04
    2bac:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2bae:	0f b6       	in	r0, 0x3f	; 63
    2bb0:	f8 94       	cli
    2bb2:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2bb4:	eb 81       	ldd	r30, Y+3	; 0x03
    2bb6:	fc 81       	ldd	r31, Y+4	; 0x04
    2bb8:	86 8d       	ldd	r24, Z+30	; 0x1e
    2bba:	8a 83       	std	Y+2, r24	; 0x02
    2bbc:	11 c0       	rjmp	.+34     	; 0x2be0 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2bbe:	eb 81       	ldd	r30, Y+3	; 0x03
    2bc0:	fc 81       	ldd	r31, Y+4	; 0x04
    2bc2:	81 89       	ldd	r24, Z+17	; 0x11
    2bc4:	88 23       	and	r24, r24
    2bc6:	79 f0       	breq	.+30     	; 0x2be6 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2bc8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bca:	9c 81       	ldd	r25, Y+4	; 0x04
    2bcc:	41 96       	adiw	r24, 0x11	; 17
    2bce:	0e 94 c6 24 	call	0x498c	; 0x498c <xTaskRemoveFromEventList>
    2bd2:	88 23       	and	r24, r24
    2bd4:	11 f0       	breq	.+4      	; 0x2bda <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2bd6:	0e 94 32 26 	call	0x4c64	; 0x4c64 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    2bda:	8a 81       	ldd	r24, Y+2	; 0x02
    2bdc:	81 50       	subi	r24, 0x01	; 1
    2bde:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2be0:	8a 81       	ldd	r24, Y+2	; 0x02
    2be2:	18 16       	cp	r1, r24
    2be4:	64 f3       	brlt	.-40     	; 0x2bbe <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2be6:	eb 81       	ldd	r30, Y+3	; 0x03
    2be8:	fc 81       	ldd	r31, Y+4	; 0x04
    2bea:	8f ef       	ldi	r24, 0xFF	; 255
    2bec:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2bee:	0f 90       	pop	r0
    2bf0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2bf2:	0f b6       	in	r0, 0x3f	; 63
    2bf4:	f8 94       	cli
    2bf6:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    2bf8:	eb 81       	ldd	r30, Y+3	; 0x03
    2bfa:	fc 81       	ldd	r31, Y+4	; 0x04
    2bfc:	85 8d       	ldd	r24, Z+29	; 0x1d
    2bfe:	89 83       	std	Y+1, r24	; 0x01
    2c00:	11 c0       	rjmp	.+34     	; 0x2c24 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2c02:	eb 81       	ldd	r30, Y+3	; 0x03
    2c04:	fc 81       	ldd	r31, Y+4	; 0x04
    2c06:	80 85       	ldd	r24, Z+8	; 0x08
    2c08:	88 23       	and	r24, r24
    2c0a:	79 f0       	breq	.+30     	; 0x2c2a <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2c0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c10:	08 96       	adiw	r24, 0x08	; 8
    2c12:	0e 94 c6 24 	call	0x498c	; 0x498c <xTaskRemoveFromEventList>
    2c16:	88 23       	and	r24, r24
    2c18:	11 f0       	breq	.+4      	; 0x2c1e <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    2c1a:	0e 94 32 26 	call	0x4c64	; 0x4c64 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2c1e:	89 81       	ldd	r24, Y+1	; 0x01
    2c20:	81 50       	subi	r24, 0x01	; 1
    2c22:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2c24:	89 81       	ldd	r24, Y+1	; 0x01
    2c26:	18 16       	cp	r1, r24
    2c28:	64 f3       	brlt	.-40     	; 0x2c02 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2c2a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c2c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c2e:	8f ef       	ldi	r24, 0xFF	; 255
    2c30:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2c32:	0f 90       	pop	r0
    2c34:	0f be       	out	0x3f, r0	; 63
}
    2c36:	0f 90       	pop	r0
    2c38:	0f 90       	pop	r0
    2c3a:	0f 90       	pop	r0
    2c3c:	0f 90       	pop	r0
    2c3e:	cf 91       	pop	r28
    2c40:	df 91       	pop	r29
    2c42:	08 95       	ret

00002c44 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2c44:	df 93       	push	r29
    2c46:	cf 93       	push	r28
    2c48:	00 d0       	rcall	.+0      	; 0x2c4a <prvIsQueueEmpty+0x6>
    2c4a:	0f 92       	push	r0
    2c4c:	cd b7       	in	r28, 0x3d	; 61
    2c4e:	de b7       	in	r29, 0x3e	; 62
    2c50:	9b 83       	std	Y+3, r25	; 0x03
    2c52:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2c54:	0f b6       	in	r0, 0x3f	; 63
    2c56:	f8 94       	cli
    2c58:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2c5a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c5c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c5e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c60:	88 23       	and	r24, r24
    2c62:	19 f4       	brne	.+6      	; 0x2c6a <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2c64:	81 e0       	ldi	r24, 0x01	; 1
    2c66:	89 83       	std	Y+1, r24	; 0x01
    2c68:	01 c0       	rjmp	.+2      	; 0x2c6c <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2c6a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2c6c:	0f 90       	pop	r0
    2c6e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2c70:	89 81       	ldd	r24, Y+1	; 0x01
}
    2c72:	0f 90       	pop	r0
    2c74:	0f 90       	pop	r0
    2c76:	0f 90       	pop	r0
    2c78:	cf 91       	pop	r28
    2c7a:	df 91       	pop	r29
    2c7c:	08 95       	ret

00002c7e <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2c7e:	df 93       	push	r29
    2c80:	cf 93       	push	r28
    2c82:	00 d0       	rcall	.+0      	; 0x2c84 <xQueueIsQueueEmptyFromISR+0x6>
    2c84:	00 d0       	rcall	.+0      	; 0x2c86 <xQueueIsQueueEmptyFromISR+0x8>
    2c86:	0f 92       	push	r0
    2c88:	cd b7       	in	r28, 0x3d	; 61
    2c8a:	de b7       	in	r29, 0x3e	; 62
    2c8c:	9d 83       	std	Y+5, r25	; 0x05
    2c8e:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2c90:	8c 81       	ldd	r24, Y+4	; 0x04
    2c92:	9d 81       	ldd	r25, Y+5	; 0x05
    2c94:	9a 83       	std	Y+2, r25	; 0x02
    2c96:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2c98:	e9 81       	ldd	r30, Y+1	; 0x01
    2c9a:	fa 81       	ldd	r31, Y+2	; 0x02
    2c9c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c9e:	88 23       	and	r24, r24
    2ca0:	19 f4       	brne	.+6      	; 0x2ca8 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2ca2:	81 e0       	ldi	r24, 0x01	; 1
    2ca4:	8b 83       	std	Y+3, r24	; 0x03
    2ca6:	01 c0       	rjmp	.+2      	; 0x2caa <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    2ca8:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2caa:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2cac:	0f 90       	pop	r0
    2cae:	0f 90       	pop	r0
    2cb0:	0f 90       	pop	r0
    2cb2:	0f 90       	pop	r0
    2cb4:	0f 90       	pop	r0
    2cb6:	cf 91       	pop	r28
    2cb8:	df 91       	pop	r29
    2cba:	08 95       	ret

00002cbc <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2cbc:	df 93       	push	r29
    2cbe:	cf 93       	push	r28
    2cc0:	00 d0       	rcall	.+0      	; 0x2cc2 <prvIsQueueFull+0x6>
    2cc2:	0f 92       	push	r0
    2cc4:	cd b7       	in	r28, 0x3d	; 61
    2cc6:	de b7       	in	r29, 0x3e	; 62
    2cc8:	9b 83       	std	Y+3, r25	; 0x03
    2cca:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2ccc:	0f b6       	in	r0, 0x3f	; 63
    2cce:	f8 94       	cli
    2cd0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2cd2:	ea 81       	ldd	r30, Y+2	; 0x02
    2cd4:	fb 81       	ldd	r31, Y+3	; 0x03
    2cd6:	92 8d       	ldd	r25, Z+26	; 0x1a
    2cd8:	ea 81       	ldd	r30, Y+2	; 0x02
    2cda:	fb 81       	ldd	r31, Y+3	; 0x03
    2cdc:	83 8d       	ldd	r24, Z+27	; 0x1b
    2cde:	98 17       	cp	r25, r24
    2ce0:	19 f4       	brne	.+6      	; 0x2ce8 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2ce2:	81 e0       	ldi	r24, 0x01	; 1
    2ce4:	89 83       	std	Y+1, r24	; 0x01
    2ce6:	01 c0       	rjmp	.+2      	; 0x2cea <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2ce8:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2cea:	0f 90       	pop	r0
    2cec:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2cee:	89 81       	ldd	r24, Y+1	; 0x01
}
    2cf0:	0f 90       	pop	r0
    2cf2:	0f 90       	pop	r0
    2cf4:	0f 90       	pop	r0
    2cf6:	cf 91       	pop	r28
    2cf8:	df 91       	pop	r29
    2cfa:	08 95       	ret

00002cfc <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2cfc:	df 93       	push	r29
    2cfe:	cf 93       	push	r28
    2d00:	00 d0       	rcall	.+0      	; 0x2d02 <xQueueIsQueueFullFromISR+0x6>
    2d02:	00 d0       	rcall	.+0      	; 0x2d04 <xQueueIsQueueFullFromISR+0x8>
    2d04:	0f 92       	push	r0
    2d06:	cd b7       	in	r28, 0x3d	; 61
    2d08:	de b7       	in	r29, 0x3e	; 62
    2d0a:	9d 83       	std	Y+5, r25	; 0x05
    2d0c:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2d0e:	8c 81       	ldd	r24, Y+4	; 0x04
    2d10:	9d 81       	ldd	r25, Y+5	; 0x05
    2d12:	9a 83       	std	Y+2, r25	; 0x02
    2d14:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2d16:	e9 81       	ldd	r30, Y+1	; 0x01
    2d18:	fa 81       	ldd	r31, Y+2	; 0x02
    2d1a:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d1c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d1e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d20:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d22:	98 17       	cp	r25, r24
    2d24:	19 f4       	brne	.+6      	; 0x2d2c <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2d26:	81 e0       	ldi	r24, 0x01	; 1
    2d28:	8b 83       	std	Y+3, r24	; 0x03
    2d2a:	01 c0       	rjmp	.+2      	; 0x2d2e <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2d2c:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2d2e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2d30:	0f 90       	pop	r0
    2d32:	0f 90       	pop	r0
    2d34:	0f 90       	pop	r0
    2d36:	0f 90       	pop	r0
    2d38:	0f 90       	pop	r0
    2d3a:	cf 91       	pop	r28
    2d3c:	df 91       	pop	r29
    2d3e:	08 95       	ret

00002d40 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    2d40:	0f 93       	push	r16
    2d42:	df 93       	push	r29
    2d44:	cf 93       	push	r28
    2d46:	cd b7       	in	r28, 0x3d	; 61
    2d48:	de b7       	in	r29, 0x3e	; 62
    2d4a:	28 97       	sbiw	r28, 0x08	; 8
    2d4c:	0f b6       	in	r0, 0x3f	; 63
    2d4e:	f8 94       	cli
    2d50:	de bf       	out	0x3e, r29	; 62
    2d52:	0f be       	out	0x3f, r0	; 63
    2d54:	cd bf       	out	0x3d, r28	; 61
    2d56:	9d 83       	std	Y+5, r25	; 0x05
    2d58:	8c 83       	std	Y+4, r24	; 0x04
    2d5a:	7f 83       	std	Y+7, r23	; 0x07
    2d5c:	6e 83       	std	Y+6, r22	; 0x06
    2d5e:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    2d60:	88 85       	ldd	r24, Y+8	; 0x08
    2d62:	81 30       	cpi	r24, 0x01	; 1
    2d64:	19 f4       	brne	.+6      	; 0x2d6c <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    2d66:	81 e0       	ldi	r24, 0x01	; 1
    2d68:	89 83       	std	Y+1, r24	; 0x01
    2d6a:	01 c0       	rjmp	.+2      	; 0x2d6e <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    2d6c:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    2d6e:	8e 81       	ldd	r24, Y+6	; 0x06
    2d70:	9f 81       	ldd	r25, Y+7	; 0x07
    2d72:	00 97       	sbiw	r24, 0x00	; 0
    2d74:	21 f4       	brne	.+8      	; 0x2d7e <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    2d76:	81 e0       	ldi	r24, 0x01	; 1
    2d78:	90 e0       	ldi	r25, 0x00	; 0
    2d7a:	9f 83       	std	Y+7, r25	; 0x07
    2d7c:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    2d7e:	8c 81       	ldd	r24, Y+4	; 0x04
    2d80:	9d 81       	ldd	r25, Y+5	; 0x05
    2d82:	01 96       	adiw	r24, 0x01	; 1
    2d84:	9d 83       	std	Y+5, r25	; 0x05
    2d86:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2d88:	8c 81       	ldd	r24, Y+4	; 0x04
    2d8a:	9d 81       	ldd	r25, Y+5	; 0x05
    2d8c:	0f 96       	adiw	r24, 0x0f	; 15
    2d8e:	0e 94 a8 08 	call	0x1150	; 0x1150 <pvPortMalloc>
    2d92:	9b 83       	std	Y+3, r25	; 0x03
    2d94:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    2d96:	8a 81       	ldd	r24, Y+2	; 0x02
    2d98:	9b 81       	ldd	r25, Y+3	; 0x03
    2d9a:	00 97       	sbiw	r24, 0x00	; 0
    2d9c:	89 f0       	breq	.+34     	; 0x2dc0 <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2d9e:	6a 81       	ldd	r22, Y+2	; 0x02
    2da0:	7b 81       	ldd	r23, Y+3	; 0x03
    2da2:	8a 81       	ldd	r24, Y+2	; 0x02
    2da4:	9b 81       	ldd	r25, Y+3	; 0x03
    2da6:	9c 01       	movw	r18, r24
    2da8:	21 5f       	subi	r18, 0xF1	; 241
    2daa:	3f 4f       	sbci	r19, 0xFF	; 255
    2dac:	4c 81       	ldd	r20, Y+4	; 0x04
    2dae:	5d 81       	ldd	r21, Y+5	; 0x05
    2db0:	ee 81       	ldd	r30, Y+6	; 0x06
    2db2:	ff 81       	ldd	r31, Y+7	; 0x07
    2db4:	cb 01       	movw	r24, r22
    2db6:	b9 01       	movw	r22, r18
    2db8:	9f 01       	movw	r18, r30
    2dba:	09 81       	ldd	r16, Y+1	; 0x01
    2dbc:	0e 94 f8 1d 	call	0x3bf0	; 0x3bf0 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    2dc0:	8a 81       	ldd	r24, Y+2	; 0x02
    2dc2:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    2dc4:	28 96       	adiw	r28, 0x08	; 8
    2dc6:	0f b6       	in	r0, 0x3f	; 63
    2dc8:	f8 94       	cli
    2dca:	de bf       	out	0x3e, r29	; 62
    2dcc:	0f be       	out	0x3f, r0	; 63
    2dce:	cd bf       	out	0x3d, r28	; 61
    2dd0:	cf 91       	pop	r28
    2dd2:	df 91       	pop	r29
    2dd4:	0f 91       	pop	r16
    2dd6:	08 95       	ret

00002dd8 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2dd8:	df 93       	push	r29
    2dda:	cf 93       	push	r28
    2ddc:	00 d0       	rcall	.+0      	; 0x2dde <vStreamBufferDelete+0x6>
    2dde:	00 d0       	rcall	.+0      	; 0x2de0 <vStreamBufferDelete+0x8>
    2de0:	cd b7       	in	r28, 0x3d	; 61
    2de2:	de b7       	in	r29, 0x3e	; 62
    2de4:	9c 83       	std	Y+4, r25	; 0x04
    2de6:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    2de8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dea:	9c 81       	ldd	r25, Y+4	; 0x04
    2dec:	9a 83       	std	Y+2, r25	; 0x02
    2dee:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2df0:	e9 81       	ldd	r30, Y+1	; 0x01
    2df2:	fa 81       	ldd	r31, Y+2	; 0x02
    2df4:	86 85       	ldd	r24, Z+14	; 0x0e
    2df6:	88 2f       	mov	r24, r24
    2df8:	90 e0       	ldi	r25, 0x00	; 0
    2dfa:	82 70       	andi	r24, 0x02	; 2
    2dfc:	90 70       	andi	r25, 0x00	; 0
    2dfe:	00 97       	sbiw	r24, 0x00	; 0
    2e00:	29 f4       	brne	.+10     	; 0x2e0c <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2e02:	89 81       	ldd	r24, Y+1	; 0x01
    2e04:	9a 81       	ldd	r25, Y+2	; 0x02
    2e06:	0e 94 fe 08 	call	0x11fc	; 0x11fc <vPortFree>
    2e0a:	08 c0       	rjmp	.+16     	; 0x2e1c <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2e0c:	89 81       	ldd	r24, Y+1	; 0x01
    2e0e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e10:	60 e0       	ldi	r22, 0x00	; 0
    2e12:	70 e0       	ldi	r23, 0x00	; 0
    2e14:	4f e0       	ldi	r20, 0x0F	; 15
    2e16:	50 e0       	ldi	r21, 0x00	; 0
    2e18:	0e 94 26 2d 	call	0x5a4c	; 0x5a4c <memset>
	}
}
    2e1c:	0f 90       	pop	r0
    2e1e:	0f 90       	pop	r0
    2e20:	0f 90       	pop	r0
    2e22:	0f 90       	pop	r0
    2e24:	cf 91       	pop	r28
    2e26:	df 91       	pop	r29
    2e28:	08 95       	ret

00002e2a <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2e2a:	0f 93       	push	r16
    2e2c:	df 93       	push	r29
    2e2e:	cf 93       	push	r28
    2e30:	00 d0       	rcall	.+0      	; 0x2e32 <xStreamBufferReset+0x8>
    2e32:	00 d0       	rcall	.+0      	; 0x2e34 <xStreamBufferReset+0xa>
    2e34:	0f 92       	push	r0
    2e36:	cd b7       	in	r28, 0x3d	; 61
    2e38:	de b7       	in	r29, 0x3e	; 62
    2e3a:	9d 83       	std	Y+5, r25	; 0x05
    2e3c:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2e3e:	8c 81       	ldd	r24, Y+4	; 0x04
    2e40:	9d 81       	ldd	r25, Y+5	; 0x05
    2e42:	9b 83       	std	Y+3, r25	; 0x03
    2e44:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    2e46:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    2e48:	0f b6       	in	r0, 0x3f	; 63
    2e4a:	f8 94       	cli
    2e4c:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    2e4e:	ea 81       	ldd	r30, Y+2	; 0x02
    2e50:	fb 81       	ldd	r31, Y+3	; 0x03
    2e52:	80 85       	ldd	r24, Z+8	; 0x08
    2e54:	91 85       	ldd	r25, Z+9	; 0x09
    2e56:	00 97       	sbiw	r24, 0x00	; 0
    2e58:	f1 f4       	brne	.+60     	; 0x2e96 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    2e5a:	ea 81       	ldd	r30, Y+2	; 0x02
    2e5c:	fb 81       	ldd	r31, Y+3	; 0x03
    2e5e:	82 85       	ldd	r24, Z+10	; 0x0a
    2e60:	93 85       	ldd	r25, Z+11	; 0x0b
    2e62:	00 97       	sbiw	r24, 0x00	; 0
    2e64:	c1 f4       	brne	.+48     	; 0x2e96 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2e66:	ea 81       	ldd	r30, Y+2	; 0x02
    2e68:	fb 81       	ldd	r31, Y+3	; 0x03
    2e6a:	24 85       	ldd	r18, Z+12	; 0x0c
    2e6c:	35 85       	ldd	r19, Z+13	; 0x0d
    2e6e:	ea 81       	ldd	r30, Y+2	; 0x02
    2e70:	fb 81       	ldd	r31, Y+3	; 0x03
    2e72:	44 81       	ldd	r20, Z+4	; 0x04
    2e74:	55 81       	ldd	r21, Z+5	; 0x05
    2e76:	ea 81       	ldd	r30, Y+2	; 0x02
    2e78:	fb 81       	ldd	r31, Y+3	; 0x03
    2e7a:	a6 81       	ldd	r26, Z+6	; 0x06
    2e7c:	b7 81       	ldd	r27, Z+7	; 0x07
    2e7e:	ea 81       	ldd	r30, Y+2	; 0x02
    2e80:	fb 81       	ldd	r31, Y+3	; 0x03
    2e82:	e6 85       	ldd	r30, Z+14	; 0x0e
    2e84:	8a 81       	ldd	r24, Y+2	; 0x02
    2e86:	9b 81       	ldd	r25, Y+3	; 0x03
    2e88:	b9 01       	movw	r22, r18
    2e8a:	9d 01       	movw	r18, r26
    2e8c:	0e 2f       	mov	r16, r30
    2e8e:	0e 94 f8 1d 	call	0x3bf0	; 0x3bf0 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    2e92:	81 e0       	ldi	r24, 0x01	; 1
    2e94:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    2e96:	0f 90       	pop	r0
    2e98:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2e9a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e9c:	0f 90       	pop	r0
    2e9e:	0f 90       	pop	r0
    2ea0:	0f 90       	pop	r0
    2ea2:	0f 90       	pop	r0
    2ea4:	0f 90       	pop	r0
    2ea6:	cf 91       	pop	r28
    2ea8:	df 91       	pop	r29
    2eaa:	0f 91       	pop	r16
    2eac:	08 95       	ret

00002eae <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    2eae:	df 93       	push	r29
    2eb0:	cf 93       	push	r28
    2eb2:	cd b7       	in	r28, 0x3d	; 61
    2eb4:	de b7       	in	r29, 0x3e	; 62
    2eb6:	27 97       	sbiw	r28, 0x07	; 7
    2eb8:	0f b6       	in	r0, 0x3f	; 63
    2eba:	f8 94       	cli
    2ebc:	de bf       	out	0x3e, r29	; 62
    2ebe:	0f be       	out	0x3f, r0	; 63
    2ec0:	cd bf       	out	0x3d, r28	; 61
    2ec2:	9d 83       	std	Y+5, r25	; 0x05
    2ec4:	8c 83       	std	Y+4, r24	; 0x04
    2ec6:	7f 83       	std	Y+7, r23	; 0x07
    2ec8:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2eca:	8c 81       	ldd	r24, Y+4	; 0x04
    2ecc:	9d 81       	ldd	r25, Y+5	; 0x05
    2ece:	9b 83       	std	Y+3, r25	; 0x03
    2ed0:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    2ed2:	8e 81       	ldd	r24, Y+6	; 0x06
    2ed4:	9f 81       	ldd	r25, Y+7	; 0x07
    2ed6:	00 97       	sbiw	r24, 0x00	; 0
    2ed8:	21 f4       	brne	.+8      	; 0x2ee2 <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    2eda:	81 e0       	ldi	r24, 0x01	; 1
    2edc:	90 e0       	ldi	r25, 0x00	; 0
    2ede:	9f 83       	std	Y+7, r25	; 0x07
    2ee0:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    2ee2:	ea 81       	ldd	r30, Y+2	; 0x02
    2ee4:	fb 81       	ldd	r31, Y+3	; 0x03
    2ee6:	24 81       	ldd	r18, Z+4	; 0x04
    2ee8:	35 81       	ldd	r19, Z+5	; 0x05
    2eea:	8e 81       	ldd	r24, Y+6	; 0x06
    2eec:	9f 81       	ldd	r25, Y+7	; 0x07
    2eee:	28 17       	cp	r18, r24
    2ef0:	39 07       	cpc	r19, r25
    2ef2:	48 f0       	brcs	.+18     	; 0x2f06 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2ef4:	ea 81       	ldd	r30, Y+2	; 0x02
    2ef6:	fb 81       	ldd	r31, Y+3	; 0x03
    2ef8:	8e 81       	ldd	r24, Y+6	; 0x06
    2efa:	9f 81       	ldd	r25, Y+7	; 0x07
    2efc:	97 83       	std	Z+7, r25	; 0x07
    2efe:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    2f00:	81 e0       	ldi	r24, 0x01	; 1
    2f02:	89 83       	std	Y+1, r24	; 0x01
    2f04:	01 c0       	rjmp	.+2      	; 0x2f08 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    2f06:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2f08:	89 81       	ldd	r24, Y+1	; 0x01
}
    2f0a:	27 96       	adiw	r28, 0x07	; 7
    2f0c:	0f b6       	in	r0, 0x3f	; 63
    2f0e:	f8 94       	cli
    2f10:	de bf       	out	0x3e, r29	; 62
    2f12:	0f be       	out	0x3f, r0	; 63
    2f14:	cd bf       	out	0x3d, r28	; 61
    2f16:	cf 91       	pop	r28
    2f18:	df 91       	pop	r29
    2f1a:	08 95       	ret

00002f1c <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2f1c:	df 93       	push	r29
    2f1e:	cf 93       	push	r28
    2f20:	00 d0       	rcall	.+0      	; 0x2f22 <xStreamBufferSpacesAvailable+0x6>
    2f22:	00 d0       	rcall	.+0      	; 0x2f24 <xStreamBufferSpacesAvailable+0x8>
    2f24:	00 d0       	rcall	.+0      	; 0x2f26 <xStreamBufferSpacesAvailable+0xa>
    2f26:	cd b7       	in	r28, 0x3d	; 61
    2f28:	de b7       	in	r29, 0x3e	; 62
    2f2a:	9e 83       	std	Y+6, r25	; 0x06
    2f2c:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2f2e:	8d 81       	ldd	r24, Y+5	; 0x05
    2f30:	9e 81       	ldd	r25, Y+6	; 0x06
    2f32:	9c 83       	std	Y+4, r25	; 0x04
    2f34:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2f36:	eb 81       	ldd	r30, Y+3	; 0x03
    2f38:	fc 81       	ldd	r31, Y+4	; 0x04
    2f3a:	24 81       	ldd	r18, Z+4	; 0x04
    2f3c:	35 81       	ldd	r19, Z+5	; 0x05
    2f3e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f40:	fc 81       	ldd	r31, Y+4	; 0x04
    2f42:	80 81       	ld	r24, Z
    2f44:	91 81       	ldd	r25, Z+1	; 0x01
    2f46:	82 0f       	add	r24, r18
    2f48:	93 1f       	adc	r25, r19
    2f4a:	9a 83       	std	Y+2, r25	; 0x02
    2f4c:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    2f4e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f50:	fc 81       	ldd	r31, Y+4	; 0x04
    2f52:	22 81       	ldd	r18, Z+2	; 0x02
    2f54:	33 81       	ldd	r19, Z+3	; 0x03
    2f56:	89 81       	ldd	r24, Y+1	; 0x01
    2f58:	9a 81       	ldd	r25, Y+2	; 0x02
    2f5a:	82 1b       	sub	r24, r18
    2f5c:	93 0b       	sbc	r25, r19
    2f5e:	9a 83       	std	Y+2, r25	; 0x02
    2f60:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    2f62:	89 81       	ldd	r24, Y+1	; 0x01
    2f64:	9a 81       	ldd	r25, Y+2	; 0x02
    2f66:	01 97       	sbiw	r24, 0x01	; 1
    2f68:	9a 83       	std	Y+2, r25	; 0x02
    2f6a:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    2f6c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f6e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f70:	24 81       	ldd	r18, Z+4	; 0x04
    2f72:	35 81       	ldd	r19, Z+5	; 0x05
    2f74:	89 81       	ldd	r24, Y+1	; 0x01
    2f76:	9a 81       	ldd	r25, Y+2	; 0x02
    2f78:	82 17       	cp	r24, r18
    2f7a:	93 07       	cpc	r25, r19
    2f7c:	50 f0       	brcs	.+20     	; 0x2f92 <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    2f7e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f80:	fc 81       	ldd	r31, Y+4	; 0x04
    2f82:	24 81       	ldd	r18, Z+4	; 0x04
    2f84:	35 81       	ldd	r19, Z+5	; 0x05
    2f86:	89 81       	ldd	r24, Y+1	; 0x01
    2f88:	9a 81       	ldd	r25, Y+2	; 0x02
    2f8a:	82 1b       	sub	r24, r18
    2f8c:	93 0b       	sbc	r25, r19
    2f8e:	9a 83       	std	Y+2, r25	; 0x02
    2f90:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    2f92:	89 81       	ldd	r24, Y+1	; 0x01
    2f94:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f96:	26 96       	adiw	r28, 0x06	; 6
    2f98:	0f b6       	in	r0, 0x3f	; 63
    2f9a:	f8 94       	cli
    2f9c:	de bf       	out	0x3e, r29	; 62
    2f9e:	0f be       	out	0x3f, r0	; 63
    2fa0:	cd bf       	out	0x3d, r28	; 61
    2fa2:	cf 91       	pop	r28
    2fa4:	df 91       	pop	r29
    2fa6:	08 95       	ret

00002fa8 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2fa8:	df 93       	push	r29
    2faa:	cf 93       	push	r28
    2fac:	00 d0       	rcall	.+0      	; 0x2fae <xStreamBufferBytesAvailable+0x6>
    2fae:	00 d0       	rcall	.+0      	; 0x2fb0 <xStreamBufferBytesAvailable+0x8>
    2fb0:	00 d0       	rcall	.+0      	; 0x2fb2 <xStreamBufferBytesAvailable+0xa>
    2fb2:	cd b7       	in	r28, 0x3d	; 61
    2fb4:	de b7       	in	r29, 0x3e	; 62
    2fb6:	9e 83       	std	Y+6, r25	; 0x06
    2fb8:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2fba:	8d 81       	ldd	r24, Y+5	; 0x05
    2fbc:	9e 81       	ldd	r25, Y+6	; 0x06
    2fbe:	9c 83       	std	Y+4, r25	; 0x04
    2fc0:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    2fc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc6:	0e 94 be 1d 	call	0x3b7c	; 0x3b7c <prvBytesInBuffer>
    2fca:	9a 83       	std	Y+2, r25	; 0x02
    2fcc:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    2fce:	89 81       	ldd	r24, Y+1	; 0x01
    2fd0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2fd2:	26 96       	adiw	r28, 0x06	; 6
    2fd4:	0f b6       	in	r0, 0x3f	; 63
    2fd6:	f8 94       	cli
    2fd8:	de bf       	out	0x3e, r29	; 62
    2fda:	0f be       	out	0x3f, r0	; 63
    2fdc:	cd bf       	out	0x3d, r28	; 61
    2fde:	cf 91       	pop	r28
    2fe0:	df 91       	pop	r29
    2fe2:	08 95       	ret

00002fe4 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    2fe4:	ef 92       	push	r14
    2fe6:	ff 92       	push	r15
    2fe8:	0f 93       	push	r16
    2fea:	1f 93       	push	r17
    2fec:	df 93       	push	r29
    2fee:	cf 93       	push	r28
    2ff0:	cd b7       	in	r28, 0x3d	; 61
    2ff2:	de b7       	in	r29, 0x3e	; 62
    2ff4:	63 97       	sbiw	r28, 0x13	; 19
    2ff6:	0f b6       	in	r0, 0x3f	; 63
    2ff8:	f8 94       	cli
    2ffa:	de bf       	out	0x3e, r29	; 62
    2ffc:	0f be       	out	0x3f, r0	; 63
    2ffe:	cd bf       	out	0x3d, r28	; 61
    3000:	9d 87       	std	Y+13, r25	; 0x0d
    3002:	8c 87       	std	Y+12, r24	; 0x0c
    3004:	7f 87       	std	Y+15, r23	; 0x0f
    3006:	6e 87       	std	Y+14, r22	; 0x0e
    3008:	59 8b       	std	Y+17, r21	; 0x11
    300a:	48 8b       	std	Y+16, r20	; 0x10
    300c:	3b 8b       	std	Y+19, r19	; 0x13
    300e:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3010:	8c 85       	ldd	r24, Y+12	; 0x0c
    3012:	9d 85       	ldd	r25, Y+13	; 0x0d
    3014:	98 87       	std	Y+8, r25	; 0x08
    3016:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    3018:	1c 82       	std	Y+4, r1	; 0x04
    301a:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    301c:	88 89       	ldd	r24, Y+16	; 0x10
    301e:	99 89       	ldd	r25, Y+17	; 0x11
    3020:	9a 83       	std	Y+2, r25	; 0x02
    3022:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3024:	ef 81       	ldd	r30, Y+7	; 0x07
    3026:	f8 85       	ldd	r31, Y+8	; 0x08
    3028:	86 85       	ldd	r24, Z+14	; 0x0e
    302a:	88 2f       	mov	r24, r24
    302c:	90 e0       	ldi	r25, 0x00	; 0
    302e:	81 70       	andi	r24, 0x01	; 1
    3030:	90 70       	andi	r25, 0x00	; 0
    3032:	88 23       	and	r24, r24
    3034:	29 f0       	breq	.+10     	; 0x3040 <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3036:	89 81       	ldd	r24, Y+1	; 0x01
    3038:	9a 81       	ldd	r25, Y+2	; 0x02
    303a:	02 96       	adiw	r24, 0x02	; 2
    303c:	9a 83       	std	Y+2, r25	; 0x02
    303e:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3040:	8a 89       	ldd	r24, Y+18	; 0x12
    3042:	9b 89       	ldd	r25, Y+19	; 0x13
    3044:	00 97       	sbiw	r24, 0x00	; 0
    3046:	09 f4       	brne	.+2      	; 0x304a <xStreamBufferSend+0x66>
    3048:	40 c0       	rjmp	.+128    	; 0x30ca <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    304a:	ce 01       	movw	r24, r28
    304c:	09 96       	adiw	r24, 0x09	; 9
    304e:	0e 94 8e 25 	call	0x4b1c	; 0x4b1c <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    3052:	0f b6       	in	r0, 0x3f	; 63
    3054:	f8 94       	cli
    3056:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3058:	8f 81       	ldd	r24, Y+7	; 0x07
    305a:	98 85       	ldd	r25, Y+8	; 0x08
    305c:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <xStreamBufferSpacesAvailable>
    3060:	9c 83       	std	Y+4, r25	; 0x04
    3062:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    3064:	2b 81       	ldd	r18, Y+3	; 0x03
    3066:	3c 81       	ldd	r19, Y+4	; 0x04
    3068:	89 81       	ldd	r24, Y+1	; 0x01
    306a:	9a 81       	ldd	r25, Y+2	; 0x02
    306c:	28 17       	cp	r18, r24
    306e:	39 07       	cpc	r19, r25
    3070:	50 f5       	brcc	.+84     	; 0x30c6 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    3072:	80 e0       	ldi	r24, 0x00	; 0
    3074:	90 e0       	ldi	r25, 0x00	; 0
    3076:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    307a:	0e 94 f7 26 	call	0x4dee	; 0x4dee <xTaskGetCurrentTaskHandle>
    307e:	ef 81       	ldd	r30, Y+7	; 0x07
    3080:	f8 85       	ldd	r31, Y+8	; 0x08
    3082:	93 87       	std	Z+11, r25	; 0x0b
    3084:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    3086:	0f 90       	pop	r0
    3088:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    308a:	ea 89       	ldd	r30, Y+18	; 0x12
    308c:	fb 89       	ldd	r31, Y+19	; 0x13
    308e:	60 e0       	ldi	r22, 0x00	; 0
    3090:	70 e0       	ldi	r23, 0x00	; 0
    3092:	80 e0       	ldi	r24, 0x00	; 0
    3094:	90 e0       	ldi	r25, 0x00	; 0
    3096:	20 e0       	ldi	r18, 0x00	; 0
    3098:	30 e0       	ldi	r19, 0x00	; 0
    309a:	40 e0       	ldi	r20, 0x00	; 0
    309c:	50 e0       	ldi	r21, 0x00	; 0
    309e:	00 e0       	ldi	r16, 0x00	; 0
    30a0:	10 e0       	ldi	r17, 0x00	; 0
    30a2:	7f 01       	movw	r14, r30
    30a4:	0e 94 64 29 	call	0x52c8	; 0x52c8 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    30a8:	ef 81       	ldd	r30, Y+7	; 0x07
    30aa:	f8 85       	ldd	r31, Y+8	; 0x08
    30ac:	13 86       	std	Z+11, r1	; 0x0b
    30ae:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    30b0:	ce 01       	movw	r24, r28
    30b2:	09 96       	adiw	r24, 0x09	; 9
    30b4:	9e 01       	movw	r18, r28
    30b6:	2e 5e       	subi	r18, 0xEE	; 238
    30b8:	3f 4f       	sbci	r19, 0xFF	; 255
    30ba:	b9 01       	movw	r22, r18
    30bc:	0e 94 c5 25 	call	0x4b8a	; 0x4b8a <xTaskCheckForTimeOut>
    30c0:	88 23       	and	r24, r24
    30c2:	39 f2       	breq	.-114    	; 0x3052 <xStreamBufferSend+0x6e>
    30c4:	02 c0       	rjmp	.+4      	; 0x30ca <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    30c6:	0f 90       	pop	r0
    30c8:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    30ca:	8b 81       	ldd	r24, Y+3	; 0x03
    30cc:	9c 81       	ldd	r25, Y+4	; 0x04
    30ce:	00 97       	sbiw	r24, 0x00	; 0
    30d0:	31 f4       	brne	.+12     	; 0x30de <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    30d2:	8f 81       	ldd	r24, Y+7	; 0x07
    30d4:	98 85       	ldd	r25, Y+8	; 0x08
    30d6:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <xStreamBufferSpacesAvailable>
    30da:	9c 83       	std	Y+4, r25	; 0x04
    30dc:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    30de:	8f 81       	ldd	r24, Y+7	; 0x07
    30e0:	98 85       	ldd	r25, Y+8	; 0x08
    30e2:	2e 85       	ldd	r18, Y+14	; 0x0e
    30e4:	3f 85       	ldd	r19, Y+15	; 0x0f
    30e6:	48 89       	ldd	r20, Y+16	; 0x10
    30e8:	59 89       	ldd	r21, Y+17	; 0x11
    30ea:	eb 81       	ldd	r30, Y+3	; 0x03
    30ec:	fc 81       	ldd	r31, Y+4	; 0x04
    30ee:	a9 81       	ldd	r26, Y+1	; 0x01
    30f0:	ba 81       	ldd	r27, Y+2	; 0x02
    30f2:	b9 01       	movw	r22, r18
    30f4:	9f 01       	movw	r18, r30
    30f6:	8d 01       	movw	r16, r26
    30f8:	0e 94 37 19 	call	0x326e	; 0x326e <prvWriteMessageToBuffer>
    30fc:	9e 83       	std	Y+6, r25	; 0x06
    30fe:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    3100:	8d 81       	ldd	r24, Y+5	; 0x05
    3102:	9e 81       	ldd	r25, Y+6	; 0x06
    3104:	00 97       	sbiw	r24, 0x00	; 0
    3106:	39 f1       	breq	.+78     	; 0x3156 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3108:	8f 81       	ldd	r24, Y+7	; 0x07
    310a:	98 85       	ldd	r25, Y+8	; 0x08
    310c:	0e 94 be 1d 	call	0x3b7c	; 0x3b7c <prvBytesInBuffer>
    3110:	9c 01       	movw	r18, r24
    3112:	ef 81       	ldd	r30, Y+7	; 0x07
    3114:	f8 85       	ldd	r31, Y+8	; 0x08
    3116:	86 81       	ldd	r24, Z+6	; 0x06
    3118:	97 81       	ldd	r25, Z+7	; 0x07
    311a:	28 17       	cp	r18, r24
    311c:	39 07       	cpc	r19, r25
    311e:	d8 f0       	brcs	.+54     	; 0x3156 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    3120:	0e 94 26 22 	call	0x444c	; 0x444c <vTaskSuspendAll>
    3124:	ef 81       	ldd	r30, Y+7	; 0x07
    3126:	f8 85       	ldd	r31, Y+8	; 0x08
    3128:	80 85       	ldd	r24, Z+8	; 0x08
    312a:	91 85       	ldd	r25, Z+9	; 0x09
    312c:	00 97       	sbiw	r24, 0x00	; 0
    312e:	89 f0       	breq	.+34     	; 0x3152 <xStreamBufferSend+0x16e>
    3130:	ef 81       	ldd	r30, Y+7	; 0x07
    3132:	f8 85       	ldd	r31, Y+8	; 0x08
    3134:	80 85       	ldd	r24, Z+8	; 0x08
    3136:	91 85       	ldd	r25, Z+9	; 0x09
    3138:	40 e0       	ldi	r20, 0x00	; 0
    313a:	50 e0       	ldi	r21, 0x00	; 0
    313c:	60 e0       	ldi	r22, 0x00	; 0
    313e:	70 e0       	ldi	r23, 0x00	; 0
    3140:	20 e0       	ldi	r18, 0x00	; 0
    3142:	00 e0       	ldi	r16, 0x00	; 0
    3144:	10 e0       	ldi	r17, 0x00	; 0
    3146:	0e 94 00 2a 	call	0x5400	; 0x5400 <xTaskGenericNotify>
    314a:	ef 81       	ldd	r30, Y+7	; 0x07
    314c:	f8 85       	ldd	r31, Y+8	; 0x08
    314e:	11 86       	std	Z+9, r1	; 0x09
    3150:	10 86       	std	Z+8, r1	; 0x08
    3152:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    3156:	8d 81       	ldd	r24, Y+5	; 0x05
    3158:	9e 81       	ldd	r25, Y+6	; 0x06
}
    315a:	63 96       	adiw	r28, 0x13	; 19
    315c:	0f b6       	in	r0, 0x3f	; 63
    315e:	f8 94       	cli
    3160:	de bf       	out	0x3e, r29	; 62
    3162:	0f be       	out	0x3f, r0	; 63
    3164:	cd bf       	out	0x3d, r28	; 61
    3166:	cf 91       	pop	r28
    3168:	df 91       	pop	r29
    316a:	1f 91       	pop	r17
    316c:	0f 91       	pop	r16
    316e:	ff 90       	pop	r15
    3170:	ef 90       	pop	r14
    3172:	08 95       	ret

00003174 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3174:	ef 92       	push	r14
    3176:	ff 92       	push	r15
    3178:	0f 93       	push	r16
    317a:	1f 93       	push	r17
    317c:	df 93       	push	r29
    317e:	cf 93       	push	r28
    3180:	cd b7       	in	r28, 0x3d	; 61
    3182:	de b7       	in	r29, 0x3e	; 62
    3184:	61 97       	sbiw	r28, 0x11	; 17
    3186:	0f b6       	in	r0, 0x3f	; 63
    3188:	f8 94       	cli
    318a:	de bf       	out	0x3e, r29	; 62
    318c:	0f be       	out	0x3f, r0	; 63
    318e:	cd bf       	out	0x3d, r28	; 61
    3190:	9b 87       	std	Y+11, r25	; 0x0b
    3192:	8a 87       	std	Y+10, r24	; 0x0a
    3194:	7d 87       	std	Y+13, r23	; 0x0d
    3196:	6c 87       	std	Y+12, r22	; 0x0c
    3198:	5f 87       	std	Y+15, r21	; 0x0f
    319a:	4e 87       	std	Y+14, r20	; 0x0e
    319c:	39 8b       	std	Y+17, r19	; 0x11
    319e:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    31a0:	8a 85       	ldd	r24, Y+10	; 0x0a
    31a2:	9b 85       	ldd	r25, Y+11	; 0x0b
    31a4:	99 87       	std	Y+9, r25	; 0x09
    31a6:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    31a8:	8e 85       	ldd	r24, Y+14	; 0x0e
    31aa:	9f 85       	ldd	r25, Y+15	; 0x0f
    31ac:	9b 83       	std	Y+3, r25	; 0x03
    31ae:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    31b0:	e8 85       	ldd	r30, Y+8	; 0x08
    31b2:	f9 85       	ldd	r31, Y+9	; 0x09
    31b4:	86 85       	ldd	r24, Z+14	; 0x0e
    31b6:	88 2f       	mov	r24, r24
    31b8:	90 e0       	ldi	r25, 0x00	; 0
    31ba:	81 70       	andi	r24, 0x01	; 1
    31bc:	90 70       	andi	r25, 0x00	; 0
    31be:	88 23       	and	r24, r24
    31c0:	29 f0       	breq	.+10     	; 0x31cc <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    31c2:	8a 81       	ldd	r24, Y+2	; 0x02
    31c4:	9b 81       	ldd	r25, Y+3	; 0x03
    31c6:	02 96       	adiw	r24, 0x02	; 2
    31c8:	9b 83       	std	Y+3, r25	; 0x03
    31ca:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    31cc:	88 85       	ldd	r24, Y+8	; 0x08
    31ce:	99 85       	ldd	r25, Y+9	; 0x09
    31d0:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <xStreamBufferSpacesAvailable>
    31d4:	9d 83       	std	Y+5, r25	; 0x05
    31d6:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    31d8:	88 85       	ldd	r24, Y+8	; 0x08
    31da:	99 85       	ldd	r25, Y+9	; 0x09
    31dc:	2c 85       	ldd	r18, Y+12	; 0x0c
    31de:	3d 85       	ldd	r19, Y+13	; 0x0d
    31e0:	4e 85       	ldd	r20, Y+14	; 0x0e
    31e2:	5f 85       	ldd	r21, Y+15	; 0x0f
    31e4:	ec 81       	ldd	r30, Y+4	; 0x04
    31e6:	fd 81       	ldd	r31, Y+5	; 0x05
    31e8:	aa 81       	ldd	r26, Y+2	; 0x02
    31ea:	bb 81       	ldd	r27, Y+3	; 0x03
    31ec:	b9 01       	movw	r22, r18
    31ee:	9f 01       	movw	r18, r30
    31f0:	8d 01       	movw	r16, r26
    31f2:	0e 94 37 19 	call	0x326e	; 0x326e <prvWriteMessageToBuffer>
    31f6:	9f 83       	std	Y+7, r25	; 0x07
    31f8:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    31fa:	8e 81       	ldd	r24, Y+6	; 0x06
    31fc:	9f 81       	ldd	r25, Y+7	; 0x07
    31fe:	00 97       	sbiw	r24, 0x00	; 0
    3200:	39 f1       	breq	.+78     	; 0x3250 <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3202:	88 85       	ldd	r24, Y+8	; 0x08
    3204:	99 85       	ldd	r25, Y+9	; 0x09
    3206:	0e 94 be 1d 	call	0x3b7c	; 0x3b7c <prvBytesInBuffer>
    320a:	9c 01       	movw	r18, r24
    320c:	e8 85       	ldd	r30, Y+8	; 0x08
    320e:	f9 85       	ldd	r31, Y+9	; 0x09
    3210:	86 81       	ldd	r24, Z+6	; 0x06
    3212:	97 81       	ldd	r25, Z+7	; 0x07
    3214:	28 17       	cp	r18, r24
    3216:	39 07       	cpc	r19, r25
    3218:	d8 f0       	brcs	.+54     	; 0x3250 <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    321a:	19 82       	std	Y+1, r1	; 0x01
    321c:	e8 85       	ldd	r30, Y+8	; 0x08
    321e:	f9 85       	ldd	r31, Y+9	; 0x09
    3220:	80 85       	ldd	r24, Z+8	; 0x08
    3222:	91 85       	ldd	r25, Z+9	; 0x09
    3224:	00 97       	sbiw	r24, 0x00	; 0
    3226:	a1 f0       	breq	.+40     	; 0x3250 <xStreamBufferSendFromISR+0xdc>
    3228:	e8 85       	ldd	r30, Y+8	; 0x08
    322a:	f9 85       	ldd	r31, Y+9	; 0x09
    322c:	80 85       	ldd	r24, Z+8	; 0x08
    322e:	91 85       	ldd	r25, Z+9	; 0x09
    3230:	e8 89       	ldd	r30, Y+16	; 0x10
    3232:	f9 89       	ldd	r31, Y+17	; 0x11
    3234:	40 e0       	ldi	r20, 0x00	; 0
    3236:	50 e0       	ldi	r21, 0x00	; 0
    3238:	60 e0       	ldi	r22, 0x00	; 0
    323a:	70 e0       	ldi	r23, 0x00	; 0
    323c:	20 e0       	ldi	r18, 0x00	; 0
    323e:	00 e0       	ldi	r16, 0x00	; 0
    3240:	10 e0       	ldi	r17, 0x00	; 0
    3242:	7f 01       	movw	r14, r30
    3244:	0e 94 dd 2a 	call	0x55ba	; 0x55ba <xTaskGenericNotifyFromISR>
    3248:	e8 85       	ldd	r30, Y+8	; 0x08
    324a:	f9 85       	ldd	r31, Y+9	; 0x09
    324c:	11 86       	std	Z+9, r1	; 0x09
    324e:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    3250:	8e 81       	ldd	r24, Y+6	; 0x06
    3252:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3254:	61 96       	adiw	r28, 0x11	; 17
    3256:	0f b6       	in	r0, 0x3f	; 63
    3258:	f8 94       	cli
    325a:	de bf       	out	0x3e, r29	; 62
    325c:	0f be       	out	0x3f, r0	; 63
    325e:	cd bf       	out	0x3d, r28	; 61
    3260:	cf 91       	pop	r28
    3262:	df 91       	pop	r29
    3264:	1f 91       	pop	r17
    3266:	0f 91       	pop	r16
    3268:	ff 90       	pop	r15
    326a:	ef 90       	pop	r14
    326c:	08 95       	ret

0000326e <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    326e:	0f 93       	push	r16
    3270:	1f 93       	push	r17
    3272:	df 93       	push	r29
    3274:	cf 93       	push	r28
    3276:	cd b7       	in	r28, 0x3d	; 61
    3278:	de b7       	in	r29, 0x3e	; 62
    327a:	61 97       	sbiw	r28, 0x11	; 17
    327c:	0f b6       	in	r0, 0x3f	; 63
    327e:	f8 94       	cli
    3280:	de bf       	out	0x3e, r29	; 62
    3282:	0f be       	out	0x3f, r0	; 63
    3284:	cd bf       	out	0x3d, r28	; 61
    3286:	9d 83       	std	Y+5, r25	; 0x05
    3288:	8c 83       	std	Y+4, r24	; 0x04
    328a:	7f 83       	std	Y+7, r23	; 0x07
    328c:	6e 83       	std	Y+6, r22	; 0x06
    328e:	59 87       	std	Y+9, r21	; 0x09
    3290:	48 87       	std	Y+8, r20	; 0x08
    3292:	3b 87       	std	Y+11, r19	; 0x0b
    3294:	2a 87       	std	Y+10, r18	; 0x0a
    3296:	1d 87       	std	Y+13, r17	; 0x0d
    3298:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    329a:	8a 85       	ldd	r24, Y+10	; 0x0a
    329c:	9b 85       	ldd	r25, Y+11	; 0x0b
    329e:	00 97       	sbiw	r24, 0x00	; 0
    32a0:	11 f4       	brne	.+4      	; 0x32a6 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    32a2:	1b 82       	std	Y+3, r1	; 0x03
    32a4:	38 c0       	rjmp	.+112    	; 0x3316 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    32a6:	ec 81       	ldd	r30, Y+4	; 0x04
    32a8:	fd 81       	ldd	r31, Y+5	; 0x05
    32aa:	86 85       	ldd	r24, Z+14	; 0x0e
    32ac:	88 2f       	mov	r24, r24
    32ae:	90 e0       	ldi	r25, 0x00	; 0
    32b0:	81 70       	andi	r24, 0x01	; 1
    32b2:	90 70       	andi	r25, 0x00	; 0
    32b4:	00 97       	sbiw	r24, 0x00	; 0
    32b6:	d1 f4       	brne	.+52     	; 0x32ec <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    32b8:	81 e0       	ldi	r24, 0x01	; 1
    32ba:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    32bc:	28 85       	ldd	r18, Y+8	; 0x08
    32be:	39 85       	ldd	r19, Y+9	; 0x09
    32c0:	39 8b       	std	Y+17, r19	; 0x11
    32c2:	28 8b       	std	Y+16, r18	; 0x10
    32c4:	8a 85       	ldd	r24, Y+10	; 0x0a
    32c6:	9b 85       	ldd	r25, Y+11	; 0x0b
    32c8:	9f 87       	std	Y+15, r25	; 0x0f
    32ca:	8e 87       	std	Y+14, r24	; 0x0e
    32cc:	2e 85       	ldd	r18, Y+14	; 0x0e
    32ce:	3f 85       	ldd	r19, Y+15	; 0x0f
    32d0:	88 89       	ldd	r24, Y+16	; 0x10
    32d2:	99 89       	ldd	r25, Y+17	; 0x11
    32d4:	82 17       	cp	r24, r18
    32d6:	93 07       	cpc	r25, r19
    32d8:	20 f4       	brcc	.+8      	; 0x32e2 <prvWriteMessageToBuffer+0x74>
    32da:	28 89       	ldd	r18, Y+16	; 0x10
    32dc:	39 89       	ldd	r19, Y+17	; 0x11
    32de:	3f 87       	std	Y+15, r19	; 0x0f
    32e0:	2e 87       	std	Y+14, r18	; 0x0e
    32e2:	8e 85       	ldd	r24, Y+14	; 0x0e
    32e4:	9f 85       	ldd	r25, Y+15	; 0x0f
    32e6:	99 87       	std	Y+9, r25	; 0x09
    32e8:	88 87       	std	Y+8, r24	; 0x08
    32ea:	15 c0       	rjmp	.+42     	; 0x3316 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    32ec:	2a 85       	ldd	r18, Y+10	; 0x0a
    32ee:	3b 85       	ldd	r19, Y+11	; 0x0b
    32f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    32f2:	9d 85       	ldd	r25, Y+13	; 0x0d
    32f4:	28 17       	cp	r18, r24
    32f6:	39 07       	cpc	r19, r25
    32f8:	68 f0       	brcs	.+26     	; 0x3314 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    32fa:	81 e0       	ldi	r24, 0x01	; 1
    32fc:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    32fe:	9e 01       	movw	r18, r28
    3300:	28 5f       	subi	r18, 0xF8	; 248
    3302:	3f 4f       	sbci	r19, 0xFF	; 255
    3304:	8c 81       	ldd	r24, Y+4	; 0x04
    3306:	9d 81       	ldd	r25, Y+5	; 0x05
    3308:	b9 01       	movw	r22, r18
    330a:	42 e0       	ldi	r20, 0x02	; 2
    330c:	50 e0       	ldi	r21, 0x00	; 0
    330e:	0e 94 84 1c 	call	0x3908	; 0x3908 <prvWriteBytesToBuffer>
    3312:	01 c0       	rjmp	.+2      	; 0x3316 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    3314:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    3316:	8b 81       	ldd	r24, Y+3	; 0x03
    3318:	88 23       	and	r24, r24
    331a:	61 f0       	breq	.+24     	; 0x3334 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    331c:	2e 81       	ldd	r18, Y+6	; 0x06
    331e:	3f 81       	ldd	r19, Y+7	; 0x07
    3320:	48 85       	ldd	r20, Y+8	; 0x08
    3322:	59 85       	ldd	r21, Y+9	; 0x09
    3324:	8c 81       	ldd	r24, Y+4	; 0x04
    3326:	9d 81       	ldd	r25, Y+5	; 0x05
    3328:	b9 01       	movw	r22, r18
    332a:	0e 94 84 1c 	call	0x3908	; 0x3908 <prvWriteBytesToBuffer>
    332e:	9a 83       	std	Y+2, r25	; 0x02
    3330:	89 83       	std	Y+1, r24	; 0x01
    3332:	02 c0       	rjmp	.+4      	; 0x3338 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    3334:	1a 82       	std	Y+2, r1	; 0x02
    3336:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3338:	89 81       	ldd	r24, Y+1	; 0x01
    333a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    333c:	61 96       	adiw	r28, 0x11	; 17
    333e:	0f b6       	in	r0, 0x3f	; 63
    3340:	f8 94       	cli
    3342:	de bf       	out	0x3e, r29	; 62
    3344:	0f be       	out	0x3f, r0	; 63
    3346:	cd bf       	out	0x3d, r28	; 61
    3348:	cf 91       	pop	r28
    334a:	df 91       	pop	r29
    334c:	1f 91       	pop	r17
    334e:	0f 91       	pop	r16
    3350:	08 95       	ret

00003352 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    3352:	ef 92       	push	r14
    3354:	ff 92       	push	r15
    3356:	0f 93       	push	r16
    3358:	1f 93       	push	r17
    335a:	df 93       	push	r29
    335c:	cf 93       	push	r28
    335e:	cd b7       	in	r28, 0x3d	; 61
    3360:	de b7       	in	r29, 0x3e	; 62
    3362:	60 97       	sbiw	r28, 0x10	; 16
    3364:	0f b6       	in	r0, 0x3f	; 63
    3366:	f8 94       	cli
    3368:	de bf       	out	0x3e, r29	; 62
    336a:	0f be       	out	0x3f, r0	; 63
    336c:	cd bf       	out	0x3d, r28	; 61
    336e:	9a 87       	std	Y+10, r25	; 0x0a
    3370:	89 87       	std	Y+9, r24	; 0x09
    3372:	7c 87       	std	Y+12, r23	; 0x0c
    3374:	6b 87       	std	Y+11, r22	; 0x0b
    3376:	5e 87       	std	Y+14, r21	; 0x0e
    3378:	4d 87       	std	Y+13, r20	; 0x0d
    337a:	38 8b       	std	Y+16, r19	; 0x10
    337c:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    337e:	89 85       	ldd	r24, Y+9	; 0x09
    3380:	9a 85       	ldd	r25, Y+10	; 0x0a
    3382:	98 87       	std	Y+8, r25	; 0x08
    3384:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3386:	1e 82       	std	Y+6, r1	; 0x06
    3388:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    338a:	ef 81       	ldd	r30, Y+7	; 0x07
    338c:	f8 85       	ldd	r31, Y+8	; 0x08
    338e:	86 85       	ldd	r24, Z+14	; 0x0e
    3390:	88 2f       	mov	r24, r24
    3392:	90 e0       	ldi	r25, 0x00	; 0
    3394:	81 70       	andi	r24, 0x01	; 1
    3396:	90 70       	andi	r25, 0x00	; 0
    3398:	88 23       	and	r24, r24
    339a:	29 f0       	breq	.+10     	; 0x33a6 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    339c:	82 e0       	ldi	r24, 0x02	; 2
    339e:	90 e0       	ldi	r25, 0x00	; 0
    33a0:	9a 83       	std	Y+2, r25	; 0x02
    33a2:	89 83       	std	Y+1, r24	; 0x01
    33a4:	02 c0       	rjmp	.+4      	; 0x33aa <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    33a6:	1a 82       	std	Y+2, r1	; 0x02
    33a8:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    33aa:	8f 85       	ldd	r24, Y+15	; 0x0f
    33ac:	98 89       	ldd	r25, Y+16	; 0x10
    33ae:	00 97       	sbiw	r24, 0x00	; 0
    33b0:	09 f4       	brne	.+2      	; 0x33b4 <xStreamBufferReceive+0x62>
    33b2:	3d c0       	rjmp	.+122    	; 0x342e <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    33b4:	0f b6       	in	r0, 0x3f	; 63
    33b6:	f8 94       	cli
    33b8:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    33ba:	8f 81       	ldd	r24, Y+7	; 0x07
    33bc:	98 85       	ldd	r25, Y+8	; 0x08
    33be:	0e 94 be 1d 	call	0x3b7c	; 0x3b7c <prvBytesInBuffer>
    33c2:	9c 83       	std	Y+4, r25	; 0x04
    33c4:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    33c6:	2b 81       	ldd	r18, Y+3	; 0x03
    33c8:	3c 81       	ldd	r19, Y+4	; 0x04
    33ca:	89 81       	ldd	r24, Y+1	; 0x01
    33cc:	9a 81       	ldd	r25, Y+2	; 0x02
    33ce:	82 17       	cp	r24, r18
    33d0:	93 07       	cpc	r25, r19
    33d2:	50 f0       	brcs	.+20     	; 0x33e8 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    33d4:	80 e0       	ldi	r24, 0x00	; 0
    33d6:	90 e0       	ldi	r25, 0x00	; 0
    33d8:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    33dc:	0e 94 f7 26 	call	0x4dee	; 0x4dee <xTaskGetCurrentTaskHandle>
    33e0:	ef 81       	ldd	r30, Y+7	; 0x07
    33e2:	f8 85       	ldd	r31, Y+8	; 0x08
    33e4:	91 87       	std	Z+9, r25	; 0x09
    33e6:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    33e8:	0f 90       	pop	r0
    33ea:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    33ec:	2b 81       	ldd	r18, Y+3	; 0x03
    33ee:	3c 81       	ldd	r19, Y+4	; 0x04
    33f0:	89 81       	ldd	r24, Y+1	; 0x01
    33f2:	9a 81       	ldd	r25, Y+2	; 0x02
    33f4:	82 17       	cp	r24, r18
    33f6:	93 07       	cpc	r25, r19
    33f8:	00 f1       	brcs	.+64     	; 0x343a <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    33fa:	ef 85       	ldd	r30, Y+15	; 0x0f
    33fc:	f8 89       	ldd	r31, Y+16	; 0x10
    33fe:	60 e0       	ldi	r22, 0x00	; 0
    3400:	70 e0       	ldi	r23, 0x00	; 0
    3402:	80 e0       	ldi	r24, 0x00	; 0
    3404:	90 e0       	ldi	r25, 0x00	; 0
    3406:	20 e0       	ldi	r18, 0x00	; 0
    3408:	30 e0       	ldi	r19, 0x00	; 0
    340a:	40 e0       	ldi	r20, 0x00	; 0
    340c:	50 e0       	ldi	r21, 0x00	; 0
    340e:	00 e0       	ldi	r16, 0x00	; 0
    3410:	10 e0       	ldi	r17, 0x00	; 0
    3412:	7f 01       	movw	r14, r30
    3414:	0e 94 64 29 	call	0x52c8	; 0x52c8 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    3418:	ef 81       	ldd	r30, Y+7	; 0x07
    341a:	f8 85       	ldd	r31, Y+8	; 0x08
    341c:	11 86       	std	Z+9, r1	; 0x09
    341e:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3420:	8f 81       	ldd	r24, Y+7	; 0x07
    3422:	98 85       	ldd	r25, Y+8	; 0x08
    3424:	0e 94 be 1d 	call	0x3b7c	; 0x3b7c <prvBytesInBuffer>
    3428:	9c 83       	std	Y+4, r25	; 0x04
    342a:	8b 83       	std	Y+3, r24	; 0x03
    342c:	06 c0       	rjmp	.+12     	; 0x343a <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    342e:	8f 81       	ldd	r24, Y+7	; 0x07
    3430:	98 85       	ldd	r25, Y+8	; 0x08
    3432:	0e 94 be 1d 	call	0x3b7c	; 0x3b7c <prvBytesInBuffer>
    3436:	9c 83       	std	Y+4, r25	; 0x04
    3438:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    343a:	2b 81       	ldd	r18, Y+3	; 0x03
    343c:	3c 81       	ldd	r19, Y+4	; 0x04
    343e:	89 81       	ldd	r24, Y+1	; 0x01
    3440:	9a 81       	ldd	r25, Y+2	; 0x02
    3442:	82 17       	cp	r24, r18
    3444:	93 07       	cpc	r25, r19
    3446:	80 f5       	brcc	.+96     	; 0x34a8 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3448:	8f 81       	ldd	r24, Y+7	; 0x07
    344a:	98 85       	ldd	r25, Y+8	; 0x08
    344c:	2b 85       	ldd	r18, Y+11	; 0x0b
    344e:	3c 85       	ldd	r19, Y+12	; 0x0c
    3450:	4d 85       	ldd	r20, Y+13	; 0x0d
    3452:	5e 85       	ldd	r21, Y+14	; 0x0e
    3454:	eb 81       	ldd	r30, Y+3	; 0x03
    3456:	fc 81       	ldd	r31, Y+4	; 0x04
    3458:	a9 81       	ldd	r26, Y+1	; 0x01
    345a:	ba 81       	ldd	r27, Y+2	; 0x02
    345c:	b9 01       	movw	r22, r18
    345e:	9f 01       	movw	r18, r30
    3460:	8d 01       	movw	r16, r26
    3462:	0e 94 2d 1b 	call	0x365a	; 0x365a <prvReadMessageFromBuffer>
    3466:	9e 83       	std	Y+6, r25	; 0x06
    3468:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    346a:	8d 81       	ldd	r24, Y+5	; 0x05
    346c:	9e 81       	ldd	r25, Y+6	; 0x06
    346e:	00 97       	sbiw	r24, 0x00	; 0
    3470:	d9 f0       	breq	.+54     	; 0x34a8 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    3472:	0e 94 26 22 	call	0x444c	; 0x444c <vTaskSuspendAll>
    3476:	ef 81       	ldd	r30, Y+7	; 0x07
    3478:	f8 85       	ldd	r31, Y+8	; 0x08
    347a:	82 85       	ldd	r24, Z+10	; 0x0a
    347c:	93 85       	ldd	r25, Z+11	; 0x0b
    347e:	00 97       	sbiw	r24, 0x00	; 0
    3480:	89 f0       	breq	.+34     	; 0x34a4 <xStreamBufferReceive+0x152>
    3482:	ef 81       	ldd	r30, Y+7	; 0x07
    3484:	f8 85       	ldd	r31, Y+8	; 0x08
    3486:	82 85       	ldd	r24, Z+10	; 0x0a
    3488:	93 85       	ldd	r25, Z+11	; 0x0b
    348a:	40 e0       	ldi	r20, 0x00	; 0
    348c:	50 e0       	ldi	r21, 0x00	; 0
    348e:	60 e0       	ldi	r22, 0x00	; 0
    3490:	70 e0       	ldi	r23, 0x00	; 0
    3492:	20 e0       	ldi	r18, 0x00	; 0
    3494:	00 e0       	ldi	r16, 0x00	; 0
    3496:	10 e0       	ldi	r17, 0x00	; 0
    3498:	0e 94 00 2a 	call	0x5400	; 0x5400 <xTaskGenericNotify>
    349c:	ef 81       	ldd	r30, Y+7	; 0x07
    349e:	f8 85       	ldd	r31, Y+8	; 0x08
    34a0:	13 86       	std	Z+11, r1	; 0x0b
    34a2:	12 86       	std	Z+10, r1	; 0x0a
    34a4:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    34a8:	8d 81       	ldd	r24, Y+5	; 0x05
    34aa:	9e 81       	ldd	r25, Y+6	; 0x06
}
    34ac:	60 96       	adiw	r28, 0x10	; 16
    34ae:	0f b6       	in	r0, 0x3f	; 63
    34b0:	f8 94       	cli
    34b2:	de bf       	out	0x3e, r29	; 62
    34b4:	0f be       	out	0x3f, r0	; 63
    34b6:	cd bf       	out	0x3d, r28	; 61
    34b8:	cf 91       	pop	r28
    34ba:	df 91       	pop	r29
    34bc:	1f 91       	pop	r17
    34be:	0f 91       	pop	r16
    34c0:	ff 90       	pop	r15
    34c2:	ef 90       	pop	r14
    34c4:	08 95       	ret

000034c6 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    34c6:	df 93       	push	r29
    34c8:	cf 93       	push	r28
    34ca:	cd b7       	in	r28, 0x3d	; 61
    34cc:	de b7       	in	r29, 0x3e	; 62
    34ce:	2c 97       	sbiw	r28, 0x0c	; 12
    34d0:	0f b6       	in	r0, 0x3f	; 63
    34d2:	f8 94       	cli
    34d4:	de bf       	out	0x3e, r29	; 62
    34d6:	0f be       	out	0x3f, r0	; 63
    34d8:	cd bf       	out	0x3d, r28	; 61
    34da:	9c 87       	std	Y+12, r25	; 0x0c
    34dc:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    34de:	8b 85       	ldd	r24, Y+11	; 0x0b
    34e0:	9c 85       	ldd	r25, Y+12	; 0x0c
    34e2:	98 87       	std	Y+8, r25	; 0x08
    34e4:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    34e6:	ef 81       	ldd	r30, Y+7	; 0x07
    34e8:	f8 85       	ldd	r31, Y+8	; 0x08
    34ea:	86 85       	ldd	r24, Z+14	; 0x0e
    34ec:	88 2f       	mov	r24, r24
    34ee:	90 e0       	ldi	r25, 0x00	; 0
    34f0:	81 70       	andi	r24, 0x01	; 1
    34f2:	90 70       	andi	r25, 0x00	; 0
    34f4:	88 23       	and	r24, r24
    34f6:	61 f1       	breq	.+88     	; 0x3550 <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    34f8:	8f 81       	ldd	r24, Y+7	; 0x07
    34fa:	98 85       	ldd	r25, Y+8	; 0x08
    34fc:	0e 94 be 1d 	call	0x3b7c	; 0x3b7c <prvBytesInBuffer>
    3500:	9c 83       	std	Y+4, r25	; 0x04
    3502:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    3504:	8b 81       	ldd	r24, Y+3	; 0x03
    3506:	9c 81       	ldd	r25, Y+4	; 0x04
    3508:	83 30       	cpi	r24, 0x03	; 3
    350a:	91 05       	cpc	r25, r1
    350c:	f0 f0       	brcs	.+60     	; 0x354a <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    350e:	ef 81       	ldd	r30, Y+7	; 0x07
    3510:	f8 85       	ldd	r31, Y+8	; 0x08
    3512:	80 81       	ld	r24, Z
    3514:	91 81       	ldd	r25, Z+1	; 0x01
    3516:	9a 83       	std	Y+2, r25	; 0x02
    3518:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    351a:	9e 01       	movw	r18, r28
    351c:	27 5f       	subi	r18, 0xF7	; 247
    351e:	3f 4f       	sbci	r19, 0xFF	; 255
    3520:	8f 81       	ldd	r24, Y+7	; 0x07
    3522:	98 85       	ldd	r25, Y+8	; 0x08
    3524:	eb 81       	ldd	r30, Y+3	; 0x03
    3526:	fc 81       	ldd	r31, Y+4	; 0x04
    3528:	b9 01       	movw	r22, r18
    352a:	42 e0       	ldi	r20, 0x02	; 2
    352c:	50 e0       	ldi	r21, 0x00	; 0
    352e:	9f 01       	movw	r18, r30
    3530:	0e 94 11 1d 	call	0x3a22	; 0x3a22 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    3534:	89 85       	ldd	r24, Y+9	; 0x09
    3536:	9a 85       	ldd	r25, Y+10	; 0x0a
    3538:	9e 83       	std	Y+6, r25	; 0x06
    353a:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    353c:	ef 81       	ldd	r30, Y+7	; 0x07
    353e:	f8 85       	ldd	r31, Y+8	; 0x08
    3540:	89 81       	ldd	r24, Y+1	; 0x01
    3542:	9a 81       	ldd	r25, Y+2	; 0x02
    3544:	91 83       	std	Z+1, r25	; 0x01
    3546:	80 83       	st	Z, r24
    3548:	05 c0       	rjmp	.+10     	; 0x3554 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    354a:	1e 82       	std	Y+6, r1	; 0x06
    354c:	1d 82       	std	Y+5, r1	; 0x05
    354e:	02 c0       	rjmp	.+4      	; 0x3554 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    3550:	1e 82       	std	Y+6, r1	; 0x06
    3552:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    3554:	8d 81       	ldd	r24, Y+5	; 0x05
    3556:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3558:	2c 96       	adiw	r28, 0x0c	; 12
    355a:	0f b6       	in	r0, 0x3f	; 63
    355c:	f8 94       	cli
    355e:	de bf       	out	0x3e, r29	; 62
    3560:	0f be       	out	0x3f, r0	; 63
    3562:	cd bf       	out	0x3d, r28	; 61
    3564:	cf 91       	pop	r28
    3566:	df 91       	pop	r29
    3568:	08 95       	ret

0000356a <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    356a:	ef 92       	push	r14
    356c:	ff 92       	push	r15
    356e:	0f 93       	push	r16
    3570:	1f 93       	push	r17
    3572:	df 93       	push	r29
    3574:	cf 93       	push	r28
    3576:	cd b7       	in	r28, 0x3d	; 61
    3578:	de b7       	in	r29, 0x3e	; 62
    357a:	61 97       	sbiw	r28, 0x11	; 17
    357c:	0f b6       	in	r0, 0x3f	; 63
    357e:	f8 94       	cli
    3580:	de bf       	out	0x3e, r29	; 62
    3582:	0f be       	out	0x3f, r0	; 63
    3584:	cd bf       	out	0x3d, r28	; 61
    3586:	9b 87       	std	Y+11, r25	; 0x0b
    3588:	8a 87       	std	Y+10, r24	; 0x0a
    358a:	7d 87       	std	Y+13, r23	; 0x0d
    358c:	6c 87       	std	Y+12, r22	; 0x0c
    358e:	5f 87       	std	Y+15, r21	; 0x0f
    3590:	4e 87       	std	Y+14, r20	; 0x0e
    3592:	39 8b       	std	Y+17, r19	; 0x11
    3594:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3596:	8a 85       	ldd	r24, Y+10	; 0x0a
    3598:	9b 85       	ldd	r25, Y+11	; 0x0b
    359a:	99 87       	std	Y+9, r25	; 0x09
    359c:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    359e:	1f 82       	std	Y+7, r1	; 0x07
    35a0:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    35a2:	e8 85       	ldd	r30, Y+8	; 0x08
    35a4:	f9 85       	ldd	r31, Y+9	; 0x09
    35a6:	86 85       	ldd	r24, Z+14	; 0x0e
    35a8:	88 2f       	mov	r24, r24
    35aa:	90 e0       	ldi	r25, 0x00	; 0
    35ac:	81 70       	andi	r24, 0x01	; 1
    35ae:	90 70       	andi	r25, 0x00	; 0
    35b0:	88 23       	and	r24, r24
    35b2:	29 f0       	breq	.+10     	; 0x35be <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    35b4:	82 e0       	ldi	r24, 0x02	; 2
    35b6:	90 e0       	ldi	r25, 0x00	; 0
    35b8:	9b 83       	std	Y+3, r25	; 0x03
    35ba:	8a 83       	std	Y+2, r24	; 0x02
    35bc:	02 c0       	rjmp	.+4      	; 0x35c2 <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    35be:	1b 82       	std	Y+3, r1	; 0x03
    35c0:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    35c2:	88 85       	ldd	r24, Y+8	; 0x08
    35c4:	99 85       	ldd	r25, Y+9	; 0x09
    35c6:	0e 94 be 1d 	call	0x3b7c	; 0x3b7c <prvBytesInBuffer>
    35ca:	9d 83       	std	Y+5, r25	; 0x05
    35cc:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    35ce:	2c 81       	ldd	r18, Y+4	; 0x04
    35d0:	3d 81       	ldd	r19, Y+5	; 0x05
    35d2:	8a 81       	ldd	r24, Y+2	; 0x02
    35d4:	9b 81       	ldd	r25, Y+3	; 0x03
    35d6:	82 17       	cp	r24, r18
    35d8:	93 07       	cpc	r25, r19
    35da:	80 f5       	brcc	.+96     	; 0x363c <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    35dc:	88 85       	ldd	r24, Y+8	; 0x08
    35de:	99 85       	ldd	r25, Y+9	; 0x09
    35e0:	2c 85       	ldd	r18, Y+12	; 0x0c
    35e2:	3d 85       	ldd	r19, Y+13	; 0x0d
    35e4:	4e 85       	ldd	r20, Y+14	; 0x0e
    35e6:	5f 85       	ldd	r21, Y+15	; 0x0f
    35e8:	ec 81       	ldd	r30, Y+4	; 0x04
    35ea:	fd 81       	ldd	r31, Y+5	; 0x05
    35ec:	aa 81       	ldd	r26, Y+2	; 0x02
    35ee:	bb 81       	ldd	r27, Y+3	; 0x03
    35f0:	b9 01       	movw	r22, r18
    35f2:	9f 01       	movw	r18, r30
    35f4:	8d 01       	movw	r16, r26
    35f6:	0e 94 2d 1b 	call	0x365a	; 0x365a <prvReadMessageFromBuffer>
    35fa:	9f 83       	std	Y+7, r25	; 0x07
    35fc:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    35fe:	8e 81       	ldd	r24, Y+6	; 0x06
    3600:	9f 81       	ldd	r25, Y+7	; 0x07
    3602:	00 97       	sbiw	r24, 0x00	; 0
    3604:	d9 f0       	breq	.+54     	; 0x363c <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3606:	19 82       	std	Y+1, r1	; 0x01
    3608:	e8 85       	ldd	r30, Y+8	; 0x08
    360a:	f9 85       	ldd	r31, Y+9	; 0x09
    360c:	82 85       	ldd	r24, Z+10	; 0x0a
    360e:	93 85       	ldd	r25, Z+11	; 0x0b
    3610:	00 97       	sbiw	r24, 0x00	; 0
    3612:	a1 f0       	breq	.+40     	; 0x363c <xStreamBufferReceiveFromISR+0xd2>
    3614:	e8 85       	ldd	r30, Y+8	; 0x08
    3616:	f9 85       	ldd	r31, Y+9	; 0x09
    3618:	82 85       	ldd	r24, Z+10	; 0x0a
    361a:	93 85       	ldd	r25, Z+11	; 0x0b
    361c:	e8 89       	ldd	r30, Y+16	; 0x10
    361e:	f9 89       	ldd	r31, Y+17	; 0x11
    3620:	40 e0       	ldi	r20, 0x00	; 0
    3622:	50 e0       	ldi	r21, 0x00	; 0
    3624:	60 e0       	ldi	r22, 0x00	; 0
    3626:	70 e0       	ldi	r23, 0x00	; 0
    3628:	20 e0       	ldi	r18, 0x00	; 0
    362a:	00 e0       	ldi	r16, 0x00	; 0
    362c:	10 e0       	ldi	r17, 0x00	; 0
    362e:	7f 01       	movw	r14, r30
    3630:	0e 94 dd 2a 	call	0x55ba	; 0x55ba <xTaskGenericNotifyFromISR>
    3634:	e8 85       	ldd	r30, Y+8	; 0x08
    3636:	f9 85       	ldd	r31, Y+9	; 0x09
    3638:	13 86       	std	Z+11, r1	; 0x0b
    363a:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    363c:	8e 81       	ldd	r24, Y+6	; 0x06
    363e:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3640:	61 96       	adiw	r28, 0x11	; 17
    3642:	0f b6       	in	r0, 0x3f	; 63
    3644:	f8 94       	cli
    3646:	de bf       	out	0x3e, r29	; 62
    3648:	0f be       	out	0x3f, r0	; 63
    364a:	cd bf       	out	0x3d, r28	; 61
    364c:	cf 91       	pop	r28
    364e:	df 91       	pop	r29
    3650:	1f 91       	pop	r17
    3652:	0f 91       	pop	r16
    3654:	ff 90       	pop	r15
    3656:	ef 90       	pop	r14
    3658:	08 95       	ret

0000365a <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    365a:	0f 93       	push	r16
    365c:	1f 93       	push	r17
    365e:	df 93       	push	r29
    3660:	cf 93       	push	r28
    3662:	cd b7       	in	r28, 0x3d	; 61
    3664:	de b7       	in	r29, 0x3e	; 62
    3666:	62 97       	sbiw	r28, 0x12	; 18
    3668:	0f b6       	in	r0, 0x3f	; 63
    366a:	f8 94       	cli
    366c:	de bf       	out	0x3e, r29	; 62
    366e:	0f be       	out	0x3f, r0	; 63
    3670:	cd bf       	out	0x3d, r28	; 61
    3672:	9a 87       	std	Y+10, r25	; 0x0a
    3674:	89 87       	std	Y+9, r24	; 0x09
    3676:	7c 87       	std	Y+12, r23	; 0x0c
    3678:	6b 87       	std	Y+11, r22	; 0x0b
    367a:	5e 87       	std	Y+14, r21	; 0x0e
    367c:	4d 87       	std	Y+13, r20	; 0x0d
    367e:	38 8b       	std	Y+16, r19	; 0x10
    3680:	2f 87       	std	Y+15, r18	; 0x0f
    3682:	1a 8b       	std	Y+18, r17	; 0x12
    3684:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    3686:	89 89       	ldd	r24, Y+17	; 0x11
    3688:	9a 89       	ldd	r25, Y+18	; 0x12
    368a:	00 97       	sbiw	r24, 0x00	; 0
    368c:	91 f1       	breq	.+100    	; 0x36f2 <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    368e:	e9 85       	ldd	r30, Y+9	; 0x09
    3690:	fa 85       	ldd	r31, Y+10	; 0x0a
    3692:	80 81       	ld	r24, Z
    3694:	91 81       	ldd	r25, Z+1	; 0x01
    3696:	9e 83       	std	Y+6, r25	; 0x06
    3698:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    369a:	ae 01       	movw	r20, r28
    369c:	49 5f       	subi	r20, 0xF9	; 249
    369e:	5f 4f       	sbci	r21, 0xFF	; 255
    36a0:	89 85       	ldd	r24, Y+9	; 0x09
    36a2:	9a 85       	ldd	r25, Y+10	; 0x0a
    36a4:	29 89       	ldd	r18, Y+17	; 0x11
    36a6:	3a 89       	ldd	r19, Y+18	; 0x12
    36a8:	ef 85       	ldd	r30, Y+15	; 0x0f
    36aa:	f8 89       	ldd	r31, Y+16	; 0x10
    36ac:	ba 01       	movw	r22, r20
    36ae:	a9 01       	movw	r20, r18
    36b0:	9f 01       	movw	r18, r30
    36b2:	0e 94 11 1d 	call	0x3a22	; 0x3a22 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    36b6:	8f 81       	ldd	r24, Y+7	; 0x07
    36b8:	98 85       	ldd	r25, Y+8	; 0x08
    36ba:	9a 83       	std	Y+2, r25	; 0x02
    36bc:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    36be:	2f 85       	ldd	r18, Y+15	; 0x0f
    36c0:	38 89       	ldd	r19, Y+16	; 0x10
    36c2:	89 89       	ldd	r24, Y+17	; 0x11
    36c4:	9a 89       	ldd	r25, Y+18	; 0x12
    36c6:	a9 01       	movw	r20, r18
    36c8:	48 1b       	sub	r20, r24
    36ca:	59 0b       	sbc	r21, r25
    36cc:	ca 01       	movw	r24, r20
    36ce:	98 8b       	std	Y+16, r25	; 0x10
    36d0:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    36d2:	29 81       	ldd	r18, Y+1	; 0x01
    36d4:	3a 81       	ldd	r19, Y+2	; 0x02
    36d6:	8d 85       	ldd	r24, Y+13	; 0x0d
    36d8:	9e 85       	ldd	r25, Y+14	; 0x0e
    36da:	82 17       	cp	r24, r18
    36dc:	93 07       	cpc	r25, r19
    36de:	68 f4       	brcc	.+26     	; 0x36fa <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    36e0:	e9 85       	ldd	r30, Y+9	; 0x09
    36e2:	fa 85       	ldd	r31, Y+10	; 0x0a
    36e4:	8d 81       	ldd	r24, Y+5	; 0x05
    36e6:	9e 81       	ldd	r25, Y+6	; 0x06
    36e8:	91 83       	std	Z+1, r25	; 0x01
    36ea:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    36ec:	1a 82       	std	Y+2, r1	; 0x02
    36ee:	19 82       	std	Y+1, r1	; 0x01
    36f0:	04 c0       	rjmp	.+8      	; 0x36fa <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    36f2:	8d 85       	ldd	r24, Y+13	; 0x0d
    36f4:	9e 85       	ldd	r25, Y+14	; 0x0e
    36f6:	9a 83       	std	Y+2, r25	; 0x02
    36f8:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    36fa:	4b 85       	ldd	r20, Y+11	; 0x0b
    36fc:	5c 85       	ldd	r21, Y+12	; 0x0c
    36fe:	89 85       	ldd	r24, Y+9	; 0x09
    3700:	9a 85       	ldd	r25, Y+10	; 0x0a
    3702:	29 81       	ldd	r18, Y+1	; 0x01
    3704:	3a 81       	ldd	r19, Y+2	; 0x02
    3706:	ef 85       	ldd	r30, Y+15	; 0x0f
    3708:	f8 89       	ldd	r31, Y+16	; 0x10
    370a:	ba 01       	movw	r22, r20
    370c:	a9 01       	movw	r20, r18
    370e:	9f 01       	movw	r18, r30
    3710:	0e 94 11 1d 	call	0x3a22	; 0x3a22 <prvReadBytesFromBuffer>
    3714:	9c 83       	std	Y+4, r25	; 0x04
    3716:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    3718:	8b 81       	ldd	r24, Y+3	; 0x03
    371a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    371c:	62 96       	adiw	r28, 0x12	; 18
    371e:	0f b6       	in	r0, 0x3f	; 63
    3720:	f8 94       	cli
    3722:	de bf       	out	0x3e, r29	; 62
    3724:	0f be       	out	0x3f, r0	; 63
    3726:	cd bf       	out	0x3d, r28	; 61
    3728:	cf 91       	pop	r28
    372a:	df 91       	pop	r29
    372c:	1f 91       	pop	r17
    372e:	0f 91       	pop	r16
    3730:	08 95       	ret

00003732 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    3732:	df 93       	push	r29
    3734:	cf 93       	push	r28
    3736:	cd b7       	in	r28, 0x3d	; 61
    3738:	de b7       	in	r29, 0x3e	; 62
    373a:	27 97       	sbiw	r28, 0x07	; 7
    373c:	0f b6       	in	r0, 0x3f	; 63
    373e:	f8 94       	cli
    3740:	de bf       	out	0x3e, r29	; 62
    3742:	0f be       	out	0x3f, r0	; 63
    3744:	cd bf       	out	0x3d, r28	; 61
    3746:	9f 83       	std	Y+7, r25	; 0x07
    3748:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    374a:	8e 81       	ldd	r24, Y+6	; 0x06
    374c:	9f 81       	ldd	r25, Y+7	; 0x07
    374e:	9d 83       	std	Y+5, r25	; 0x05
    3750:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    3752:	ec 81       	ldd	r30, Y+4	; 0x04
    3754:	fd 81       	ldd	r31, Y+5	; 0x05
    3756:	80 81       	ld	r24, Z
    3758:	91 81       	ldd	r25, Z+1	; 0x01
    375a:	9a 83       	std	Y+2, r25	; 0x02
    375c:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    375e:	ec 81       	ldd	r30, Y+4	; 0x04
    3760:	fd 81       	ldd	r31, Y+5	; 0x05
    3762:	22 81       	ldd	r18, Z+2	; 0x02
    3764:	33 81       	ldd	r19, Z+3	; 0x03
    3766:	89 81       	ldd	r24, Y+1	; 0x01
    3768:	9a 81       	ldd	r25, Y+2	; 0x02
    376a:	28 17       	cp	r18, r24
    376c:	39 07       	cpc	r19, r25
    376e:	19 f4       	brne	.+6      	; 0x3776 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    3770:	81 e0       	ldi	r24, 0x01	; 1
    3772:	8b 83       	std	Y+3, r24	; 0x03
    3774:	01 c0       	rjmp	.+2      	; 0x3778 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    3776:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    3778:	8b 81       	ldd	r24, Y+3	; 0x03
}
    377a:	27 96       	adiw	r28, 0x07	; 7
    377c:	0f b6       	in	r0, 0x3f	; 63
    377e:	f8 94       	cli
    3780:	de bf       	out	0x3e, r29	; 62
    3782:	0f be       	out	0x3f, r0	; 63
    3784:	cd bf       	out	0x3d, r28	; 61
    3786:	cf 91       	pop	r28
    3788:	df 91       	pop	r29
    378a:	08 95       	ret

0000378c <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    378c:	df 93       	push	r29
    378e:	cf 93       	push	r28
    3790:	cd b7       	in	r28, 0x3d	; 61
    3792:	de b7       	in	r29, 0x3e	; 62
    3794:	27 97       	sbiw	r28, 0x07	; 7
    3796:	0f b6       	in	r0, 0x3f	; 63
    3798:	f8 94       	cli
    379a:	de bf       	out	0x3e, r29	; 62
    379c:	0f be       	out	0x3f, r0	; 63
    379e:	cd bf       	out	0x3d, r28	; 61
    37a0:	9f 83       	std	Y+7, r25	; 0x07
    37a2:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    37a4:	8e 81       	ldd	r24, Y+6	; 0x06
    37a6:	9f 81       	ldd	r25, Y+7	; 0x07
    37a8:	9a 83       	std	Y+2, r25	; 0x02
    37aa:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    37ac:	e9 81       	ldd	r30, Y+1	; 0x01
    37ae:	fa 81       	ldd	r31, Y+2	; 0x02
    37b0:	86 85       	ldd	r24, Z+14	; 0x0e
    37b2:	88 2f       	mov	r24, r24
    37b4:	90 e0       	ldi	r25, 0x00	; 0
    37b6:	81 70       	andi	r24, 0x01	; 1
    37b8:	90 70       	andi	r25, 0x00	; 0
    37ba:	88 23       	and	r24, r24
    37bc:	29 f0       	breq	.+10     	; 0x37c8 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    37be:	82 e0       	ldi	r24, 0x02	; 2
    37c0:	90 e0       	ldi	r25, 0x00	; 0
    37c2:	9c 83       	std	Y+4, r25	; 0x04
    37c4:	8b 83       	std	Y+3, r24	; 0x03
    37c6:	02 c0       	rjmp	.+4      	; 0x37cc <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    37c8:	1c 82       	std	Y+4, r1	; 0x04
    37ca:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    37cc:	8e 81       	ldd	r24, Y+6	; 0x06
    37ce:	9f 81       	ldd	r25, Y+7	; 0x07
    37d0:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <xStreamBufferSpacesAvailable>
    37d4:	9c 01       	movw	r18, r24
    37d6:	8b 81       	ldd	r24, Y+3	; 0x03
    37d8:	9c 81       	ldd	r25, Y+4	; 0x04
    37da:	82 17       	cp	r24, r18
    37dc:	93 07       	cpc	r25, r19
    37de:	18 f0       	brcs	.+6      	; 0x37e6 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    37e0:	81 e0       	ldi	r24, 0x01	; 1
    37e2:	8d 83       	std	Y+5, r24	; 0x05
    37e4:	01 c0       	rjmp	.+2      	; 0x37e8 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    37e6:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    37e8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    37ea:	27 96       	adiw	r28, 0x07	; 7
    37ec:	0f b6       	in	r0, 0x3f	; 63
    37ee:	f8 94       	cli
    37f0:	de bf       	out	0x3e, r29	; 62
    37f2:	0f be       	out	0x3f, r0	; 63
    37f4:	cd bf       	out	0x3d, r28	; 61
    37f6:	cf 91       	pop	r28
    37f8:	df 91       	pop	r29
    37fa:	08 95       	ret

000037fc <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    37fc:	ef 92       	push	r14
    37fe:	ff 92       	push	r15
    3800:	0f 93       	push	r16
    3802:	1f 93       	push	r17
    3804:	df 93       	push	r29
    3806:	cf 93       	push	r28
    3808:	cd b7       	in	r28, 0x3d	; 61
    380a:	de b7       	in	r29, 0x3e	; 62
    380c:	28 97       	sbiw	r28, 0x08	; 8
    380e:	0f b6       	in	r0, 0x3f	; 63
    3810:	f8 94       	cli
    3812:	de bf       	out	0x3e, r29	; 62
    3814:	0f be       	out	0x3f, r0	; 63
    3816:	cd bf       	out	0x3d, r28	; 61
    3818:	9e 83       	std	Y+6, r25	; 0x06
    381a:	8d 83       	std	Y+5, r24	; 0x05
    381c:	78 87       	std	Y+8, r23	; 0x08
    381e:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3820:	8d 81       	ldd	r24, Y+5	; 0x05
    3822:	9e 81       	ldd	r25, Y+6	; 0x06
    3824:	9c 83       	std	Y+4, r25	; 0x04
    3826:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    3828:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    382a:	eb 81       	ldd	r30, Y+3	; 0x03
    382c:	fc 81       	ldd	r31, Y+4	; 0x04
    382e:	80 85       	ldd	r24, Z+8	; 0x08
    3830:	91 85       	ldd	r25, Z+9	; 0x09
    3832:	00 97       	sbiw	r24, 0x00	; 0
    3834:	b9 f0       	breq	.+46     	; 0x3864 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    3836:	eb 81       	ldd	r30, Y+3	; 0x03
    3838:	fc 81       	ldd	r31, Y+4	; 0x04
    383a:	80 85       	ldd	r24, Z+8	; 0x08
    383c:	91 85       	ldd	r25, Z+9	; 0x09
    383e:	ef 81       	ldd	r30, Y+7	; 0x07
    3840:	f8 85       	ldd	r31, Y+8	; 0x08
    3842:	40 e0       	ldi	r20, 0x00	; 0
    3844:	50 e0       	ldi	r21, 0x00	; 0
    3846:	60 e0       	ldi	r22, 0x00	; 0
    3848:	70 e0       	ldi	r23, 0x00	; 0
    384a:	20 e0       	ldi	r18, 0x00	; 0
    384c:	00 e0       	ldi	r16, 0x00	; 0
    384e:	10 e0       	ldi	r17, 0x00	; 0
    3850:	7f 01       	movw	r14, r30
    3852:	0e 94 dd 2a 	call	0x55ba	; 0x55ba <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    3856:	eb 81       	ldd	r30, Y+3	; 0x03
    3858:	fc 81       	ldd	r31, Y+4	; 0x04
    385a:	11 86       	std	Z+9, r1	; 0x09
    385c:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    385e:	81 e0       	ldi	r24, 0x01	; 1
    3860:	8a 83       	std	Y+2, r24	; 0x02
    3862:	01 c0       	rjmp	.+2      	; 0x3866 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    3864:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3866:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3868:	28 96       	adiw	r28, 0x08	; 8
    386a:	0f b6       	in	r0, 0x3f	; 63
    386c:	f8 94       	cli
    386e:	de bf       	out	0x3e, r29	; 62
    3870:	0f be       	out	0x3f, r0	; 63
    3872:	cd bf       	out	0x3d, r28	; 61
    3874:	cf 91       	pop	r28
    3876:	df 91       	pop	r29
    3878:	1f 91       	pop	r17
    387a:	0f 91       	pop	r16
    387c:	ff 90       	pop	r15
    387e:	ef 90       	pop	r14
    3880:	08 95       	ret

00003882 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    3882:	ef 92       	push	r14
    3884:	ff 92       	push	r15
    3886:	0f 93       	push	r16
    3888:	1f 93       	push	r17
    388a:	df 93       	push	r29
    388c:	cf 93       	push	r28
    388e:	cd b7       	in	r28, 0x3d	; 61
    3890:	de b7       	in	r29, 0x3e	; 62
    3892:	28 97       	sbiw	r28, 0x08	; 8
    3894:	0f b6       	in	r0, 0x3f	; 63
    3896:	f8 94       	cli
    3898:	de bf       	out	0x3e, r29	; 62
    389a:	0f be       	out	0x3f, r0	; 63
    389c:	cd bf       	out	0x3d, r28	; 61
    389e:	9e 83       	std	Y+6, r25	; 0x06
    38a0:	8d 83       	std	Y+5, r24	; 0x05
    38a2:	78 87       	std	Y+8, r23	; 0x08
    38a4:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    38a6:	8d 81       	ldd	r24, Y+5	; 0x05
    38a8:	9e 81       	ldd	r25, Y+6	; 0x06
    38aa:	9c 83       	std	Y+4, r25	; 0x04
    38ac:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    38ae:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    38b0:	eb 81       	ldd	r30, Y+3	; 0x03
    38b2:	fc 81       	ldd	r31, Y+4	; 0x04
    38b4:	82 85       	ldd	r24, Z+10	; 0x0a
    38b6:	93 85       	ldd	r25, Z+11	; 0x0b
    38b8:	00 97       	sbiw	r24, 0x00	; 0
    38ba:	b9 f0       	breq	.+46     	; 0x38ea <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    38bc:	eb 81       	ldd	r30, Y+3	; 0x03
    38be:	fc 81       	ldd	r31, Y+4	; 0x04
    38c0:	82 85       	ldd	r24, Z+10	; 0x0a
    38c2:	93 85       	ldd	r25, Z+11	; 0x0b
    38c4:	ef 81       	ldd	r30, Y+7	; 0x07
    38c6:	f8 85       	ldd	r31, Y+8	; 0x08
    38c8:	40 e0       	ldi	r20, 0x00	; 0
    38ca:	50 e0       	ldi	r21, 0x00	; 0
    38cc:	60 e0       	ldi	r22, 0x00	; 0
    38ce:	70 e0       	ldi	r23, 0x00	; 0
    38d0:	20 e0       	ldi	r18, 0x00	; 0
    38d2:	00 e0       	ldi	r16, 0x00	; 0
    38d4:	10 e0       	ldi	r17, 0x00	; 0
    38d6:	7f 01       	movw	r14, r30
    38d8:	0e 94 dd 2a 	call	0x55ba	; 0x55ba <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    38dc:	eb 81       	ldd	r30, Y+3	; 0x03
    38de:	fc 81       	ldd	r31, Y+4	; 0x04
    38e0:	13 86       	std	Z+11, r1	; 0x0b
    38e2:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    38e4:	81 e0       	ldi	r24, 0x01	; 1
    38e6:	8a 83       	std	Y+2, r24	; 0x02
    38e8:	01 c0       	rjmp	.+2      	; 0x38ec <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    38ea:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    38ec:	8a 81       	ldd	r24, Y+2	; 0x02
}
    38ee:	28 96       	adiw	r28, 0x08	; 8
    38f0:	0f b6       	in	r0, 0x3f	; 63
    38f2:	f8 94       	cli
    38f4:	de bf       	out	0x3e, r29	; 62
    38f6:	0f be       	out	0x3f, r0	; 63
    38f8:	cd bf       	out	0x3d, r28	; 61
    38fa:	cf 91       	pop	r28
    38fc:	df 91       	pop	r29
    38fe:	1f 91       	pop	r17
    3900:	0f 91       	pop	r16
    3902:	ff 90       	pop	r15
    3904:	ef 90       	pop	r14
    3906:	08 95       	ret

00003908 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    3908:	df 93       	push	r29
    390a:	cf 93       	push	r28
    390c:	cd b7       	in	r28, 0x3d	; 61
    390e:	de b7       	in	r29, 0x3e	; 62
    3910:	2e 97       	sbiw	r28, 0x0e	; 14
    3912:	0f b6       	in	r0, 0x3f	; 63
    3914:	f8 94       	cli
    3916:	de bf       	out	0x3e, r29	; 62
    3918:	0f be       	out	0x3f, r0	; 63
    391a:	cd bf       	out	0x3d, r28	; 61
    391c:	9e 83       	std	Y+6, r25	; 0x06
    391e:	8d 83       	std	Y+5, r24	; 0x05
    3920:	78 87       	std	Y+8, r23	; 0x08
    3922:	6f 83       	std	Y+7, r22	; 0x07
    3924:	5a 87       	std	Y+10, r21	; 0x0a
    3926:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    3928:	ed 81       	ldd	r30, Y+5	; 0x05
    392a:	fe 81       	ldd	r31, Y+6	; 0x06
    392c:	82 81       	ldd	r24, Z+2	; 0x02
    392e:	93 81       	ldd	r25, Z+3	; 0x03
    3930:	9c 83       	std	Y+4, r25	; 0x04
    3932:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    3934:	ed 81       	ldd	r30, Y+5	; 0x05
    3936:	fe 81       	ldd	r31, Y+6	; 0x06
    3938:	24 81       	ldd	r18, Z+4	; 0x04
    393a:	35 81       	ldd	r19, Z+5	; 0x05
    393c:	8b 81       	ldd	r24, Y+3	; 0x03
    393e:	9c 81       	ldd	r25, Y+4	; 0x04
    3940:	a9 01       	movw	r20, r18
    3942:	48 1b       	sub	r20, r24
    3944:	59 0b       	sbc	r21, r25
    3946:	ca 01       	movw	r24, r20
    3948:	29 85       	ldd	r18, Y+9	; 0x09
    394a:	3a 85       	ldd	r19, Y+10	; 0x0a
    394c:	3e 87       	std	Y+14, r19	; 0x0e
    394e:	2d 87       	std	Y+13, r18	; 0x0d
    3950:	9c 87       	std	Y+12, r25	; 0x0c
    3952:	8b 87       	std	Y+11, r24	; 0x0b
    3954:	4b 85       	ldd	r20, Y+11	; 0x0b
    3956:	5c 85       	ldd	r21, Y+12	; 0x0c
    3958:	8d 85       	ldd	r24, Y+13	; 0x0d
    395a:	9e 85       	ldd	r25, Y+14	; 0x0e
    395c:	84 17       	cp	r24, r20
    395e:	95 07       	cpc	r25, r21
    3960:	20 f4       	brcc	.+8      	; 0x396a <prvWriteBytesToBuffer+0x62>
    3962:	2d 85       	ldd	r18, Y+13	; 0x0d
    3964:	3e 85       	ldd	r19, Y+14	; 0x0e
    3966:	3c 87       	std	Y+12, r19	; 0x0c
    3968:	2b 87       	std	Y+11, r18	; 0x0b
    396a:	4b 85       	ldd	r20, Y+11	; 0x0b
    396c:	5c 85       	ldd	r21, Y+12	; 0x0c
    396e:	5a 83       	std	Y+2, r21	; 0x02
    3970:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3972:	ed 81       	ldd	r30, Y+5	; 0x05
    3974:	fe 81       	ldd	r31, Y+6	; 0x06
    3976:	24 85       	ldd	r18, Z+12	; 0x0c
    3978:	35 85       	ldd	r19, Z+13	; 0x0d
    397a:	8b 81       	ldd	r24, Y+3	; 0x03
    397c:	9c 81       	ldd	r25, Y+4	; 0x04
    397e:	82 0f       	add	r24, r18
    3980:	93 1f       	adc	r25, r19
    3982:	2f 81       	ldd	r18, Y+7	; 0x07
    3984:	38 85       	ldd	r19, Y+8	; 0x08
    3986:	49 81       	ldd	r20, Y+1	; 0x01
    3988:	5a 81       	ldd	r21, Y+2	; 0x02
    398a:	b9 01       	movw	r22, r18
    398c:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    3990:	29 85       	ldd	r18, Y+9	; 0x09
    3992:	3a 85       	ldd	r19, Y+10	; 0x0a
    3994:	89 81       	ldd	r24, Y+1	; 0x01
    3996:	9a 81       	ldd	r25, Y+2	; 0x02
    3998:	82 17       	cp	r24, r18
    399a:	93 07       	cpc	r25, r19
    399c:	b0 f4       	brcc	.+44     	; 0x39ca <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    399e:	ed 81       	ldd	r30, Y+5	; 0x05
    39a0:	fe 81       	ldd	r31, Y+6	; 0x06
    39a2:	64 85       	ldd	r22, Z+12	; 0x0c
    39a4:	75 85       	ldd	r23, Z+13	; 0x0d
    39a6:	2f 81       	ldd	r18, Y+7	; 0x07
    39a8:	38 85       	ldd	r19, Y+8	; 0x08
    39aa:	89 81       	ldd	r24, Y+1	; 0x01
    39ac:	9a 81       	ldd	r25, Y+2	; 0x02
    39ae:	a9 01       	movw	r20, r18
    39b0:	48 0f       	add	r20, r24
    39b2:	59 1f       	adc	r21, r25
    39b4:	29 85       	ldd	r18, Y+9	; 0x09
    39b6:	3a 85       	ldd	r19, Y+10	; 0x0a
    39b8:	89 81       	ldd	r24, Y+1	; 0x01
    39ba:	9a 81       	ldd	r25, Y+2	; 0x02
    39bc:	28 1b       	sub	r18, r24
    39be:	39 0b       	sbc	r19, r25
    39c0:	cb 01       	movw	r24, r22
    39c2:	ba 01       	movw	r22, r20
    39c4:	a9 01       	movw	r20, r18
    39c6:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    39ca:	2b 81       	ldd	r18, Y+3	; 0x03
    39cc:	3c 81       	ldd	r19, Y+4	; 0x04
    39ce:	89 85       	ldd	r24, Y+9	; 0x09
    39d0:	9a 85       	ldd	r25, Y+10	; 0x0a
    39d2:	82 0f       	add	r24, r18
    39d4:	93 1f       	adc	r25, r19
    39d6:	9c 83       	std	Y+4, r25	; 0x04
    39d8:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    39da:	ed 81       	ldd	r30, Y+5	; 0x05
    39dc:	fe 81       	ldd	r31, Y+6	; 0x06
    39de:	24 81       	ldd	r18, Z+4	; 0x04
    39e0:	35 81       	ldd	r19, Z+5	; 0x05
    39e2:	8b 81       	ldd	r24, Y+3	; 0x03
    39e4:	9c 81       	ldd	r25, Y+4	; 0x04
    39e6:	82 17       	cp	r24, r18
    39e8:	93 07       	cpc	r25, r19
    39ea:	50 f0       	brcs	.+20     	; 0x3a00 <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    39ec:	ed 81       	ldd	r30, Y+5	; 0x05
    39ee:	fe 81       	ldd	r31, Y+6	; 0x06
    39f0:	24 81       	ldd	r18, Z+4	; 0x04
    39f2:	35 81       	ldd	r19, Z+5	; 0x05
    39f4:	8b 81       	ldd	r24, Y+3	; 0x03
    39f6:	9c 81       	ldd	r25, Y+4	; 0x04
    39f8:	82 1b       	sub	r24, r18
    39fa:	93 0b       	sbc	r25, r19
    39fc:	9c 83       	std	Y+4, r25	; 0x04
    39fe:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    3a00:	ed 81       	ldd	r30, Y+5	; 0x05
    3a02:	fe 81       	ldd	r31, Y+6	; 0x06
    3a04:	8b 81       	ldd	r24, Y+3	; 0x03
    3a06:	9c 81       	ldd	r25, Y+4	; 0x04
    3a08:	93 83       	std	Z+3, r25	; 0x03
    3a0a:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    3a0c:	89 85       	ldd	r24, Y+9	; 0x09
    3a0e:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    3a10:	2e 96       	adiw	r28, 0x0e	; 14
    3a12:	0f b6       	in	r0, 0x3f	; 63
    3a14:	f8 94       	cli
    3a16:	de bf       	out	0x3e, r29	; 62
    3a18:	0f be       	out	0x3f, r0	; 63
    3a1a:	cd bf       	out	0x3d, r28	; 61
    3a1c:	cf 91       	pop	r28
    3a1e:	df 91       	pop	r29
    3a20:	08 95       	ret

00003a22 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    3a22:	df 93       	push	r29
    3a24:	cf 93       	push	r28
    3a26:	cd b7       	in	r28, 0x3d	; 61
    3a28:	de b7       	in	r29, 0x3e	; 62
    3a2a:	66 97       	sbiw	r28, 0x16	; 22
    3a2c:	0f b6       	in	r0, 0x3f	; 63
    3a2e:	f8 94       	cli
    3a30:	de bf       	out	0x3e, r29	; 62
    3a32:	0f be       	out	0x3f, r0	; 63
    3a34:	cd bf       	out	0x3d, r28	; 61
    3a36:	98 87       	std	Y+8, r25	; 0x08
    3a38:	8f 83       	std	Y+7, r24	; 0x07
    3a3a:	7a 87       	std	Y+10, r23	; 0x0a
    3a3c:	69 87       	std	Y+9, r22	; 0x09
    3a3e:	5c 87       	std	Y+12, r21	; 0x0c
    3a40:	4b 87       	std	Y+11, r20	; 0x0b
    3a42:	3e 87       	std	Y+14, r19	; 0x0e
    3a44:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    3a46:	2d 85       	ldd	r18, Y+13	; 0x0d
    3a48:	3e 85       	ldd	r19, Y+14	; 0x0e
    3a4a:	3a 8b       	std	Y+18, r19	; 0x12
    3a4c:	29 8b       	std	Y+17, r18	; 0x11
    3a4e:	4b 85       	ldd	r20, Y+11	; 0x0b
    3a50:	5c 85       	ldd	r21, Y+12	; 0x0c
    3a52:	58 8b       	std	Y+16, r21	; 0x10
    3a54:	4f 87       	std	Y+15, r20	; 0x0f
    3a56:	8f 85       	ldd	r24, Y+15	; 0x0f
    3a58:	98 89       	ldd	r25, Y+16	; 0x10
    3a5a:	29 89       	ldd	r18, Y+17	; 0x11
    3a5c:	3a 89       	ldd	r19, Y+18	; 0x12
    3a5e:	28 17       	cp	r18, r24
    3a60:	39 07       	cpc	r19, r25
    3a62:	20 f4       	brcc	.+8      	; 0x3a6c <prvReadBytesFromBuffer+0x4a>
    3a64:	49 89       	ldd	r20, Y+17	; 0x11
    3a66:	5a 89       	ldd	r21, Y+18	; 0x12
    3a68:	58 8b       	std	Y+16, r21	; 0x10
    3a6a:	4f 87       	std	Y+15, r20	; 0x0f
    3a6c:	8f 85       	ldd	r24, Y+15	; 0x0f
    3a6e:	98 89       	ldd	r25, Y+16	; 0x10
    3a70:	9e 83       	std	Y+6, r25	; 0x06
    3a72:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    3a74:	8d 81       	ldd	r24, Y+5	; 0x05
    3a76:	9e 81       	ldd	r25, Y+6	; 0x06
    3a78:	00 97       	sbiw	r24, 0x00	; 0
    3a7a:	09 f4       	brne	.+2      	; 0x3a7e <prvReadBytesFromBuffer+0x5c>
    3a7c:	74 c0       	rjmp	.+232    	; 0x3b66 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    3a7e:	ef 81       	ldd	r30, Y+7	; 0x07
    3a80:	f8 85       	ldd	r31, Y+8	; 0x08
    3a82:	80 81       	ld	r24, Z
    3a84:	91 81       	ldd	r25, Z+1	; 0x01
    3a86:	9a 83       	std	Y+2, r25	; 0x02
    3a88:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    3a8a:	ef 81       	ldd	r30, Y+7	; 0x07
    3a8c:	f8 85       	ldd	r31, Y+8	; 0x08
    3a8e:	24 81       	ldd	r18, Z+4	; 0x04
    3a90:	35 81       	ldd	r19, Z+5	; 0x05
    3a92:	89 81       	ldd	r24, Y+1	; 0x01
    3a94:	9a 81       	ldd	r25, Y+2	; 0x02
    3a96:	a9 01       	movw	r20, r18
    3a98:	48 1b       	sub	r20, r24
    3a9a:	59 0b       	sbc	r21, r25
    3a9c:	ca 01       	movw	r24, r20
    3a9e:	2d 81       	ldd	r18, Y+5	; 0x05
    3aa0:	3e 81       	ldd	r19, Y+6	; 0x06
    3aa2:	3e 8b       	std	Y+22, r19	; 0x16
    3aa4:	2d 8b       	std	Y+21, r18	; 0x15
    3aa6:	9c 8b       	std	Y+20, r25	; 0x14
    3aa8:	8b 8b       	std	Y+19, r24	; 0x13
    3aaa:	4b 89       	ldd	r20, Y+19	; 0x13
    3aac:	5c 89       	ldd	r21, Y+20	; 0x14
    3aae:	8d 89       	ldd	r24, Y+21	; 0x15
    3ab0:	9e 89       	ldd	r25, Y+22	; 0x16
    3ab2:	84 17       	cp	r24, r20
    3ab4:	95 07       	cpc	r25, r21
    3ab6:	20 f4       	brcc	.+8      	; 0x3ac0 <prvReadBytesFromBuffer+0x9e>
    3ab8:	2d 89       	ldd	r18, Y+21	; 0x15
    3aba:	3e 89       	ldd	r19, Y+22	; 0x16
    3abc:	3c 8b       	std	Y+20, r19	; 0x14
    3abe:	2b 8b       	std	Y+19, r18	; 0x13
    3ac0:	4b 89       	ldd	r20, Y+19	; 0x13
    3ac2:	5c 89       	ldd	r21, Y+20	; 0x14
    3ac4:	5c 83       	std	Y+4, r21	; 0x04
    3ac6:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3ac8:	ef 81       	ldd	r30, Y+7	; 0x07
    3aca:	f8 85       	ldd	r31, Y+8	; 0x08
    3acc:	24 85       	ldd	r18, Z+12	; 0x0c
    3ace:	35 85       	ldd	r19, Z+13	; 0x0d
    3ad0:	89 81       	ldd	r24, Y+1	; 0x01
    3ad2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad4:	a9 01       	movw	r20, r18
    3ad6:	48 0f       	add	r20, r24
    3ad8:	59 1f       	adc	r21, r25
    3ada:	89 85       	ldd	r24, Y+9	; 0x09
    3adc:	9a 85       	ldd	r25, Y+10	; 0x0a
    3ade:	2b 81       	ldd	r18, Y+3	; 0x03
    3ae0:	3c 81       	ldd	r19, Y+4	; 0x04
    3ae2:	ba 01       	movw	r22, r20
    3ae4:	a9 01       	movw	r20, r18
    3ae6:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    3aea:	2d 81       	ldd	r18, Y+5	; 0x05
    3aec:	3e 81       	ldd	r19, Y+6	; 0x06
    3aee:	8b 81       	ldd	r24, Y+3	; 0x03
    3af0:	9c 81       	ldd	r25, Y+4	; 0x04
    3af2:	82 17       	cp	r24, r18
    3af4:	93 07       	cpc	r25, r19
    3af6:	b0 f4       	brcc	.+44     	; 0x3b24 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3af8:	29 85       	ldd	r18, Y+9	; 0x09
    3afa:	3a 85       	ldd	r19, Y+10	; 0x0a
    3afc:	8b 81       	ldd	r24, Y+3	; 0x03
    3afe:	9c 81       	ldd	r25, Y+4	; 0x04
    3b00:	b9 01       	movw	r22, r18
    3b02:	68 0f       	add	r22, r24
    3b04:	79 1f       	adc	r23, r25
    3b06:	ef 81       	ldd	r30, Y+7	; 0x07
    3b08:	f8 85       	ldd	r31, Y+8	; 0x08
    3b0a:	44 85       	ldd	r20, Z+12	; 0x0c
    3b0c:	55 85       	ldd	r21, Z+13	; 0x0d
    3b0e:	2d 81       	ldd	r18, Y+5	; 0x05
    3b10:	3e 81       	ldd	r19, Y+6	; 0x06
    3b12:	8b 81       	ldd	r24, Y+3	; 0x03
    3b14:	9c 81       	ldd	r25, Y+4	; 0x04
    3b16:	28 1b       	sub	r18, r24
    3b18:	39 0b       	sbc	r19, r25
    3b1a:	cb 01       	movw	r24, r22
    3b1c:	ba 01       	movw	r22, r20
    3b1e:	a9 01       	movw	r20, r18
    3b20:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    3b24:	29 81       	ldd	r18, Y+1	; 0x01
    3b26:	3a 81       	ldd	r19, Y+2	; 0x02
    3b28:	8d 81       	ldd	r24, Y+5	; 0x05
    3b2a:	9e 81       	ldd	r25, Y+6	; 0x06
    3b2c:	82 0f       	add	r24, r18
    3b2e:	93 1f       	adc	r25, r19
    3b30:	9a 83       	std	Y+2, r25	; 0x02
    3b32:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    3b34:	ef 81       	ldd	r30, Y+7	; 0x07
    3b36:	f8 85       	ldd	r31, Y+8	; 0x08
    3b38:	24 81       	ldd	r18, Z+4	; 0x04
    3b3a:	35 81       	ldd	r19, Z+5	; 0x05
    3b3c:	89 81       	ldd	r24, Y+1	; 0x01
    3b3e:	9a 81       	ldd	r25, Y+2	; 0x02
    3b40:	82 17       	cp	r24, r18
    3b42:	93 07       	cpc	r25, r19
    3b44:	50 f0       	brcs	.+20     	; 0x3b5a <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    3b46:	ef 81       	ldd	r30, Y+7	; 0x07
    3b48:	f8 85       	ldd	r31, Y+8	; 0x08
    3b4a:	24 81       	ldd	r18, Z+4	; 0x04
    3b4c:	35 81       	ldd	r19, Z+5	; 0x05
    3b4e:	89 81       	ldd	r24, Y+1	; 0x01
    3b50:	9a 81       	ldd	r25, Y+2	; 0x02
    3b52:	82 1b       	sub	r24, r18
    3b54:	93 0b       	sbc	r25, r19
    3b56:	9a 83       	std	Y+2, r25	; 0x02
    3b58:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    3b5a:	ef 81       	ldd	r30, Y+7	; 0x07
    3b5c:	f8 85       	ldd	r31, Y+8	; 0x08
    3b5e:	89 81       	ldd	r24, Y+1	; 0x01
    3b60:	9a 81       	ldd	r25, Y+2	; 0x02
    3b62:	91 83       	std	Z+1, r25	; 0x01
    3b64:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    3b66:	8d 81       	ldd	r24, Y+5	; 0x05
    3b68:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3b6a:	66 96       	adiw	r28, 0x16	; 22
    3b6c:	0f b6       	in	r0, 0x3f	; 63
    3b6e:	f8 94       	cli
    3b70:	de bf       	out	0x3e, r29	; 62
    3b72:	0f be       	out	0x3f, r0	; 63
    3b74:	cd bf       	out	0x3d, r28	; 61
    3b76:	cf 91       	pop	r28
    3b78:	df 91       	pop	r29
    3b7a:	08 95       	ret

00003b7c <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    3b7c:	df 93       	push	r29
    3b7e:	cf 93       	push	r28
    3b80:	00 d0       	rcall	.+0      	; 0x3b82 <prvBytesInBuffer+0x6>
    3b82:	00 d0       	rcall	.+0      	; 0x3b84 <prvBytesInBuffer+0x8>
    3b84:	cd b7       	in	r28, 0x3d	; 61
    3b86:	de b7       	in	r29, 0x3e	; 62
    3b88:	9c 83       	std	Y+4, r25	; 0x04
    3b8a:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    3b8c:	eb 81       	ldd	r30, Y+3	; 0x03
    3b8e:	fc 81       	ldd	r31, Y+4	; 0x04
    3b90:	24 81       	ldd	r18, Z+4	; 0x04
    3b92:	35 81       	ldd	r19, Z+5	; 0x05
    3b94:	eb 81       	ldd	r30, Y+3	; 0x03
    3b96:	fc 81       	ldd	r31, Y+4	; 0x04
    3b98:	82 81       	ldd	r24, Z+2	; 0x02
    3b9a:	93 81       	ldd	r25, Z+3	; 0x03
    3b9c:	82 0f       	add	r24, r18
    3b9e:	93 1f       	adc	r25, r19
    3ba0:	9a 83       	std	Y+2, r25	; 0x02
    3ba2:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    3ba4:	eb 81       	ldd	r30, Y+3	; 0x03
    3ba6:	fc 81       	ldd	r31, Y+4	; 0x04
    3ba8:	20 81       	ld	r18, Z
    3baa:	31 81       	ldd	r19, Z+1	; 0x01
    3bac:	89 81       	ldd	r24, Y+1	; 0x01
    3bae:	9a 81       	ldd	r25, Y+2	; 0x02
    3bb0:	82 1b       	sub	r24, r18
    3bb2:	93 0b       	sbc	r25, r19
    3bb4:	9a 83       	std	Y+2, r25	; 0x02
    3bb6:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    3bb8:	eb 81       	ldd	r30, Y+3	; 0x03
    3bba:	fc 81       	ldd	r31, Y+4	; 0x04
    3bbc:	24 81       	ldd	r18, Z+4	; 0x04
    3bbe:	35 81       	ldd	r19, Z+5	; 0x05
    3bc0:	89 81       	ldd	r24, Y+1	; 0x01
    3bc2:	9a 81       	ldd	r25, Y+2	; 0x02
    3bc4:	82 17       	cp	r24, r18
    3bc6:	93 07       	cpc	r25, r19
    3bc8:	50 f0       	brcs	.+20     	; 0x3bde <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    3bca:	eb 81       	ldd	r30, Y+3	; 0x03
    3bcc:	fc 81       	ldd	r31, Y+4	; 0x04
    3bce:	24 81       	ldd	r18, Z+4	; 0x04
    3bd0:	35 81       	ldd	r19, Z+5	; 0x05
    3bd2:	89 81       	ldd	r24, Y+1	; 0x01
    3bd4:	9a 81       	ldd	r25, Y+2	; 0x02
    3bd6:	82 1b       	sub	r24, r18
    3bd8:	93 0b       	sbc	r25, r19
    3bda:	9a 83       	std	Y+2, r25	; 0x02
    3bdc:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    3bde:	89 81       	ldd	r24, Y+1	; 0x01
    3be0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3be2:	0f 90       	pop	r0
    3be4:	0f 90       	pop	r0
    3be6:	0f 90       	pop	r0
    3be8:	0f 90       	pop	r0
    3bea:	cf 91       	pop	r28
    3bec:	df 91       	pop	r29
    3bee:	08 95       	ret

00003bf0 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    3bf0:	0f 93       	push	r16
    3bf2:	df 93       	push	r29
    3bf4:	cf 93       	push	r28
    3bf6:	cd b7       	in	r28, 0x3d	; 61
    3bf8:	de b7       	in	r29, 0x3e	; 62
    3bfa:	29 97       	sbiw	r28, 0x09	; 9
    3bfc:	0f b6       	in	r0, 0x3f	; 63
    3bfe:	f8 94       	cli
    3c00:	de bf       	out	0x3e, r29	; 62
    3c02:	0f be       	out	0x3f, r0	; 63
    3c04:	cd bf       	out	0x3d, r28	; 61
    3c06:	9a 83       	std	Y+2, r25	; 0x02
    3c08:	89 83       	std	Y+1, r24	; 0x01
    3c0a:	7c 83       	std	Y+4, r23	; 0x04
    3c0c:	6b 83       	std	Y+3, r22	; 0x03
    3c0e:	5e 83       	std	Y+6, r21	; 0x06
    3c10:	4d 83       	std	Y+5, r20	; 0x05
    3c12:	38 87       	std	Y+8, r19	; 0x08
    3c14:	2f 83       	std	Y+7, r18	; 0x07
    3c16:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    3c18:	89 81       	ldd	r24, Y+1	; 0x01
    3c1a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c1c:	60 e0       	ldi	r22, 0x00	; 0
    3c1e:	70 e0       	ldi	r23, 0x00	; 0
    3c20:	4f e0       	ldi	r20, 0x0F	; 15
    3c22:	50 e0       	ldi	r21, 0x00	; 0
    3c24:	0e 94 26 2d 	call	0x5a4c	; 0x5a4c <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    3c28:	e9 81       	ldd	r30, Y+1	; 0x01
    3c2a:	fa 81       	ldd	r31, Y+2	; 0x02
    3c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c30:	95 87       	std	Z+13, r25	; 0x0d
    3c32:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    3c34:	e9 81       	ldd	r30, Y+1	; 0x01
    3c36:	fa 81       	ldd	r31, Y+2	; 0x02
    3c38:	8d 81       	ldd	r24, Y+5	; 0x05
    3c3a:	9e 81       	ldd	r25, Y+6	; 0x06
    3c3c:	95 83       	std	Z+5, r25	; 0x05
    3c3e:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    3c40:	e9 81       	ldd	r30, Y+1	; 0x01
    3c42:	fa 81       	ldd	r31, Y+2	; 0x02
    3c44:	8f 81       	ldd	r24, Y+7	; 0x07
    3c46:	98 85       	ldd	r25, Y+8	; 0x08
    3c48:	97 83       	std	Z+7, r25	; 0x07
    3c4a:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    3c4c:	e9 81       	ldd	r30, Y+1	; 0x01
    3c4e:	fa 81       	ldd	r31, Y+2	; 0x02
    3c50:	89 85       	ldd	r24, Y+9	; 0x09
    3c52:	86 87       	std	Z+14, r24	; 0x0e
}
    3c54:	29 96       	adiw	r28, 0x09	; 9
    3c56:	0f b6       	in	r0, 0x3f	; 63
    3c58:	f8 94       	cli
    3c5a:	de bf       	out	0x3e, r29	; 62
    3c5c:	0f be       	out	0x3f, r0	; 63
    3c5e:	cd bf       	out	0x3d, r28	; 61
    3c60:	cf 91       	pop	r28
    3c62:	df 91       	pop	r29
    3c64:	0f 91       	pop	r16
    3c66:	08 95       	ret

00003c68 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    3c68:	8f 92       	push	r8
    3c6a:	9f 92       	push	r9
    3c6c:	af 92       	push	r10
    3c6e:	bf 92       	push	r11
    3c70:	cf 92       	push	r12
    3c72:	df 92       	push	r13
    3c74:	ef 92       	push	r14
    3c76:	ff 92       	push	r15
    3c78:	0f 93       	push	r16
    3c7a:	1f 93       	push	r17
    3c7c:	df 93       	push	r29
    3c7e:	cf 93       	push	r28
    3c80:	cd b7       	in	r28, 0x3d	; 61
    3c82:	de b7       	in	r29, 0x3e	; 62
    3c84:	60 97       	sbiw	r28, 0x10	; 16
    3c86:	0f b6       	in	r0, 0x3f	; 63
    3c88:	f8 94       	cli
    3c8a:	de bf       	out	0x3e, r29	; 62
    3c8c:	0f be       	out	0x3f, r0	; 63
    3c8e:	cd bf       	out	0x3d, r28	; 61
    3c90:	9f 83       	std	Y+7, r25	; 0x07
    3c92:	8e 83       	std	Y+6, r24	; 0x06
    3c94:	79 87       	std	Y+9, r23	; 0x09
    3c96:	68 87       	std	Y+8, r22	; 0x08
    3c98:	5b 87       	std	Y+11, r21	; 0x0b
    3c9a:	4a 87       	std	Y+10, r20	; 0x0a
    3c9c:	3d 87       	std	Y+13, r19	; 0x0d
    3c9e:	2c 87       	std	Y+12, r18	; 0x0c
    3ca0:	0e 87       	std	Y+14, r16	; 0x0e
    3ca2:	f8 8a       	std	Y+16, r15	; 0x10
    3ca4:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3ca6:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ca8:	9b 85       	ldd	r25, Y+11	; 0x0b
    3caa:	0e 94 a8 08 	call	0x1150	; 0x1150 <pvPortMalloc>
    3cae:	9a 83       	std	Y+2, r25	; 0x02
    3cb0:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    3cb2:	89 81       	ldd	r24, Y+1	; 0x01
    3cb4:	9a 81       	ldd	r25, Y+2	; 0x02
    3cb6:	00 97       	sbiw	r24, 0x00	; 0
    3cb8:	b1 f0       	breq	.+44     	; 0x3ce6 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3cba:	84 e3       	ldi	r24, 0x34	; 52
    3cbc:	90 e0       	ldi	r25, 0x00	; 0
    3cbe:	0e 94 a8 08 	call	0x1150	; 0x1150 <pvPortMalloc>
    3cc2:	9d 83       	std	Y+5, r25	; 0x05
    3cc4:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    3cc6:	8c 81       	ldd	r24, Y+4	; 0x04
    3cc8:	9d 81       	ldd	r25, Y+5	; 0x05
    3cca:	00 97       	sbiw	r24, 0x00	; 0
    3ccc:	39 f0       	breq	.+14     	; 0x3cdc <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    3cce:	ec 81       	ldd	r30, Y+4	; 0x04
    3cd0:	fd 81       	ldd	r31, Y+5	; 0x05
    3cd2:	89 81       	ldd	r24, Y+1	; 0x01
    3cd4:	9a 81       	ldd	r25, Y+2	; 0x02
    3cd6:	90 8f       	std	Z+24, r25	; 0x18
    3cd8:	87 8b       	std	Z+23, r24	; 0x17
    3cda:	07 c0       	rjmp	.+14     	; 0x3cea <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    3cdc:	89 81       	ldd	r24, Y+1	; 0x01
    3cde:	9a 81       	ldd	r25, Y+2	; 0x02
    3ce0:	0e 94 fe 08 	call	0x11fc	; 0x11fc <vPortFree>
    3ce4:	02 c0       	rjmp	.+4      	; 0x3cea <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    3ce6:	1d 82       	std	Y+5, r1	; 0x05
    3ce8:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    3cea:	8c 81       	ldd	r24, Y+4	; 0x04
    3cec:	9d 81       	ldd	r25, Y+5	; 0x05
    3cee:	00 97       	sbiw	r24, 0x00	; 0
    3cf0:	e9 f0       	breq	.+58     	; 0x3d2c <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3cf2:	8a 85       	ldd	r24, Y+10	; 0x0a
    3cf4:	9b 85       	ldd	r25, Y+11	; 0x0b
    3cf6:	9c 01       	movw	r18, r24
    3cf8:	40 e0       	ldi	r20, 0x00	; 0
    3cfa:	50 e0       	ldi	r21, 0x00	; 0
    3cfc:	8e 81       	ldd	r24, Y+6	; 0x06
    3cfe:	9f 81       	ldd	r25, Y+7	; 0x07
    3d00:	68 85       	ldd	r22, Y+8	; 0x08
    3d02:	79 85       	ldd	r23, Y+9	; 0x09
    3d04:	ec 85       	ldd	r30, Y+12	; 0x0c
    3d06:	fd 85       	ldd	r31, Y+13	; 0x0d
    3d08:	af 85       	ldd	r26, Y+15	; 0x0f
    3d0a:	b8 89       	ldd	r27, Y+16	; 0x10
    3d0c:	ac 80       	ldd	r10, Y+4	; 0x04
    3d0e:	bd 80       	ldd	r11, Y+5	; 0x05
    3d10:	8f 01       	movw	r16, r30
    3d12:	ee 84       	ldd	r14, Y+14	; 0x0e
    3d14:	6d 01       	movw	r12, r26
    3d16:	88 24       	eor	r8, r8
    3d18:	99 24       	eor	r9, r9
    3d1a:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    3d1e:	8c 81       	ldd	r24, Y+4	; 0x04
    3d20:	9d 81       	ldd	r25, Y+5	; 0x05
    3d22:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    3d26:	81 e0       	ldi	r24, 0x01	; 1
    3d28:	8b 83       	std	Y+3, r24	; 0x03
    3d2a:	02 c0       	rjmp	.+4      	; 0x3d30 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3d2c:	8f ef       	ldi	r24, 0xFF	; 255
    3d2e:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    3d30:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3d32:	60 96       	adiw	r28, 0x10	; 16
    3d34:	0f b6       	in	r0, 0x3f	; 63
    3d36:	f8 94       	cli
    3d38:	de bf       	out	0x3e, r29	; 62
    3d3a:	0f be       	out	0x3f, r0	; 63
    3d3c:	cd bf       	out	0x3d, r28	; 61
    3d3e:	cf 91       	pop	r28
    3d40:	df 91       	pop	r29
    3d42:	1f 91       	pop	r17
    3d44:	0f 91       	pop	r16
    3d46:	ff 90       	pop	r15
    3d48:	ef 90       	pop	r14
    3d4a:	df 90       	pop	r13
    3d4c:	cf 90       	pop	r12
    3d4e:	bf 90       	pop	r11
    3d50:	af 90       	pop	r10
    3d52:	9f 90       	pop	r9
    3d54:	8f 90       	pop	r8
    3d56:	08 95       	ret

00003d58 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    3d58:	8f 92       	push	r8
    3d5a:	9f 92       	push	r9
    3d5c:	af 92       	push	r10
    3d5e:	bf 92       	push	r11
    3d60:	cf 92       	push	r12
    3d62:	df 92       	push	r13
    3d64:	ef 92       	push	r14
    3d66:	0f 93       	push	r16
    3d68:	1f 93       	push	r17
    3d6a:	df 93       	push	r29
    3d6c:	cf 93       	push	r28
    3d6e:	cd b7       	in	r28, 0x3d	; 61
    3d70:	de b7       	in	r29, 0x3e	; 62
    3d72:	64 97       	sbiw	r28, 0x14	; 20
    3d74:	0f b6       	in	r0, 0x3f	; 63
    3d76:	f8 94       	cli
    3d78:	de bf       	out	0x3e, r29	; 62
    3d7a:	0f be       	out	0x3f, r0	; 63
    3d7c:	cd bf       	out	0x3d, r28	; 61
    3d7e:	9d 83       	std	Y+5, r25	; 0x05
    3d80:	8c 83       	std	Y+4, r24	; 0x04
    3d82:	7f 83       	std	Y+7, r23	; 0x07
    3d84:	6e 83       	std	Y+6, r22	; 0x06
    3d86:	28 87       	std	Y+8, r18	; 0x08
    3d88:	39 87       	std	Y+9, r19	; 0x09
    3d8a:	4a 87       	std	Y+10, r20	; 0x0a
    3d8c:	5b 87       	std	Y+11, r21	; 0x0b
    3d8e:	1d 87       	std	Y+13, r17	; 0x0d
    3d90:	0c 87       	std	Y+12, r16	; 0x0c
    3d92:	ee 86       	std	Y+14, r14	; 0x0e
    3d94:	d8 8a       	std	Y+16, r13	; 0x10
    3d96:	cf 86       	std	Y+15, r12	; 0x0f
    3d98:	ba 8a       	std	Y+18, r11	; 0x12
    3d9a:	a9 8a       	std	Y+17, r10	; 0x11
    3d9c:	9c 8a       	std	Y+20, r9	; 0x14
    3d9e:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3da0:	e9 89       	ldd	r30, Y+17	; 0x11
    3da2:	fa 89       	ldd	r31, Y+18	; 0x12
    3da4:	27 89       	ldd	r18, Z+23	; 0x17
    3da6:	30 8d       	ldd	r19, Z+24	; 0x18
    3da8:	88 85       	ldd	r24, Y+8	; 0x08
    3daa:	99 85       	ldd	r25, Y+9	; 0x09
    3dac:	01 97       	sbiw	r24, 0x01	; 1
    3dae:	82 0f       	add	r24, r18
    3db0:	93 1f       	adc	r25, r19
    3db2:	9b 83       	std	Y+3, r25	; 0x03
    3db4:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    3db6:	8e 81       	ldd	r24, Y+6	; 0x06
    3db8:	9f 81       	ldd	r25, Y+7	; 0x07
    3dba:	00 97       	sbiw	r24, 0x00	; 0
    3dbc:	51 f1       	breq	.+84     	; 0x3e12 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3dbe:	19 82       	std	Y+1, r1	; 0x01
    3dc0:	21 c0       	rjmp	.+66     	; 0x3e04 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3dc2:	89 81       	ldd	r24, Y+1	; 0x01
    3dc4:	48 2f       	mov	r20, r24
    3dc6:	50 e0       	ldi	r21, 0x00	; 0
    3dc8:	89 81       	ldd	r24, Y+1	; 0x01
    3dca:	28 2f       	mov	r18, r24
    3dcc:	30 e0       	ldi	r19, 0x00	; 0
    3dce:	8e 81       	ldd	r24, Y+6	; 0x06
    3dd0:	9f 81       	ldd	r25, Y+7	; 0x07
    3dd2:	fc 01       	movw	r30, r24
    3dd4:	e2 0f       	add	r30, r18
    3dd6:	f3 1f       	adc	r31, r19
    3dd8:	20 81       	ld	r18, Z
    3dda:	89 89       	ldd	r24, Y+17	; 0x11
    3ddc:	9a 89       	ldd	r25, Y+18	; 0x12
    3dde:	84 0f       	add	r24, r20
    3de0:	95 1f       	adc	r25, r21
    3de2:	fc 01       	movw	r30, r24
    3de4:	79 96       	adiw	r30, 0x19	; 25
    3de6:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3de8:	89 81       	ldd	r24, Y+1	; 0x01
    3dea:	28 2f       	mov	r18, r24
    3dec:	30 e0       	ldi	r19, 0x00	; 0
    3dee:	8e 81       	ldd	r24, Y+6	; 0x06
    3df0:	9f 81       	ldd	r25, Y+7	; 0x07
    3df2:	fc 01       	movw	r30, r24
    3df4:	e2 0f       	add	r30, r18
    3df6:	f3 1f       	adc	r31, r19
    3df8:	80 81       	ld	r24, Z
    3dfa:	88 23       	and	r24, r24
    3dfc:	31 f0       	breq	.+12     	; 0x3e0a <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3dfe:	89 81       	ldd	r24, Y+1	; 0x01
    3e00:	8f 5f       	subi	r24, 0xFF	; 255
    3e02:	89 83       	std	Y+1, r24	; 0x01
    3e04:	89 81       	ldd	r24, Y+1	; 0x01
    3e06:	84 31       	cpi	r24, 0x14	; 20
    3e08:	e0 f2       	brcs	.-72     	; 0x3dc2 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3e0a:	e9 89       	ldd	r30, Y+17	; 0x11
    3e0c:	fa 89       	ldd	r31, Y+18	; 0x12
    3e0e:	14 a6       	std	Z+44, r1	; 0x2c
    3e10:	03 c0       	rjmp	.+6      	; 0x3e18 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3e12:	e9 89       	ldd	r30, Y+17	; 0x11
    3e14:	fa 89       	ldd	r31, Y+18	; 0x12
    3e16:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3e18:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e1a:	87 30       	cpi	r24, 0x07	; 7
    3e1c:	10 f0       	brcs	.+4      	; 0x3e22 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3e1e:	86 e0       	ldi	r24, 0x06	; 6
    3e20:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    3e22:	e9 89       	ldd	r30, Y+17	; 0x11
    3e24:	fa 89       	ldd	r31, Y+18	; 0x12
    3e26:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e28:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    3e2a:	e9 89       	ldd	r30, Y+17	; 0x11
    3e2c:	fa 89       	ldd	r31, Y+18	; 0x12
    3e2e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e30:	85 a7       	std	Z+45, r24	; 0x2d
		pxNewTCB->uxMutexesHeld = 0;
    3e32:	e9 89       	ldd	r30, Y+17	; 0x11
    3e34:	fa 89       	ldd	r31, Y+18	; 0x12
    3e36:	16 a6       	std	Z+46, r1	; 0x2e
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3e38:	89 89       	ldd	r24, Y+17	; 0x11
    3e3a:	9a 89       	ldd	r25, Y+18	; 0x12
    3e3c:	02 96       	adiw	r24, 0x02	; 2
    3e3e:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3e42:	89 89       	ldd	r24, Y+17	; 0x11
    3e44:	9a 89       	ldd	r25, Y+18	; 0x12
    3e46:	0c 96       	adiw	r24, 0x0c	; 12
    3e48:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3e4c:	e9 89       	ldd	r30, Y+17	; 0x11
    3e4e:	fa 89       	ldd	r31, Y+18	; 0x12
    3e50:	89 89       	ldd	r24, Y+17	; 0x11
    3e52:	9a 89       	ldd	r25, Y+18	; 0x12
    3e54:	91 87       	std	Z+9, r25	; 0x09
    3e56:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3e58:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e5a:	28 2f       	mov	r18, r24
    3e5c:	30 e0       	ldi	r19, 0x00	; 0
    3e5e:	87 e0       	ldi	r24, 0x07	; 7
    3e60:	90 e0       	ldi	r25, 0x00	; 0
    3e62:	82 1b       	sub	r24, r18
    3e64:	93 0b       	sbc	r25, r19
    3e66:	e9 89       	ldd	r30, Y+17	; 0x11
    3e68:	fa 89       	ldd	r31, Y+18	; 0x12
    3e6a:	95 87       	std	Z+13, r25	; 0x0d
    3e6c:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3e6e:	e9 89       	ldd	r30, Y+17	; 0x11
    3e70:	fa 89       	ldd	r31, Y+18	; 0x12
    3e72:	89 89       	ldd	r24, Y+17	; 0x11
    3e74:	9a 89       	ldd	r25, Y+18	; 0x12
    3e76:	93 8b       	std	Z+19, r25	; 0x13
    3e78:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    3e7a:	e9 89       	ldd	r30, Y+17	; 0x11
    3e7c:	fa 89       	ldd	r31, Y+18	; 0x12
    3e7e:	17 a6       	std	Z+47, r1	; 0x2f
    3e80:	10 aa       	std	Z+48, r1	; 0x30
    3e82:	11 aa       	std	Z+49, r1	; 0x31
    3e84:	12 aa       	std	Z+50, r1	; 0x32
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3e86:	e9 89       	ldd	r30, Y+17	; 0x11
    3e88:	fa 89       	ldd	r31, Y+18	; 0x12
    3e8a:	13 aa       	std	Z+51, r1	; 0x33
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3e8c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e8e:	9b 81       	ldd	r25, Y+3	; 0x03
    3e90:	2c 81       	ldd	r18, Y+4	; 0x04
    3e92:	3d 81       	ldd	r19, Y+5	; 0x05
    3e94:	4c 85       	ldd	r20, Y+12	; 0x0c
    3e96:	5d 85       	ldd	r21, Y+13	; 0x0d
    3e98:	b9 01       	movw	r22, r18
    3e9a:	0e 94 00 0c 	call	0x1800	; 0x1800 <pxPortInitialiseStack>
    3e9e:	e9 89       	ldd	r30, Y+17	; 0x11
    3ea0:	fa 89       	ldd	r31, Y+18	; 0x12
    3ea2:	91 83       	std	Z+1, r25	; 0x01
    3ea4:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    3ea6:	8f 85       	ldd	r24, Y+15	; 0x0f
    3ea8:	98 89       	ldd	r25, Y+16	; 0x10
    3eaa:	00 97       	sbiw	r24, 0x00	; 0
    3eac:	31 f0       	breq	.+12     	; 0x3eba <prvInitialiseNewTask+0x162>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3eae:	ef 85       	ldd	r30, Y+15	; 0x0f
    3eb0:	f8 89       	ldd	r31, Y+16	; 0x10
    3eb2:	89 89       	ldd	r24, Y+17	; 0x11
    3eb4:	9a 89       	ldd	r25, Y+18	; 0x12
    3eb6:	91 83       	std	Z+1, r25	; 0x01
    3eb8:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3eba:	64 96       	adiw	r28, 0x14	; 20
    3ebc:	0f b6       	in	r0, 0x3f	; 63
    3ebe:	f8 94       	cli
    3ec0:	de bf       	out	0x3e, r29	; 62
    3ec2:	0f be       	out	0x3f, r0	; 63
    3ec4:	cd bf       	out	0x3d, r28	; 61
    3ec6:	cf 91       	pop	r28
    3ec8:	df 91       	pop	r29
    3eca:	1f 91       	pop	r17
    3ecc:	0f 91       	pop	r16
    3ece:	ef 90       	pop	r14
    3ed0:	df 90       	pop	r13
    3ed2:	cf 90       	pop	r12
    3ed4:	bf 90       	pop	r11
    3ed6:	af 90       	pop	r10
    3ed8:	9f 90       	pop	r9
    3eda:	8f 90       	pop	r8
    3edc:	08 95       	ret

00003ede <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    3ede:	df 93       	push	r29
    3ee0:	cf 93       	push	r28
    3ee2:	00 d0       	rcall	.+0      	; 0x3ee4 <prvAddNewTaskToReadyList+0x6>
    3ee4:	cd b7       	in	r28, 0x3d	; 61
    3ee6:	de b7       	in	r29, 0x3e	; 62
    3ee8:	9a 83       	std	Y+2, r25	; 0x02
    3eea:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    3eec:	0f b6       	in	r0, 0x3f	; 63
    3eee:	f8 94       	cli
    3ef0:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    3ef2:	80 91 d1 06 	lds	r24, 0x06D1
    3ef6:	8f 5f       	subi	r24, 0xFF	; 255
    3ef8:	80 93 d1 06 	sts	0x06D1, r24
		if( pxCurrentTCB == NULL )
    3efc:	80 91 ce 06 	lds	r24, 0x06CE
    3f00:	90 91 cf 06 	lds	r25, 0x06CF
    3f04:	00 97       	sbiw	r24, 0x00	; 0
    3f06:	69 f4       	brne	.+26     	; 0x3f22 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3f08:	89 81       	ldd	r24, Y+1	; 0x01
    3f0a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f0c:	90 93 cf 06 	sts	0x06CF, r25
    3f10:	80 93 ce 06 	sts	0x06CE, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3f14:	80 91 d1 06 	lds	r24, 0x06D1
    3f18:	81 30       	cpi	r24, 0x01	; 1
    3f1a:	b9 f4       	brne	.+46     	; 0x3f4a <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3f1c:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <prvInitialiseTaskLists>
    3f20:	14 c0       	rjmp	.+40     	; 0x3f4a <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    3f22:	80 91 d5 06 	lds	r24, 0x06D5
    3f26:	88 23       	and	r24, r24
    3f28:	81 f4       	brne	.+32     	; 0x3f4a <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3f2a:	e0 91 ce 06 	lds	r30, 0x06CE
    3f2e:	f0 91 cf 06 	lds	r31, 0x06CF
    3f32:	96 89       	ldd	r25, Z+22	; 0x16
    3f34:	e9 81       	ldd	r30, Y+1	; 0x01
    3f36:	fa 81       	ldd	r31, Y+2	; 0x02
    3f38:	86 89       	ldd	r24, Z+22	; 0x16
    3f3a:	89 17       	cp	r24, r25
    3f3c:	30 f0       	brcs	.+12     	; 0x3f4a <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    3f3e:	89 81       	ldd	r24, Y+1	; 0x01
    3f40:	9a 81       	ldd	r25, Y+2	; 0x02
    3f42:	90 93 cf 06 	sts	0x06CF, r25
    3f46:	80 93 ce 06 	sts	0x06CE, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3f4a:	80 91 d9 06 	lds	r24, 0x06D9
    3f4e:	8f 5f       	subi	r24, 0xFF	; 255
    3f50:	80 93 d9 06 	sts	0x06D9, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    3f54:	e9 81       	ldd	r30, Y+1	; 0x01
    3f56:	fa 81       	ldd	r31, Y+2	; 0x02
    3f58:	96 89       	ldd	r25, Z+22	; 0x16
    3f5a:	80 91 d4 06 	lds	r24, 0x06D4
    3f5e:	89 17       	cp	r24, r25
    3f60:	28 f4       	brcc	.+10     	; 0x3f6c <prvAddNewTaskToReadyList+0x8e>
    3f62:	e9 81       	ldd	r30, Y+1	; 0x01
    3f64:	fa 81       	ldd	r31, Y+2	; 0x02
    3f66:	86 89       	ldd	r24, Z+22	; 0x16
    3f68:	80 93 d4 06 	sts	0x06D4, r24
    3f6c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f6e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f70:	86 89       	ldd	r24, Z+22	; 0x16
    3f72:	28 2f       	mov	r18, r24
    3f74:	30 e0       	ldi	r19, 0x00	; 0
    3f76:	c9 01       	movw	r24, r18
    3f78:	88 0f       	add	r24, r24
    3f7a:	99 1f       	adc	r25, r25
    3f7c:	88 0f       	add	r24, r24
    3f7e:	99 1f       	adc	r25, r25
    3f80:	88 0f       	add	r24, r24
    3f82:	99 1f       	adc	r25, r25
    3f84:	82 0f       	add	r24, r18
    3f86:	93 1f       	adc	r25, r19
    3f88:	ac 01       	movw	r20, r24
    3f8a:	41 52       	subi	r20, 0x21	; 33
    3f8c:	59 4f       	sbci	r21, 0xF9	; 249
    3f8e:	89 81       	ldd	r24, Y+1	; 0x01
    3f90:	9a 81       	ldd	r25, Y+2	; 0x02
    3f92:	9c 01       	movw	r18, r24
    3f94:	2e 5f       	subi	r18, 0xFE	; 254
    3f96:	3f 4f       	sbci	r19, 0xFF	; 255
    3f98:	ca 01       	movw	r24, r20
    3f9a:	b9 01       	movw	r22, r18
    3f9c:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3fa0:	0f 90       	pop	r0
    3fa2:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    3fa4:	80 91 d5 06 	lds	r24, 0x06D5
    3fa8:	88 23       	and	r24, r24
    3faa:	61 f0       	breq	.+24     	; 0x3fc4 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3fac:	e0 91 ce 06 	lds	r30, 0x06CE
    3fb0:	f0 91 cf 06 	lds	r31, 0x06CF
    3fb4:	96 89       	ldd	r25, Z+22	; 0x16
    3fb6:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb8:	fa 81       	ldd	r31, Y+2	; 0x02
    3fba:	86 89       	ldd	r24, Z+22	; 0x16
    3fbc:	98 17       	cp	r25, r24
    3fbe:	10 f4       	brcc	.+4      	; 0x3fc4 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    3fc0:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3fc4:	0f 90       	pop	r0
    3fc6:	0f 90       	pop	r0
    3fc8:	cf 91       	pop	r28
    3fca:	df 91       	pop	r29
    3fcc:	08 95       	ret

00003fce <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3fce:	df 93       	push	r29
    3fd0:	cf 93       	push	r28
    3fd2:	00 d0       	rcall	.+0      	; 0x3fd4 <vTaskDelete+0x6>
    3fd4:	00 d0       	rcall	.+0      	; 0x3fd6 <vTaskDelete+0x8>
    3fd6:	00 d0       	rcall	.+0      	; 0x3fd8 <vTaskDelete+0xa>
    3fd8:	cd b7       	in	r28, 0x3d	; 61
    3fda:	de b7       	in	r29, 0x3e	; 62
    3fdc:	9c 83       	std	Y+4, r25	; 0x04
    3fde:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3fe0:	0f b6       	in	r0, 0x3f	; 63
    3fe2:	f8 94       	cli
    3fe4:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3fe6:	8b 81       	ldd	r24, Y+3	; 0x03
    3fe8:	9c 81       	ldd	r25, Y+4	; 0x04
    3fea:	00 97       	sbiw	r24, 0x00	; 0
    3fec:	39 f4       	brne	.+14     	; 0x3ffc <vTaskDelete+0x2e>
    3fee:	80 91 ce 06 	lds	r24, 0x06CE
    3ff2:	90 91 cf 06 	lds	r25, 0x06CF
    3ff6:	9e 83       	std	Y+6, r25	; 0x06
    3ff8:	8d 83       	std	Y+5, r24	; 0x05
    3ffa:	04 c0       	rjmp	.+8      	; 0x4004 <vTaskDelete+0x36>
    3ffc:	8b 81       	ldd	r24, Y+3	; 0x03
    3ffe:	9c 81       	ldd	r25, Y+4	; 0x04
    4000:	9e 83       	std	Y+6, r25	; 0x06
    4002:	8d 83       	std	Y+5, r24	; 0x05
    4004:	8d 81       	ldd	r24, Y+5	; 0x05
    4006:	9e 81       	ldd	r25, Y+6	; 0x06
    4008:	9a 83       	std	Y+2, r25	; 0x02
    400a:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    400c:	89 81       	ldd	r24, Y+1	; 0x01
    400e:	9a 81       	ldd	r25, Y+2	; 0x02
    4010:	02 96       	adiw	r24, 0x02	; 2
    4012:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4016:	e9 81       	ldd	r30, Y+1	; 0x01
    4018:	fa 81       	ldd	r31, Y+2	; 0x02
    401a:	84 89       	ldd	r24, Z+20	; 0x14
    401c:	95 89       	ldd	r25, Z+21	; 0x15
    401e:	00 97       	sbiw	r24, 0x00	; 0
    4020:	29 f0       	breq	.+10     	; 0x402c <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4022:	89 81       	ldd	r24, Y+1	; 0x01
    4024:	9a 81       	ldd	r25, Y+2	; 0x02
    4026:	0c 96       	adiw	r24, 0x0c	; 12
    4028:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    402c:	80 91 d9 06 	lds	r24, 0x06D9
    4030:	8f 5f       	subi	r24, 0xFF	; 255
    4032:	80 93 d9 06 	sts	0x06D9, r24

			if( pxTCB == pxCurrentTCB )
    4036:	20 91 ce 06 	lds	r18, 0x06CE
    403a:	30 91 cf 06 	lds	r19, 0x06CF
    403e:	89 81       	ldd	r24, Y+1	; 0x01
    4040:	9a 81       	ldd	r25, Y+2	; 0x02
    4042:	82 17       	cp	r24, r18
    4044:	93 07       	cpc	r25, r19
    4046:	81 f4       	brne	.+32     	; 0x4068 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4048:	89 81       	ldd	r24, Y+1	; 0x01
    404a:	9a 81       	ldd	r25, Y+2	; 0x02
    404c:	9c 01       	movw	r18, r24
    404e:	2e 5f       	subi	r18, 0xFE	; 254
    4050:	3f 4f       	sbci	r19, 0xFF	; 255
    4052:	8d e3       	ldi	r24, 0x3D	; 61
    4054:	97 e0       	ldi	r25, 0x07	; 7
    4056:	b9 01       	movw	r22, r18
    4058:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    405c:	80 91 d0 06 	lds	r24, 0x06D0
    4060:	8f 5f       	subi	r24, 0xFF	; 255
    4062:	80 93 d0 06 	sts	0x06D0, r24
    4066:	0b c0       	rjmp	.+22     	; 0x407e <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    4068:	80 91 d1 06 	lds	r24, 0x06D1
    406c:	81 50       	subi	r24, 0x01	; 1
    406e:	80 93 d1 06 	sts	0x06D1, r24
				prvDeleteTCB( pxTCB );
    4072:	89 81       	ldd	r24, Y+1	; 0x01
    4074:	9a 81       	ldd	r25, Y+2	; 0x02
    4076:	0e 94 b6 26 	call	0x4d6c	; 0x4d6c <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    407a:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    407e:	0f 90       	pop	r0
    4080:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4082:	80 91 d5 06 	lds	r24, 0x06D5
    4086:	88 23       	and	r24, r24
    4088:	59 f0       	breq	.+22     	; 0x40a0 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    408a:	20 91 ce 06 	lds	r18, 0x06CE
    408e:	30 91 cf 06 	lds	r19, 0x06CF
    4092:	89 81       	ldd	r24, Y+1	; 0x01
    4094:	9a 81       	ldd	r25, Y+2	; 0x02
    4096:	82 17       	cp	r24, r18
    4098:	93 07       	cpc	r25, r19
    409a:	11 f4       	brne	.+4      	; 0x40a0 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    409c:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    40a0:	26 96       	adiw	r28, 0x06	; 6
    40a2:	0f b6       	in	r0, 0x3f	; 63
    40a4:	f8 94       	cli
    40a6:	de bf       	out	0x3e, r29	; 62
    40a8:	0f be       	out	0x3f, r0	; 63
    40aa:	cd bf       	out	0x3d, r28	; 61
    40ac:	cf 91       	pop	r28
    40ae:	df 91       	pop	r29
    40b0:	08 95       	ret

000040b2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    40b2:	df 93       	push	r29
    40b4:	cf 93       	push	r28
    40b6:	00 d0       	rcall	.+0      	; 0x40b8 <vTaskDelay+0x6>
    40b8:	0f 92       	push	r0
    40ba:	cd b7       	in	r28, 0x3d	; 61
    40bc:	de b7       	in	r29, 0x3e	; 62
    40be:	9b 83       	std	Y+3, r25	; 0x03
    40c0:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    40c2:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    40c4:	8a 81       	ldd	r24, Y+2	; 0x02
    40c6:	9b 81       	ldd	r25, Y+3	; 0x03
    40c8:	00 97       	sbiw	r24, 0x00	; 0
    40ca:	51 f0       	breq	.+20     	; 0x40e0 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    40cc:	0e 94 26 22 	call	0x444c	; 0x444c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    40d0:	8a 81       	ldd	r24, Y+2	; 0x02
    40d2:	9b 81       	ldd	r25, Y+3	; 0x03
    40d4:	60 e0       	ldi	r22, 0x00	; 0
    40d6:	0e 94 95 2c 	call	0x592a	; 0x592a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    40da:	0e 94 32 22 	call	0x4464	; 0x4464 <xTaskResumeAll>
    40de:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    40e0:	89 81       	ldd	r24, Y+1	; 0x01
    40e2:	88 23       	and	r24, r24
    40e4:	11 f4       	brne	.+4      	; 0x40ea <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    40e6:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    40ea:	0f 90       	pop	r0
    40ec:	0f 90       	pop	r0
    40ee:	0f 90       	pop	r0
    40f0:	cf 91       	pop	r28
    40f2:	df 91       	pop	r29
    40f4:	08 95       	ret

000040f6 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    40f6:	df 93       	push	r29
    40f8:	cf 93       	push	r28
    40fa:	00 d0       	rcall	.+0      	; 0x40fc <vTaskSuspend+0x6>
    40fc:	00 d0       	rcall	.+0      	; 0x40fe <vTaskSuspend+0x8>
    40fe:	00 d0       	rcall	.+0      	; 0x4100 <vTaskSuspend+0xa>
    4100:	cd b7       	in	r28, 0x3d	; 61
    4102:	de b7       	in	r29, 0x3e	; 62
    4104:	9c 83       	std	Y+4, r25	; 0x04
    4106:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4108:	0f b6       	in	r0, 0x3f	; 63
    410a:	f8 94       	cli
    410c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    410e:	8b 81       	ldd	r24, Y+3	; 0x03
    4110:	9c 81       	ldd	r25, Y+4	; 0x04
    4112:	00 97       	sbiw	r24, 0x00	; 0
    4114:	39 f4       	brne	.+14     	; 0x4124 <vTaskSuspend+0x2e>
    4116:	80 91 ce 06 	lds	r24, 0x06CE
    411a:	90 91 cf 06 	lds	r25, 0x06CF
    411e:	9e 83       	std	Y+6, r25	; 0x06
    4120:	8d 83       	std	Y+5, r24	; 0x05
    4122:	04 c0       	rjmp	.+8      	; 0x412c <vTaskSuspend+0x36>
    4124:	8b 81       	ldd	r24, Y+3	; 0x03
    4126:	9c 81       	ldd	r25, Y+4	; 0x04
    4128:	9e 83       	std	Y+6, r25	; 0x06
    412a:	8d 83       	std	Y+5, r24	; 0x05
    412c:	8d 81       	ldd	r24, Y+5	; 0x05
    412e:	9e 81       	ldd	r25, Y+6	; 0x06
    4130:	9a 83       	std	Y+2, r25	; 0x02
    4132:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4134:	89 81       	ldd	r24, Y+1	; 0x01
    4136:	9a 81       	ldd	r25, Y+2	; 0x02
    4138:	02 96       	adiw	r24, 0x02	; 2
    413a:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    413e:	e9 81       	ldd	r30, Y+1	; 0x01
    4140:	fa 81       	ldd	r31, Y+2	; 0x02
    4142:	84 89       	ldd	r24, Z+20	; 0x14
    4144:	95 89       	ldd	r25, Z+21	; 0x15
    4146:	00 97       	sbiw	r24, 0x00	; 0
    4148:	29 f0       	breq	.+10     	; 0x4154 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    414a:	89 81       	ldd	r24, Y+1	; 0x01
    414c:	9a 81       	ldd	r25, Y+2	; 0x02
    414e:	0c 96       	adiw	r24, 0x0c	; 12
    4150:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    4154:	89 81       	ldd	r24, Y+1	; 0x01
    4156:	9a 81       	ldd	r25, Y+2	; 0x02
    4158:	9c 01       	movw	r18, r24
    415a:	2e 5f       	subi	r18, 0xFE	; 254
    415c:	3f 4f       	sbci	r19, 0xFF	; 255
    415e:	86 e4       	ldi	r24, 0x46	; 70
    4160:	97 e0       	ldi	r25, 0x07	; 7
    4162:	b9 01       	movw	r22, r18
    4164:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    4168:	e9 81       	ldd	r30, Y+1	; 0x01
    416a:	fa 81       	ldd	r31, Y+2	; 0x02
    416c:	83 a9       	ldd	r24, Z+51	; 0x33
    416e:	81 30       	cpi	r24, 0x01	; 1
    4170:	19 f4       	brne	.+6      	; 0x4178 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4172:	e9 81       	ldd	r30, Y+1	; 0x01
    4174:	fa 81       	ldd	r31, Y+2	; 0x02
    4176:	13 aa       	std	Z+51, r1	; 0x33
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    4178:	0f 90       	pop	r0
    417a:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    417c:	80 91 d5 06 	lds	r24, 0x06D5
    4180:	88 23       	and	r24, r24
    4182:	39 f0       	breq	.+14     	; 0x4192 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    4184:	0f b6       	in	r0, 0x3f	; 63
    4186:	f8 94       	cli
    4188:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    418a:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    418e:	0f 90       	pop	r0
    4190:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    4192:	20 91 ce 06 	lds	r18, 0x06CE
    4196:	30 91 cf 06 	lds	r19, 0x06CF
    419a:	89 81       	ldd	r24, Y+1	; 0x01
    419c:	9a 81       	ldd	r25, Y+2	; 0x02
    419e:	82 17       	cp	r24, r18
    41a0:	93 07       	cpc	r25, r19
    41a2:	a1 f4       	brne	.+40     	; 0x41cc <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    41a4:	80 91 d5 06 	lds	r24, 0x06D5
    41a8:	88 23       	and	r24, r24
    41aa:	19 f0       	breq	.+6      	; 0x41b2 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    41ac:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
    41b0:	0d c0       	rjmp	.+26     	; 0x41cc <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    41b2:	90 91 46 07 	lds	r25, 0x0746
    41b6:	80 91 d1 06 	lds	r24, 0x06D1
    41ba:	98 17       	cp	r25, r24
    41bc:	29 f4       	brne	.+10     	; 0x41c8 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    41be:	10 92 cf 06 	sts	0x06CF, r1
    41c2:	10 92 ce 06 	sts	0x06CE, r1
    41c6:	02 c0       	rjmp	.+4      	; 0x41cc <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    41c8:	0e 94 07 24 	call	0x480e	; 0x480e <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    41cc:	26 96       	adiw	r28, 0x06	; 6
    41ce:	0f b6       	in	r0, 0x3f	; 63
    41d0:	f8 94       	cli
    41d2:	de bf       	out	0x3e, r29	; 62
    41d4:	0f be       	out	0x3f, r0	; 63
    41d6:	cd bf       	out	0x3d, r28	; 61
    41d8:	cf 91       	pop	r28
    41da:	df 91       	pop	r29
    41dc:	08 95       	ret

000041de <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    41de:	df 93       	push	r29
    41e0:	cf 93       	push	r28
    41e2:	00 d0       	rcall	.+0      	; 0x41e4 <prvTaskIsTaskSuspended+0x6>
    41e4:	00 d0       	rcall	.+0      	; 0x41e6 <prvTaskIsTaskSuspended+0x8>
    41e6:	0f 92       	push	r0
    41e8:	cd b7       	in	r28, 0x3d	; 61
    41ea:	de b7       	in	r29, 0x3e	; 62
    41ec:	9d 83       	std	Y+5, r25	; 0x05
    41ee:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    41f0:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    41f2:	8c 81       	ldd	r24, Y+4	; 0x04
    41f4:	9d 81       	ldd	r25, Y+5	; 0x05
    41f6:	9a 83       	std	Y+2, r25	; 0x02
    41f8:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    41fa:	e9 81       	ldd	r30, Y+1	; 0x01
    41fc:	fa 81       	ldd	r31, Y+2	; 0x02
    41fe:	82 85       	ldd	r24, Z+10	; 0x0a
    4200:	93 85       	ldd	r25, Z+11	; 0x0b
    4202:	27 e0       	ldi	r18, 0x07	; 7
    4204:	86 34       	cpi	r24, 0x46	; 70
    4206:	92 07       	cpc	r25, r18
    4208:	81 f4       	brne	.+32     	; 0x422a <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    420a:	e9 81       	ldd	r30, Y+1	; 0x01
    420c:	fa 81       	ldd	r31, Y+2	; 0x02
    420e:	84 89       	ldd	r24, Z+20	; 0x14
    4210:	95 89       	ldd	r25, Z+21	; 0x15
    4212:	27 e0       	ldi	r18, 0x07	; 7
    4214:	84 33       	cpi	r24, 0x34	; 52
    4216:	92 07       	cpc	r25, r18
    4218:	41 f0       	breq	.+16     	; 0x422a <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    421a:	e9 81       	ldd	r30, Y+1	; 0x01
    421c:	fa 81       	ldd	r31, Y+2	; 0x02
    421e:	84 89       	ldd	r24, Z+20	; 0x14
    4220:	95 89       	ldd	r25, Z+21	; 0x15
    4222:	00 97       	sbiw	r24, 0x00	; 0
    4224:	11 f4       	brne	.+4      	; 0x422a <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    4226:	81 e0       	ldi	r24, 0x01	; 1
    4228:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    422a:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    422c:	0f 90       	pop	r0
    422e:	0f 90       	pop	r0
    4230:	0f 90       	pop	r0
    4232:	0f 90       	pop	r0
    4234:	0f 90       	pop	r0
    4236:	cf 91       	pop	r28
    4238:	df 91       	pop	r29
    423a:	08 95       	ret

0000423c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    423c:	df 93       	push	r29
    423e:	cf 93       	push	r28
    4240:	00 d0       	rcall	.+0      	; 0x4242 <vTaskResume+0x6>
    4242:	00 d0       	rcall	.+0      	; 0x4244 <vTaskResume+0x8>
    4244:	cd b7       	in	r28, 0x3d	; 61
    4246:	de b7       	in	r29, 0x3e	; 62
    4248:	9c 83       	std	Y+4, r25	; 0x04
    424a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    424c:	8b 81       	ldd	r24, Y+3	; 0x03
    424e:	9c 81       	ldd	r25, Y+4	; 0x04
    4250:	9a 83       	std	Y+2, r25	; 0x02
    4252:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    4254:	20 91 ce 06 	lds	r18, 0x06CE
    4258:	30 91 cf 06 	lds	r19, 0x06CF
    425c:	89 81       	ldd	r24, Y+1	; 0x01
    425e:	9a 81       	ldd	r25, Y+2	; 0x02
    4260:	82 17       	cp	r24, r18
    4262:	93 07       	cpc	r25, r19
    4264:	09 f4       	brne	.+2      	; 0x4268 <vTaskResume+0x2c>
    4266:	47 c0       	rjmp	.+142    	; 0x42f6 <vTaskResume+0xba>
    4268:	89 81       	ldd	r24, Y+1	; 0x01
    426a:	9a 81       	ldd	r25, Y+2	; 0x02
    426c:	00 97       	sbiw	r24, 0x00	; 0
    426e:	09 f4       	brne	.+2      	; 0x4272 <vTaskResume+0x36>
    4270:	42 c0       	rjmp	.+132    	; 0x42f6 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    4272:	0f b6       	in	r0, 0x3f	; 63
    4274:	f8 94       	cli
    4276:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4278:	89 81       	ldd	r24, Y+1	; 0x01
    427a:	9a 81       	ldd	r25, Y+2	; 0x02
    427c:	0e 94 ef 20 	call	0x41de	; 0x41de <prvTaskIsTaskSuspended>
    4280:	88 23       	and	r24, r24
    4282:	b9 f1       	breq	.+110    	; 0x42f2 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    4284:	89 81       	ldd	r24, Y+1	; 0x01
    4286:	9a 81       	ldd	r25, Y+2	; 0x02
    4288:	02 96       	adiw	r24, 0x02	; 2
    428a:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    428e:	e9 81       	ldd	r30, Y+1	; 0x01
    4290:	fa 81       	ldd	r31, Y+2	; 0x02
    4292:	96 89       	ldd	r25, Z+22	; 0x16
    4294:	80 91 d4 06 	lds	r24, 0x06D4
    4298:	89 17       	cp	r24, r25
    429a:	28 f4       	brcc	.+10     	; 0x42a6 <vTaskResume+0x6a>
    429c:	e9 81       	ldd	r30, Y+1	; 0x01
    429e:	fa 81       	ldd	r31, Y+2	; 0x02
    42a0:	86 89       	ldd	r24, Z+22	; 0x16
    42a2:	80 93 d4 06 	sts	0x06D4, r24
    42a6:	e9 81       	ldd	r30, Y+1	; 0x01
    42a8:	fa 81       	ldd	r31, Y+2	; 0x02
    42aa:	86 89       	ldd	r24, Z+22	; 0x16
    42ac:	28 2f       	mov	r18, r24
    42ae:	30 e0       	ldi	r19, 0x00	; 0
    42b0:	c9 01       	movw	r24, r18
    42b2:	88 0f       	add	r24, r24
    42b4:	99 1f       	adc	r25, r25
    42b6:	88 0f       	add	r24, r24
    42b8:	99 1f       	adc	r25, r25
    42ba:	88 0f       	add	r24, r24
    42bc:	99 1f       	adc	r25, r25
    42be:	82 0f       	add	r24, r18
    42c0:	93 1f       	adc	r25, r19
    42c2:	ac 01       	movw	r20, r24
    42c4:	41 52       	subi	r20, 0x21	; 33
    42c6:	59 4f       	sbci	r21, 0xF9	; 249
    42c8:	89 81       	ldd	r24, Y+1	; 0x01
    42ca:	9a 81       	ldd	r25, Y+2	; 0x02
    42cc:	9c 01       	movw	r18, r24
    42ce:	2e 5f       	subi	r18, 0xFE	; 254
    42d0:	3f 4f       	sbci	r19, 0xFF	; 255
    42d2:	ca 01       	movw	r24, r20
    42d4:	b9 01       	movw	r22, r18
    42d6:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    42da:	e9 81       	ldd	r30, Y+1	; 0x01
    42dc:	fa 81       	ldd	r31, Y+2	; 0x02
    42de:	96 89       	ldd	r25, Z+22	; 0x16
    42e0:	e0 91 ce 06 	lds	r30, 0x06CE
    42e4:	f0 91 cf 06 	lds	r31, 0x06CF
    42e8:	86 89       	ldd	r24, Z+22	; 0x16
    42ea:	98 17       	cp	r25, r24
    42ec:	10 f0       	brcs	.+4      	; 0x42f2 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    42ee:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    42f2:	0f 90       	pop	r0
    42f4:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    42f6:	0f 90       	pop	r0
    42f8:	0f 90       	pop	r0
    42fa:	0f 90       	pop	r0
    42fc:	0f 90       	pop	r0
    42fe:	cf 91       	pop	r28
    4300:	df 91       	pop	r29
    4302:	08 95       	ret

00004304 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    4304:	df 93       	push	r29
    4306:	cf 93       	push	r28
    4308:	00 d0       	rcall	.+0      	; 0x430a <xTaskResumeFromISR+0x6>
    430a:	00 d0       	rcall	.+0      	; 0x430c <xTaskResumeFromISR+0x8>
    430c:	00 d0       	rcall	.+0      	; 0x430e <xTaskResumeFromISR+0xa>
    430e:	cd b7       	in	r28, 0x3d	; 61
    4310:	de b7       	in	r29, 0x3e	; 62
    4312:	9e 83       	std	Y+6, r25	; 0x06
    4314:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    4316:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    4318:	8d 81       	ldd	r24, Y+5	; 0x05
    431a:	9e 81       	ldd	r25, Y+6	; 0x06
    431c:	9b 83       	std	Y+3, r25	; 0x03
    431e:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4320:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4322:	8a 81       	ldd	r24, Y+2	; 0x02
    4324:	9b 81       	ldd	r25, Y+3	; 0x03
    4326:	0e 94 ef 20 	call	0x41de	; 0x41de <prvTaskIsTaskSuspended>
    432a:	88 23       	and	r24, r24
    432c:	09 f4       	brne	.+2      	; 0x4330 <xTaskResumeFromISR+0x2c>
    432e:	46 c0       	rjmp	.+140    	; 0x43bc <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4330:	80 91 de 06 	lds	r24, 0x06DE
    4334:	88 23       	and	r24, r24
    4336:	c1 f5       	brne	.+112    	; 0x43a8 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4338:	ea 81       	ldd	r30, Y+2	; 0x02
    433a:	fb 81       	ldd	r31, Y+3	; 0x03
    433c:	96 89       	ldd	r25, Z+22	; 0x16
    433e:	e0 91 ce 06 	lds	r30, 0x06CE
    4342:	f0 91 cf 06 	lds	r31, 0x06CF
    4346:	86 89       	ldd	r24, Z+22	; 0x16
    4348:	98 17       	cp	r25, r24
    434a:	10 f0       	brcs	.+4      	; 0x4350 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    434c:	81 e0       	ldi	r24, 0x01	; 1
    434e:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4350:	8a 81       	ldd	r24, Y+2	; 0x02
    4352:	9b 81       	ldd	r25, Y+3	; 0x03
    4354:	02 96       	adiw	r24, 0x02	; 2
    4356:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    435a:	ea 81       	ldd	r30, Y+2	; 0x02
    435c:	fb 81       	ldd	r31, Y+3	; 0x03
    435e:	96 89       	ldd	r25, Z+22	; 0x16
    4360:	80 91 d4 06 	lds	r24, 0x06D4
    4364:	89 17       	cp	r24, r25
    4366:	28 f4       	brcc	.+10     	; 0x4372 <xTaskResumeFromISR+0x6e>
    4368:	ea 81       	ldd	r30, Y+2	; 0x02
    436a:	fb 81       	ldd	r31, Y+3	; 0x03
    436c:	86 89       	ldd	r24, Z+22	; 0x16
    436e:	80 93 d4 06 	sts	0x06D4, r24
    4372:	ea 81       	ldd	r30, Y+2	; 0x02
    4374:	fb 81       	ldd	r31, Y+3	; 0x03
    4376:	86 89       	ldd	r24, Z+22	; 0x16
    4378:	28 2f       	mov	r18, r24
    437a:	30 e0       	ldi	r19, 0x00	; 0
    437c:	c9 01       	movw	r24, r18
    437e:	88 0f       	add	r24, r24
    4380:	99 1f       	adc	r25, r25
    4382:	88 0f       	add	r24, r24
    4384:	99 1f       	adc	r25, r25
    4386:	88 0f       	add	r24, r24
    4388:	99 1f       	adc	r25, r25
    438a:	82 0f       	add	r24, r18
    438c:	93 1f       	adc	r25, r19
    438e:	ac 01       	movw	r20, r24
    4390:	41 52       	subi	r20, 0x21	; 33
    4392:	59 4f       	sbci	r21, 0xF9	; 249
    4394:	8a 81       	ldd	r24, Y+2	; 0x02
    4396:	9b 81       	ldd	r25, Y+3	; 0x03
    4398:	9c 01       	movw	r18, r24
    439a:	2e 5f       	subi	r18, 0xFE	; 254
    439c:	3f 4f       	sbci	r19, 0xFF	; 255
    439e:	ca 01       	movw	r24, r20
    43a0:	b9 01       	movw	r22, r18
    43a2:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
    43a6:	0a c0       	rjmp	.+20     	; 0x43bc <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    43a8:	8a 81       	ldd	r24, Y+2	; 0x02
    43aa:	9b 81       	ldd	r25, Y+3	; 0x03
    43ac:	9c 01       	movw	r18, r24
    43ae:	24 5f       	subi	r18, 0xF4	; 244
    43b0:	3f 4f       	sbci	r19, 0xFF	; 255
    43b2:	84 e3       	ldi	r24, 0x34	; 52
    43b4:	97 e0       	ldi	r25, 0x07	; 7
    43b6:	b9 01       	movw	r22, r18
    43b8:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    43bc:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    43be:	26 96       	adiw	r28, 0x06	; 6
    43c0:	0f b6       	in	r0, 0x3f	; 63
    43c2:	f8 94       	cli
    43c4:	de bf       	out	0x3e, r29	; 62
    43c6:	0f be       	out	0x3f, r0	; 63
    43c8:	cd bf       	out	0x3d, r28	; 61
    43ca:	cf 91       	pop	r28
    43cc:	df 91       	pop	r29
    43ce:	08 95       	ret

000043d0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    43d0:	ef 92       	push	r14
    43d2:	ff 92       	push	r15
    43d4:	0f 93       	push	r16
    43d6:	df 93       	push	r29
    43d8:	cf 93       	push	r28
    43da:	0f 92       	push	r0
    43dc:	cd b7       	in	r28, 0x3d	; 61
    43de:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    43e0:	8c e3       	ldi	r24, 0x3C	; 60
    43e2:	96 e2       	ldi	r25, 0x26	; 38
    43e4:	21 ee       	ldi	r18, 0xE1	; 225
    43e6:	30 e0       	ldi	r19, 0x00	; 0
    43e8:	ec ed       	ldi	r30, 0xDC	; 220
    43ea:	f6 e0       	ldi	r31, 0x06	; 6
    43ec:	b9 01       	movw	r22, r18
    43ee:	46 e9       	ldi	r20, 0x96	; 150
    43f0:	50 e0       	ldi	r21, 0x00	; 0
    43f2:	20 e0       	ldi	r18, 0x00	; 0
    43f4:	30 e0       	ldi	r19, 0x00	; 0
    43f6:	00 e0       	ldi	r16, 0x00	; 0
    43f8:	7f 01       	movw	r14, r30
    43fa:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskCreate>
    43fe:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    4400:	89 81       	ldd	r24, Y+1	; 0x01
    4402:	81 30       	cpi	r24, 0x01	; 1
    4404:	81 f4       	brne	.+32     	; 0x4426 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4406:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    4408:	8f ef       	ldi	r24, 0xFF	; 255
    440a:	9f ef       	ldi	r25, 0xFF	; 255
    440c:	90 93 db 06 	sts	0x06DB, r25
    4410:	80 93 da 06 	sts	0x06DA, r24
		xSchedulerRunning = pdTRUE;
    4414:	81 e0       	ldi	r24, 0x01	; 1
    4416:	80 93 d5 06 	sts	0x06D5, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    441a:	10 92 d3 06 	sts	0x06D3, r1
    441e:	10 92 d2 06 	sts	0x06D2, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4422:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    4426:	0f 90       	pop	r0
    4428:	cf 91       	pop	r28
    442a:	df 91       	pop	r29
    442c:	0f 91       	pop	r16
    442e:	ff 90       	pop	r15
    4430:	ef 90       	pop	r14
    4432:	08 95       	ret

00004434 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4434:	df 93       	push	r29
    4436:	cf 93       	push	r28
    4438:	cd b7       	in	r28, 0x3d	; 61
    443a:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    443c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    443e:	10 92 d5 06 	sts	0x06D5, r1
	vPortEndScheduler();
    4442:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vPortEndScheduler>
}
    4446:	cf 91       	pop	r28
    4448:	df 91       	pop	r29
    444a:	08 95       	ret

0000444c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    444c:	df 93       	push	r29
    444e:	cf 93       	push	r28
    4450:	cd b7       	in	r28, 0x3d	; 61
    4452:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4454:	80 91 de 06 	lds	r24, 0x06DE
    4458:	8f 5f       	subi	r24, 0xFF	; 255
    445a:	80 93 de 06 	sts	0x06DE, r24
}
    445e:	cf 91       	pop	r28
    4460:	df 91       	pop	r29
    4462:	08 95       	ret

00004464 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4464:	df 93       	push	r29
    4466:	cf 93       	push	r28
    4468:	00 d0       	rcall	.+0      	; 0x446a <xTaskResumeAll+0x6>
    446a:	00 d0       	rcall	.+0      	; 0x446c <xTaskResumeAll+0x8>
    446c:	cd b7       	in	r28, 0x3d	; 61
    446e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    4470:	1c 82       	std	Y+4, r1	; 0x04
    4472:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    4474:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4476:	0f b6       	in	r0, 0x3f	; 63
    4478:	f8 94       	cli
    447a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    447c:	80 91 de 06 	lds	r24, 0x06DE
    4480:	81 50       	subi	r24, 0x01	; 1
    4482:	80 93 de 06 	sts	0x06DE, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4486:	80 91 de 06 	lds	r24, 0x06DE
    448a:	88 23       	and	r24, r24
    448c:	09 f0       	breq	.+2      	; 0x4490 <xTaskResumeAll+0x2c>
    448e:	73 c0       	rjmp	.+230    	; 0x4576 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4490:	80 91 d1 06 	lds	r24, 0x06D1
    4494:	88 23       	and	r24, r24
    4496:	09 f4       	brne	.+2      	; 0x449a <xTaskResumeAll+0x36>
    4498:	6e c0       	rjmp	.+220    	; 0x4576 <xTaskResumeAll+0x112>
    449a:	45 c0       	rjmp	.+138    	; 0x4526 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    449c:	e0 91 39 07 	lds	r30, 0x0739
    44a0:	f0 91 3a 07 	lds	r31, 0x073A
    44a4:	86 81       	ldd	r24, Z+6	; 0x06
    44a6:	97 81       	ldd	r25, Z+7	; 0x07
    44a8:	9c 83       	std	Y+4, r25	; 0x04
    44aa:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    44ac:	8b 81       	ldd	r24, Y+3	; 0x03
    44ae:	9c 81       	ldd	r25, Y+4	; 0x04
    44b0:	0c 96       	adiw	r24, 0x0c	; 12
    44b2:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    44b6:	8b 81       	ldd	r24, Y+3	; 0x03
    44b8:	9c 81       	ldd	r25, Y+4	; 0x04
    44ba:	02 96       	adiw	r24, 0x02	; 2
    44bc:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    44c0:	eb 81       	ldd	r30, Y+3	; 0x03
    44c2:	fc 81       	ldd	r31, Y+4	; 0x04
    44c4:	96 89       	ldd	r25, Z+22	; 0x16
    44c6:	80 91 d4 06 	lds	r24, 0x06D4
    44ca:	89 17       	cp	r24, r25
    44cc:	28 f4       	brcc	.+10     	; 0x44d8 <xTaskResumeAll+0x74>
    44ce:	eb 81       	ldd	r30, Y+3	; 0x03
    44d0:	fc 81       	ldd	r31, Y+4	; 0x04
    44d2:	86 89       	ldd	r24, Z+22	; 0x16
    44d4:	80 93 d4 06 	sts	0x06D4, r24
    44d8:	eb 81       	ldd	r30, Y+3	; 0x03
    44da:	fc 81       	ldd	r31, Y+4	; 0x04
    44dc:	86 89       	ldd	r24, Z+22	; 0x16
    44de:	28 2f       	mov	r18, r24
    44e0:	30 e0       	ldi	r19, 0x00	; 0
    44e2:	c9 01       	movw	r24, r18
    44e4:	88 0f       	add	r24, r24
    44e6:	99 1f       	adc	r25, r25
    44e8:	88 0f       	add	r24, r24
    44ea:	99 1f       	adc	r25, r25
    44ec:	88 0f       	add	r24, r24
    44ee:	99 1f       	adc	r25, r25
    44f0:	82 0f       	add	r24, r18
    44f2:	93 1f       	adc	r25, r19
    44f4:	ac 01       	movw	r20, r24
    44f6:	41 52       	subi	r20, 0x21	; 33
    44f8:	59 4f       	sbci	r21, 0xF9	; 249
    44fa:	8b 81       	ldd	r24, Y+3	; 0x03
    44fc:	9c 81       	ldd	r25, Y+4	; 0x04
    44fe:	9c 01       	movw	r18, r24
    4500:	2e 5f       	subi	r18, 0xFE	; 254
    4502:	3f 4f       	sbci	r19, 0xFF	; 255
    4504:	ca 01       	movw	r24, r20
    4506:	b9 01       	movw	r22, r18
    4508:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    450c:	eb 81       	ldd	r30, Y+3	; 0x03
    450e:	fc 81       	ldd	r31, Y+4	; 0x04
    4510:	96 89       	ldd	r25, Z+22	; 0x16
    4512:	e0 91 ce 06 	lds	r30, 0x06CE
    4516:	f0 91 cf 06 	lds	r31, 0x06CF
    451a:	86 89       	ldd	r24, Z+22	; 0x16
    451c:	98 17       	cp	r25, r24
    451e:	18 f0       	brcs	.+6      	; 0x4526 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    4520:	81 e0       	ldi	r24, 0x01	; 1
    4522:	80 93 d7 06 	sts	0x06D7, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4526:	80 91 34 07 	lds	r24, 0x0734
    452a:	88 23       	and	r24, r24
    452c:	09 f0       	breq	.+2      	; 0x4530 <xTaskResumeAll+0xcc>
    452e:	b6 cf       	rjmp	.-148    	; 0x449c <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    4530:	8b 81       	ldd	r24, Y+3	; 0x03
    4532:	9c 81       	ldd	r25, Y+4	; 0x04
    4534:	00 97       	sbiw	r24, 0x00	; 0
    4536:	11 f0       	breq	.+4      	; 0x453c <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    4538:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    453c:	80 91 d6 06 	lds	r24, 0x06D6
    4540:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    4542:	89 81       	ldd	r24, Y+1	; 0x01
    4544:	88 23       	and	r24, r24
    4546:	79 f0       	breq	.+30     	; 0x4566 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    4548:	0e 94 22 23 	call	0x4644	; 0x4644 <xTaskIncrementTick>
    454c:	88 23       	and	r24, r24
    454e:	19 f0       	breq	.+6      	; 0x4556 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    4550:	81 e0       	ldi	r24, 0x01	; 1
    4552:	80 93 d7 06 	sts	0x06D7, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4556:	89 81       	ldd	r24, Y+1	; 0x01
    4558:	81 50       	subi	r24, 0x01	; 1
    455a:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    455c:	89 81       	ldd	r24, Y+1	; 0x01
    455e:	88 23       	and	r24, r24
    4560:	99 f7       	brne	.-26     	; 0x4548 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    4562:	10 92 d6 06 	sts	0x06D6, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    4566:	80 91 d7 06 	lds	r24, 0x06D7
    456a:	88 23       	and	r24, r24
    456c:	21 f0       	breq	.+8      	; 0x4576 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    456e:	81 e0       	ldi	r24, 0x01	; 1
    4570:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4572:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4576:	0f 90       	pop	r0
    4578:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    457a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    457c:	0f 90       	pop	r0
    457e:	0f 90       	pop	r0
    4580:	0f 90       	pop	r0
    4582:	0f 90       	pop	r0
    4584:	cf 91       	pop	r28
    4586:	df 91       	pop	r29
    4588:	08 95       	ret

0000458a <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    458a:	df 93       	push	r29
    458c:	cf 93       	push	r28
    458e:	00 d0       	rcall	.+0      	; 0x4590 <xTaskGetTickCount+0x6>
    4590:	cd b7       	in	r28, 0x3d	; 61
    4592:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4594:	0f b6       	in	r0, 0x3f	; 63
    4596:	f8 94       	cli
    4598:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    459a:	80 91 d2 06 	lds	r24, 0x06D2
    459e:	90 91 d3 06 	lds	r25, 0x06D3
    45a2:	9a 83       	std	Y+2, r25	; 0x02
    45a4:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    45a6:	0f 90       	pop	r0
    45a8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    45aa:	89 81       	ldd	r24, Y+1	; 0x01
    45ac:	9a 81       	ldd	r25, Y+2	; 0x02
}
    45ae:	0f 90       	pop	r0
    45b0:	0f 90       	pop	r0
    45b2:	cf 91       	pop	r28
    45b4:	df 91       	pop	r29
    45b6:	08 95       	ret

000045b8 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    45b8:	df 93       	push	r29
    45ba:	cf 93       	push	r28
    45bc:	00 d0       	rcall	.+0      	; 0x45be <xTaskGetTickCountFromISR+0x6>
    45be:	0f 92       	push	r0
    45c0:	cd b7       	in	r28, 0x3d	; 61
    45c2:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    45c4:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    45c6:	80 91 d2 06 	lds	r24, 0x06D2
    45ca:	90 91 d3 06 	lds	r25, 0x06D3
    45ce:	9b 83       	std	Y+3, r25	; 0x03
    45d0:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    45d2:	8a 81       	ldd	r24, Y+2	; 0x02
    45d4:	9b 81       	ldd	r25, Y+3	; 0x03
}
    45d6:	0f 90       	pop	r0
    45d8:	0f 90       	pop	r0
    45da:	0f 90       	pop	r0
    45dc:	cf 91       	pop	r28
    45de:	df 91       	pop	r29
    45e0:	08 95       	ret

000045e2 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    45e2:	df 93       	push	r29
    45e4:	cf 93       	push	r28
    45e6:	cd b7       	in	r28, 0x3d	; 61
    45e8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    45ea:	80 91 d1 06 	lds	r24, 0x06D1
}
    45ee:	cf 91       	pop	r28
    45f0:	df 91       	pop	r29
    45f2:	08 95       	ret

000045f4 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    45f4:	df 93       	push	r29
    45f6:	cf 93       	push	r28
    45f8:	00 d0       	rcall	.+0      	; 0x45fa <pcTaskGetName+0x6>
    45fa:	00 d0       	rcall	.+0      	; 0x45fc <pcTaskGetName+0x8>
    45fc:	00 d0       	rcall	.+0      	; 0x45fe <pcTaskGetName+0xa>
    45fe:	cd b7       	in	r28, 0x3d	; 61
    4600:	de b7       	in	r29, 0x3e	; 62
    4602:	9c 83       	std	Y+4, r25	; 0x04
    4604:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4606:	8b 81       	ldd	r24, Y+3	; 0x03
    4608:	9c 81       	ldd	r25, Y+4	; 0x04
    460a:	00 97       	sbiw	r24, 0x00	; 0
    460c:	39 f4       	brne	.+14     	; 0x461c <pcTaskGetName+0x28>
    460e:	80 91 ce 06 	lds	r24, 0x06CE
    4612:	90 91 cf 06 	lds	r25, 0x06CF
    4616:	9e 83       	std	Y+6, r25	; 0x06
    4618:	8d 83       	std	Y+5, r24	; 0x05
    461a:	04 c0       	rjmp	.+8      	; 0x4624 <pcTaskGetName+0x30>
    461c:	8b 81       	ldd	r24, Y+3	; 0x03
    461e:	9c 81       	ldd	r25, Y+4	; 0x04
    4620:	9e 83       	std	Y+6, r25	; 0x06
    4622:	8d 83       	std	Y+5, r24	; 0x05
    4624:	8d 81       	ldd	r24, Y+5	; 0x05
    4626:	9e 81       	ldd	r25, Y+6	; 0x06
    4628:	9a 83       	std	Y+2, r25	; 0x02
    462a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    462c:	89 81       	ldd	r24, Y+1	; 0x01
    462e:	9a 81       	ldd	r25, Y+2	; 0x02
    4630:	49 96       	adiw	r24, 0x19	; 25
}
    4632:	26 96       	adiw	r28, 0x06	; 6
    4634:	0f b6       	in	r0, 0x3f	; 63
    4636:	f8 94       	cli
    4638:	de bf       	out	0x3e, r29	; 62
    463a:	0f be       	out	0x3f, r0	; 63
    463c:	cd bf       	out	0x3d, r28	; 61
    463e:	cf 91       	pop	r28
    4640:	df 91       	pop	r29
    4642:	08 95       	ret

00004644 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4644:	df 93       	push	r29
    4646:	cf 93       	push	r28
    4648:	cd b7       	in	r28, 0x3d	; 61
    464a:	de b7       	in	r29, 0x3e	; 62
    464c:	29 97       	sbiw	r28, 0x09	; 9
    464e:	0f b6       	in	r0, 0x3f	; 63
    4650:	f8 94       	cli
    4652:	de bf       	out	0x3e, r29	; 62
    4654:	0f be       	out	0x3f, r0	; 63
    4656:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4658:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    465a:	80 91 de 06 	lds	r24, 0x06DE
    465e:	88 23       	and	r24, r24
    4660:	09 f0       	breq	.+2      	; 0x4664 <xTaskIncrementTick+0x20>
    4662:	c0 c0       	rjmp	.+384    	; 0x47e4 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4664:	80 91 d2 06 	lds	r24, 0x06D2
    4668:	90 91 d3 06 	lds	r25, 0x06D3
    466c:	01 96       	adiw	r24, 0x01	; 1
    466e:	9c 83       	std	Y+4, r25	; 0x04
    4670:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4672:	8b 81       	ldd	r24, Y+3	; 0x03
    4674:	9c 81       	ldd	r25, Y+4	; 0x04
    4676:	90 93 d3 06 	sts	0x06D3, r25
    467a:	80 93 d2 06 	sts	0x06D2, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    467e:	8b 81       	ldd	r24, Y+3	; 0x03
    4680:	9c 81       	ldd	r25, Y+4	; 0x04
    4682:	00 97       	sbiw	r24, 0x00	; 0
    4684:	d9 f4       	brne	.+54     	; 0x46bc <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    4686:	80 91 30 07 	lds	r24, 0x0730
    468a:	90 91 31 07 	lds	r25, 0x0731
    468e:	9a 83       	std	Y+2, r25	; 0x02
    4690:	89 83       	std	Y+1, r24	; 0x01
    4692:	80 91 32 07 	lds	r24, 0x0732
    4696:	90 91 33 07 	lds	r25, 0x0733
    469a:	90 93 31 07 	sts	0x0731, r25
    469e:	80 93 30 07 	sts	0x0730, r24
    46a2:	89 81       	ldd	r24, Y+1	; 0x01
    46a4:	9a 81       	ldd	r25, Y+2	; 0x02
    46a6:	90 93 33 07 	sts	0x0733, r25
    46aa:	80 93 32 07 	sts	0x0732, r24
    46ae:	80 91 d8 06 	lds	r24, 0x06D8
    46b2:	8f 5f       	subi	r24, 0xFF	; 255
    46b4:	80 93 d8 06 	sts	0x06D8, r24
    46b8:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    46bc:	20 91 da 06 	lds	r18, 0x06DA
    46c0:	30 91 db 06 	lds	r19, 0x06DB
    46c4:	8b 81       	ldd	r24, Y+3	; 0x03
    46c6:	9c 81       	ldd	r25, Y+4	; 0x04
    46c8:	82 17       	cp	r24, r18
    46ca:	93 07       	cpc	r25, r19
    46cc:	08 f4       	brcc	.+2      	; 0x46d0 <xTaskIncrementTick+0x8c>
    46ce:	71 c0       	rjmp	.+226    	; 0x47b2 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    46d0:	e0 91 30 07 	lds	r30, 0x0730
    46d4:	f0 91 31 07 	lds	r31, 0x0731
    46d8:	80 81       	ld	r24, Z
    46da:	88 23       	and	r24, r24
    46dc:	39 f4       	brne	.+14     	; 0x46ec <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    46de:	8f ef       	ldi	r24, 0xFF	; 255
    46e0:	9f ef       	ldi	r25, 0xFF	; 255
    46e2:	90 93 db 06 	sts	0x06DB, r25
    46e6:	80 93 da 06 	sts	0x06DA, r24
    46ea:	63 c0       	rjmp	.+198    	; 0x47b2 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    46ec:	e0 91 30 07 	lds	r30, 0x0730
    46f0:	f0 91 31 07 	lds	r31, 0x0731
    46f4:	05 80       	ldd	r0, Z+5	; 0x05
    46f6:	f6 81       	ldd	r31, Z+6	; 0x06
    46f8:	e0 2d       	mov	r30, r0
    46fa:	86 81       	ldd	r24, Z+6	; 0x06
    46fc:	97 81       	ldd	r25, Z+7	; 0x07
    46fe:	99 87       	std	Y+9, r25	; 0x09
    4700:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4702:	e8 85       	ldd	r30, Y+8	; 0x08
    4704:	f9 85       	ldd	r31, Y+9	; 0x09
    4706:	82 81       	ldd	r24, Z+2	; 0x02
    4708:	93 81       	ldd	r25, Z+3	; 0x03
    470a:	9f 83       	std	Y+7, r25	; 0x07
    470c:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    470e:	2b 81       	ldd	r18, Y+3	; 0x03
    4710:	3c 81       	ldd	r19, Y+4	; 0x04
    4712:	8e 81       	ldd	r24, Y+6	; 0x06
    4714:	9f 81       	ldd	r25, Y+7	; 0x07
    4716:	28 17       	cp	r18, r24
    4718:	39 07       	cpc	r19, r25
    471a:	38 f4       	brcc	.+14     	; 0x472a <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    471c:	8e 81       	ldd	r24, Y+6	; 0x06
    471e:	9f 81       	ldd	r25, Y+7	; 0x07
    4720:	90 93 db 06 	sts	0x06DB, r25
    4724:	80 93 da 06 	sts	0x06DA, r24
    4728:	44 c0       	rjmp	.+136    	; 0x47b2 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    472a:	88 85       	ldd	r24, Y+8	; 0x08
    472c:	99 85       	ldd	r25, Y+9	; 0x09
    472e:	02 96       	adiw	r24, 0x02	; 2
    4730:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4734:	e8 85       	ldd	r30, Y+8	; 0x08
    4736:	f9 85       	ldd	r31, Y+9	; 0x09
    4738:	84 89       	ldd	r24, Z+20	; 0x14
    473a:	95 89       	ldd	r25, Z+21	; 0x15
    473c:	00 97       	sbiw	r24, 0x00	; 0
    473e:	29 f0       	breq	.+10     	; 0x474a <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4740:	88 85       	ldd	r24, Y+8	; 0x08
    4742:	99 85       	ldd	r25, Y+9	; 0x09
    4744:	0c 96       	adiw	r24, 0x0c	; 12
    4746:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    474a:	e8 85       	ldd	r30, Y+8	; 0x08
    474c:	f9 85       	ldd	r31, Y+9	; 0x09
    474e:	96 89       	ldd	r25, Z+22	; 0x16
    4750:	80 91 d4 06 	lds	r24, 0x06D4
    4754:	89 17       	cp	r24, r25
    4756:	28 f4       	brcc	.+10     	; 0x4762 <xTaskIncrementTick+0x11e>
    4758:	e8 85       	ldd	r30, Y+8	; 0x08
    475a:	f9 85       	ldd	r31, Y+9	; 0x09
    475c:	86 89       	ldd	r24, Z+22	; 0x16
    475e:	80 93 d4 06 	sts	0x06D4, r24
    4762:	e8 85       	ldd	r30, Y+8	; 0x08
    4764:	f9 85       	ldd	r31, Y+9	; 0x09
    4766:	86 89       	ldd	r24, Z+22	; 0x16
    4768:	28 2f       	mov	r18, r24
    476a:	30 e0       	ldi	r19, 0x00	; 0
    476c:	c9 01       	movw	r24, r18
    476e:	88 0f       	add	r24, r24
    4770:	99 1f       	adc	r25, r25
    4772:	88 0f       	add	r24, r24
    4774:	99 1f       	adc	r25, r25
    4776:	88 0f       	add	r24, r24
    4778:	99 1f       	adc	r25, r25
    477a:	82 0f       	add	r24, r18
    477c:	93 1f       	adc	r25, r19
    477e:	ac 01       	movw	r20, r24
    4780:	41 52       	subi	r20, 0x21	; 33
    4782:	59 4f       	sbci	r21, 0xF9	; 249
    4784:	88 85       	ldd	r24, Y+8	; 0x08
    4786:	99 85       	ldd	r25, Y+9	; 0x09
    4788:	9c 01       	movw	r18, r24
    478a:	2e 5f       	subi	r18, 0xFE	; 254
    478c:	3f 4f       	sbci	r19, 0xFF	; 255
    478e:	ca 01       	movw	r24, r20
    4790:	b9 01       	movw	r22, r18
    4792:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4796:	e8 85       	ldd	r30, Y+8	; 0x08
    4798:	f9 85       	ldd	r31, Y+9	; 0x09
    479a:	96 89       	ldd	r25, Z+22	; 0x16
    479c:	e0 91 ce 06 	lds	r30, 0x06CE
    47a0:	f0 91 cf 06 	lds	r31, 0x06CF
    47a4:	86 89       	ldd	r24, Z+22	; 0x16
    47a6:	98 17       	cp	r25, r24
    47a8:	08 f4       	brcc	.+2      	; 0x47ac <xTaskIncrementTick+0x168>
    47aa:	92 cf       	rjmp	.-220    	; 0x46d0 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    47ac:	81 e0       	ldi	r24, 0x01	; 1
    47ae:	8d 83       	std	Y+5, r24	; 0x05
    47b0:	8f cf       	rjmp	.-226    	; 0x46d0 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    47b2:	e0 91 ce 06 	lds	r30, 0x06CE
    47b6:	f0 91 cf 06 	lds	r31, 0x06CF
    47ba:	86 89       	ldd	r24, Z+22	; 0x16
    47bc:	28 2f       	mov	r18, r24
    47be:	30 e0       	ldi	r19, 0x00	; 0
    47c0:	c9 01       	movw	r24, r18
    47c2:	88 0f       	add	r24, r24
    47c4:	99 1f       	adc	r25, r25
    47c6:	88 0f       	add	r24, r24
    47c8:	99 1f       	adc	r25, r25
    47ca:	88 0f       	add	r24, r24
    47cc:	99 1f       	adc	r25, r25
    47ce:	82 0f       	add	r24, r18
    47d0:	93 1f       	adc	r25, r19
    47d2:	fc 01       	movw	r30, r24
    47d4:	e1 52       	subi	r30, 0x21	; 33
    47d6:	f9 4f       	sbci	r31, 0xF9	; 249
    47d8:	80 81       	ld	r24, Z
    47da:	82 30       	cpi	r24, 0x02	; 2
    47dc:	40 f0       	brcs	.+16     	; 0x47ee <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    47de:	81 e0       	ldi	r24, 0x01	; 1
    47e0:	8d 83       	std	Y+5, r24	; 0x05
    47e2:	05 c0       	rjmp	.+10     	; 0x47ee <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    47e4:	80 91 d6 06 	lds	r24, 0x06D6
    47e8:	8f 5f       	subi	r24, 0xFF	; 255
    47ea:	80 93 d6 06 	sts	0x06D6, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    47ee:	80 91 d7 06 	lds	r24, 0x06D7
    47f2:	88 23       	and	r24, r24
    47f4:	11 f0       	breq	.+4      	; 0x47fa <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    47f6:	81 e0       	ldi	r24, 0x01	; 1
    47f8:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    47fa:	8d 81       	ldd	r24, Y+5	; 0x05
}
    47fc:	29 96       	adiw	r28, 0x09	; 9
    47fe:	0f b6       	in	r0, 0x3f	; 63
    4800:	f8 94       	cli
    4802:	de bf       	out	0x3e, r29	; 62
    4804:	0f be       	out	0x3f, r0	; 63
    4806:	cd bf       	out	0x3d, r28	; 61
    4808:	cf 91       	pop	r28
    480a:	df 91       	pop	r29
    480c:	08 95       	ret

0000480e <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    480e:	df 93       	push	r29
    4810:	cf 93       	push	r28
    4812:	00 d0       	rcall	.+0      	; 0x4814 <vTaskSwitchContext+0x6>
    4814:	0f 92       	push	r0
    4816:	cd b7       	in	r28, 0x3d	; 61
    4818:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    481a:	80 91 de 06 	lds	r24, 0x06DE
    481e:	88 23       	and	r24, r24
    4820:	21 f0       	breq	.+8      	; 0x482a <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4822:	81 e0       	ldi	r24, 0x01	; 1
    4824:	80 93 d7 06 	sts	0x06D7, r24
    4828:	59 c0       	rjmp	.+178    	; 0x48dc <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    482a:	10 92 d7 06 	sts	0x06D7, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    482e:	80 91 d4 06 	lds	r24, 0x06D4
    4832:	8b 83       	std	Y+3, r24	; 0x03
    4834:	03 c0       	rjmp	.+6      	; 0x483c <vTaskSwitchContext+0x2e>
    4836:	8b 81       	ldd	r24, Y+3	; 0x03
    4838:	81 50       	subi	r24, 0x01	; 1
    483a:	8b 83       	std	Y+3, r24	; 0x03
    483c:	8b 81       	ldd	r24, Y+3	; 0x03
    483e:	28 2f       	mov	r18, r24
    4840:	30 e0       	ldi	r19, 0x00	; 0
    4842:	c9 01       	movw	r24, r18
    4844:	88 0f       	add	r24, r24
    4846:	99 1f       	adc	r25, r25
    4848:	88 0f       	add	r24, r24
    484a:	99 1f       	adc	r25, r25
    484c:	88 0f       	add	r24, r24
    484e:	99 1f       	adc	r25, r25
    4850:	82 0f       	add	r24, r18
    4852:	93 1f       	adc	r25, r19
    4854:	fc 01       	movw	r30, r24
    4856:	e1 52       	subi	r30, 0x21	; 33
    4858:	f9 4f       	sbci	r31, 0xF9	; 249
    485a:	80 81       	ld	r24, Z
    485c:	88 23       	and	r24, r24
    485e:	59 f3       	breq	.-42     	; 0x4836 <vTaskSwitchContext+0x28>
    4860:	8b 81       	ldd	r24, Y+3	; 0x03
    4862:	28 2f       	mov	r18, r24
    4864:	30 e0       	ldi	r19, 0x00	; 0
    4866:	c9 01       	movw	r24, r18
    4868:	88 0f       	add	r24, r24
    486a:	99 1f       	adc	r25, r25
    486c:	88 0f       	add	r24, r24
    486e:	99 1f       	adc	r25, r25
    4870:	88 0f       	add	r24, r24
    4872:	99 1f       	adc	r25, r25
    4874:	82 0f       	add	r24, r18
    4876:	93 1f       	adc	r25, r19
    4878:	81 52       	subi	r24, 0x21	; 33
    487a:	99 4f       	sbci	r25, 0xF9	; 249
    487c:	9a 83       	std	Y+2, r25	; 0x02
    487e:	89 83       	std	Y+1, r24	; 0x01
    4880:	e9 81       	ldd	r30, Y+1	; 0x01
    4882:	fa 81       	ldd	r31, Y+2	; 0x02
    4884:	01 80       	ldd	r0, Z+1	; 0x01
    4886:	f2 81       	ldd	r31, Z+2	; 0x02
    4888:	e0 2d       	mov	r30, r0
    488a:	82 81       	ldd	r24, Z+2	; 0x02
    488c:	93 81       	ldd	r25, Z+3	; 0x03
    488e:	e9 81       	ldd	r30, Y+1	; 0x01
    4890:	fa 81       	ldd	r31, Y+2	; 0x02
    4892:	92 83       	std	Z+2, r25	; 0x02
    4894:	81 83       	std	Z+1, r24	; 0x01
    4896:	e9 81       	ldd	r30, Y+1	; 0x01
    4898:	fa 81       	ldd	r31, Y+2	; 0x02
    489a:	21 81       	ldd	r18, Z+1	; 0x01
    489c:	32 81       	ldd	r19, Z+2	; 0x02
    489e:	89 81       	ldd	r24, Y+1	; 0x01
    48a0:	9a 81       	ldd	r25, Y+2	; 0x02
    48a2:	03 96       	adiw	r24, 0x03	; 3
    48a4:	28 17       	cp	r18, r24
    48a6:	39 07       	cpc	r19, r25
    48a8:	59 f4       	brne	.+22     	; 0x48c0 <vTaskSwitchContext+0xb2>
    48aa:	e9 81       	ldd	r30, Y+1	; 0x01
    48ac:	fa 81       	ldd	r31, Y+2	; 0x02
    48ae:	01 80       	ldd	r0, Z+1	; 0x01
    48b0:	f2 81       	ldd	r31, Z+2	; 0x02
    48b2:	e0 2d       	mov	r30, r0
    48b4:	82 81       	ldd	r24, Z+2	; 0x02
    48b6:	93 81       	ldd	r25, Z+3	; 0x03
    48b8:	e9 81       	ldd	r30, Y+1	; 0x01
    48ba:	fa 81       	ldd	r31, Y+2	; 0x02
    48bc:	92 83       	std	Z+2, r25	; 0x02
    48be:	81 83       	std	Z+1, r24	; 0x01
    48c0:	e9 81       	ldd	r30, Y+1	; 0x01
    48c2:	fa 81       	ldd	r31, Y+2	; 0x02
    48c4:	01 80       	ldd	r0, Z+1	; 0x01
    48c6:	f2 81       	ldd	r31, Z+2	; 0x02
    48c8:	e0 2d       	mov	r30, r0
    48ca:	86 81       	ldd	r24, Z+6	; 0x06
    48cc:	97 81       	ldd	r25, Z+7	; 0x07
    48ce:	90 93 cf 06 	sts	0x06CF, r25
    48d2:	80 93 ce 06 	sts	0x06CE, r24
    48d6:	8b 81       	ldd	r24, Y+3	; 0x03
    48d8:	80 93 d4 06 	sts	0x06D4, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    48dc:	0f 90       	pop	r0
    48de:	0f 90       	pop	r0
    48e0:	0f 90       	pop	r0
    48e2:	cf 91       	pop	r28
    48e4:	df 91       	pop	r29
    48e6:	08 95       	ret

000048e8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    48e8:	df 93       	push	r29
    48ea:	cf 93       	push	r28
    48ec:	00 d0       	rcall	.+0      	; 0x48ee <vTaskPlaceOnEventList+0x6>
    48ee:	00 d0       	rcall	.+0      	; 0x48f0 <vTaskPlaceOnEventList+0x8>
    48f0:	cd b7       	in	r28, 0x3d	; 61
    48f2:	de b7       	in	r29, 0x3e	; 62
    48f4:	9a 83       	std	Y+2, r25	; 0x02
    48f6:	89 83       	std	Y+1, r24	; 0x01
    48f8:	7c 83       	std	Y+4, r23	; 0x04
    48fa:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    48fc:	80 91 ce 06 	lds	r24, 0x06CE
    4900:	90 91 cf 06 	lds	r25, 0x06CF
    4904:	9c 01       	movw	r18, r24
    4906:	24 5f       	subi	r18, 0xF4	; 244
    4908:	3f 4f       	sbci	r19, 0xFF	; 255
    490a:	89 81       	ldd	r24, Y+1	; 0x01
    490c:	9a 81       	ldd	r25, Y+2	; 0x02
    490e:	b9 01       	movw	r22, r18
    4910:	0e 94 2b 0b 	call	0x1656	; 0x1656 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4914:	8b 81       	ldd	r24, Y+3	; 0x03
    4916:	9c 81       	ldd	r25, Y+4	; 0x04
    4918:	61 e0       	ldi	r22, 0x01	; 1
    491a:	0e 94 95 2c 	call	0x592a	; 0x592a <prvAddCurrentTaskToDelayedList>
}
    491e:	0f 90       	pop	r0
    4920:	0f 90       	pop	r0
    4922:	0f 90       	pop	r0
    4924:	0f 90       	pop	r0
    4926:	cf 91       	pop	r28
    4928:	df 91       	pop	r29
    492a:	08 95       	ret

0000492c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    492c:	df 93       	push	r29
    492e:	cf 93       	push	r28
    4930:	00 d0       	rcall	.+0      	; 0x4932 <vTaskPlaceOnUnorderedEventList+0x6>
    4932:	00 d0       	rcall	.+0      	; 0x4934 <vTaskPlaceOnUnorderedEventList+0x8>
    4934:	00 d0       	rcall	.+0      	; 0x4936 <vTaskPlaceOnUnorderedEventList+0xa>
    4936:	cd b7       	in	r28, 0x3d	; 61
    4938:	de b7       	in	r29, 0x3e	; 62
    493a:	9a 83       	std	Y+2, r25	; 0x02
    493c:	89 83       	std	Y+1, r24	; 0x01
    493e:	7c 83       	std	Y+4, r23	; 0x04
    4940:	6b 83       	std	Y+3, r22	; 0x03
    4942:	5e 83       	std	Y+6, r21	; 0x06
    4944:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4946:	e0 91 ce 06 	lds	r30, 0x06CE
    494a:	f0 91 cf 06 	lds	r31, 0x06CF
    494e:	8b 81       	ldd	r24, Y+3	; 0x03
    4950:	9c 81       	ldd	r25, Y+4	; 0x04
    4952:	90 68       	ori	r25, 0x80	; 128
    4954:	95 87       	std	Z+13, r25	; 0x0d
    4956:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4958:	80 91 ce 06 	lds	r24, 0x06CE
    495c:	90 91 cf 06 	lds	r25, 0x06CF
    4960:	9c 01       	movw	r18, r24
    4962:	24 5f       	subi	r18, 0xF4	; 244
    4964:	3f 4f       	sbci	r19, 0xFF	; 255
    4966:	89 81       	ldd	r24, Y+1	; 0x01
    4968:	9a 81       	ldd	r25, Y+2	; 0x02
    496a:	b9 01       	movw	r22, r18
    496c:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4970:	8d 81       	ldd	r24, Y+5	; 0x05
    4972:	9e 81       	ldd	r25, Y+6	; 0x06
    4974:	61 e0       	ldi	r22, 0x01	; 1
    4976:	0e 94 95 2c 	call	0x592a	; 0x592a <prvAddCurrentTaskToDelayedList>
}
    497a:	26 96       	adiw	r28, 0x06	; 6
    497c:	0f b6       	in	r0, 0x3f	; 63
    497e:	f8 94       	cli
    4980:	de bf       	out	0x3e, r29	; 62
    4982:	0f be       	out	0x3f, r0	; 63
    4984:	cd bf       	out	0x3d, r28	; 61
    4986:	cf 91       	pop	r28
    4988:	df 91       	pop	r29
    498a:	08 95       	ret

0000498c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    498c:	df 93       	push	r29
    498e:	cf 93       	push	r28
    4990:	00 d0       	rcall	.+0      	; 0x4992 <xTaskRemoveFromEventList+0x6>
    4992:	00 d0       	rcall	.+0      	; 0x4994 <xTaskRemoveFromEventList+0x8>
    4994:	0f 92       	push	r0
    4996:	cd b7       	in	r28, 0x3d	; 61
    4998:	de b7       	in	r29, 0x3e	; 62
    499a:	9d 83       	std	Y+5, r25	; 0x05
    499c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    499e:	ec 81       	ldd	r30, Y+4	; 0x04
    49a0:	fd 81       	ldd	r31, Y+5	; 0x05
    49a2:	05 80       	ldd	r0, Z+5	; 0x05
    49a4:	f6 81       	ldd	r31, Z+6	; 0x06
    49a6:	e0 2d       	mov	r30, r0
    49a8:	86 81       	ldd	r24, Z+6	; 0x06
    49aa:	97 81       	ldd	r25, Z+7	; 0x07
    49ac:	9b 83       	std	Y+3, r25	; 0x03
    49ae:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    49b0:	8a 81       	ldd	r24, Y+2	; 0x02
    49b2:	9b 81       	ldd	r25, Y+3	; 0x03
    49b4:	0c 96       	adiw	r24, 0x0c	; 12
    49b6:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    49ba:	80 91 de 06 	lds	r24, 0x06DE
    49be:	88 23       	and	r24, r24
    49c0:	61 f5       	brne	.+88     	; 0x4a1a <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    49c2:	8a 81       	ldd	r24, Y+2	; 0x02
    49c4:	9b 81       	ldd	r25, Y+3	; 0x03
    49c6:	02 96       	adiw	r24, 0x02	; 2
    49c8:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    49cc:	ea 81       	ldd	r30, Y+2	; 0x02
    49ce:	fb 81       	ldd	r31, Y+3	; 0x03
    49d0:	96 89       	ldd	r25, Z+22	; 0x16
    49d2:	80 91 d4 06 	lds	r24, 0x06D4
    49d6:	89 17       	cp	r24, r25
    49d8:	28 f4       	brcc	.+10     	; 0x49e4 <xTaskRemoveFromEventList+0x58>
    49da:	ea 81       	ldd	r30, Y+2	; 0x02
    49dc:	fb 81       	ldd	r31, Y+3	; 0x03
    49de:	86 89       	ldd	r24, Z+22	; 0x16
    49e0:	80 93 d4 06 	sts	0x06D4, r24
    49e4:	ea 81       	ldd	r30, Y+2	; 0x02
    49e6:	fb 81       	ldd	r31, Y+3	; 0x03
    49e8:	86 89       	ldd	r24, Z+22	; 0x16
    49ea:	28 2f       	mov	r18, r24
    49ec:	30 e0       	ldi	r19, 0x00	; 0
    49ee:	c9 01       	movw	r24, r18
    49f0:	88 0f       	add	r24, r24
    49f2:	99 1f       	adc	r25, r25
    49f4:	88 0f       	add	r24, r24
    49f6:	99 1f       	adc	r25, r25
    49f8:	88 0f       	add	r24, r24
    49fa:	99 1f       	adc	r25, r25
    49fc:	82 0f       	add	r24, r18
    49fe:	93 1f       	adc	r25, r19
    4a00:	ac 01       	movw	r20, r24
    4a02:	41 52       	subi	r20, 0x21	; 33
    4a04:	59 4f       	sbci	r21, 0xF9	; 249
    4a06:	8a 81       	ldd	r24, Y+2	; 0x02
    4a08:	9b 81       	ldd	r25, Y+3	; 0x03
    4a0a:	9c 01       	movw	r18, r24
    4a0c:	2e 5f       	subi	r18, 0xFE	; 254
    4a0e:	3f 4f       	sbci	r19, 0xFF	; 255
    4a10:	ca 01       	movw	r24, r20
    4a12:	b9 01       	movw	r22, r18
    4a14:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
    4a18:	0a c0       	rjmp	.+20     	; 0x4a2e <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4a1a:	8a 81       	ldd	r24, Y+2	; 0x02
    4a1c:	9b 81       	ldd	r25, Y+3	; 0x03
    4a1e:	9c 01       	movw	r18, r24
    4a20:	24 5f       	subi	r18, 0xF4	; 244
    4a22:	3f 4f       	sbci	r19, 0xFF	; 255
    4a24:	84 e3       	ldi	r24, 0x34	; 52
    4a26:	97 e0       	ldi	r25, 0x07	; 7
    4a28:	b9 01       	movw	r22, r18
    4a2a:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4a2e:	ea 81       	ldd	r30, Y+2	; 0x02
    4a30:	fb 81       	ldd	r31, Y+3	; 0x03
    4a32:	96 89       	ldd	r25, Z+22	; 0x16
    4a34:	e0 91 ce 06 	lds	r30, 0x06CE
    4a38:	f0 91 cf 06 	lds	r31, 0x06CF
    4a3c:	86 89       	ldd	r24, Z+22	; 0x16
    4a3e:	89 17       	cp	r24, r25
    4a40:	30 f4       	brcc	.+12     	; 0x4a4e <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4a42:	81 e0       	ldi	r24, 0x01	; 1
    4a44:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4a46:	81 e0       	ldi	r24, 0x01	; 1
    4a48:	80 93 d7 06 	sts	0x06D7, r24
    4a4c:	01 c0       	rjmp	.+2      	; 0x4a50 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    4a4e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4a50:	89 81       	ldd	r24, Y+1	; 0x01
}
    4a52:	0f 90       	pop	r0
    4a54:	0f 90       	pop	r0
    4a56:	0f 90       	pop	r0
    4a58:	0f 90       	pop	r0
    4a5a:	0f 90       	pop	r0
    4a5c:	cf 91       	pop	r28
    4a5e:	df 91       	pop	r29
    4a60:	08 95       	ret

00004a62 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4a62:	df 93       	push	r29
    4a64:	cf 93       	push	r28
    4a66:	00 d0       	rcall	.+0      	; 0x4a68 <vTaskRemoveFromUnorderedEventList+0x6>
    4a68:	00 d0       	rcall	.+0      	; 0x4a6a <vTaskRemoveFromUnorderedEventList+0x8>
    4a6a:	00 d0       	rcall	.+0      	; 0x4a6c <vTaskRemoveFromUnorderedEventList+0xa>
    4a6c:	cd b7       	in	r28, 0x3d	; 61
    4a6e:	de b7       	in	r29, 0x3e	; 62
    4a70:	9c 83       	std	Y+4, r25	; 0x04
    4a72:	8b 83       	std	Y+3, r24	; 0x03
    4a74:	7e 83       	std	Y+6, r23	; 0x06
    4a76:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4a78:	8d 81       	ldd	r24, Y+5	; 0x05
    4a7a:	9e 81       	ldd	r25, Y+6	; 0x06
    4a7c:	90 68       	ori	r25, 0x80	; 128
    4a7e:	eb 81       	ldd	r30, Y+3	; 0x03
    4a80:	fc 81       	ldd	r31, Y+4	; 0x04
    4a82:	91 83       	std	Z+1, r25	; 0x01
    4a84:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4a86:	eb 81       	ldd	r30, Y+3	; 0x03
    4a88:	fc 81       	ldd	r31, Y+4	; 0x04
    4a8a:	86 81       	ldd	r24, Z+6	; 0x06
    4a8c:	97 81       	ldd	r25, Z+7	; 0x07
    4a8e:	9a 83       	std	Y+2, r25	; 0x02
    4a90:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4a92:	8b 81       	ldd	r24, Y+3	; 0x03
    4a94:	9c 81       	ldd	r25, Y+4	; 0x04
    4a96:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4a9a:	89 81       	ldd	r24, Y+1	; 0x01
    4a9c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a9e:	02 96       	adiw	r24, 0x02	; 2
    4aa0:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4aa4:	e9 81       	ldd	r30, Y+1	; 0x01
    4aa6:	fa 81       	ldd	r31, Y+2	; 0x02
    4aa8:	96 89       	ldd	r25, Z+22	; 0x16
    4aaa:	80 91 d4 06 	lds	r24, 0x06D4
    4aae:	89 17       	cp	r24, r25
    4ab0:	28 f4       	brcc	.+10     	; 0x4abc <vTaskRemoveFromUnorderedEventList+0x5a>
    4ab2:	e9 81       	ldd	r30, Y+1	; 0x01
    4ab4:	fa 81       	ldd	r31, Y+2	; 0x02
    4ab6:	86 89       	ldd	r24, Z+22	; 0x16
    4ab8:	80 93 d4 06 	sts	0x06D4, r24
    4abc:	e9 81       	ldd	r30, Y+1	; 0x01
    4abe:	fa 81       	ldd	r31, Y+2	; 0x02
    4ac0:	86 89       	ldd	r24, Z+22	; 0x16
    4ac2:	28 2f       	mov	r18, r24
    4ac4:	30 e0       	ldi	r19, 0x00	; 0
    4ac6:	c9 01       	movw	r24, r18
    4ac8:	88 0f       	add	r24, r24
    4aca:	99 1f       	adc	r25, r25
    4acc:	88 0f       	add	r24, r24
    4ace:	99 1f       	adc	r25, r25
    4ad0:	88 0f       	add	r24, r24
    4ad2:	99 1f       	adc	r25, r25
    4ad4:	82 0f       	add	r24, r18
    4ad6:	93 1f       	adc	r25, r19
    4ad8:	ac 01       	movw	r20, r24
    4ada:	41 52       	subi	r20, 0x21	; 33
    4adc:	59 4f       	sbci	r21, 0xF9	; 249
    4ade:	89 81       	ldd	r24, Y+1	; 0x01
    4ae0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ae2:	9c 01       	movw	r18, r24
    4ae4:	2e 5f       	subi	r18, 0xFE	; 254
    4ae6:	3f 4f       	sbci	r19, 0xFF	; 255
    4ae8:	ca 01       	movw	r24, r20
    4aea:	b9 01       	movw	r22, r18
    4aec:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4af0:	e9 81       	ldd	r30, Y+1	; 0x01
    4af2:	fa 81       	ldd	r31, Y+2	; 0x02
    4af4:	96 89       	ldd	r25, Z+22	; 0x16
    4af6:	e0 91 ce 06 	lds	r30, 0x06CE
    4afa:	f0 91 cf 06 	lds	r31, 0x06CF
    4afe:	86 89       	ldd	r24, Z+22	; 0x16
    4b00:	89 17       	cp	r24, r25
    4b02:	18 f4       	brcc	.+6      	; 0x4b0a <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    4b04:	81 e0       	ldi	r24, 0x01	; 1
    4b06:	80 93 d7 06 	sts	0x06D7, r24
	}
}
    4b0a:	26 96       	adiw	r28, 0x06	; 6
    4b0c:	0f b6       	in	r0, 0x3f	; 63
    4b0e:	f8 94       	cli
    4b10:	de bf       	out	0x3e, r29	; 62
    4b12:	0f be       	out	0x3f, r0	; 63
    4b14:	cd bf       	out	0x3d, r28	; 61
    4b16:	cf 91       	pop	r28
    4b18:	df 91       	pop	r29
    4b1a:	08 95       	ret

00004b1c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4b1c:	df 93       	push	r29
    4b1e:	cf 93       	push	r28
    4b20:	00 d0       	rcall	.+0      	; 0x4b22 <vTaskSetTimeOutState+0x6>
    4b22:	cd b7       	in	r28, 0x3d	; 61
    4b24:	de b7       	in	r29, 0x3e	; 62
    4b26:	9a 83       	std	Y+2, r25	; 0x02
    4b28:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    4b2a:	0f b6       	in	r0, 0x3f	; 63
    4b2c:	f8 94       	cli
    4b2e:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    4b30:	80 91 d8 06 	lds	r24, 0x06D8
    4b34:	e9 81       	ldd	r30, Y+1	; 0x01
    4b36:	fa 81       	ldd	r31, Y+2	; 0x02
    4b38:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    4b3a:	80 91 d2 06 	lds	r24, 0x06D2
    4b3e:	90 91 d3 06 	lds	r25, 0x06D3
    4b42:	e9 81       	ldd	r30, Y+1	; 0x01
    4b44:	fa 81       	ldd	r31, Y+2	; 0x02
    4b46:	92 83       	std	Z+2, r25	; 0x02
    4b48:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4b4a:	0f 90       	pop	r0
    4b4c:	0f be       	out	0x3f, r0	; 63
}
    4b4e:	0f 90       	pop	r0
    4b50:	0f 90       	pop	r0
    4b52:	cf 91       	pop	r28
    4b54:	df 91       	pop	r29
    4b56:	08 95       	ret

00004b58 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4b58:	df 93       	push	r29
    4b5a:	cf 93       	push	r28
    4b5c:	00 d0       	rcall	.+0      	; 0x4b5e <vTaskInternalSetTimeOutState+0x6>
    4b5e:	cd b7       	in	r28, 0x3d	; 61
    4b60:	de b7       	in	r29, 0x3e	; 62
    4b62:	9a 83       	std	Y+2, r25	; 0x02
    4b64:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4b66:	80 91 d8 06 	lds	r24, 0x06D8
    4b6a:	e9 81       	ldd	r30, Y+1	; 0x01
    4b6c:	fa 81       	ldd	r31, Y+2	; 0x02
    4b6e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4b70:	80 91 d2 06 	lds	r24, 0x06D2
    4b74:	90 91 d3 06 	lds	r25, 0x06D3
    4b78:	e9 81       	ldd	r30, Y+1	; 0x01
    4b7a:	fa 81       	ldd	r31, Y+2	; 0x02
    4b7c:	92 83       	std	Z+2, r25	; 0x02
    4b7e:	81 83       	std	Z+1, r24	; 0x01
}
    4b80:	0f 90       	pop	r0
    4b82:	0f 90       	pop	r0
    4b84:	cf 91       	pop	r28
    4b86:	df 91       	pop	r29
    4b88:	08 95       	ret

00004b8a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4b8a:	df 93       	push	r29
    4b8c:	cf 93       	push	r28
    4b8e:	cd b7       	in	r28, 0x3d	; 61
    4b90:	de b7       	in	r29, 0x3e	; 62
    4b92:	29 97       	sbiw	r28, 0x09	; 9
    4b94:	0f b6       	in	r0, 0x3f	; 63
    4b96:	f8 94       	cli
    4b98:	de bf       	out	0x3e, r29	; 62
    4b9a:	0f be       	out	0x3f, r0	; 63
    4b9c:	cd bf       	out	0x3d, r28	; 61
    4b9e:	9f 83       	std	Y+7, r25	; 0x07
    4ba0:	8e 83       	std	Y+6, r24	; 0x06
    4ba2:	79 87       	std	Y+9, r23	; 0x09
    4ba4:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4ba6:	0f b6       	in	r0, 0x3f	; 63
    4ba8:	f8 94       	cli
    4baa:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4bac:	80 91 d2 06 	lds	r24, 0x06D2
    4bb0:	90 91 d3 06 	lds	r25, 0x06D3
    4bb4:	9c 83       	std	Y+4, r25	; 0x04
    4bb6:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4bb8:	ee 81       	ldd	r30, Y+6	; 0x06
    4bba:	ff 81       	ldd	r31, Y+7	; 0x07
    4bbc:	21 81       	ldd	r18, Z+1	; 0x01
    4bbe:	32 81       	ldd	r19, Z+2	; 0x02
    4bc0:	8b 81       	ldd	r24, Y+3	; 0x03
    4bc2:	9c 81       	ldd	r25, Y+4	; 0x04
    4bc4:	82 1b       	sub	r24, r18
    4bc6:	93 0b       	sbc	r25, r19
    4bc8:	9a 83       	std	Y+2, r25	; 0x02
    4bca:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    4bcc:	e8 85       	ldd	r30, Y+8	; 0x08
    4bce:	f9 85       	ldd	r31, Y+9	; 0x09
    4bd0:	80 81       	ld	r24, Z
    4bd2:	91 81       	ldd	r25, Z+1	; 0x01
    4bd4:	2f ef       	ldi	r18, 0xFF	; 255
    4bd6:	8f 3f       	cpi	r24, 0xFF	; 255
    4bd8:	92 07       	cpc	r25, r18
    4bda:	11 f4       	brne	.+4      	; 0x4be0 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    4bdc:	1d 82       	std	Y+5, r1	; 0x05
    4bde:	36 c0       	rjmp	.+108    	; 0x4c4c <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4be0:	ee 81       	ldd	r30, Y+6	; 0x06
    4be2:	ff 81       	ldd	r31, Y+7	; 0x07
    4be4:	90 81       	ld	r25, Z
    4be6:	80 91 d8 06 	lds	r24, 0x06D8
    4bea:	98 17       	cp	r25, r24
    4bec:	61 f0       	breq	.+24     	; 0x4c06 <xTaskCheckForTimeOut+0x7c>
    4bee:	ee 81       	ldd	r30, Y+6	; 0x06
    4bf0:	ff 81       	ldd	r31, Y+7	; 0x07
    4bf2:	21 81       	ldd	r18, Z+1	; 0x01
    4bf4:	32 81       	ldd	r19, Z+2	; 0x02
    4bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    4bf8:	9c 81       	ldd	r25, Y+4	; 0x04
    4bfa:	82 17       	cp	r24, r18
    4bfc:	93 07       	cpc	r25, r19
    4bfe:	18 f0       	brcs	.+6      	; 0x4c06 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    4c00:	81 e0       	ldi	r24, 0x01	; 1
    4c02:	8d 83       	std	Y+5, r24	; 0x05
    4c04:	23 c0       	rjmp	.+70     	; 0x4c4c <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4c06:	e8 85       	ldd	r30, Y+8	; 0x08
    4c08:	f9 85       	ldd	r31, Y+9	; 0x09
    4c0a:	20 81       	ld	r18, Z
    4c0c:	31 81       	ldd	r19, Z+1	; 0x01
    4c0e:	89 81       	ldd	r24, Y+1	; 0x01
    4c10:	9a 81       	ldd	r25, Y+2	; 0x02
    4c12:	82 17       	cp	r24, r18
    4c14:	93 07       	cpc	r25, r19
    4c16:	a0 f4       	brcc	.+40     	; 0x4c40 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    4c18:	e8 85       	ldd	r30, Y+8	; 0x08
    4c1a:	f9 85       	ldd	r31, Y+9	; 0x09
    4c1c:	20 81       	ld	r18, Z
    4c1e:	31 81       	ldd	r19, Z+1	; 0x01
    4c20:	89 81       	ldd	r24, Y+1	; 0x01
    4c22:	9a 81       	ldd	r25, Y+2	; 0x02
    4c24:	a9 01       	movw	r20, r18
    4c26:	48 1b       	sub	r20, r24
    4c28:	59 0b       	sbc	r21, r25
    4c2a:	ca 01       	movw	r24, r20
    4c2c:	e8 85       	ldd	r30, Y+8	; 0x08
    4c2e:	f9 85       	ldd	r31, Y+9	; 0x09
    4c30:	91 83       	std	Z+1, r25	; 0x01
    4c32:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    4c34:	8e 81       	ldd	r24, Y+6	; 0x06
    4c36:	9f 81       	ldd	r25, Y+7	; 0x07
    4c38:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    4c3c:	1d 82       	std	Y+5, r1	; 0x05
    4c3e:	06 c0       	rjmp	.+12     	; 0x4c4c <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    4c40:	e8 85       	ldd	r30, Y+8	; 0x08
    4c42:	f9 85       	ldd	r31, Y+9	; 0x09
    4c44:	11 82       	std	Z+1, r1	; 0x01
    4c46:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    4c48:	81 e0       	ldi	r24, 0x01	; 1
    4c4a:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    4c4c:	0f 90       	pop	r0
    4c4e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4c50:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4c52:	29 96       	adiw	r28, 0x09	; 9
    4c54:	0f b6       	in	r0, 0x3f	; 63
    4c56:	f8 94       	cli
    4c58:	de bf       	out	0x3e, r29	; 62
    4c5a:	0f be       	out	0x3f, r0	; 63
    4c5c:	cd bf       	out	0x3d, r28	; 61
    4c5e:	cf 91       	pop	r28
    4c60:	df 91       	pop	r29
    4c62:	08 95       	ret

00004c64 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4c64:	df 93       	push	r29
    4c66:	cf 93       	push	r28
    4c68:	cd b7       	in	r28, 0x3d	; 61
    4c6a:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    4c6c:	81 e0       	ldi	r24, 0x01	; 1
    4c6e:	80 93 d7 06 	sts	0x06D7, r24
}
    4c72:	cf 91       	pop	r28
    4c74:	df 91       	pop	r29
    4c76:	08 95       	ret

00004c78 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4c78:	df 93       	push	r29
    4c7a:	cf 93       	push	r28
    4c7c:	00 d0       	rcall	.+0      	; 0x4c7e <prvIdleTask+0x6>
    4c7e:	cd b7       	in	r28, 0x3d	; 61
    4c80:	de b7       	in	r29, 0x3e	; 62
    4c82:	9a 83       	std	Y+2, r25	; 0x02
    4c84:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    4c86:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <prvCheckTasksWaitingTermination>
    4c8a:	fd cf       	rjmp	.-6      	; 0x4c86 <prvIdleTask+0xe>

00004c8c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4c8c:	df 93       	push	r29
    4c8e:	cf 93       	push	r28
    4c90:	0f 92       	push	r0
    4c92:	cd b7       	in	r28, 0x3d	; 61
    4c94:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4c96:	19 82       	std	Y+1, r1	; 0x01
    4c98:	13 c0       	rjmp	.+38     	; 0x4cc0 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4c9a:	89 81       	ldd	r24, Y+1	; 0x01
    4c9c:	28 2f       	mov	r18, r24
    4c9e:	30 e0       	ldi	r19, 0x00	; 0
    4ca0:	c9 01       	movw	r24, r18
    4ca2:	88 0f       	add	r24, r24
    4ca4:	99 1f       	adc	r25, r25
    4ca6:	88 0f       	add	r24, r24
    4ca8:	99 1f       	adc	r25, r25
    4caa:	88 0f       	add	r24, r24
    4cac:	99 1f       	adc	r25, r25
    4cae:	82 0f       	add	r24, r18
    4cb0:	93 1f       	adc	r25, r19
    4cb2:	81 52       	subi	r24, 0x21	; 33
    4cb4:	99 4f       	sbci	r25, 0xF9	; 249
    4cb6:	0e 94 ad 0a 	call	0x155a	; 0x155a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4cba:	89 81       	ldd	r24, Y+1	; 0x01
    4cbc:	8f 5f       	subi	r24, 0xFF	; 255
    4cbe:	89 83       	std	Y+1, r24	; 0x01
    4cc0:	89 81       	ldd	r24, Y+1	; 0x01
    4cc2:	87 30       	cpi	r24, 0x07	; 7
    4cc4:	50 f3       	brcs	.-44     	; 0x4c9a <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4cc6:	8e e1       	ldi	r24, 0x1E	; 30
    4cc8:	97 e0       	ldi	r25, 0x07	; 7
    4cca:	0e 94 ad 0a 	call	0x155a	; 0x155a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4cce:	87 e2       	ldi	r24, 0x27	; 39
    4cd0:	97 e0       	ldi	r25, 0x07	; 7
    4cd2:	0e 94 ad 0a 	call	0x155a	; 0x155a <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4cd6:	84 e3       	ldi	r24, 0x34	; 52
    4cd8:	97 e0       	ldi	r25, 0x07	; 7
    4cda:	0e 94 ad 0a 	call	0x155a	; 0x155a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4cde:	8d e3       	ldi	r24, 0x3D	; 61
    4ce0:	97 e0       	ldi	r25, 0x07	; 7
    4ce2:	0e 94 ad 0a 	call	0x155a	; 0x155a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4ce6:	86 e4       	ldi	r24, 0x46	; 70
    4ce8:	97 e0       	ldi	r25, 0x07	; 7
    4cea:	0e 94 ad 0a 	call	0x155a	; 0x155a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4cee:	8e e1       	ldi	r24, 0x1E	; 30
    4cf0:	97 e0       	ldi	r25, 0x07	; 7
    4cf2:	90 93 31 07 	sts	0x0731, r25
    4cf6:	80 93 30 07 	sts	0x0730, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4cfa:	87 e2       	ldi	r24, 0x27	; 39
    4cfc:	97 e0       	ldi	r25, 0x07	; 7
    4cfe:	90 93 33 07 	sts	0x0733, r25
    4d02:	80 93 32 07 	sts	0x0732, r24
}
    4d06:	0f 90       	pop	r0
    4d08:	cf 91       	pop	r28
    4d0a:	df 91       	pop	r29
    4d0c:	08 95       	ret

00004d0e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4d0e:	df 93       	push	r29
    4d10:	cf 93       	push	r28
    4d12:	00 d0       	rcall	.+0      	; 0x4d14 <prvCheckTasksWaitingTermination+0x6>
    4d14:	cd b7       	in	r28, 0x3d	; 61
    4d16:	de b7       	in	r29, 0x3e	; 62
    4d18:	20 c0       	rjmp	.+64     	; 0x4d5a <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    4d1a:	0f b6       	in	r0, 0x3f	; 63
    4d1c:	f8 94       	cli
    4d1e:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4d20:	e0 91 42 07 	lds	r30, 0x0742
    4d24:	f0 91 43 07 	lds	r31, 0x0743
    4d28:	86 81       	ldd	r24, Z+6	; 0x06
    4d2a:	97 81       	ldd	r25, Z+7	; 0x07
    4d2c:	9a 83       	std	Y+2, r25	; 0x02
    4d2e:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4d30:	89 81       	ldd	r24, Y+1	; 0x01
    4d32:	9a 81       	ldd	r25, Y+2	; 0x02
    4d34:	02 96       	adiw	r24, 0x02	; 2
    4d36:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
				--uxCurrentNumberOfTasks;
    4d3a:	80 91 d1 06 	lds	r24, 0x06D1
    4d3e:	81 50       	subi	r24, 0x01	; 1
    4d40:	80 93 d1 06 	sts	0x06D1, r24
				--uxDeletedTasksWaitingCleanUp;
    4d44:	80 91 d0 06 	lds	r24, 0x06D0
    4d48:	81 50       	subi	r24, 0x01	; 1
    4d4a:	80 93 d0 06 	sts	0x06D0, r24
			}
			taskEXIT_CRITICAL();
    4d4e:	0f 90       	pop	r0
    4d50:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    4d52:	89 81       	ldd	r24, Y+1	; 0x01
    4d54:	9a 81       	ldd	r25, Y+2	; 0x02
    4d56:	0e 94 b6 26 	call	0x4d6c	; 0x4d6c <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4d5a:	80 91 d0 06 	lds	r24, 0x06D0
    4d5e:	88 23       	and	r24, r24
    4d60:	e1 f6       	brne	.-72     	; 0x4d1a <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    4d62:	0f 90       	pop	r0
    4d64:	0f 90       	pop	r0
    4d66:	cf 91       	pop	r28
    4d68:	df 91       	pop	r29
    4d6a:	08 95       	ret

00004d6c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4d6c:	df 93       	push	r29
    4d6e:	cf 93       	push	r28
    4d70:	00 d0       	rcall	.+0      	; 0x4d72 <prvDeleteTCB+0x6>
    4d72:	cd b7       	in	r28, 0x3d	; 61
    4d74:	de b7       	in	r29, 0x3e	; 62
    4d76:	9a 83       	std	Y+2, r25	; 0x02
    4d78:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    4d7a:	e9 81       	ldd	r30, Y+1	; 0x01
    4d7c:	fa 81       	ldd	r31, Y+2	; 0x02
    4d7e:	87 89       	ldd	r24, Z+23	; 0x17
    4d80:	90 8d       	ldd	r25, Z+24	; 0x18
    4d82:	0e 94 fe 08 	call	0x11fc	; 0x11fc <vPortFree>
			vPortFree( pxTCB );
    4d86:	89 81       	ldd	r24, Y+1	; 0x01
    4d88:	9a 81       	ldd	r25, Y+2	; 0x02
    4d8a:	0e 94 fe 08 	call	0x11fc	; 0x11fc <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4d8e:	0f 90       	pop	r0
    4d90:	0f 90       	pop	r0
    4d92:	cf 91       	pop	r28
    4d94:	df 91       	pop	r29
    4d96:	08 95       	ret

00004d98 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4d98:	df 93       	push	r29
    4d9a:	cf 93       	push	r28
    4d9c:	00 d0       	rcall	.+0      	; 0x4d9e <prvResetNextTaskUnblockTime+0x6>
    4d9e:	cd b7       	in	r28, 0x3d	; 61
    4da0:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4da2:	e0 91 30 07 	lds	r30, 0x0730
    4da6:	f0 91 31 07 	lds	r31, 0x0731
    4daa:	80 81       	ld	r24, Z
    4dac:	88 23       	and	r24, r24
    4dae:	39 f4       	brne	.+14     	; 0x4dbe <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4db0:	8f ef       	ldi	r24, 0xFF	; 255
    4db2:	9f ef       	ldi	r25, 0xFF	; 255
    4db4:	90 93 db 06 	sts	0x06DB, r25
    4db8:	80 93 da 06 	sts	0x06DA, r24
    4dbc:	13 c0       	rjmp	.+38     	; 0x4de4 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4dbe:	e0 91 30 07 	lds	r30, 0x0730
    4dc2:	f0 91 31 07 	lds	r31, 0x0731
    4dc6:	05 80       	ldd	r0, Z+5	; 0x05
    4dc8:	f6 81       	ldd	r31, Z+6	; 0x06
    4dca:	e0 2d       	mov	r30, r0
    4dcc:	86 81       	ldd	r24, Z+6	; 0x06
    4dce:	97 81       	ldd	r25, Z+7	; 0x07
    4dd0:	9a 83       	std	Y+2, r25	; 0x02
    4dd2:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4dd4:	e9 81       	ldd	r30, Y+1	; 0x01
    4dd6:	fa 81       	ldd	r31, Y+2	; 0x02
    4dd8:	82 81       	ldd	r24, Z+2	; 0x02
    4dda:	93 81       	ldd	r25, Z+3	; 0x03
    4ddc:	90 93 db 06 	sts	0x06DB, r25
    4de0:	80 93 da 06 	sts	0x06DA, r24
	}
}
    4de4:	0f 90       	pop	r0
    4de6:	0f 90       	pop	r0
    4de8:	cf 91       	pop	r28
    4dea:	df 91       	pop	r29
    4dec:	08 95       	ret

00004dee <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4dee:	df 93       	push	r29
    4df0:	cf 93       	push	r28
    4df2:	00 d0       	rcall	.+0      	; 0x4df4 <xTaskGetCurrentTaskHandle+0x6>
    4df4:	cd b7       	in	r28, 0x3d	; 61
    4df6:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4df8:	80 91 ce 06 	lds	r24, 0x06CE
    4dfc:	90 91 cf 06 	lds	r25, 0x06CF
    4e00:	9a 83       	std	Y+2, r25	; 0x02
    4e02:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4e04:	89 81       	ldd	r24, Y+1	; 0x01
    4e06:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4e08:	0f 90       	pop	r0
    4e0a:	0f 90       	pop	r0
    4e0c:	cf 91       	pop	r28
    4e0e:	df 91       	pop	r29
    4e10:	08 95       	ret

00004e12 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    4e12:	df 93       	push	r29
    4e14:	cf 93       	push	r28
    4e16:	00 d0       	rcall	.+0      	; 0x4e18 <xTaskPriorityInherit+0x6>
    4e18:	00 d0       	rcall	.+0      	; 0x4e1a <xTaskPriorityInherit+0x8>
    4e1a:	0f 92       	push	r0
    4e1c:	cd b7       	in	r28, 0x3d	; 61
    4e1e:	de b7       	in	r29, 0x3e	; 62
    4e20:	9d 83       	std	Y+5, r25	; 0x05
    4e22:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    4e24:	8c 81       	ldd	r24, Y+4	; 0x04
    4e26:	9d 81       	ldd	r25, Y+5	; 0x05
    4e28:	9b 83       	std	Y+3, r25	; 0x03
    4e2a:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    4e2c:	19 82       	std	Y+1, r1	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    4e2e:	8c 81       	ldd	r24, Y+4	; 0x04
    4e30:	9d 81       	ldd	r25, Y+5	; 0x05
    4e32:	00 97       	sbiw	r24, 0x00	; 0
    4e34:	09 f4       	brne	.+2      	; 0x4e38 <xTaskPriorityInherit+0x26>
    4e36:	82 c0       	rjmp	.+260    	; 0x4f3c <xTaskPriorityInherit+0x12a>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    4e38:	ea 81       	ldd	r30, Y+2	; 0x02
    4e3a:	fb 81       	ldd	r31, Y+3	; 0x03
    4e3c:	96 89       	ldd	r25, Z+22	; 0x16
    4e3e:	e0 91 ce 06 	lds	r30, 0x06CE
    4e42:	f0 91 cf 06 	lds	r31, 0x06CF
    4e46:	86 89       	ldd	r24, Z+22	; 0x16
    4e48:	98 17       	cp	r25, r24
    4e4a:	08 f0       	brcs	.+2      	; 0x4e4e <xTaskPriorityInherit+0x3c>
    4e4c:	6b c0       	rjmp	.+214    	; 0x4f24 <xTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    4e4e:	ea 81       	ldd	r30, Y+2	; 0x02
    4e50:	fb 81       	ldd	r31, Y+3	; 0x03
    4e52:	84 85       	ldd	r24, Z+12	; 0x0c
    4e54:	95 85       	ldd	r25, Z+13	; 0x0d
    4e56:	99 23       	and	r25, r25
    4e58:	7c f0       	brlt	.+30     	; 0x4e78 <xTaskPriorityInherit+0x66>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4e5a:	e0 91 ce 06 	lds	r30, 0x06CE
    4e5e:	f0 91 cf 06 	lds	r31, 0x06CF
    4e62:	86 89       	ldd	r24, Z+22	; 0x16
    4e64:	28 2f       	mov	r18, r24
    4e66:	30 e0       	ldi	r19, 0x00	; 0
    4e68:	87 e0       	ldi	r24, 0x07	; 7
    4e6a:	90 e0       	ldi	r25, 0x00	; 0
    4e6c:	82 1b       	sub	r24, r18
    4e6e:	93 0b       	sbc	r25, r19
    4e70:	ea 81       	ldd	r30, Y+2	; 0x02
    4e72:	fb 81       	ldd	r31, Y+3	; 0x03
    4e74:	95 87       	std	Z+13, r25	; 0x0d
    4e76:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    4e78:	ea 81       	ldd	r30, Y+2	; 0x02
    4e7a:	fb 81       	ldd	r31, Y+3	; 0x03
    4e7c:	42 85       	ldd	r20, Z+10	; 0x0a
    4e7e:	53 85       	ldd	r21, Z+11	; 0x0b
    4e80:	ea 81       	ldd	r30, Y+2	; 0x02
    4e82:	fb 81       	ldd	r31, Y+3	; 0x03
    4e84:	86 89       	ldd	r24, Z+22	; 0x16
    4e86:	28 2f       	mov	r18, r24
    4e88:	30 e0       	ldi	r19, 0x00	; 0
    4e8a:	c9 01       	movw	r24, r18
    4e8c:	88 0f       	add	r24, r24
    4e8e:	99 1f       	adc	r25, r25
    4e90:	88 0f       	add	r24, r24
    4e92:	99 1f       	adc	r25, r25
    4e94:	88 0f       	add	r24, r24
    4e96:	99 1f       	adc	r25, r25
    4e98:	82 0f       	add	r24, r18
    4e9a:	93 1f       	adc	r25, r19
    4e9c:	81 52       	subi	r24, 0x21	; 33
    4e9e:	99 4f       	sbci	r25, 0xF9	; 249
    4ea0:	48 17       	cp	r20, r24
    4ea2:	59 07       	cpc	r21, r25
    4ea4:	a1 f5       	brne	.+104    	; 0x4f0e <xTaskPriorityInherit+0xfc>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4ea6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ea8:	9b 81       	ldd	r25, Y+3	; 0x03
    4eaa:	02 96       	adiw	r24, 0x02	; 2
    4eac:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    4eb0:	e0 91 ce 06 	lds	r30, 0x06CE
    4eb4:	f0 91 cf 06 	lds	r31, 0x06CF
    4eb8:	86 89       	ldd	r24, Z+22	; 0x16
    4eba:	ea 81       	ldd	r30, Y+2	; 0x02
    4ebc:	fb 81       	ldd	r31, Y+3	; 0x03
    4ebe:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    4ec0:	ea 81       	ldd	r30, Y+2	; 0x02
    4ec2:	fb 81       	ldd	r31, Y+3	; 0x03
    4ec4:	96 89       	ldd	r25, Z+22	; 0x16
    4ec6:	80 91 d4 06 	lds	r24, 0x06D4
    4eca:	89 17       	cp	r24, r25
    4ecc:	28 f4       	brcc	.+10     	; 0x4ed8 <xTaskPriorityInherit+0xc6>
    4ece:	ea 81       	ldd	r30, Y+2	; 0x02
    4ed0:	fb 81       	ldd	r31, Y+3	; 0x03
    4ed2:	86 89       	ldd	r24, Z+22	; 0x16
    4ed4:	80 93 d4 06 	sts	0x06D4, r24
    4ed8:	ea 81       	ldd	r30, Y+2	; 0x02
    4eda:	fb 81       	ldd	r31, Y+3	; 0x03
    4edc:	86 89       	ldd	r24, Z+22	; 0x16
    4ede:	28 2f       	mov	r18, r24
    4ee0:	30 e0       	ldi	r19, 0x00	; 0
    4ee2:	c9 01       	movw	r24, r18
    4ee4:	88 0f       	add	r24, r24
    4ee6:	99 1f       	adc	r25, r25
    4ee8:	88 0f       	add	r24, r24
    4eea:	99 1f       	adc	r25, r25
    4eec:	88 0f       	add	r24, r24
    4eee:	99 1f       	adc	r25, r25
    4ef0:	82 0f       	add	r24, r18
    4ef2:	93 1f       	adc	r25, r19
    4ef4:	ac 01       	movw	r20, r24
    4ef6:	41 52       	subi	r20, 0x21	; 33
    4ef8:	59 4f       	sbci	r21, 0xF9	; 249
    4efa:	8a 81       	ldd	r24, Y+2	; 0x02
    4efc:	9b 81       	ldd	r25, Y+3	; 0x03
    4efe:	9c 01       	movw	r18, r24
    4f00:	2e 5f       	subi	r18, 0xFE	; 254
    4f02:	3f 4f       	sbci	r19, 0xFF	; 255
    4f04:	ca 01       	movw	r24, r20
    4f06:	b9 01       	movw	r22, r18
    4f08:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
    4f0c:	08 c0       	rjmp	.+16     	; 0x4f1e <xTaskPriorityInherit+0x10c>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    4f0e:	e0 91 ce 06 	lds	r30, 0x06CE
    4f12:	f0 91 cf 06 	lds	r31, 0x06CF
    4f16:	86 89       	ldd	r24, Z+22	; 0x16
    4f18:	ea 81       	ldd	r30, Y+2	; 0x02
    4f1a:	fb 81       	ldd	r31, Y+3	; 0x03
    4f1c:	86 8b       	std	Z+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    4f1e:	81 e0       	ldi	r24, 0x01	; 1
    4f20:	89 83       	std	Y+1, r24	; 0x01
    4f22:	0c c0       	rjmp	.+24     	; 0x4f3c <xTaskPriorityInherit+0x12a>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    4f24:	ea 81       	ldd	r30, Y+2	; 0x02
    4f26:	fb 81       	ldd	r31, Y+3	; 0x03
    4f28:	95 a5       	ldd	r25, Z+45	; 0x2d
    4f2a:	e0 91 ce 06 	lds	r30, 0x06CE
    4f2e:	f0 91 cf 06 	lds	r31, 0x06CF
    4f32:	86 89       	ldd	r24, Z+22	; 0x16
    4f34:	98 17       	cp	r25, r24
    4f36:	10 f4       	brcc	.+4      	; 0x4f3c <xTaskPriorityInherit+0x12a>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    4f38:	81 e0       	ldi	r24, 0x01	; 1
    4f3a:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4f3c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4f3e:	0f 90       	pop	r0
    4f40:	0f 90       	pop	r0
    4f42:	0f 90       	pop	r0
    4f44:	0f 90       	pop	r0
    4f46:	0f 90       	pop	r0
    4f48:	cf 91       	pop	r28
    4f4a:	df 91       	pop	r29
    4f4c:	08 95       	ret

00004f4e <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    4f4e:	df 93       	push	r29
    4f50:	cf 93       	push	r28
    4f52:	00 d0       	rcall	.+0      	; 0x4f54 <xTaskPriorityDisinherit+0x6>
    4f54:	00 d0       	rcall	.+0      	; 0x4f56 <xTaskPriorityDisinherit+0x8>
    4f56:	0f 92       	push	r0
    4f58:	cd b7       	in	r28, 0x3d	; 61
    4f5a:	de b7       	in	r29, 0x3e	; 62
    4f5c:	9d 83       	std	Y+5, r25	; 0x05
    4f5e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = pxMutexHolder;
    4f60:	8c 81       	ldd	r24, Y+4	; 0x04
    4f62:	9d 81       	ldd	r25, Y+5	; 0x05
    4f64:	9b 83       	std	Y+3, r25	; 0x03
    4f66:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    4f68:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    4f6a:	8c 81       	ldd	r24, Y+4	; 0x04
    4f6c:	9d 81       	ldd	r25, Y+5	; 0x05
    4f6e:	00 97       	sbiw	r24, 0x00	; 0
    4f70:	09 f4       	brne	.+2      	; 0x4f74 <xTaskPriorityDisinherit+0x26>
    4f72:	56 c0       	rjmp	.+172    	; 0x5020 <xTaskPriorityDisinherit+0xd2>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    4f74:	ea 81       	ldd	r30, Y+2	; 0x02
    4f76:	fb 81       	ldd	r31, Y+3	; 0x03
    4f78:	86 a5       	ldd	r24, Z+46	; 0x2e
    4f7a:	81 50       	subi	r24, 0x01	; 1
    4f7c:	ea 81       	ldd	r30, Y+2	; 0x02
    4f7e:	fb 81       	ldd	r31, Y+3	; 0x03
    4f80:	86 a7       	std	Z+46, r24	; 0x2e

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    4f82:	ea 81       	ldd	r30, Y+2	; 0x02
    4f84:	fb 81       	ldd	r31, Y+3	; 0x03
    4f86:	96 89       	ldd	r25, Z+22	; 0x16
    4f88:	ea 81       	ldd	r30, Y+2	; 0x02
    4f8a:	fb 81       	ldd	r31, Y+3	; 0x03
    4f8c:	85 a5       	ldd	r24, Z+45	; 0x2d
    4f8e:	98 17       	cp	r25, r24
    4f90:	09 f4       	brne	.+2      	; 0x4f94 <xTaskPriorityDisinherit+0x46>
    4f92:	46 c0       	rjmp	.+140    	; 0x5020 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    4f94:	ea 81       	ldd	r30, Y+2	; 0x02
    4f96:	fb 81       	ldd	r31, Y+3	; 0x03
    4f98:	86 a5       	ldd	r24, Z+46	; 0x2e
    4f9a:	88 23       	and	r24, r24
    4f9c:	09 f0       	breq	.+2      	; 0x4fa0 <xTaskPriorityDisinherit+0x52>
    4f9e:	40 c0       	rjmp	.+128    	; 0x5020 <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4fa0:	8a 81       	ldd	r24, Y+2	; 0x02
    4fa2:	9b 81       	ldd	r25, Y+3	; 0x03
    4fa4:	02 96       	adiw	r24, 0x02	; 2
    4fa6:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    4faa:	ea 81       	ldd	r30, Y+2	; 0x02
    4fac:	fb 81       	ldd	r31, Y+3	; 0x03
    4fae:	85 a5       	ldd	r24, Z+45	; 0x2d
    4fb0:	ea 81       	ldd	r30, Y+2	; 0x02
    4fb2:	fb 81       	ldd	r31, Y+3	; 0x03
    4fb4:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4fb6:	ea 81       	ldd	r30, Y+2	; 0x02
    4fb8:	fb 81       	ldd	r31, Y+3	; 0x03
    4fba:	86 89       	ldd	r24, Z+22	; 0x16
    4fbc:	28 2f       	mov	r18, r24
    4fbe:	30 e0       	ldi	r19, 0x00	; 0
    4fc0:	87 e0       	ldi	r24, 0x07	; 7
    4fc2:	90 e0       	ldi	r25, 0x00	; 0
    4fc4:	82 1b       	sub	r24, r18
    4fc6:	93 0b       	sbc	r25, r19
    4fc8:	ea 81       	ldd	r30, Y+2	; 0x02
    4fca:	fb 81       	ldd	r31, Y+3	; 0x03
    4fcc:	95 87       	std	Z+13, r25	; 0x0d
    4fce:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    4fd0:	ea 81       	ldd	r30, Y+2	; 0x02
    4fd2:	fb 81       	ldd	r31, Y+3	; 0x03
    4fd4:	96 89       	ldd	r25, Z+22	; 0x16
    4fd6:	80 91 d4 06 	lds	r24, 0x06D4
    4fda:	89 17       	cp	r24, r25
    4fdc:	28 f4       	brcc	.+10     	; 0x4fe8 <xTaskPriorityDisinherit+0x9a>
    4fde:	ea 81       	ldd	r30, Y+2	; 0x02
    4fe0:	fb 81       	ldd	r31, Y+3	; 0x03
    4fe2:	86 89       	ldd	r24, Z+22	; 0x16
    4fe4:	80 93 d4 06 	sts	0x06D4, r24
    4fe8:	ea 81       	ldd	r30, Y+2	; 0x02
    4fea:	fb 81       	ldd	r31, Y+3	; 0x03
    4fec:	86 89       	ldd	r24, Z+22	; 0x16
    4fee:	28 2f       	mov	r18, r24
    4ff0:	30 e0       	ldi	r19, 0x00	; 0
    4ff2:	c9 01       	movw	r24, r18
    4ff4:	88 0f       	add	r24, r24
    4ff6:	99 1f       	adc	r25, r25
    4ff8:	88 0f       	add	r24, r24
    4ffa:	99 1f       	adc	r25, r25
    4ffc:	88 0f       	add	r24, r24
    4ffe:	99 1f       	adc	r25, r25
    5000:	82 0f       	add	r24, r18
    5002:	93 1f       	adc	r25, r19
    5004:	ac 01       	movw	r20, r24
    5006:	41 52       	subi	r20, 0x21	; 33
    5008:	59 4f       	sbci	r21, 0xF9	; 249
    500a:	8a 81       	ldd	r24, Y+2	; 0x02
    500c:	9b 81       	ldd	r25, Y+3	; 0x03
    500e:	9c 01       	movw	r18, r24
    5010:	2e 5f       	subi	r18, 0xFE	; 254
    5012:	3f 4f       	sbci	r19, 0xFF	; 255
    5014:	ca 01       	movw	r24, r20
    5016:	b9 01       	movw	r22, r18
    5018:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    501c:	81 e0       	ldi	r24, 0x01	; 1
    501e:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    5020:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5022:	0f 90       	pop	r0
    5024:	0f 90       	pop	r0
    5026:	0f 90       	pop	r0
    5028:	0f 90       	pop	r0
    502a:	0f 90       	pop	r0
    502c:	cf 91       	pop	r28
    502e:	df 91       	pop	r29
    5030:	08 95       	ret

00005032 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    5032:	df 93       	push	r29
    5034:	cf 93       	push	r28
    5036:	cd b7       	in	r28, 0x3d	; 61
    5038:	de b7       	in	r29, 0x3e	; 62
    503a:	28 97       	sbiw	r28, 0x08	; 8
    503c:	0f b6       	in	r0, 0x3f	; 63
    503e:	f8 94       	cli
    5040:	de bf       	out	0x3e, r29	; 62
    5042:	0f be       	out	0x3f, r0	; 63
    5044:	cd bf       	out	0x3d, r28	; 61
    5046:	9f 83       	std	Y+7, r25	; 0x07
    5048:	8e 83       	std	Y+6, r24	; 0x06
    504a:	68 87       	std	Y+8, r22	; 0x08
	TCB_t * const pxTCB = pxMutexHolder;
    504c:	8e 81       	ldd	r24, Y+6	; 0x06
    504e:	9f 81       	ldd	r25, Y+7	; 0x07
    5050:	9d 83       	std	Y+5, r25	; 0x05
    5052:	8c 83       	std	Y+4, r24	; 0x04
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    5054:	81 e0       	ldi	r24, 0x01	; 1
    5056:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    5058:	8e 81       	ldd	r24, Y+6	; 0x06
    505a:	9f 81       	ldd	r25, Y+7	; 0x07
    505c:	00 97       	sbiw	r24, 0x00	; 0
    505e:	09 f4       	brne	.+2      	; 0x5062 <vTaskPriorityDisinheritAfterTimeout+0x30>
    5060:	74 c0       	rjmp	.+232    	; 0x514a <vTaskPriorityDisinheritAfterTimeout+0x118>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    5062:	ec 81       	ldd	r30, Y+4	; 0x04
    5064:	fd 81       	ldd	r31, Y+5	; 0x05
    5066:	95 a5       	ldd	r25, Z+45	; 0x2d
    5068:	88 85       	ldd	r24, Y+8	; 0x08
    506a:	98 17       	cp	r25, r24
    506c:	18 f4       	brcc	.+6      	; 0x5074 <vTaskPriorityDisinheritAfterTimeout+0x42>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    506e:	88 85       	ldd	r24, Y+8	; 0x08
    5070:	8a 83       	std	Y+2, r24	; 0x02
    5072:	04 c0       	rjmp	.+8      	; 0x507c <vTaskPriorityDisinheritAfterTimeout+0x4a>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    5074:	ec 81       	ldd	r30, Y+4	; 0x04
    5076:	fd 81       	ldd	r31, Y+5	; 0x05
    5078:	85 a5       	ldd	r24, Z+45	; 0x2d
    507a:	8a 83       	std	Y+2, r24	; 0x02
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    507c:	ec 81       	ldd	r30, Y+4	; 0x04
    507e:	fd 81       	ldd	r31, Y+5	; 0x05
    5080:	96 89       	ldd	r25, Z+22	; 0x16
    5082:	8a 81       	ldd	r24, Y+2	; 0x02
    5084:	98 17       	cp	r25, r24
    5086:	09 f4       	brne	.+2      	; 0x508a <vTaskPriorityDisinheritAfterTimeout+0x58>
    5088:	60 c0       	rjmp	.+192    	; 0x514a <vTaskPriorityDisinheritAfterTimeout+0x118>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    508a:	ec 81       	ldd	r30, Y+4	; 0x04
    508c:	fd 81       	ldd	r31, Y+5	; 0x05
    508e:	96 a5       	ldd	r25, Z+46	; 0x2e
    5090:	89 81       	ldd	r24, Y+1	; 0x01
    5092:	98 17       	cp	r25, r24
    5094:	09 f0       	breq	.+2      	; 0x5098 <vTaskPriorityDisinheritAfterTimeout+0x66>
    5096:	59 c0       	rjmp	.+178    	; 0x514a <vTaskPriorityDisinheritAfterTimeout+0x118>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    5098:	ec 81       	ldd	r30, Y+4	; 0x04
    509a:	fd 81       	ldd	r31, Y+5	; 0x05
    509c:	86 89       	ldd	r24, Z+22	; 0x16
    509e:	8b 83       	std	Y+3, r24	; 0x03
					pxTCB->uxPriority = uxPriorityToUse;
    50a0:	ec 81       	ldd	r30, Y+4	; 0x04
    50a2:	fd 81       	ldd	r31, Y+5	; 0x05
    50a4:	8a 81       	ldd	r24, Y+2	; 0x02
    50a6:	86 8b       	std	Z+22, r24	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    50a8:	ec 81       	ldd	r30, Y+4	; 0x04
    50aa:	fd 81       	ldd	r31, Y+5	; 0x05
    50ac:	84 85       	ldd	r24, Z+12	; 0x0c
    50ae:	95 85       	ldd	r25, Z+13	; 0x0d
    50b0:	99 23       	and	r25, r25
    50b2:	5c f0       	brlt	.+22     	; 0x50ca <vTaskPriorityDisinheritAfterTimeout+0x98>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    50b4:	8a 81       	ldd	r24, Y+2	; 0x02
    50b6:	28 2f       	mov	r18, r24
    50b8:	30 e0       	ldi	r19, 0x00	; 0
    50ba:	87 e0       	ldi	r24, 0x07	; 7
    50bc:	90 e0       	ldi	r25, 0x00	; 0
    50be:	82 1b       	sub	r24, r18
    50c0:	93 0b       	sbc	r25, r19
    50c2:	ec 81       	ldd	r30, Y+4	; 0x04
    50c4:	fd 81       	ldd	r31, Y+5	; 0x05
    50c6:	95 87       	std	Z+13, r25	; 0x0d
    50c8:	84 87       	std	Z+12, r24	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    50ca:	ec 81       	ldd	r30, Y+4	; 0x04
    50cc:	fd 81       	ldd	r31, Y+5	; 0x05
    50ce:	42 85       	ldd	r20, Z+10	; 0x0a
    50d0:	53 85       	ldd	r21, Z+11	; 0x0b
    50d2:	8b 81       	ldd	r24, Y+3	; 0x03
    50d4:	28 2f       	mov	r18, r24
    50d6:	30 e0       	ldi	r19, 0x00	; 0
    50d8:	c9 01       	movw	r24, r18
    50da:	88 0f       	add	r24, r24
    50dc:	99 1f       	adc	r25, r25
    50de:	88 0f       	add	r24, r24
    50e0:	99 1f       	adc	r25, r25
    50e2:	88 0f       	add	r24, r24
    50e4:	99 1f       	adc	r25, r25
    50e6:	82 0f       	add	r24, r18
    50e8:	93 1f       	adc	r25, r19
    50ea:	81 52       	subi	r24, 0x21	; 33
    50ec:	99 4f       	sbci	r25, 0xF9	; 249
    50ee:	48 17       	cp	r20, r24
    50f0:	59 07       	cpc	r21, r25
    50f2:	59 f5       	brne	.+86     	; 0x514a <vTaskPriorityDisinheritAfterTimeout+0x118>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    50f4:	8c 81       	ldd	r24, Y+4	; 0x04
    50f6:	9d 81       	ldd	r25, Y+5	; 0x05
    50f8:	02 96       	adiw	r24, 0x02	; 2
    50fa:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    50fe:	ec 81       	ldd	r30, Y+4	; 0x04
    5100:	fd 81       	ldd	r31, Y+5	; 0x05
    5102:	96 89       	ldd	r25, Z+22	; 0x16
    5104:	80 91 d4 06 	lds	r24, 0x06D4
    5108:	89 17       	cp	r24, r25
    510a:	28 f4       	brcc	.+10     	; 0x5116 <vTaskPriorityDisinheritAfterTimeout+0xe4>
    510c:	ec 81       	ldd	r30, Y+4	; 0x04
    510e:	fd 81       	ldd	r31, Y+5	; 0x05
    5110:	86 89       	ldd	r24, Z+22	; 0x16
    5112:	80 93 d4 06 	sts	0x06D4, r24
    5116:	ec 81       	ldd	r30, Y+4	; 0x04
    5118:	fd 81       	ldd	r31, Y+5	; 0x05
    511a:	86 89       	ldd	r24, Z+22	; 0x16
    511c:	28 2f       	mov	r18, r24
    511e:	30 e0       	ldi	r19, 0x00	; 0
    5120:	c9 01       	movw	r24, r18
    5122:	88 0f       	add	r24, r24
    5124:	99 1f       	adc	r25, r25
    5126:	88 0f       	add	r24, r24
    5128:	99 1f       	adc	r25, r25
    512a:	88 0f       	add	r24, r24
    512c:	99 1f       	adc	r25, r25
    512e:	82 0f       	add	r24, r18
    5130:	93 1f       	adc	r25, r19
    5132:	ac 01       	movw	r20, r24
    5134:	41 52       	subi	r20, 0x21	; 33
    5136:	59 4f       	sbci	r21, 0xF9	; 249
    5138:	8c 81       	ldd	r24, Y+4	; 0x04
    513a:	9d 81       	ldd	r25, Y+5	; 0x05
    513c:	9c 01       	movw	r18, r24
    513e:	2e 5f       	subi	r18, 0xFE	; 254
    5140:	3f 4f       	sbci	r19, 0xFF	; 255
    5142:	ca 01       	movw	r24, r20
    5144:	b9 01       	movw	r22, r18
    5146:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    514a:	28 96       	adiw	r28, 0x08	; 8
    514c:	0f b6       	in	r0, 0x3f	; 63
    514e:	f8 94       	cli
    5150:	de bf       	out	0x3e, r29	; 62
    5152:	0f be       	out	0x3f, r0	; 63
    5154:	cd bf       	out	0x3d, r28	; 61
    5156:	cf 91       	pop	r28
    5158:	df 91       	pop	r29
    515a:	08 95       	ret

0000515c <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    515c:	df 93       	push	r29
    515e:	cf 93       	push	r28
    5160:	00 d0       	rcall	.+0      	; 0x5162 <uxTaskResetEventItemValue+0x6>
    5162:	cd b7       	in	r28, 0x3d	; 61
    5164:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5166:	e0 91 ce 06 	lds	r30, 0x06CE
    516a:	f0 91 cf 06 	lds	r31, 0x06CF
    516e:	84 85       	ldd	r24, Z+12	; 0x0c
    5170:	95 85       	ldd	r25, Z+13	; 0x0d
    5172:	9a 83       	std	Y+2, r25	; 0x02
    5174:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5176:	a0 91 ce 06 	lds	r26, 0x06CE
    517a:	b0 91 cf 06 	lds	r27, 0x06CF
    517e:	e0 91 ce 06 	lds	r30, 0x06CE
    5182:	f0 91 cf 06 	lds	r31, 0x06CF
    5186:	86 89       	ldd	r24, Z+22	; 0x16
    5188:	28 2f       	mov	r18, r24
    518a:	30 e0       	ldi	r19, 0x00	; 0
    518c:	87 e0       	ldi	r24, 0x07	; 7
    518e:	90 e0       	ldi	r25, 0x00	; 0
    5190:	82 1b       	sub	r24, r18
    5192:	93 0b       	sbc	r25, r19
    5194:	1d 96       	adiw	r26, 0x0d	; 13
    5196:	9c 93       	st	X, r25
    5198:	8e 93       	st	-X, r24
    519a:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    519c:	89 81       	ldd	r24, Y+1	; 0x01
    519e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    51a0:	0f 90       	pop	r0
    51a2:	0f 90       	pop	r0
    51a4:	cf 91       	pop	r28
    51a6:	df 91       	pop	r29
    51a8:	08 95       	ret

000051aa <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
    51aa:	df 93       	push	r29
    51ac:	cf 93       	push	r28
    51ae:	cd b7       	in	r28, 0x3d	; 61
    51b0:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    51b2:	80 91 ce 06 	lds	r24, 0x06CE
    51b6:	90 91 cf 06 	lds	r25, 0x06CF
    51ba:	00 97       	sbiw	r24, 0x00	; 0
    51bc:	39 f0       	breq	.+14     	; 0x51cc <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    51be:	e0 91 ce 06 	lds	r30, 0x06CE
    51c2:	f0 91 cf 06 	lds	r31, 0x06CF
    51c6:	86 a5       	ldd	r24, Z+46	; 0x2e
    51c8:	8f 5f       	subi	r24, 0xFF	; 255
    51ca:	86 a7       	std	Z+46, r24	; 0x2e
		}

		return pxCurrentTCB;
    51cc:	80 91 ce 06 	lds	r24, 0x06CE
    51d0:	90 91 cf 06 	lds	r25, 0x06CF
	}
    51d4:	cf 91       	pop	r28
    51d6:	df 91       	pop	r29
    51d8:	08 95       	ret

000051da <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    51da:	df 93       	push	r29
    51dc:	cf 93       	push	r28
    51de:	cd b7       	in	r28, 0x3d	; 61
    51e0:	de b7       	in	r29, 0x3e	; 62
    51e2:	27 97       	sbiw	r28, 0x07	; 7
    51e4:	0f b6       	in	r0, 0x3f	; 63
    51e6:	f8 94       	cli
    51e8:	de bf       	out	0x3e, r29	; 62
    51ea:	0f be       	out	0x3f, r0	; 63
    51ec:	cd bf       	out	0x3d, r28	; 61
    51ee:	8d 83       	std	Y+5, r24	; 0x05
    51f0:	7f 83       	std	Y+7, r23	; 0x07
    51f2:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    51f4:	0f b6       	in	r0, 0x3f	; 63
    51f6:	f8 94       	cli
    51f8:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    51fa:	e0 91 ce 06 	lds	r30, 0x06CE
    51fe:	f0 91 cf 06 	lds	r31, 0x06CF
    5202:	87 a5       	ldd	r24, Z+47	; 0x2f
    5204:	90 a9       	ldd	r25, Z+48	; 0x30
    5206:	a1 a9       	ldd	r26, Z+49	; 0x31
    5208:	b2 a9       	ldd	r27, Z+50	; 0x32
    520a:	00 97       	sbiw	r24, 0x00	; 0
    520c:	a1 05       	cpc	r26, r1
    520e:	b1 05       	cpc	r27, r1
    5210:	89 f4       	brne	.+34     	; 0x5234 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5212:	e0 91 ce 06 	lds	r30, 0x06CE
    5216:	f0 91 cf 06 	lds	r31, 0x06CF
    521a:	81 e0       	ldi	r24, 0x01	; 1
    521c:	83 ab       	std	Z+51, r24	; 0x33

				if( xTicksToWait > ( TickType_t ) 0 )
    521e:	8e 81       	ldd	r24, Y+6	; 0x06
    5220:	9f 81       	ldd	r25, Y+7	; 0x07
    5222:	00 97       	sbiw	r24, 0x00	; 0
    5224:	39 f0       	breq	.+14     	; 0x5234 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5226:	8e 81       	ldd	r24, Y+6	; 0x06
    5228:	9f 81       	ldd	r25, Y+7	; 0x07
    522a:	61 e0       	ldi	r22, 0x01	; 1
    522c:	0e 94 95 2c 	call	0x592a	; 0x592a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5230:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5234:	0f 90       	pop	r0
    5236:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5238:	0f b6       	in	r0, 0x3f	; 63
    523a:	f8 94       	cli
    523c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    523e:	e0 91 ce 06 	lds	r30, 0x06CE
    5242:	f0 91 cf 06 	lds	r31, 0x06CF
    5246:	87 a5       	ldd	r24, Z+47	; 0x2f
    5248:	90 a9       	ldd	r25, Z+48	; 0x30
    524a:	a1 a9       	ldd	r26, Z+49	; 0x31
    524c:	b2 a9       	ldd	r27, Z+50	; 0x32
    524e:	89 83       	std	Y+1, r24	; 0x01
    5250:	9a 83       	std	Y+2, r25	; 0x02
    5252:	ab 83       	std	Y+3, r26	; 0x03
    5254:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    5256:	89 81       	ldd	r24, Y+1	; 0x01
    5258:	9a 81       	ldd	r25, Y+2	; 0x02
    525a:	ab 81       	ldd	r26, Y+3	; 0x03
    525c:	bc 81       	ldd	r27, Y+4	; 0x04
    525e:	00 97       	sbiw	r24, 0x00	; 0
    5260:	a1 05       	cpc	r26, r1
    5262:	b1 05       	cpc	r27, r1
    5264:	d9 f0       	breq	.+54     	; 0x529c <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    5266:	8d 81       	ldd	r24, Y+5	; 0x05
    5268:	88 23       	and	r24, r24
    526a:	49 f0       	breq	.+18     	; 0x527e <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    526c:	e0 91 ce 06 	lds	r30, 0x06CE
    5270:	f0 91 cf 06 	lds	r31, 0x06CF
    5274:	17 a6       	std	Z+47, r1	; 0x2f
    5276:	10 aa       	std	Z+48, r1	; 0x30
    5278:	11 aa       	std	Z+49, r1	; 0x31
    527a:	12 aa       	std	Z+50, r1	; 0x32
    527c:	0f c0       	rjmp	.+30     	; 0x529c <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    527e:	e0 91 ce 06 	lds	r30, 0x06CE
    5282:	f0 91 cf 06 	lds	r31, 0x06CF
    5286:	89 81       	ldd	r24, Y+1	; 0x01
    5288:	9a 81       	ldd	r25, Y+2	; 0x02
    528a:	ab 81       	ldd	r26, Y+3	; 0x03
    528c:	bc 81       	ldd	r27, Y+4	; 0x04
    528e:	01 97       	sbiw	r24, 0x01	; 1
    5290:	a1 09       	sbc	r26, r1
    5292:	b1 09       	sbc	r27, r1
    5294:	87 a7       	std	Z+47, r24	; 0x2f
    5296:	90 ab       	std	Z+48, r25	; 0x30
    5298:	a1 ab       	std	Z+49, r26	; 0x31
    529a:	b2 ab       	std	Z+50, r27	; 0x32
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    529c:	e0 91 ce 06 	lds	r30, 0x06CE
    52a0:	f0 91 cf 06 	lds	r31, 0x06CF
    52a4:	13 aa       	std	Z+51, r1	; 0x33
		}
		taskEXIT_CRITICAL();
    52a6:	0f 90       	pop	r0
    52a8:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    52aa:	89 81       	ldd	r24, Y+1	; 0x01
    52ac:	9a 81       	ldd	r25, Y+2	; 0x02
    52ae:	ab 81       	ldd	r26, Y+3	; 0x03
    52b0:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    52b2:	bc 01       	movw	r22, r24
    52b4:	cd 01       	movw	r24, r26
    52b6:	27 96       	adiw	r28, 0x07	; 7
    52b8:	0f b6       	in	r0, 0x3f	; 63
    52ba:	f8 94       	cli
    52bc:	de bf       	out	0x3e, r29	; 62
    52be:	0f be       	out	0x3f, r0	; 63
    52c0:	cd bf       	out	0x3d, r28	; 61
    52c2:	cf 91       	pop	r28
    52c4:	df 91       	pop	r29
    52c6:	08 95       	ret

000052c8 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    52c8:	ef 92       	push	r14
    52ca:	ff 92       	push	r15
    52cc:	0f 93       	push	r16
    52ce:	1f 93       	push	r17
    52d0:	df 93       	push	r29
    52d2:	cf 93       	push	r28
    52d4:	cd b7       	in	r28, 0x3d	; 61
    52d6:	de b7       	in	r29, 0x3e	; 62
    52d8:	2d 97       	sbiw	r28, 0x0d	; 13
    52da:	0f b6       	in	r0, 0x3f	; 63
    52dc:	f8 94       	cli
    52de:	de bf       	out	0x3e, r29	; 62
    52e0:	0f be       	out	0x3f, r0	; 63
    52e2:	cd bf       	out	0x3d, r28	; 61
    52e4:	6a 83       	std	Y+2, r22	; 0x02
    52e6:	7b 83       	std	Y+3, r23	; 0x03
    52e8:	8c 83       	std	Y+4, r24	; 0x04
    52ea:	9d 83       	std	Y+5, r25	; 0x05
    52ec:	2e 83       	std	Y+6, r18	; 0x06
    52ee:	3f 83       	std	Y+7, r19	; 0x07
    52f0:	48 87       	std	Y+8, r20	; 0x08
    52f2:	59 87       	std	Y+9, r21	; 0x09
    52f4:	1b 87       	std	Y+11, r17	; 0x0b
    52f6:	0a 87       	std	Y+10, r16	; 0x0a
    52f8:	fd 86       	std	Y+13, r15	; 0x0d
    52fa:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    52fc:	0f b6       	in	r0, 0x3f	; 63
    52fe:	f8 94       	cli
    5300:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5302:	e0 91 ce 06 	lds	r30, 0x06CE
    5306:	f0 91 cf 06 	lds	r31, 0x06CF
    530a:	83 a9       	ldd	r24, Z+51	; 0x33
    530c:	82 30       	cpi	r24, 0x02	; 2
    530e:	49 f1       	breq	.+82     	; 0x5362 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    5310:	e0 91 ce 06 	lds	r30, 0x06CE
    5314:	f0 91 cf 06 	lds	r31, 0x06CF
    5318:	27 a5       	ldd	r18, Z+47	; 0x2f
    531a:	30 a9       	ldd	r19, Z+48	; 0x30
    531c:	41 a9       	ldd	r20, Z+49	; 0x31
    531e:	52 a9       	ldd	r21, Z+50	; 0x32
    5320:	8a 81       	ldd	r24, Y+2	; 0x02
    5322:	9b 81       	ldd	r25, Y+3	; 0x03
    5324:	ac 81       	ldd	r26, Y+4	; 0x04
    5326:	bd 81       	ldd	r27, Y+5	; 0x05
    5328:	80 95       	com	r24
    532a:	90 95       	com	r25
    532c:	a0 95       	com	r26
    532e:	b0 95       	com	r27
    5330:	82 23       	and	r24, r18
    5332:	93 23       	and	r25, r19
    5334:	a4 23       	and	r26, r20
    5336:	b5 23       	and	r27, r21
    5338:	87 a7       	std	Z+47, r24	; 0x2f
    533a:	90 ab       	std	Z+48, r25	; 0x30
    533c:	a1 ab       	std	Z+49, r26	; 0x31
    533e:	b2 ab       	std	Z+50, r27	; 0x32

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5340:	e0 91 ce 06 	lds	r30, 0x06CE
    5344:	f0 91 cf 06 	lds	r31, 0x06CF
    5348:	81 e0       	ldi	r24, 0x01	; 1
    534a:	83 ab       	std	Z+51, r24	; 0x33

				if( xTicksToWait > ( TickType_t ) 0 )
    534c:	8c 85       	ldd	r24, Y+12	; 0x0c
    534e:	9d 85       	ldd	r25, Y+13	; 0x0d
    5350:	00 97       	sbiw	r24, 0x00	; 0
    5352:	39 f0       	breq	.+14     	; 0x5362 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5354:	8c 85       	ldd	r24, Y+12	; 0x0c
    5356:	9d 85       	ldd	r25, Y+13	; 0x0d
    5358:	61 e0       	ldi	r22, 0x01	; 1
    535a:	0e 94 95 2c 	call	0x592a	; 0x592a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    535e:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5362:	0f 90       	pop	r0
    5364:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5366:	0f b6       	in	r0, 0x3f	; 63
    5368:	f8 94       	cli
    536a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    536c:	8a 85       	ldd	r24, Y+10	; 0x0a
    536e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5370:	00 97       	sbiw	r24, 0x00	; 0
    5372:	71 f0       	breq	.+28     	; 0x5390 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    5374:	e0 91 ce 06 	lds	r30, 0x06CE
    5378:	f0 91 cf 06 	lds	r31, 0x06CF
    537c:	87 a5       	ldd	r24, Z+47	; 0x2f
    537e:	90 a9       	ldd	r25, Z+48	; 0x30
    5380:	a1 a9       	ldd	r26, Z+49	; 0x31
    5382:	b2 a9       	ldd	r27, Z+50	; 0x32
    5384:	ea 85       	ldd	r30, Y+10	; 0x0a
    5386:	fb 85       	ldd	r31, Y+11	; 0x0b
    5388:	80 83       	st	Z, r24
    538a:	91 83       	std	Z+1, r25	; 0x01
    538c:	a2 83       	std	Z+2, r26	; 0x02
    538e:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5390:	e0 91 ce 06 	lds	r30, 0x06CE
    5394:	f0 91 cf 06 	lds	r31, 0x06CF
    5398:	83 a9       	ldd	r24, Z+51	; 0x33
    539a:	82 30       	cpi	r24, 0x02	; 2
    539c:	11 f0       	breq	.+4      	; 0x53a2 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    539e:	19 82       	std	Y+1, r1	; 0x01
    53a0:	1a c0       	rjmp	.+52     	; 0x53d6 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    53a2:	e0 91 ce 06 	lds	r30, 0x06CE
    53a6:	f0 91 cf 06 	lds	r31, 0x06CF
    53aa:	27 a5       	ldd	r18, Z+47	; 0x2f
    53ac:	30 a9       	ldd	r19, Z+48	; 0x30
    53ae:	41 a9       	ldd	r20, Z+49	; 0x31
    53b0:	52 a9       	ldd	r21, Z+50	; 0x32
    53b2:	8e 81       	ldd	r24, Y+6	; 0x06
    53b4:	9f 81       	ldd	r25, Y+7	; 0x07
    53b6:	a8 85       	ldd	r26, Y+8	; 0x08
    53b8:	b9 85       	ldd	r27, Y+9	; 0x09
    53ba:	80 95       	com	r24
    53bc:	90 95       	com	r25
    53be:	a0 95       	com	r26
    53c0:	b0 95       	com	r27
    53c2:	82 23       	and	r24, r18
    53c4:	93 23       	and	r25, r19
    53c6:	a4 23       	and	r26, r20
    53c8:	b5 23       	and	r27, r21
    53ca:	87 a7       	std	Z+47, r24	; 0x2f
    53cc:	90 ab       	std	Z+48, r25	; 0x30
    53ce:	a1 ab       	std	Z+49, r26	; 0x31
    53d0:	b2 ab       	std	Z+50, r27	; 0x32
				xReturn = pdTRUE;
    53d2:	81 e0       	ldi	r24, 0x01	; 1
    53d4:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    53d6:	e0 91 ce 06 	lds	r30, 0x06CE
    53da:	f0 91 cf 06 	lds	r31, 0x06CF
    53de:	13 aa       	std	Z+51, r1	; 0x33
		}
		taskEXIT_CRITICAL();
    53e0:	0f 90       	pop	r0
    53e2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    53e4:	89 81       	ldd	r24, Y+1	; 0x01
	}
    53e6:	2d 96       	adiw	r28, 0x0d	; 13
    53e8:	0f b6       	in	r0, 0x3f	; 63
    53ea:	f8 94       	cli
    53ec:	de bf       	out	0x3e, r29	; 62
    53ee:	0f be       	out	0x3f, r0	; 63
    53f0:	cd bf       	out	0x3d, r28	; 61
    53f2:	cf 91       	pop	r28
    53f4:	df 91       	pop	r29
    53f6:	1f 91       	pop	r17
    53f8:	0f 91       	pop	r16
    53fa:	ff 90       	pop	r15
    53fc:	ef 90       	pop	r14
    53fe:	08 95       	ret

00005400 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    5400:	0f 93       	push	r16
    5402:	1f 93       	push	r17
    5404:	df 93       	push	r29
    5406:	cf 93       	push	r28
    5408:	cd b7       	in	r28, 0x3d	; 61
    540a:	de b7       	in	r29, 0x3e	; 62
    540c:	2f 97       	sbiw	r28, 0x0f	; 15
    540e:	0f b6       	in	r0, 0x3f	; 63
    5410:	f8 94       	cli
    5412:	de bf       	out	0x3e, r29	; 62
    5414:	0f be       	out	0x3f, r0	; 63
    5416:	cd bf       	out	0x3d, r28	; 61
    5418:	9e 83       	std	Y+6, r25	; 0x06
    541a:	8d 83       	std	Y+5, r24	; 0x05
    541c:	4f 83       	std	Y+7, r20	; 0x07
    541e:	58 87       	std	Y+8, r21	; 0x08
    5420:	69 87       	std	Y+9, r22	; 0x09
    5422:	7a 87       	std	Y+10, r23	; 0x0a
    5424:	2b 87       	std	Y+11, r18	; 0x0b
    5426:	1d 87       	std	Y+13, r17	; 0x0d
    5428:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    542a:	81 e0       	ldi	r24, 0x01	; 1
    542c:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    542e:	8d 81       	ldd	r24, Y+5	; 0x05
    5430:	9e 81       	ldd	r25, Y+6	; 0x06
    5432:	9c 83       	std	Y+4, r25	; 0x04
    5434:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    5436:	0f b6       	in	r0, 0x3f	; 63
    5438:	f8 94       	cli
    543a:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    543c:	8c 85       	ldd	r24, Y+12	; 0x0c
    543e:	9d 85       	ldd	r25, Y+13	; 0x0d
    5440:	00 97       	sbiw	r24, 0x00	; 0
    5442:	61 f0       	breq	.+24     	; 0x545c <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5444:	eb 81       	ldd	r30, Y+3	; 0x03
    5446:	fc 81       	ldd	r31, Y+4	; 0x04
    5448:	87 a5       	ldd	r24, Z+47	; 0x2f
    544a:	90 a9       	ldd	r25, Z+48	; 0x30
    544c:	a1 a9       	ldd	r26, Z+49	; 0x31
    544e:	b2 a9       	ldd	r27, Z+50	; 0x32
    5450:	ec 85       	ldd	r30, Y+12	; 0x0c
    5452:	fd 85       	ldd	r31, Y+13	; 0x0d
    5454:	80 83       	st	Z, r24
    5456:	91 83       	std	Z+1, r25	; 0x01
    5458:	a2 83       	std	Z+2, r26	; 0x02
    545a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    545c:	eb 81       	ldd	r30, Y+3	; 0x03
    545e:	fc 81       	ldd	r31, Y+4	; 0x04
    5460:	83 a9       	ldd	r24, Z+51	; 0x33
    5462:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5464:	eb 81       	ldd	r30, Y+3	; 0x03
    5466:	fc 81       	ldd	r31, Y+4	; 0x04
    5468:	82 e0       	ldi	r24, 0x02	; 2
    546a:	83 ab       	std	Z+51, r24	; 0x33

			switch( eAction )
    546c:	8b 85       	ldd	r24, Y+11	; 0x0b
    546e:	28 2f       	mov	r18, r24
    5470:	30 e0       	ldi	r19, 0x00	; 0
    5472:	3f 87       	std	Y+15, r19	; 0x0f
    5474:	2e 87       	std	Y+14, r18	; 0x0e
    5476:	8e 85       	ldd	r24, Y+14	; 0x0e
    5478:	9f 85       	ldd	r25, Y+15	; 0x0f
    547a:	82 30       	cpi	r24, 0x02	; 2
    547c:	91 05       	cpc	r25, r1
    547e:	59 f1       	breq	.+86     	; 0x54d6 <xTaskGenericNotify+0xd6>
    5480:	2e 85       	ldd	r18, Y+14	; 0x0e
    5482:	3f 85       	ldd	r19, Y+15	; 0x0f
    5484:	23 30       	cpi	r18, 0x03	; 3
    5486:	31 05       	cpc	r19, r1
    5488:	34 f4       	brge	.+12     	; 0x5496 <xTaskGenericNotify+0x96>
    548a:	8e 85       	ldd	r24, Y+14	; 0x0e
    548c:	9f 85       	ldd	r25, Y+15	; 0x0f
    548e:	81 30       	cpi	r24, 0x01	; 1
    5490:	91 05       	cpc	r25, r1
    5492:	61 f0       	breq	.+24     	; 0x54ac <xTaskGenericNotify+0xac>
    5494:	4a c0       	rjmp	.+148    	; 0x552a <xTaskGenericNotify+0x12a>
    5496:	2e 85       	ldd	r18, Y+14	; 0x0e
    5498:	3f 85       	ldd	r19, Y+15	; 0x0f
    549a:	23 30       	cpi	r18, 0x03	; 3
    549c:	31 05       	cpc	r19, r1
    549e:	59 f1       	breq	.+86     	; 0x54f6 <xTaskGenericNotify+0xf6>
    54a0:	8e 85       	ldd	r24, Y+14	; 0x0e
    54a2:	9f 85       	ldd	r25, Y+15	; 0x0f
    54a4:	84 30       	cpi	r24, 0x04	; 4
    54a6:	91 05       	cpc	r25, r1
    54a8:	89 f1       	breq	.+98     	; 0x550c <xTaskGenericNotify+0x10c>
    54aa:	3f c0       	rjmp	.+126    	; 0x552a <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    54ac:	eb 81       	ldd	r30, Y+3	; 0x03
    54ae:	fc 81       	ldd	r31, Y+4	; 0x04
    54b0:	27 a5       	ldd	r18, Z+47	; 0x2f
    54b2:	30 a9       	ldd	r19, Z+48	; 0x30
    54b4:	41 a9       	ldd	r20, Z+49	; 0x31
    54b6:	52 a9       	ldd	r21, Z+50	; 0x32
    54b8:	8f 81       	ldd	r24, Y+7	; 0x07
    54ba:	98 85       	ldd	r25, Y+8	; 0x08
    54bc:	a9 85       	ldd	r26, Y+9	; 0x09
    54be:	ba 85       	ldd	r27, Y+10	; 0x0a
    54c0:	82 2b       	or	r24, r18
    54c2:	93 2b       	or	r25, r19
    54c4:	a4 2b       	or	r26, r20
    54c6:	b5 2b       	or	r27, r21
    54c8:	eb 81       	ldd	r30, Y+3	; 0x03
    54ca:	fc 81       	ldd	r31, Y+4	; 0x04
    54cc:	87 a7       	std	Z+47, r24	; 0x2f
    54ce:	90 ab       	std	Z+48, r25	; 0x30
    54d0:	a1 ab       	std	Z+49, r26	; 0x31
    54d2:	b2 ab       	std	Z+50, r27	; 0x32
    54d4:	2a c0       	rjmp	.+84     	; 0x552a <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    54d6:	eb 81       	ldd	r30, Y+3	; 0x03
    54d8:	fc 81       	ldd	r31, Y+4	; 0x04
    54da:	87 a5       	ldd	r24, Z+47	; 0x2f
    54dc:	90 a9       	ldd	r25, Z+48	; 0x30
    54de:	a1 a9       	ldd	r26, Z+49	; 0x31
    54e0:	b2 a9       	ldd	r27, Z+50	; 0x32
    54e2:	01 96       	adiw	r24, 0x01	; 1
    54e4:	a1 1d       	adc	r26, r1
    54e6:	b1 1d       	adc	r27, r1
    54e8:	eb 81       	ldd	r30, Y+3	; 0x03
    54ea:	fc 81       	ldd	r31, Y+4	; 0x04
    54ec:	87 a7       	std	Z+47, r24	; 0x2f
    54ee:	90 ab       	std	Z+48, r25	; 0x30
    54f0:	a1 ab       	std	Z+49, r26	; 0x31
    54f2:	b2 ab       	std	Z+50, r27	; 0x32
    54f4:	1a c0       	rjmp	.+52     	; 0x552a <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    54f6:	eb 81       	ldd	r30, Y+3	; 0x03
    54f8:	fc 81       	ldd	r31, Y+4	; 0x04
    54fa:	8f 81       	ldd	r24, Y+7	; 0x07
    54fc:	98 85       	ldd	r25, Y+8	; 0x08
    54fe:	a9 85       	ldd	r26, Y+9	; 0x09
    5500:	ba 85       	ldd	r27, Y+10	; 0x0a
    5502:	87 a7       	std	Z+47, r24	; 0x2f
    5504:	90 ab       	std	Z+48, r25	; 0x30
    5506:	a1 ab       	std	Z+49, r26	; 0x31
    5508:	b2 ab       	std	Z+50, r27	; 0x32
    550a:	0f c0       	rjmp	.+30     	; 0x552a <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    550c:	89 81       	ldd	r24, Y+1	; 0x01
    550e:	82 30       	cpi	r24, 0x02	; 2
    5510:	59 f0       	breq	.+22     	; 0x5528 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5512:	eb 81       	ldd	r30, Y+3	; 0x03
    5514:	fc 81       	ldd	r31, Y+4	; 0x04
    5516:	8f 81       	ldd	r24, Y+7	; 0x07
    5518:	98 85       	ldd	r25, Y+8	; 0x08
    551a:	a9 85       	ldd	r26, Y+9	; 0x09
    551c:	ba 85       	ldd	r27, Y+10	; 0x0a
    551e:	87 a7       	std	Z+47, r24	; 0x2f
    5520:	90 ab       	std	Z+48, r25	; 0x30
    5522:	a1 ab       	std	Z+49, r26	; 0x31
    5524:	b2 ab       	std	Z+50, r27	; 0x32
    5526:	01 c0       	rjmp	.+2      	; 0x552a <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5528:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    552a:	89 81       	ldd	r24, Y+1	; 0x01
    552c:	81 30       	cpi	r24, 0x01	; 1
    552e:	b9 f5       	brne	.+110    	; 0x559e <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5530:	8b 81       	ldd	r24, Y+3	; 0x03
    5532:	9c 81       	ldd	r25, Y+4	; 0x04
    5534:	02 96       	adiw	r24, 0x02	; 2
    5536:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    553a:	eb 81       	ldd	r30, Y+3	; 0x03
    553c:	fc 81       	ldd	r31, Y+4	; 0x04
    553e:	96 89       	ldd	r25, Z+22	; 0x16
    5540:	80 91 d4 06 	lds	r24, 0x06D4
    5544:	89 17       	cp	r24, r25
    5546:	28 f4       	brcc	.+10     	; 0x5552 <xTaskGenericNotify+0x152>
    5548:	eb 81       	ldd	r30, Y+3	; 0x03
    554a:	fc 81       	ldd	r31, Y+4	; 0x04
    554c:	86 89       	ldd	r24, Z+22	; 0x16
    554e:	80 93 d4 06 	sts	0x06D4, r24
    5552:	eb 81       	ldd	r30, Y+3	; 0x03
    5554:	fc 81       	ldd	r31, Y+4	; 0x04
    5556:	86 89       	ldd	r24, Z+22	; 0x16
    5558:	28 2f       	mov	r18, r24
    555a:	30 e0       	ldi	r19, 0x00	; 0
    555c:	c9 01       	movw	r24, r18
    555e:	88 0f       	add	r24, r24
    5560:	99 1f       	adc	r25, r25
    5562:	88 0f       	add	r24, r24
    5564:	99 1f       	adc	r25, r25
    5566:	88 0f       	add	r24, r24
    5568:	99 1f       	adc	r25, r25
    556a:	82 0f       	add	r24, r18
    556c:	93 1f       	adc	r25, r19
    556e:	ac 01       	movw	r20, r24
    5570:	41 52       	subi	r20, 0x21	; 33
    5572:	59 4f       	sbci	r21, 0xF9	; 249
    5574:	8b 81       	ldd	r24, Y+3	; 0x03
    5576:	9c 81       	ldd	r25, Y+4	; 0x04
    5578:	9c 01       	movw	r18, r24
    557a:	2e 5f       	subi	r18, 0xFE	; 254
    557c:	3f 4f       	sbci	r19, 0xFF	; 255
    557e:	ca 01       	movw	r24, r20
    5580:	b9 01       	movw	r22, r18
    5582:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5586:	eb 81       	ldd	r30, Y+3	; 0x03
    5588:	fc 81       	ldd	r31, Y+4	; 0x04
    558a:	96 89       	ldd	r25, Z+22	; 0x16
    558c:	e0 91 ce 06 	lds	r30, 0x06CE
    5590:	f0 91 cf 06 	lds	r31, 0x06CF
    5594:	86 89       	ldd	r24, Z+22	; 0x16
    5596:	89 17       	cp	r24, r25
    5598:	10 f4       	brcc	.+4      	; 0x559e <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    559a:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    559e:	0f 90       	pop	r0
    55a0:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    55a2:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    55a4:	2f 96       	adiw	r28, 0x0f	; 15
    55a6:	0f b6       	in	r0, 0x3f	; 63
    55a8:	f8 94       	cli
    55aa:	de bf       	out	0x3e, r29	; 62
    55ac:	0f be       	out	0x3f, r0	; 63
    55ae:	cd bf       	out	0x3d, r28	; 61
    55b0:	cf 91       	pop	r28
    55b2:	df 91       	pop	r29
    55b4:	1f 91       	pop	r17
    55b6:	0f 91       	pop	r16
    55b8:	08 95       	ret

000055ba <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    55ba:	ef 92       	push	r14
    55bc:	ff 92       	push	r15
    55be:	0f 93       	push	r16
    55c0:	1f 93       	push	r17
    55c2:	df 93       	push	r29
    55c4:	cf 93       	push	r28
    55c6:	cd b7       	in	r28, 0x3d	; 61
    55c8:	de b7       	in	r29, 0x3e	; 62
    55ca:	62 97       	sbiw	r28, 0x12	; 18
    55cc:	0f b6       	in	r0, 0x3f	; 63
    55ce:	f8 94       	cli
    55d0:	de bf       	out	0x3e, r29	; 62
    55d2:	0f be       	out	0x3f, r0	; 63
    55d4:	cd bf       	out	0x3d, r28	; 61
    55d6:	9f 83       	std	Y+7, r25	; 0x07
    55d8:	8e 83       	std	Y+6, r24	; 0x06
    55da:	48 87       	std	Y+8, r20	; 0x08
    55dc:	59 87       	std	Y+9, r21	; 0x09
    55de:	6a 87       	std	Y+10, r22	; 0x0a
    55e0:	7b 87       	std	Y+11, r23	; 0x0b
    55e2:	2c 87       	std	Y+12, r18	; 0x0c
    55e4:	1e 87       	std	Y+14, r17	; 0x0e
    55e6:	0d 87       	std	Y+13, r16	; 0x0d
    55e8:	f8 8a       	std	Y+16, r15	; 0x10
    55ea:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    55ec:	81 e0       	ldi	r24, 0x01	; 1
    55ee:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    55f0:	8e 81       	ldd	r24, Y+6	; 0x06
    55f2:	9f 81       	ldd	r25, Y+7	; 0x07
    55f4:	9d 83       	std	Y+5, r25	; 0x05
    55f6:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    55f8:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    55fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    55fc:	9e 85       	ldd	r25, Y+14	; 0x0e
    55fe:	00 97       	sbiw	r24, 0x00	; 0
    5600:	61 f0       	breq	.+24     	; 0x561a <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5602:	ec 81       	ldd	r30, Y+4	; 0x04
    5604:	fd 81       	ldd	r31, Y+5	; 0x05
    5606:	87 a5       	ldd	r24, Z+47	; 0x2f
    5608:	90 a9       	ldd	r25, Z+48	; 0x30
    560a:	a1 a9       	ldd	r26, Z+49	; 0x31
    560c:	b2 a9       	ldd	r27, Z+50	; 0x32
    560e:	ed 85       	ldd	r30, Y+13	; 0x0d
    5610:	fe 85       	ldd	r31, Y+14	; 0x0e
    5612:	80 83       	st	Z, r24
    5614:	91 83       	std	Z+1, r25	; 0x01
    5616:	a2 83       	std	Z+2, r26	; 0x02
    5618:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    561a:	ec 81       	ldd	r30, Y+4	; 0x04
    561c:	fd 81       	ldd	r31, Y+5	; 0x05
    561e:	83 a9       	ldd	r24, Z+51	; 0x33
    5620:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5622:	ec 81       	ldd	r30, Y+4	; 0x04
    5624:	fd 81       	ldd	r31, Y+5	; 0x05
    5626:	82 e0       	ldi	r24, 0x02	; 2
    5628:	83 ab       	std	Z+51, r24	; 0x33

			switch( eAction )
    562a:	8c 85       	ldd	r24, Y+12	; 0x0c
    562c:	28 2f       	mov	r18, r24
    562e:	30 e0       	ldi	r19, 0x00	; 0
    5630:	3a 8b       	std	Y+18, r19	; 0x12
    5632:	29 8b       	std	Y+17, r18	; 0x11
    5634:	89 89       	ldd	r24, Y+17	; 0x11
    5636:	9a 89       	ldd	r25, Y+18	; 0x12
    5638:	82 30       	cpi	r24, 0x02	; 2
    563a:	91 05       	cpc	r25, r1
    563c:	59 f1       	breq	.+86     	; 0x5694 <xTaskGenericNotifyFromISR+0xda>
    563e:	29 89       	ldd	r18, Y+17	; 0x11
    5640:	3a 89       	ldd	r19, Y+18	; 0x12
    5642:	23 30       	cpi	r18, 0x03	; 3
    5644:	31 05       	cpc	r19, r1
    5646:	34 f4       	brge	.+12     	; 0x5654 <xTaskGenericNotifyFromISR+0x9a>
    5648:	89 89       	ldd	r24, Y+17	; 0x11
    564a:	9a 89       	ldd	r25, Y+18	; 0x12
    564c:	81 30       	cpi	r24, 0x01	; 1
    564e:	91 05       	cpc	r25, r1
    5650:	61 f0       	breq	.+24     	; 0x566a <xTaskGenericNotifyFromISR+0xb0>
    5652:	4a c0       	rjmp	.+148    	; 0x56e8 <xTaskGenericNotifyFromISR+0x12e>
    5654:	29 89       	ldd	r18, Y+17	; 0x11
    5656:	3a 89       	ldd	r19, Y+18	; 0x12
    5658:	23 30       	cpi	r18, 0x03	; 3
    565a:	31 05       	cpc	r19, r1
    565c:	59 f1       	breq	.+86     	; 0x56b4 <xTaskGenericNotifyFromISR+0xfa>
    565e:	89 89       	ldd	r24, Y+17	; 0x11
    5660:	9a 89       	ldd	r25, Y+18	; 0x12
    5662:	84 30       	cpi	r24, 0x04	; 4
    5664:	91 05       	cpc	r25, r1
    5666:	89 f1       	breq	.+98     	; 0x56ca <xTaskGenericNotifyFromISR+0x110>
    5668:	3f c0       	rjmp	.+126    	; 0x56e8 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    566a:	ec 81       	ldd	r30, Y+4	; 0x04
    566c:	fd 81       	ldd	r31, Y+5	; 0x05
    566e:	27 a5       	ldd	r18, Z+47	; 0x2f
    5670:	30 a9       	ldd	r19, Z+48	; 0x30
    5672:	41 a9       	ldd	r20, Z+49	; 0x31
    5674:	52 a9       	ldd	r21, Z+50	; 0x32
    5676:	88 85       	ldd	r24, Y+8	; 0x08
    5678:	99 85       	ldd	r25, Y+9	; 0x09
    567a:	aa 85       	ldd	r26, Y+10	; 0x0a
    567c:	bb 85       	ldd	r27, Y+11	; 0x0b
    567e:	82 2b       	or	r24, r18
    5680:	93 2b       	or	r25, r19
    5682:	a4 2b       	or	r26, r20
    5684:	b5 2b       	or	r27, r21
    5686:	ec 81       	ldd	r30, Y+4	; 0x04
    5688:	fd 81       	ldd	r31, Y+5	; 0x05
    568a:	87 a7       	std	Z+47, r24	; 0x2f
    568c:	90 ab       	std	Z+48, r25	; 0x30
    568e:	a1 ab       	std	Z+49, r26	; 0x31
    5690:	b2 ab       	std	Z+50, r27	; 0x32
    5692:	2a c0       	rjmp	.+84     	; 0x56e8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5694:	ec 81       	ldd	r30, Y+4	; 0x04
    5696:	fd 81       	ldd	r31, Y+5	; 0x05
    5698:	87 a5       	ldd	r24, Z+47	; 0x2f
    569a:	90 a9       	ldd	r25, Z+48	; 0x30
    569c:	a1 a9       	ldd	r26, Z+49	; 0x31
    569e:	b2 a9       	ldd	r27, Z+50	; 0x32
    56a0:	01 96       	adiw	r24, 0x01	; 1
    56a2:	a1 1d       	adc	r26, r1
    56a4:	b1 1d       	adc	r27, r1
    56a6:	ec 81       	ldd	r30, Y+4	; 0x04
    56a8:	fd 81       	ldd	r31, Y+5	; 0x05
    56aa:	87 a7       	std	Z+47, r24	; 0x2f
    56ac:	90 ab       	std	Z+48, r25	; 0x30
    56ae:	a1 ab       	std	Z+49, r26	; 0x31
    56b0:	b2 ab       	std	Z+50, r27	; 0x32
    56b2:	1a c0       	rjmp	.+52     	; 0x56e8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    56b4:	ec 81       	ldd	r30, Y+4	; 0x04
    56b6:	fd 81       	ldd	r31, Y+5	; 0x05
    56b8:	88 85       	ldd	r24, Y+8	; 0x08
    56ba:	99 85       	ldd	r25, Y+9	; 0x09
    56bc:	aa 85       	ldd	r26, Y+10	; 0x0a
    56be:	bb 85       	ldd	r27, Y+11	; 0x0b
    56c0:	87 a7       	std	Z+47, r24	; 0x2f
    56c2:	90 ab       	std	Z+48, r25	; 0x30
    56c4:	a1 ab       	std	Z+49, r26	; 0x31
    56c6:	b2 ab       	std	Z+50, r27	; 0x32
    56c8:	0f c0       	rjmp	.+30     	; 0x56e8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    56ca:	8b 81       	ldd	r24, Y+3	; 0x03
    56cc:	82 30       	cpi	r24, 0x02	; 2
    56ce:	59 f0       	breq	.+22     	; 0x56e6 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    56d0:	ec 81       	ldd	r30, Y+4	; 0x04
    56d2:	fd 81       	ldd	r31, Y+5	; 0x05
    56d4:	88 85       	ldd	r24, Y+8	; 0x08
    56d6:	99 85       	ldd	r25, Y+9	; 0x09
    56d8:	aa 85       	ldd	r26, Y+10	; 0x0a
    56da:	bb 85       	ldd	r27, Y+11	; 0x0b
    56dc:	87 a7       	std	Z+47, r24	; 0x2f
    56de:	90 ab       	std	Z+48, r25	; 0x30
    56e0:	a1 ab       	std	Z+49, r26	; 0x31
    56e2:	b2 ab       	std	Z+50, r27	; 0x32
    56e4:	01 c0       	rjmp	.+2      	; 0x56e8 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    56e6:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    56e8:	8b 81       	ldd	r24, Y+3	; 0x03
    56ea:	81 30       	cpi	r24, 0x01	; 1
    56ec:	09 f0       	breq	.+2      	; 0x56f0 <xTaskGenericNotifyFromISR+0x136>
    56ee:	4f c0       	rjmp	.+158    	; 0x578e <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    56f0:	80 91 de 06 	lds	r24, 0x06DE
    56f4:	88 23       	and	r24, r24
    56f6:	61 f5       	brne	.+88     	; 0x5750 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    56f8:	8c 81       	ldd	r24, Y+4	; 0x04
    56fa:	9d 81       	ldd	r25, Y+5	; 0x05
    56fc:	02 96       	adiw	r24, 0x02	; 2
    56fe:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5702:	ec 81       	ldd	r30, Y+4	; 0x04
    5704:	fd 81       	ldd	r31, Y+5	; 0x05
    5706:	96 89       	ldd	r25, Z+22	; 0x16
    5708:	80 91 d4 06 	lds	r24, 0x06D4
    570c:	89 17       	cp	r24, r25
    570e:	28 f4       	brcc	.+10     	; 0x571a <xTaskGenericNotifyFromISR+0x160>
    5710:	ec 81       	ldd	r30, Y+4	; 0x04
    5712:	fd 81       	ldd	r31, Y+5	; 0x05
    5714:	86 89       	ldd	r24, Z+22	; 0x16
    5716:	80 93 d4 06 	sts	0x06D4, r24
    571a:	ec 81       	ldd	r30, Y+4	; 0x04
    571c:	fd 81       	ldd	r31, Y+5	; 0x05
    571e:	86 89       	ldd	r24, Z+22	; 0x16
    5720:	28 2f       	mov	r18, r24
    5722:	30 e0       	ldi	r19, 0x00	; 0
    5724:	c9 01       	movw	r24, r18
    5726:	88 0f       	add	r24, r24
    5728:	99 1f       	adc	r25, r25
    572a:	88 0f       	add	r24, r24
    572c:	99 1f       	adc	r25, r25
    572e:	88 0f       	add	r24, r24
    5730:	99 1f       	adc	r25, r25
    5732:	82 0f       	add	r24, r18
    5734:	93 1f       	adc	r25, r19
    5736:	ac 01       	movw	r20, r24
    5738:	41 52       	subi	r20, 0x21	; 33
    573a:	59 4f       	sbci	r21, 0xF9	; 249
    573c:	8c 81       	ldd	r24, Y+4	; 0x04
    573e:	9d 81       	ldd	r25, Y+5	; 0x05
    5740:	9c 01       	movw	r18, r24
    5742:	2e 5f       	subi	r18, 0xFE	; 254
    5744:	3f 4f       	sbci	r19, 0xFF	; 255
    5746:	ca 01       	movw	r24, r20
    5748:	b9 01       	movw	r22, r18
    574a:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
    574e:	0a c0       	rjmp	.+20     	; 0x5764 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5750:	8c 81       	ldd	r24, Y+4	; 0x04
    5752:	9d 81       	ldd	r25, Y+5	; 0x05
    5754:	9c 01       	movw	r18, r24
    5756:	24 5f       	subi	r18, 0xF4	; 244
    5758:	3f 4f       	sbci	r19, 0xFF	; 255
    575a:	84 e3       	ldi	r24, 0x34	; 52
    575c:	97 e0       	ldi	r25, 0x07	; 7
    575e:	b9 01       	movw	r22, r18
    5760:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5764:	ec 81       	ldd	r30, Y+4	; 0x04
    5766:	fd 81       	ldd	r31, Y+5	; 0x05
    5768:	96 89       	ldd	r25, Z+22	; 0x16
    576a:	e0 91 ce 06 	lds	r30, 0x06CE
    576e:	f0 91 cf 06 	lds	r31, 0x06CF
    5772:	86 89       	ldd	r24, Z+22	; 0x16
    5774:	89 17       	cp	r24, r25
    5776:	58 f4       	brcc	.+22     	; 0x578e <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5778:	8f 85       	ldd	r24, Y+15	; 0x0f
    577a:	98 89       	ldd	r25, Y+16	; 0x10
    577c:	00 97       	sbiw	r24, 0x00	; 0
    577e:	21 f0       	breq	.+8      	; 0x5788 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5780:	ef 85       	ldd	r30, Y+15	; 0x0f
    5782:	f8 89       	ldd	r31, Y+16	; 0x10
    5784:	81 e0       	ldi	r24, 0x01	; 1
    5786:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5788:	81 e0       	ldi	r24, 0x01	; 1
    578a:	80 93 d7 06 	sts	0x06D7, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    578e:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    5790:	62 96       	adiw	r28, 0x12	; 18
    5792:	0f b6       	in	r0, 0x3f	; 63
    5794:	f8 94       	cli
    5796:	de bf       	out	0x3e, r29	; 62
    5798:	0f be       	out	0x3f, r0	; 63
    579a:	cd bf       	out	0x3d, r28	; 61
    579c:	cf 91       	pop	r28
    579e:	df 91       	pop	r29
    57a0:	1f 91       	pop	r17
    57a2:	0f 91       	pop	r16
    57a4:	ff 90       	pop	r15
    57a6:	ef 90       	pop	r14
    57a8:	08 95       	ret

000057aa <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    57aa:	df 93       	push	r29
    57ac:	cf 93       	push	r28
    57ae:	cd b7       	in	r28, 0x3d	; 61
    57b0:	de b7       	in	r29, 0x3e	; 62
    57b2:	28 97       	sbiw	r28, 0x08	; 8
    57b4:	0f b6       	in	r0, 0x3f	; 63
    57b6:	f8 94       	cli
    57b8:	de bf       	out	0x3e, r29	; 62
    57ba:	0f be       	out	0x3f, r0	; 63
    57bc:	cd bf       	out	0x3d, r28	; 61
    57be:	9e 83       	std	Y+6, r25	; 0x06
    57c0:	8d 83       	std	Y+5, r24	; 0x05
    57c2:	78 87       	std	Y+8, r23	; 0x08
    57c4:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    57c6:	8d 81       	ldd	r24, Y+5	; 0x05
    57c8:	9e 81       	ldd	r25, Y+6	; 0x06
    57ca:	9c 83       	std	Y+4, r25	; 0x04
    57cc:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    57ce:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    57d0:	eb 81       	ldd	r30, Y+3	; 0x03
    57d2:	fc 81       	ldd	r31, Y+4	; 0x04
    57d4:	83 a9       	ldd	r24, Z+51	; 0x33
    57d6:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    57d8:	eb 81       	ldd	r30, Y+3	; 0x03
    57da:	fc 81       	ldd	r31, Y+4	; 0x04
    57dc:	82 e0       	ldi	r24, 0x02	; 2
    57de:	83 ab       	std	Z+51, r24	; 0x33

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    57e0:	eb 81       	ldd	r30, Y+3	; 0x03
    57e2:	fc 81       	ldd	r31, Y+4	; 0x04
    57e4:	87 a5       	ldd	r24, Z+47	; 0x2f
    57e6:	90 a9       	ldd	r25, Z+48	; 0x30
    57e8:	a1 a9       	ldd	r26, Z+49	; 0x31
    57ea:	b2 a9       	ldd	r27, Z+50	; 0x32
    57ec:	01 96       	adiw	r24, 0x01	; 1
    57ee:	a1 1d       	adc	r26, r1
    57f0:	b1 1d       	adc	r27, r1
    57f2:	eb 81       	ldd	r30, Y+3	; 0x03
    57f4:	fc 81       	ldd	r31, Y+4	; 0x04
    57f6:	87 a7       	std	Z+47, r24	; 0x2f
    57f8:	90 ab       	std	Z+48, r25	; 0x30
    57fa:	a1 ab       	std	Z+49, r26	; 0x31
    57fc:	b2 ab       	std	Z+50, r27	; 0x32

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    57fe:	8a 81       	ldd	r24, Y+2	; 0x02
    5800:	81 30       	cpi	r24, 0x01	; 1
    5802:	09 f0       	breq	.+2      	; 0x5806 <vTaskNotifyGiveFromISR+0x5c>
    5804:	4f c0       	rjmp	.+158    	; 0x58a4 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5806:	80 91 de 06 	lds	r24, 0x06DE
    580a:	88 23       	and	r24, r24
    580c:	61 f5       	brne	.+88     	; 0x5866 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    580e:	8b 81       	ldd	r24, Y+3	; 0x03
    5810:	9c 81       	ldd	r25, Y+4	; 0x04
    5812:	02 96       	adiw	r24, 0x02	; 2
    5814:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5818:	eb 81       	ldd	r30, Y+3	; 0x03
    581a:	fc 81       	ldd	r31, Y+4	; 0x04
    581c:	96 89       	ldd	r25, Z+22	; 0x16
    581e:	80 91 d4 06 	lds	r24, 0x06D4
    5822:	89 17       	cp	r24, r25
    5824:	28 f4       	brcc	.+10     	; 0x5830 <vTaskNotifyGiveFromISR+0x86>
    5826:	eb 81       	ldd	r30, Y+3	; 0x03
    5828:	fc 81       	ldd	r31, Y+4	; 0x04
    582a:	86 89       	ldd	r24, Z+22	; 0x16
    582c:	80 93 d4 06 	sts	0x06D4, r24
    5830:	eb 81       	ldd	r30, Y+3	; 0x03
    5832:	fc 81       	ldd	r31, Y+4	; 0x04
    5834:	86 89       	ldd	r24, Z+22	; 0x16
    5836:	28 2f       	mov	r18, r24
    5838:	30 e0       	ldi	r19, 0x00	; 0
    583a:	c9 01       	movw	r24, r18
    583c:	88 0f       	add	r24, r24
    583e:	99 1f       	adc	r25, r25
    5840:	88 0f       	add	r24, r24
    5842:	99 1f       	adc	r25, r25
    5844:	88 0f       	add	r24, r24
    5846:	99 1f       	adc	r25, r25
    5848:	82 0f       	add	r24, r18
    584a:	93 1f       	adc	r25, r19
    584c:	ac 01       	movw	r20, r24
    584e:	41 52       	subi	r20, 0x21	; 33
    5850:	59 4f       	sbci	r21, 0xF9	; 249
    5852:	8b 81       	ldd	r24, Y+3	; 0x03
    5854:	9c 81       	ldd	r25, Y+4	; 0x04
    5856:	9c 01       	movw	r18, r24
    5858:	2e 5f       	subi	r18, 0xFE	; 254
    585a:	3f 4f       	sbci	r19, 0xFF	; 255
    585c:	ca 01       	movw	r24, r20
    585e:	b9 01       	movw	r22, r18
    5860:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
    5864:	0a c0       	rjmp	.+20     	; 0x587a <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5866:	8b 81       	ldd	r24, Y+3	; 0x03
    5868:	9c 81       	ldd	r25, Y+4	; 0x04
    586a:	9c 01       	movw	r18, r24
    586c:	24 5f       	subi	r18, 0xF4	; 244
    586e:	3f 4f       	sbci	r19, 0xFF	; 255
    5870:	84 e3       	ldi	r24, 0x34	; 52
    5872:	97 e0       	ldi	r25, 0x07	; 7
    5874:	b9 01       	movw	r22, r18
    5876:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    587a:	eb 81       	ldd	r30, Y+3	; 0x03
    587c:	fc 81       	ldd	r31, Y+4	; 0x04
    587e:	96 89       	ldd	r25, Z+22	; 0x16
    5880:	e0 91 ce 06 	lds	r30, 0x06CE
    5884:	f0 91 cf 06 	lds	r31, 0x06CF
    5888:	86 89       	ldd	r24, Z+22	; 0x16
    588a:	89 17       	cp	r24, r25
    588c:	58 f4       	brcc	.+22     	; 0x58a4 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    588e:	8f 81       	ldd	r24, Y+7	; 0x07
    5890:	98 85       	ldd	r25, Y+8	; 0x08
    5892:	00 97       	sbiw	r24, 0x00	; 0
    5894:	21 f0       	breq	.+8      	; 0x589e <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5896:	ef 81       	ldd	r30, Y+7	; 0x07
    5898:	f8 85       	ldd	r31, Y+8	; 0x08
    589a:	81 e0       	ldi	r24, 0x01	; 1
    589c:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    589e:	81 e0       	ldi	r24, 0x01	; 1
    58a0:	80 93 d7 06 	sts	0x06D7, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    58a4:	28 96       	adiw	r28, 0x08	; 8
    58a6:	0f b6       	in	r0, 0x3f	; 63
    58a8:	f8 94       	cli
    58aa:	de bf       	out	0x3e, r29	; 62
    58ac:	0f be       	out	0x3f, r0	; 63
    58ae:	cd bf       	out	0x3d, r28	; 61
    58b0:	cf 91       	pop	r28
    58b2:	df 91       	pop	r29
    58b4:	08 95       	ret

000058b6 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    58b6:	df 93       	push	r29
    58b8:	cf 93       	push	r28
    58ba:	cd b7       	in	r28, 0x3d	; 61
    58bc:	de b7       	in	r29, 0x3e	; 62
    58be:	27 97       	sbiw	r28, 0x07	; 7
    58c0:	0f b6       	in	r0, 0x3f	; 63
    58c2:	f8 94       	cli
    58c4:	de bf       	out	0x3e, r29	; 62
    58c6:	0f be       	out	0x3f, r0	; 63
    58c8:	cd bf       	out	0x3d, r28	; 61
    58ca:	9d 83       	std	Y+5, r25	; 0x05
    58cc:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    58ce:	8c 81       	ldd	r24, Y+4	; 0x04
    58d0:	9d 81       	ldd	r25, Y+5	; 0x05
    58d2:	00 97       	sbiw	r24, 0x00	; 0
    58d4:	39 f4       	brne	.+14     	; 0x58e4 <xTaskNotifyStateClear+0x2e>
    58d6:	80 91 ce 06 	lds	r24, 0x06CE
    58da:	90 91 cf 06 	lds	r25, 0x06CF
    58de:	9f 83       	std	Y+7, r25	; 0x07
    58e0:	8e 83       	std	Y+6, r24	; 0x06
    58e2:	04 c0       	rjmp	.+8      	; 0x58ec <xTaskNotifyStateClear+0x36>
    58e4:	8c 81       	ldd	r24, Y+4	; 0x04
    58e6:	9d 81       	ldd	r25, Y+5	; 0x05
    58e8:	9f 83       	std	Y+7, r25	; 0x07
    58ea:	8e 83       	std	Y+6, r24	; 0x06
    58ec:	8e 81       	ldd	r24, Y+6	; 0x06
    58ee:	9f 81       	ldd	r25, Y+7	; 0x07
    58f0:	9b 83       	std	Y+3, r25	; 0x03
    58f2:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    58f4:	0f b6       	in	r0, 0x3f	; 63
    58f6:	f8 94       	cli
    58f8:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    58fa:	ea 81       	ldd	r30, Y+2	; 0x02
    58fc:	fb 81       	ldd	r31, Y+3	; 0x03
    58fe:	83 a9       	ldd	r24, Z+51	; 0x33
    5900:	82 30       	cpi	r24, 0x02	; 2
    5902:	31 f4       	brne	.+12     	; 0x5910 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5904:	ea 81       	ldd	r30, Y+2	; 0x02
    5906:	fb 81       	ldd	r31, Y+3	; 0x03
    5908:	13 aa       	std	Z+51, r1	; 0x33
				xReturn = pdPASS;
    590a:	81 e0       	ldi	r24, 0x01	; 1
    590c:	89 83       	std	Y+1, r24	; 0x01
    590e:	01 c0       	rjmp	.+2      	; 0x5912 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    5910:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5912:	0f 90       	pop	r0
    5914:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5916:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5918:	27 96       	adiw	r28, 0x07	; 7
    591a:	0f b6       	in	r0, 0x3f	; 63
    591c:	f8 94       	cli
    591e:	de bf       	out	0x3e, r29	; 62
    5920:	0f be       	out	0x3f, r0	; 63
    5922:	cd bf       	out	0x3d, r28	; 61
    5924:	cf 91       	pop	r28
    5926:	df 91       	pop	r29
    5928:	08 95       	ret

0000592a <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    592a:	df 93       	push	r29
    592c:	cf 93       	push	r28
    592e:	cd b7       	in	r28, 0x3d	; 61
    5930:	de b7       	in	r29, 0x3e	; 62
    5932:	27 97       	sbiw	r28, 0x07	; 7
    5934:	0f b6       	in	r0, 0x3f	; 63
    5936:	f8 94       	cli
    5938:	de bf       	out	0x3e, r29	; 62
    593a:	0f be       	out	0x3f, r0	; 63
    593c:	cd bf       	out	0x3d, r28	; 61
    593e:	9e 83       	std	Y+6, r25	; 0x06
    5940:	8d 83       	std	Y+5, r24	; 0x05
    5942:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5944:	80 91 d2 06 	lds	r24, 0x06D2
    5948:	90 91 d3 06 	lds	r25, 0x06D3
    594c:	9a 83       	std	Y+2, r25	; 0x02
    594e:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5950:	80 91 ce 06 	lds	r24, 0x06CE
    5954:	90 91 cf 06 	lds	r25, 0x06CF
    5958:	02 96       	adiw	r24, 0x02	; 2
    595a:	0e 94 97 0b 	call	0x172e	; 0x172e <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    595e:	8d 81       	ldd	r24, Y+5	; 0x05
    5960:	9e 81       	ldd	r25, Y+6	; 0x06
    5962:	2f ef       	ldi	r18, 0xFF	; 255
    5964:	8f 3f       	cpi	r24, 0xFF	; 255
    5966:	92 07       	cpc	r25, r18
    5968:	81 f4       	brne	.+32     	; 0x598a <prvAddCurrentTaskToDelayedList+0x60>
    596a:	8f 81       	ldd	r24, Y+7	; 0x07
    596c:	88 23       	and	r24, r24
    596e:	69 f0       	breq	.+26     	; 0x598a <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5970:	80 91 ce 06 	lds	r24, 0x06CE
    5974:	90 91 cf 06 	lds	r25, 0x06CF
    5978:	9c 01       	movw	r18, r24
    597a:	2e 5f       	subi	r18, 0xFE	; 254
    597c:	3f 4f       	sbci	r19, 0xFF	; 255
    597e:	86 e4       	ldi	r24, 0x46	; 70
    5980:	97 e0       	ldi	r25, 0x07	; 7
    5982:	b9 01       	movw	r22, r18
    5984:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <vListInsertEnd>
    5988:	43 c0       	rjmp	.+134    	; 0x5a10 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    598a:	29 81       	ldd	r18, Y+1	; 0x01
    598c:	3a 81       	ldd	r19, Y+2	; 0x02
    598e:	8d 81       	ldd	r24, Y+5	; 0x05
    5990:	9e 81       	ldd	r25, Y+6	; 0x06
    5992:	82 0f       	add	r24, r18
    5994:	93 1f       	adc	r25, r19
    5996:	9c 83       	std	Y+4, r25	; 0x04
    5998:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    599a:	e0 91 ce 06 	lds	r30, 0x06CE
    599e:	f0 91 cf 06 	lds	r31, 0x06CF
    59a2:	8b 81       	ldd	r24, Y+3	; 0x03
    59a4:	9c 81       	ldd	r25, Y+4	; 0x04
    59a6:	93 83       	std	Z+3, r25	; 0x03
    59a8:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    59aa:	2b 81       	ldd	r18, Y+3	; 0x03
    59ac:	3c 81       	ldd	r19, Y+4	; 0x04
    59ae:	89 81       	ldd	r24, Y+1	; 0x01
    59b0:	9a 81       	ldd	r25, Y+2	; 0x02
    59b2:	28 17       	cp	r18, r24
    59b4:	39 07       	cpc	r19, r25
    59b6:	70 f4       	brcc	.+28     	; 0x59d4 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    59b8:	80 91 32 07 	lds	r24, 0x0732
    59bc:	90 91 33 07 	lds	r25, 0x0733
    59c0:	20 91 ce 06 	lds	r18, 0x06CE
    59c4:	30 91 cf 06 	lds	r19, 0x06CF
    59c8:	2e 5f       	subi	r18, 0xFE	; 254
    59ca:	3f 4f       	sbci	r19, 0xFF	; 255
    59cc:	b9 01       	movw	r22, r18
    59ce:	0e 94 2b 0b 	call	0x1656	; 0x1656 <vListInsert>
    59d2:	1e c0       	rjmp	.+60     	; 0x5a10 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    59d4:	40 91 30 07 	lds	r20, 0x0730
    59d8:	50 91 31 07 	lds	r21, 0x0731
    59dc:	80 91 ce 06 	lds	r24, 0x06CE
    59e0:	90 91 cf 06 	lds	r25, 0x06CF
    59e4:	9c 01       	movw	r18, r24
    59e6:	2e 5f       	subi	r18, 0xFE	; 254
    59e8:	3f 4f       	sbci	r19, 0xFF	; 255
    59ea:	ca 01       	movw	r24, r20
    59ec:	b9 01       	movw	r22, r18
    59ee:	0e 94 2b 0b 	call	0x1656	; 0x1656 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    59f2:	20 91 da 06 	lds	r18, 0x06DA
    59f6:	30 91 db 06 	lds	r19, 0x06DB
    59fa:	8b 81       	ldd	r24, Y+3	; 0x03
    59fc:	9c 81       	ldd	r25, Y+4	; 0x04
    59fe:	82 17       	cp	r24, r18
    5a00:	93 07       	cpc	r25, r19
    5a02:	30 f4       	brcc	.+12     	; 0x5a10 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5a04:	8b 81       	ldd	r24, Y+3	; 0x03
    5a06:	9c 81       	ldd	r25, Y+4	; 0x04
    5a08:	90 93 db 06 	sts	0x06DB, r25
    5a0c:	80 93 da 06 	sts	0x06DA, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5a10:	27 96       	adiw	r28, 0x07	; 7
    5a12:	0f b6       	in	r0, 0x3f	; 63
    5a14:	f8 94       	cli
    5a16:	de bf       	out	0x3e, r29	; 62
    5a18:	0f be       	out	0x3f, r0	; 63
    5a1a:	cd bf       	out	0x3d, r28	; 61
    5a1c:	cf 91       	pop	r28
    5a1e:	df 91       	pop	r29
    5a20:	08 95       	ret

00005a22 <__udivmodqi4>:
    5a22:	99 1b       	sub	r25, r25
    5a24:	79 e0       	ldi	r23, 0x09	; 9
    5a26:	04 c0       	rjmp	.+8      	; 0x5a30 <__udivmodqi4_ep>

00005a28 <__udivmodqi4_loop>:
    5a28:	99 1f       	adc	r25, r25
    5a2a:	96 17       	cp	r25, r22
    5a2c:	08 f0       	brcs	.+2      	; 0x5a30 <__udivmodqi4_ep>
    5a2e:	96 1b       	sub	r25, r22

00005a30 <__udivmodqi4_ep>:
    5a30:	88 1f       	adc	r24, r24
    5a32:	7a 95       	dec	r23
    5a34:	c9 f7       	brne	.-14     	; 0x5a28 <__udivmodqi4_loop>
    5a36:	80 95       	com	r24
    5a38:	08 95       	ret

00005a3a <memcpy>:
    5a3a:	fb 01       	movw	r30, r22
    5a3c:	dc 01       	movw	r26, r24
    5a3e:	02 c0       	rjmp	.+4      	; 0x5a44 <memcpy+0xa>
    5a40:	01 90       	ld	r0, Z+
    5a42:	0d 92       	st	X+, r0
    5a44:	41 50       	subi	r20, 0x01	; 1
    5a46:	50 40       	sbci	r21, 0x00	; 0
    5a48:	d8 f7       	brcc	.-10     	; 0x5a40 <memcpy+0x6>
    5a4a:	08 95       	ret

00005a4c <memset>:
    5a4c:	dc 01       	movw	r26, r24
    5a4e:	01 c0       	rjmp	.+2      	; 0x5a52 <memset+0x6>
    5a50:	6d 93       	st	X+, r22
    5a52:	41 50       	subi	r20, 0x01	; 1
    5a54:	50 40       	sbci	r21, 0x00	; 0
    5a56:	e0 f7       	brcc	.-8      	; 0x5a50 <memset+0x4>
    5a58:	08 95       	ret

00005a5a <_exit>:
    5a5a:	f8 94       	cli

00005a5c <__stop_program>:
    5a5c:	ff cf       	rjmp	.-2      	; 0x5a5c <__stop_program>
