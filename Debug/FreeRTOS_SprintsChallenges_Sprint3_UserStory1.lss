
FreeRTOS_SprintsChallenges_Sprint3_UserStory1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000064ac  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000060  00800060  000064ac  00006540  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000657  008000c0  008000c0  000065a0  2**0
                  ALLOC
  3 .stab         0000a308  00000000  00000000  000065a0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000529c  00000000  00000000  000108a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 e0 15 	jmp	0x2bc0	; 0x2bc0 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec ea       	ldi	r30, 0xAC	; 172
      68:	f4 e6       	ldi	r31, 0x64	; 100
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 3c       	cpi	r26, 0xC0	; 192
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a0 ec       	ldi	r26, 0xC0	; 192
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 31       	cpi	r26, 0x17	; 23
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 f2 12 	call	0x25e4	; 0x25e4 <main>
      8a:	0c 94 54 32 	jmp	0x64a8	; 0x64a8 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <ADC_Init>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	2c 97       	sbiw	r28, 0x0c	; 12
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	80 91 ac 00 	lds	r24, 0x00AC
      aa:	28 2f       	mov	r18, r24
      ac:	30 e0       	ldi	r19, 0x00	; 0
      ae:	3c 87       	std	Y+12, r19	; 0x0c
      b0:	2b 87       	std	Y+11, r18	; 0x0b
      b2:	8b 85       	ldd	r24, Y+11	; 0x0b
      b4:	9c 85       	ldd	r25, Y+12	; 0x0c
      b6:	81 30       	cpi	r24, 0x01	; 1
      b8:	91 05       	cpc	r25, r1
      ba:	c1 f0       	breq	.+48     	; 0xec <ADC_Init+0x5a>
      bc:	2b 85       	ldd	r18, Y+11	; 0x0b
      be:	3c 85       	ldd	r19, Y+12	; 0x0c
      c0:	22 30       	cpi	r18, 0x02	; 2
      c2:	31 05       	cpc	r19, r1
      c4:	11 f1       	breq	.+68     	; 0x10a <ADC_Init+0x78>
      c6:	8b 85       	ldd	r24, Y+11	; 0x0b
      c8:	9c 85       	ldd	r25, Y+12	; 0x0c
      ca:	00 97       	sbiw	r24, 0x00	; 0
      cc:	69 f5       	brne	.+90     	; 0x128 <ADC_Init+0x96>
      ce:	a7 e2       	ldi	r26, 0x27	; 39
      d0:	b0 e0       	ldi	r27, 0x00	; 0
      d2:	e7 e2       	ldi	r30, 0x27	; 39
      d4:	f0 e0       	ldi	r31, 0x00	; 0
      d6:	80 81       	ld	r24, Z
      d8:	8f 77       	andi	r24, 0x7F	; 127
      da:	8c 93       	st	X, r24
      dc:	a7 e2       	ldi	r26, 0x27	; 39
      de:	b0 e0       	ldi	r27, 0x00	; 0
      e0:	e7 e2       	ldi	r30, 0x27	; 39
      e2:	f0 e0       	ldi	r31, 0x00	; 0
      e4:	80 81       	ld	r24, Z
      e6:	8f 7b       	andi	r24, 0xBF	; 191
      e8:	8c 93       	st	X, r24
      ea:	2c c0       	rjmp	.+88     	; 0x144 <ADC_Init+0xb2>
      ec:	a7 e2       	ldi	r26, 0x27	; 39
      ee:	b0 e0       	ldi	r27, 0x00	; 0
      f0:	e7 e2       	ldi	r30, 0x27	; 39
      f2:	f0 e0       	ldi	r31, 0x00	; 0
      f4:	80 81       	ld	r24, Z
      f6:	8f 77       	andi	r24, 0x7F	; 127
      f8:	8c 93       	st	X, r24
      fa:	a7 e2       	ldi	r26, 0x27	; 39
      fc:	b0 e0       	ldi	r27, 0x00	; 0
      fe:	e7 e2       	ldi	r30, 0x27	; 39
     100:	f0 e0       	ldi	r31, 0x00	; 0
     102:	80 81       	ld	r24, Z
     104:	80 64       	ori	r24, 0x40	; 64
     106:	8c 93       	st	X, r24
     108:	1d c0       	rjmp	.+58     	; 0x144 <ADC_Init+0xb2>
     10a:	a7 e2       	ldi	r26, 0x27	; 39
     10c:	b0 e0       	ldi	r27, 0x00	; 0
     10e:	e7 e2       	ldi	r30, 0x27	; 39
     110:	f0 e0       	ldi	r31, 0x00	; 0
     112:	80 81       	ld	r24, Z
     114:	80 68       	ori	r24, 0x80	; 128
     116:	8c 93       	st	X, r24
     118:	a7 e2       	ldi	r26, 0x27	; 39
     11a:	b0 e0       	ldi	r27, 0x00	; 0
     11c:	e7 e2       	ldi	r30, 0x27	; 39
     11e:	f0 e0       	ldi	r31, 0x00	; 0
     120:	80 81       	ld	r24, Z
     122:	80 64       	ori	r24, 0x40	; 64
     124:	8c 93       	st	X, r24
     126:	0e c0       	rjmp	.+28     	; 0x144 <ADC_Init+0xb2>
     128:	a7 e2       	ldi	r26, 0x27	; 39
     12a:	b0 e0       	ldi	r27, 0x00	; 0
     12c:	e7 e2       	ldi	r30, 0x27	; 39
     12e:	f0 e0       	ldi	r31, 0x00	; 0
     130:	80 81       	ld	r24, Z
     132:	8f 77       	andi	r24, 0x7F	; 127
     134:	8c 93       	st	X, r24
     136:	a7 e2       	ldi	r26, 0x27	; 39
     138:	b0 e0       	ldi	r27, 0x00	; 0
     13a:	e7 e2       	ldi	r30, 0x27	; 39
     13c:	f0 e0       	ldi	r31, 0x00	; 0
     13e:	80 81       	ld	r24, Z
     140:	8f 7b       	andi	r24, 0xBF	; 191
     142:	8c 93       	st	X, r24
     144:	80 91 ad 00 	lds	r24, 0x00AD
     148:	28 2f       	mov	r18, r24
     14a:	30 e0       	ldi	r19, 0x00	; 0
     14c:	3a 87       	std	Y+10, r19	; 0x0a
     14e:	29 87       	std	Y+9, r18	; 0x09
     150:	89 85       	ldd	r24, Y+9	; 0x09
     152:	9a 85       	ldd	r25, Y+10	; 0x0a
     154:	00 97       	sbiw	r24, 0x00	; 0
     156:	31 f0       	breq	.+12     	; 0x164 <ADC_Init+0xd2>
     158:	29 85       	ldd	r18, Y+9	; 0x09
     15a:	3a 85       	ldd	r19, Y+10	; 0x0a
     15c:	21 30       	cpi	r18, 0x01	; 1
     15e:	31 05       	cpc	r19, r1
     160:	49 f0       	breq	.+18     	; 0x174 <ADC_Init+0xe2>
     162:	10 c0       	rjmp	.+32     	; 0x184 <ADC_Init+0xf2>
     164:	a7 e2       	ldi	r26, 0x27	; 39
     166:	b0 e0       	ldi	r27, 0x00	; 0
     168:	e7 e2       	ldi	r30, 0x27	; 39
     16a:	f0 e0       	ldi	r31, 0x00	; 0
     16c:	80 81       	ld	r24, Z
     16e:	8f 7d       	andi	r24, 0xDF	; 223
     170:	8c 93       	st	X, r24
     172:	0f c0       	rjmp	.+30     	; 0x192 <ADC_Init+0x100>
     174:	a7 e2       	ldi	r26, 0x27	; 39
     176:	b0 e0       	ldi	r27, 0x00	; 0
     178:	e7 e2       	ldi	r30, 0x27	; 39
     17a:	f0 e0       	ldi	r31, 0x00	; 0
     17c:	80 81       	ld	r24, Z
     17e:	80 62       	ori	r24, 0x20	; 32
     180:	8c 93       	st	X, r24
     182:	07 c0       	rjmp	.+14     	; 0x192 <ADC_Init+0x100>
     184:	a7 e2       	ldi	r26, 0x27	; 39
     186:	b0 e0       	ldi	r27, 0x00	; 0
     188:	e7 e2       	ldi	r30, 0x27	; 39
     18a:	f0 e0       	ldi	r31, 0x00	; 0
     18c:	80 81       	ld	r24, Z
     18e:	8f 7d       	andi	r24, 0xDF	; 223
     190:	8c 93       	st	X, r24
     192:	80 91 ae 00 	lds	r24, 0x00AE
     196:	28 2f       	mov	r18, r24
     198:	30 e0       	ldi	r19, 0x00	; 0
     19a:	38 87       	std	Y+8, r19	; 0x08
     19c:	2f 83       	std	Y+7, r18	; 0x07
     19e:	8f 81       	ldd	r24, Y+7	; 0x07
     1a0:	98 85       	ldd	r25, Y+8	; 0x08
     1a2:	83 30       	cpi	r24, 0x03	; 3
     1a4:	91 05       	cpc	r25, r1
     1a6:	09 f4       	brne	.+2      	; 0x1aa <ADC_Init+0x118>
     1a8:	9b c0       	rjmp	.+310    	; 0x2e0 <ADC_Init+0x24e>
     1aa:	2f 81       	ldd	r18, Y+7	; 0x07
     1ac:	38 85       	ldd	r19, Y+8	; 0x08
     1ae:	24 30       	cpi	r18, 0x04	; 4
     1b0:	31 05       	cpc	r19, r1
     1b2:	8c f4       	brge	.+34     	; 0x1d6 <ADC_Init+0x144>
     1b4:	8f 81       	ldd	r24, Y+7	; 0x07
     1b6:	98 85       	ldd	r25, Y+8	; 0x08
     1b8:	81 30       	cpi	r24, 0x01	; 1
     1ba:	91 05       	cpc	r25, r1
     1bc:	09 f4       	brne	.+2      	; 0x1c0 <ADC_Init+0x12e>
     1be:	48 c0       	rjmp	.+144    	; 0x250 <ADC_Init+0x1be>
     1c0:	2f 81       	ldd	r18, Y+7	; 0x07
     1c2:	38 85       	ldd	r19, Y+8	; 0x08
     1c4:	22 30       	cpi	r18, 0x02	; 2
     1c6:	31 05       	cpc	r19, r1
     1c8:	0c f0       	brlt	.+2      	; 0x1cc <ADC_Init+0x13a>
     1ca:	66 c0       	rjmp	.+204    	; 0x298 <ADC_Init+0x206>
     1cc:	8f 81       	ldd	r24, Y+7	; 0x07
     1ce:	98 85       	ldd	r25, Y+8	; 0x08
     1d0:	00 97       	sbiw	r24, 0x00	; 0
     1d2:	d1 f0       	breq	.+52     	; 0x208 <ADC_Init+0x176>
     1d4:	38 c1       	rjmp	.+624    	; 0x446 <ADC_Init+0x3b4>
     1d6:	2f 81       	ldd	r18, Y+7	; 0x07
     1d8:	38 85       	ldd	r19, Y+8	; 0x08
     1da:	25 30       	cpi	r18, 0x05	; 5
     1dc:	31 05       	cpc	r19, r1
     1de:	09 f4       	brne	.+2      	; 0x1e2 <ADC_Init+0x150>
     1e0:	c7 c0       	rjmp	.+398    	; 0x370 <ADC_Init+0x2de>
     1e2:	8f 81       	ldd	r24, Y+7	; 0x07
     1e4:	98 85       	ldd	r25, Y+8	; 0x08
     1e6:	85 30       	cpi	r24, 0x05	; 5
     1e8:	91 05       	cpc	r25, r1
     1ea:	0c f4       	brge	.+2      	; 0x1ee <ADC_Init+0x15c>
     1ec:	9d c0       	rjmp	.+314    	; 0x328 <ADC_Init+0x296>
     1ee:	2f 81       	ldd	r18, Y+7	; 0x07
     1f0:	38 85       	ldd	r19, Y+8	; 0x08
     1f2:	26 30       	cpi	r18, 0x06	; 6
     1f4:	31 05       	cpc	r19, r1
     1f6:	09 f4       	brne	.+2      	; 0x1fa <ADC_Init+0x168>
     1f8:	df c0       	rjmp	.+446    	; 0x3b8 <ADC_Init+0x326>
     1fa:	8f 81       	ldd	r24, Y+7	; 0x07
     1fc:	98 85       	ldd	r25, Y+8	; 0x08
     1fe:	87 30       	cpi	r24, 0x07	; 7
     200:	91 05       	cpc	r25, r1
     202:	09 f4       	brne	.+2      	; 0x206 <ADC_Init+0x174>
     204:	fd c0       	rjmp	.+506    	; 0x400 <ADC_Init+0x36e>
     206:	1f c1       	rjmp	.+574    	; 0x446 <ADC_Init+0x3b4>
     208:	a7 e2       	ldi	r26, 0x27	; 39
     20a:	b0 e0       	ldi	r27, 0x00	; 0
     20c:	e7 e2       	ldi	r30, 0x27	; 39
     20e:	f0 e0       	ldi	r31, 0x00	; 0
     210:	80 81       	ld	r24, Z
     212:	8f 7e       	andi	r24, 0xEF	; 239
     214:	8c 93       	st	X, r24
     216:	a7 e2       	ldi	r26, 0x27	; 39
     218:	b0 e0       	ldi	r27, 0x00	; 0
     21a:	e7 e2       	ldi	r30, 0x27	; 39
     21c:	f0 e0       	ldi	r31, 0x00	; 0
     21e:	80 81       	ld	r24, Z
     220:	87 7f       	andi	r24, 0xF7	; 247
     222:	8c 93       	st	X, r24
     224:	a7 e2       	ldi	r26, 0x27	; 39
     226:	b0 e0       	ldi	r27, 0x00	; 0
     228:	e7 e2       	ldi	r30, 0x27	; 39
     22a:	f0 e0       	ldi	r31, 0x00	; 0
     22c:	80 81       	ld	r24, Z
     22e:	8b 7f       	andi	r24, 0xFB	; 251
     230:	8c 93       	st	X, r24
     232:	a7 e2       	ldi	r26, 0x27	; 39
     234:	b0 e0       	ldi	r27, 0x00	; 0
     236:	e7 e2       	ldi	r30, 0x27	; 39
     238:	f0 e0       	ldi	r31, 0x00	; 0
     23a:	80 81       	ld	r24, Z
     23c:	8d 7f       	andi	r24, 0xFD	; 253
     23e:	8c 93       	st	X, r24
     240:	a7 e2       	ldi	r26, 0x27	; 39
     242:	b0 e0       	ldi	r27, 0x00	; 0
     244:	e7 e2       	ldi	r30, 0x27	; 39
     246:	f0 e0       	ldi	r31, 0x00	; 0
     248:	80 81       	ld	r24, Z
     24a:	8e 7f       	andi	r24, 0xFE	; 254
     24c:	8c 93       	st	X, r24
     24e:	fb c0       	rjmp	.+502    	; 0x446 <ADC_Init+0x3b4>
     250:	a7 e2       	ldi	r26, 0x27	; 39
     252:	b0 e0       	ldi	r27, 0x00	; 0
     254:	e7 e2       	ldi	r30, 0x27	; 39
     256:	f0 e0       	ldi	r31, 0x00	; 0
     258:	80 81       	ld	r24, Z
     25a:	8f 7e       	andi	r24, 0xEF	; 239
     25c:	8c 93       	st	X, r24
     25e:	a7 e2       	ldi	r26, 0x27	; 39
     260:	b0 e0       	ldi	r27, 0x00	; 0
     262:	e7 e2       	ldi	r30, 0x27	; 39
     264:	f0 e0       	ldi	r31, 0x00	; 0
     266:	80 81       	ld	r24, Z
     268:	87 7f       	andi	r24, 0xF7	; 247
     26a:	8c 93       	st	X, r24
     26c:	a7 e2       	ldi	r26, 0x27	; 39
     26e:	b0 e0       	ldi	r27, 0x00	; 0
     270:	e7 e2       	ldi	r30, 0x27	; 39
     272:	f0 e0       	ldi	r31, 0x00	; 0
     274:	80 81       	ld	r24, Z
     276:	8b 7f       	andi	r24, 0xFB	; 251
     278:	8c 93       	st	X, r24
     27a:	a7 e2       	ldi	r26, 0x27	; 39
     27c:	b0 e0       	ldi	r27, 0x00	; 0
     27e:	e7 e2       	ldi	r30, 0x27	; 39
     280:	f0 e0       	ldi	r31, 0x00	; 0
     282:	80 81       	ld	r24, Z
     284:	8d 7f       	andi	r24, 0xFD	; 253
     286:	8c 93       	st	X, r24
     288:	a7 e2       	ldi	r26, 0x27	; 39
     28a:	b0 e0       	ldi	r27, 0x00	; 0
     28c:	e7 e2       	ldi	r30, 0x27	; 39
     28e:	f0 e0       	ldi	r31, 0x00	; 0
     290:	80 81       	ld	r24, Z
     292:	81 60       	ori	r24, 0x01	; 1
     294:	8c 93       	st	X, r24
     296:	d7 c0       	rjmp	.+430    	; 0x446 <ADC_Init+0x3b4>
     298:	a7 e2       	ldi	r26, 0x27	; 39
     29a:	b0 e0       	ldi	r27, 0x00	; 0
     29c:	e7 e2       	ldi	r30, 0x27	; 39
     29e:	f0 e0       	ldi	r31, 0x00	; 0
     2a0:	80 81       	ld	r24, Z
     2a2:	8f 7e       	andi	r24, 0xEF	; 239
     2a4:	8c 93       	st	X, r24
     2a6:	a7 e2       	ldi	r26, 0x27	; 39
     2a8:	b0 e0       	ldi	r27, 0x00	; 0
     2aa:	e7 e2       	ldi	r30, 0x27	; 39
     2ac:	f0 e0       	ldi	r31, 0x00	; 0
     2ae:	80 81       	ld	r24, Z
     2b0:	87 7f       	andi	r24, 0xF7	; 247
     2b2:	8c 93       	st	X, r24
     2b4:	a7 e2       	ldi	r26, 0x27	; 39
     2b6:	b0 e0       	ldi	r27, 0x00	; 0
     2b8:	e7 e2       	ldi	r30, 0x27	; 39
     2ba:	f0 e0       	ldi	r31, 0x00	; 0
     2bc:	80 81       	ld	r24, Z
     2be:	8b 7f       	andi	r24, 0xFB	; 251
     2c0:	8c 93       	st	X, r24
     2c2:	a7 e2       	ldi	r26, 0x27	; 39
     2c4:	b0 e0       	ldi	r27, 0x00	; 0
     2c6:	e7 e2       	ldi	r30, 0x27	; 39
     2c8:	f0 e0       	ldi	r31, 0x00	; 0
     2ca:	80 81       	ld	r24, Z
     2cc:	82 60       	ori	r24, 0x02	; 2
     2ce:	8c 93       	st	X, r24
     2d0:	a7 e2       	ldi	r26, 0x27	; 39
     2d2:	b0 e0       	ldi	r27, 0x00	; 0
     2d4:	e7 e2       	ldi	r30, 0x27	; 39
     2d6:	f0 e0       	ldi	r31, 0x00	; 0
     2d8:	80 81       	ld	r24, Z
     2da:	8e 7f       	andi	r24, 0xFE	; 254
     2dc:	8c 93       	st	X, r24
     2de:	b3 c0       	rjmp	.+358    	; 0x446 <ADC_Init+0x3b4>
     2e0:	a7 e2       	ldi	r26, 0x27	; 39
     2e2:	b0 e0       	ldi	r27, 0x00	; 0
     2e4:	e7 e2       	ldi	r30, 0x27	; 39
     2e6:	f0 e0       	ldi	r31, 0x00	; 0
     2e8:	80 81       	ld	r24, Z
     2ea:	8f 7e       	andi	r24, 0xEF	; 239
     2ec:	8c 93       	st	X, r24
     2ee:	a7 e2       	ldi	r26, 0x27	; 39
     2f0:	b0 e0       	ldi	r27, 0x00	; 0
     2f2:	e7 e2       	ldi	r30, 0x27	; 39
     2f4:	f0 e0       	ldi	r31, 0x00	; 0
     2f6:	80 81       	ld	r24, Z
     2f8:	87 7f       	andi	r24, 0xF7	; 247
     2fa:	8c 93       	st	X, r24
     2fc:	a7 e2       	ldi	r26, 0x27	; 39
     2fe:	b0 e0       	ldi	r27, 0x00	; 0
     300:	e7 e2       	ldi	r30, 0x27	; 39
     302:	f0 e0       	ldi	r31, 0x00	; 0
     304:	80 81       	ld	r24, Z
     306:	8b 7f       	andi	r24, 0xFB	; 251
     308:	8c 93       	st	X, r24
     30a:	a7 e2       	ldi	r26, 0x27	; 39
     30c:	b0 e0       	ldi	r27, 0x00	; 0
     30e:	e7 e2       	ldi	r30, 0x27	; 39
     310:	f0 e0       	ldi	r31, 0x00	; 0
     312:	80 81       	ld	r24, Z
     314:	82 60       	ori	r24, 0x02	; 2
     316:	8c 93       	st	X, r24
     318:	a7 e2       	ldi	r26, 0x27	; 39
     31a:	b0 e0       	ldi	r27, 0x00	; 0
     31c:	e7 e2       	ldi	r30, 0x27	; 39
     31e:	f0 e0       	ldi	r31, 0x00	; 0
     320:	80 81       	ld	r24, Z
     322:	81 60       	ori	r24, 0x01	; 1
     324:	8c 93       	st	X, r24
     326:	8f c0       	rjmp	.+286    	; 0x446 <ADC_Init+0x3b4>
     328:	a7 e2       	ldi	r26, 0x27	; 39
     32a:	b0 e0       	ldi	r27, 0x00	; 0
     32c:	e7 e2       	ldi	r30, 0x27	; 39
     32e:	f0 e0       	ldi	r31, 0x00	; 0
     330:	80 81       	ld	r24, Z
     332:	8f 7e       	andi	r24, 0xEF	; 239
     334:	8c 93       	st	X, r24
     336:	a7 e2       	ldi	r26, 0x27	; 39
     338:	b0 e0       	ldi	r27, 0x00	; 0
     33a:	e7 e2       	ldi	r30, 0x27	; 39
     33c:	f0 e0       	ldi	r31, 0x00	; 0
     33e:	80 81       	ld	r24, Z
     340:	87 7f       	andi	r24, 0xF7	; 247
     342:	8c 93       	st	X, r24
     344:	a7 e2       	ldi	r26, 0x27	; 39
     346:	b0 e0       	ldi	r27, 0x00	; 0
     348:	e7 e2       	ldi	r30, 0x27	; 39
     34a:	f0 e0       	ldi	r31, 0x00	; 0
     34c:	80 81       	ld	r24, Z
     34e:	84 60       	ori	r24, 0x04	; 4
     350:	8c 93       	st	X, r24
     352:	a7 e2       	ldi	r26, 0x27	; 39
     354:	b0 e0       	ldi	r27, 0x00	; 0
     356:	e7 e2       	ldi	r30, 0x27	; 39
     358:	f0 e0       	ldi	r31, 0x00	; 0
     35a:	80 81       	ld	r24, Z
     35c:	8d 7f       	andi	r24, 0xFD	; 253
     35e:	8c 93       	st	X, r24
     360:	a7 e2       	ldi	r26, 0x27	; 39
     362:	b0 e0       	ldi	r27, 0x00	; 0
     364:	e7 e2       	ldi	r30, 0x27	; 39
     366:	f0 e0       	ldi	r31, 0x00	; 0
     368:	80 81       	ld	r24, Z
     36a:	8e 7f       	andi	r24, 0xFE	; 254
     36c:	8c 93       	st	X, r24
     36e:	6b c0       	rjmp	.+214    	; 0x446 <ADC_Init+0x3b4>
     370:	a7 e2       	ldi	r26, 0x27	; 39
     372:	b0 e0       	ldi	r27, 0x00	; 0
     374:	e7 e2       	ldi	r30, 0x27	; 39
     376:	f0 e0       	ldi	r31, 0x00	; 0
     378:	80 81       	ld	r24, Z
     37a:	8f 7e       	andi	r24, 0xEF	; 239
     37c:	8c 93       	st	X, r24
     37e:	a7 e2       	ldi	r26, 0x27	; 39
     380:	b0 e0       	ldi	r27, 0x00	; 0
     382:	e7 e2       	ldi	r30, 0x27	; 39
     384:	f0 e0       	ldi	r31, 0x00	; 0
     386:	80 81       	ld	r24, Z
     388:	87 7f       	andi	r24, 0xF7	; 247
     38a:	8c 93       	st	X, r24
     38c:	a7 e2       	ldi	r26, 0x27	; 39
     38e:	b0 e0       	ldi	r27, 0x00	; 0
     390:	e7 e2       	ldi	r30, 0x27	; 39
     392:	f0 e0       	ldi	r31, 0x00	; 0
     394:	80 81       	ld	r24, Z
     396:	84 60       	ori	r24, 0x04	; 4
     398:	8c 93       	st	X, r24
     39a:	a7 e2       	ldi	r26, 0x27	; 39
     39c:	b0 e0       	ldi	r27, 0x00	; 0
     39e:	e7 e2       	ldi	r30, 0x27	; 39
     3a0:	f0 e0       	ldi	r31, 0x00	; 0
     3a2:	80 81       	ld	r24, Z
     3a4:	8d 7f       	andi	r24, 0xFD	; 253
     3a6:	8c 93       	st	X, r24
     3a8:	a7 e2       	ldi	r26, 0x27	; 39
     3aa:	b0 e0       	ldi	r27, 0x00	; 0
     3ac:	e7 e2       	ldi	r30, 0x27	; 39
     3ae:	f0 e0       	ldi	r31, 0x00	; 0
     3b0:	80 81       	ld	r24, Z
     3b2:	81 60       	ori	r24, 0x01	; 1
     3b4:	8c 93       	st	X, r24
     3b6:	47 c0       	rjmp	.+142    	; 0x446 <ADC_Init+0x3b4>
     3b8:	a7 e2       	ldi	r26, 0x27	; 39
     3ba:	b0 e0       	ldi	r27, 0x00	; 0
     3bc:	e7 e2       	ldi	r30, 0x27	; 39
     3be:	f0 e0       	ldi	r31, 0x00	; 0
     3c0:	80 81       	ld	r24, Z
     3c2:	8f 7e       	andi	r24, 0xEF	; 239
     3c4:	8c 93       	st	X, r24
     3c6:	a7 e2       	ldi	r26, 0x27	; 39
     3c8:	b0 e0       	ldi	r27, 0x00	; 0
     3ca:	e7 e2       	ldi	r30, 0x27	; 39
     3cc:	f0 e0       	ldi	r31, 0x00	; 0
     3ce:	80 81       	ld	r24, Z
     3d0:	87 7f       	andi	r24, 0xF7	; 247
     3d2:	8c 93       	st	X, r24
     3d4:	a7 e2       	ldi	r26, 0x27	; 39
     3d6:	b0 e0       	ldi	r27, 0x00	; 0
     3d8:	e7 e2       	ldi	r30, 0x27	; 39
     3da:	f0 e0       	ldi	r31, 0x00	; 0
     3dc:	80 81       	ld	r24, Z
     3de:	84 60       	ori	r24, 0x04	; 4
     3e0:	8c 93       	st	X, r24
     3e2:	a7 e2       	ldi	r26, 0x27	; 39
     3e4:	b0 e0       	ldi	r27, 0x00	; 0
     3e6:	e7 e2       	ldi	r30, 0x27	; 39
     3e8:	f0 e0       	ldi	r31, 0x00	; 0
     3ea:	80 81       	ld	r24, Z
     3ec:	82 60       	ori	r24, 0x02	; 2
     3ee:	8c 93       	st	X, r24
     3f0:	a7 e2       	ldi	r26, 0x27	; 39
     3f2:	b0 e0       	ldi	r27, 0x00	; 0
     3f4:	e7 e2       	ldi	r30, 0x27	; 39
     3f6:	f0 e0       	ldi	r31, 0x00	; 0
     3f8:	80 81       	ld	r24, Z
     3fa:	8e 7f       	andi	r24, 0xFE	; 254
     3fc:	8c 93       	st	X, r24
     3fe:	23 c0       	rjmp	.+70     	; 0x446 <ADC_Init+0x3b4>
     400:	a7 e2       	ldi	r26, 0x27	; 39
     402:	b0 e0       	ldi	r27, 0x00	; 0
     404:	e7 e2       	ldi	r30, 0x27	; 39
     406:	f0 e0       	ldi	r31, 0x00	; 0
     408:	80 81       	ld	r24, Z
     40a:	8f 7e       	andi	r24, 0xEF	; 239
     40c:	8c 93       	st	X, r24
     40e:	a7 e2       	ldi	r26, 0x27	; 39
     410:	b0 e0       	ldi	r27, 0x00	; 0
     412:	e7 e2       	ldi	r30, 0x27	; 39
     414:	f0 e0       	ldi	r31, 0x00	; 0
     416:	80 81       	ld	r24, Z
     418:	87 7f       	andi	r24, 0xF7	; 247
     41a:	8c 93       	st	X, r24
     41c:	a7 e2       	ldi	r26, 0x27	; 39
     41e:	b0 e0       	ldi	r27, 0x00	; 0
     420:	e7 e2       	ldi	r30, 0x27	; 39
     422:	f0 e0       	ldi	r31, 0x00	; 0
     424:	80 81       	ld	r24, Z
     426:	84 60       	ori	r24, 0x04	; 4
     428:	8c 93       	st	X, r24
     42a:	a7 e2       	ldi	r26, 0x27	; 39
     42c:	b0 e0       	ldi	r27, 0x00	; 0
     42e:	e7 e2       	ldi	r30, 0x27	; 39
     430:	f0 e0       	ldi	r31, 0x00	; 0
     432:	80 81       	ld	r24, Z
     434:	82 60       	ori	r24, 0x02	; 2
     436:	8c 93       	st	X, r24
     438:	a7 e2       	ldi	r26, 0x27	; 39
     43a:	b0 e0       	ldi	r27, 0x00	; 0
     43c:	e7 e2       	ldi	r30, 0x27	; 39
     43e:	f0 e0       	ldi	r31, 0x00	; 0
     440:	80 81       	ld	r24, Z
     442:	81 60       	ori	r24, 0x01	; 1
     444:	8c 93       	st	X, r24
     446:	a6 e2       	ldi	r26, 0x26	; 38
     448:	b0 e0       	ldi	r27, 0x00	; 0
     44a:	e6 e2       	ldi	r30, 0x26	; 38
     44c:	f0 e0       	ldi	r31, 0x00	; 0
     44e:	80 81       	ld	r24, Z
     450:	80 68       	ori	r24, 0x80	; 128
     452:	8c 93       	st	X, r24
     454:	a6 e2       	ldi	r26, 0x26	; 38
     456:	b0 e0       	ldi	r27, 0x00	; 0
     458:	e6 e2       	ldi	r30, 0x26	; 38
     45a:	f0 e0       	ldi	r31, 0x00	; 0
     45c:	80 81       	ld	r24, Z
     45e:	8f 7b       	andi	r24, 0xBF	; 191
     460:	8c 93       	st	X, r24
     462:	80 91 b1 00 	lds	r24, 0x00B1
     466:	28 2f       	mov	r18, r24
     468:	30 e0       	ldi	r19, 0x00	; 0
     46a:	3e 83       	std	Y+6, r19	; 0x06
     46c:	2d 83       	std	Y+5, r18	; 0x05
     46e:	8d 81       	ldd	r24, Y+5	; 0x05
     470:	9e 81       	ldd	r25, Y+6	; 0x06
     472:	00 97       	sbiw	r24, 0x00	; 0
     474:	31 f0       	breq	.+12     	; 0x482 <ADC_Init+0x3f0>
     476:	2d 81       	ldd	r18, Y+5	; 0x05
     478:	3e 81       	ldd	r19, Y+6	; 0x06
     47a:	21 30       	cpi	r18, 0x01	; 1
     47c:	31 05       	cpc	r19, r1
     47e:	49 f0       	breq	.+18     	; 0x492 <ADC_Init+0x400>
     480:	0f c0       	rjmp	.+30     	; 0x4a0 <ADC_Init+0x40e>
     482:	a6 e2       	ldi	r26, 0x26	; 38
     484:	b0 e0       	ldi	r27, 0x00	; 0
     486:	e6 e2       	ldi	r30, 0x26	; 38
     488:	f0 e0       	ldi	r31, 0x00	; 0
     48a:	80 81       	ld	r24, Z
     48c:	87 7f       	andi	r24, 0xF7	; 247
     48e:	8c 93       	st	X, r24
     490:	07 c0       	rjmp	.+14     	; 0x4a0 <ADC_Init+0x40e>
     492:	a6 e2       	ldi	r26, 0x26	; 38
     494:	b0 e0       	ldi	r27, 0x00	; 0
     496:	e6 e2       	ldi	r30, 0x26	; 38
     498:	f0 e0       	ldi	r31, 0x00	; 0
     49a:	80 81       	ld	r24, Z
     49c:	88 60       	ori	r24, 0x08	; 8
     49e:	8c 93       	st	X, r24
     4a0:	80 91 af 00 	lds	r24, 0x00AF
     4a4:	28 2f       	mov	r18, r24
     4a6:	30 e0       	ldi	r19, 0x00	; 0
     4a8:	3c 83       	std	Y+4, r19	; 0x04
     4aa:	2b 83       	std	Y+3, r18	; 0x03
     4ac:	8b 81       	ldd	r24, Y+3	; 0x03
     4ae:	9c 81       	ldd	r25, Y+4	; 0x04
     4b0:	83 30       	cpi	r24, 0x03	; 3
     4b2:	91 05       	cpc	r25, r1
     4b4:	09 f4       	brne	.+2      	; 0x4b8 <ADC_Init+0x426>
     4b6:	70 c0       	rjmp	.+224    	; 0x598 <ADC_Init+0x506>
     4b8:	2b 81       	ldd	r18, Y+3	; 0x03
     4ba:	3c 81       	ldd	r19, Y+4	; 0x04
     4bc:	24 30       	cpi	r18, 0x04	; 4
     4be:	31 05       	cpc	r19, r1
     4c0:	84 f4       	brge	.+32     	; 0x4e2 <ADC_Init+0x450>
     4c2:	8b 81       	ldd	r24, Y+3	; 0x03
     4c4:	9c 81       	ldd	r25, Y+4	; 0x04
     4c6:	81 30       	cpi	r24, 0x01	; 1
     4c8:	91 05       	cpc	r25, r1
     4ca:	d1 f1       	breq	.+116    	; 0x540 <ADC_Init+0x4ae>
     4cc:	2b 81       	ldd	r18, Y+3	; 0x03
     4ce:	3c 81       	ldd	r19, Y+4	; 0x04
     4d0:	22 30       	cpi	r18, 0x02	; 2
     4d2:	31 05       	cpc	r19, r1
     4d4:	0c f0       	brlt	.+2      	; 0x4d8 <ADC_Init+0x446>
     4d6:	4a c0       	rjmp	.+148    	; 0x56c <ADC_Init+0x4da>
     4d8:	8b 81       	ldd	r24, Y+3	; 0x03
     4da:	9c 81       	ldd	r25, Y+4	; 0x04
     4dc:	00 97       	sbiw	r24, 0x00	; 0
     4de:	d1 f0       	breq	.+52     	; 0x514 <ADC_Init+0x482>
     4e0:	c9 c0       	rjmp	.+402    	; 0x674 <ADC_Init+0x5e2>
     4e2:	2b 81       	ldd	r18, Y+3	; 0x03
     4e4:	3c 81       	ldd	r19, Y+4	; 0x04
     4e6:	25 30       	cpi	r18, 0x05	; 5
     4e8:	31 05       	cpc	r19, r1
     4ea:	09 f4       	brne	.+2      	; 0x4ee <ADC_Init+0x45c>
     4ec:	81 c0       	rjmp	.+258    	; 0x5f0 <ADC_Init+0x55e>
     4ee:	8b 81       	ldd	r24, Y+3	; 0x03
     4f0:	9c 81       	ldd	r25, Y+4	; 0x04
     4f2:	85 30       	cpi	r24, 0x05	; 5
     4f4:	91 05       	cpc	r25, r1
     4f6:	0c f4       	brge	.+2      	; 0x4fa <ADC_Init+0x468>
     4f8:	65 c0       	rjmp	.+202    	; 0x5c4 <ADC_Init+0x532>
     4fa:	2b 81       	ldd	r18, Y+3	; 0x03
     4fc:	3c 81       	ldd	r19, Y+4	; 0x04
     4fe:	26 30       	cpi	r18, 0x06	; 6
     500:	31 05       	cpc	r19, r1
     502:	09 f4       	brne	.+2      	; 0x506 <ADC_Init+0x474>
     504:	8b c0       	rjmp	.+278    	; 0x61c <ADC_Init+0x58a>
     506:	8b 81       	ldd	r24, Y+3	; 0x03
     508:	9c 81       	ldd	r25, Y+4	; 0x04
     50a:	87 30       	cpi	r24, 0x07	; 7
     50c:	91 05       	cpc	r25, r1
     50e:	09 f4       	brne	.+2      	; 0x512 <ADC_Init+0x480>
     510:	9b c0       	rjmp	.+310    	; 0x648 <ADC_Init+0x5b6>
     512:	b0 c0       	rjmp	.+352    	; 0x674 <ADC_Init+0x5e2>
     514:	a6 e2       	ldi	r26, 0x26	; 38
     516:	b0 e0       	ldi	r27, 0x00	; 0
     518:	e6 e2       	ldi	r30, 0x26	; 38
     51a:	f0 e0       	ldi	r31, 0x00	; 0
     51c:	80 81       	ld	r24, Z
     51e:	8b 7f       	andi	r24, 0xFB	; 251
     520:	8c 93       	st	X, r24
     522:	a6 e2       	ldi	r26, 0x26	; 38
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	e6 e2       	ldi	r30, 0x26	; 38
     528:	f0 e0       	ldi	r31, 0x00	; 0
     52a:	80 81       	ld	r24, Z
     52c:	8d 7f       	andi	r24, 0xFD	; 253
     52e:	8c 93       	st	X, r24
     530:	a6 e2       	ldi	r26, 0x26	; 38
     532:	b0 e0       	ldi	r27, 0x00	; 0
     534:	e6 e2       	ldi	r30, 0x26	; 38
     536:	f0 e0       	ldi	r31, 0x00	; 0
     538:	80 81       	ld	r24, Z
     53a:	8e 7f       	andi	r24, 0xFE	; 254
     53c:	8c 93       	st	X, r24
     53e:	af c0       	rjmp	.+350    	; 0x69e <ADC_Init+0x60c>
     540:	a6 e2       	ldi	r26, 0x26	; 38
     542:	b0 e0       	ldi	r27, 0x00	; 0
     544:	e6 e2       	ldi	r30, 0x26	; 38
     546:	f0 e0       	ldi	r31, 0x00	; 0
     548:	80 81       	ld	r24, Z
     54a:	8b 7f       	andi	r24, 0xFB	; 251
     54c:	8c 93       	st	X, r24
     54e:	a6 e2       	ldi	r26, 0x26	; 38
     550:	b0 e0       	ldi	r27, 0x00	; 0
     552:	e6 e2       	ldi	r30, 0x26	; 38
     554:	f0 e0       	ldi	r31, 0x00	; 0
     556:	80 81       	ld	r24, Z
     558:	8d 7f       	andi	r24, 0xFD	; 253
     55a:	8c 93       	st	X, r24
     55c:	a6 e2       	ldi	r26, 0x26	; 38
     55e:	b0 e0       	ldi	r27, 0x00	; 0
     560:	e6 e2       	ldi	r30, 0x26	; 38
     562:	f0 e0       	ldi	r31, 0x00	; 0
     564:	80 81       	ld	r24, Z
     566:	81 60       	ori	r24, 0x01	; 1
     568:	8c 93       	st	X, r24
     56a:	99 c0       	rjmp	.+306    	; 0x69e <ADC_Init+0x60c>
     56c:	a6 e2       	ldi	r26, 0x26	; 38
     56e:	b0 e0       	ldi	r27, 0x00	; 0
     570:	e6 e2       	ldi	r30, 0x26	; 38
     572:	f0 e0       	ldi	r31, 0x00	; 0
     574:	80 81       	ld	r24, Z
     576:	8b 7f       	andi	r24, 0xFB	; 251
     578:	8c 93       	st	X, r24
     57a:	a6 e2       	ldi	r26, 0x26	; 38
     57c:	b0 e0       	ldi	r27, 0x00	; 0
     57e:	e6 e2       	ldi	r30, 0x26	; 38
     580:	f0 e0       	ldi	r31, 0x00	; 0
     582:	80 81       	ld	r24, Z
     584:	82 60       	ori	r24, 0x02	; 2
     586:	8c 93       	st	X, r24
     588:	a6 e2       	ldi	r26, 0x26	; 38
     58a:	b0 e0       	ldi	r27, 0x00	; 0
     58c:	e6 e2       	ldi	r30, 0x26	; 38
     58e:	f0 e0       	ldi	r31, 0x00	; 0
     590:	80 81       	ld	r24, Z
     592:	8e 7f       	andi	r24, 0xFE	; 254
     594:	8c 93       	st	X, r24
     596:	83 c0       	rjmp	.+262    	; 0x69e <ADC_Init+0x60c>
     598:	a6 e2       	ldi	r26, 0x26	; 38
     59a:	b0 e0       	ldi	r27, 0x00	; 0
     59c:	e6 e2       	ldi	r30, 0x26	; 38
     59e:	f0 e0       	ldi	r31, 0x00	; 0
     5a0:	80 81       	ld	r24, Z
     5a2:	8b 7f       	andi	r24, 0xFB	; 251
     5a4:	8c 93       	st	X, r24
     5a6:	a6 e2       	ldi	r26, 0x26	; 38
     5a8:	b0 e0       	ldi	r27, 0x00	; 0
     5aa:	e6 e2       	ldi	r30, 0x26	; 38
     5ac:	f0 e0       	ldi	r31, 0x00	; 0
     5ae:	80 81       	ld	r24, Z
     5b0:	82 60       	ori	r24, 0x02	; 2
     5b2:	8c 93       	st	X, r24
     5b4:	a6 e2       	ldi	r26, 0x26	; 38
     5b6:	b0 e0       	ldi	r27, 0x00	; 0
     5b8:	e6 e2       	ldi	r30, 0x26	; 38
     5ba:	f0 e0       	ldi	r31, 0x00	; 0
     5bc:	80 81       	ld	r24, Z
     5be:	81 60       	ori	r24, 0x01	; 1
     5c0:	8c 93       	st	X, r24
     5c2:	6d c0       	rjmp	.+218    	; 0x69e <ADC_Init+0x60c>
     5c4:	a6 e2       	ldi	r26, 0x26	; 38
     5c6:	b0 e0       	ldi	r27, 0x00	; 0
     5c8:	e6 e2       	ldi	r30, 0x26	; 38
     5ca:	f0 e0       	ldi	r31, 0x00	; 0
     5cc:	80 81       	ld	r24, Z
     5ce:	84 60       	ori	r24, 0x04	; 4
     5d0:	8c 93       	st	X, r24
     5d2:	a6 e2       	ldi	r26, 0x26	; 38
     5d4:	b0 e0       	ldi	r27, 0x00	; 0
     5d6:	e6 e2       	ldi	r30, 0x26	; 38
     5d8:	f0 e0       	ldi	r31, 0x00	; 0
     5da:	80 81       	ld	r24, Z
     5dc:	8d 7f       	andi	r24, 0xFD	; 253
     5de:	8c 93       	st	X, r24
     5e0:	a6 e2       	ldi	r26, 0x26	; 38
     5e2:	b0 e0       	ldi	r27, 0x00	; 0
     5e4:	e6 e2       	ldi	r30, 0x26	; 38
     5e6:	f0 e0       	ldi	r31, 0x00	; 0
     5e8:	80 81       	ld	r24, Z
     5ea:	8e 7f       	andi	r24, 0xFE	; 254
     5ec:	8c 93       	st	X, r24
     5ee:	57 c0       	rjmp	.+174    	; 0x69e <ADC_Init+0x60c>
     5f0:	a6 e2       	ldi	r26, 0x26	; 38
     5f2:	b0 e0       	ldi	r27, 0x00	; 0
     5f4:	e6 e2       	ldi	r30, 0x26	; 38
     5f6:	f0 e0       	ldi	r31, 0x00	; 0
     5f8:	80 81       	ld	r24, Z
     5fa:	84 60       	ori	r24, 0x04	; 4
     5fc:	8c 93       	st	X, r24
     5fe:	a6 e2       	ldi	r26, 0x26	; 38
     600:	b0 e0       	ldi	r27, 0x00	; 0
     602:	e6 e2       	ldi	r30, 0x26	; 38
     604:	f0 e0       	ldi	r31, 0x00	; 0
     606:	80 81       	ld	r24, Z
     608:	8d 7f       	andi	r24, 0xFD	; 253
     60a:	8c 93       	st	X, r24
     60c:	a6 e2       	ldi	r26, 0x26	; 38
     60e:	b0 e0       	ldi	r27, 0x00	; 0
     610:	e6 e2       	ldi	r30, 0x26	; 38
     612:	f0 e0       	ldi	r31, 0x00	; 0
     614:	80 81       	ld	r24, Z
     616:	81 60       	ori	r24, 0x01	; 1
     618:	8c 93       	st	X, r24
     61a:	41 c0       	rjmp	.+130    	; 0x69e <ADC_Init+0x60c>
     61c:	a6 e2       	ldi	r26, 0x26	; 38
     61e:	b0 e0       	ldi	r27, 0x00	; 0
     620:	e6 e2       	ldi	r30, 0x26	; 38
     622:	f0 e0       	ldi	r31, 0x00	; 0
     624:	80 81       	ld	r24, Z
     626:	84 60       	ori	r24, 0x04	; 4
     628:	8c 93       	st	X, r24
     62a:	a6 e2       	ldi	r26, 0x26	; 38
     62c:	b0 e0       	ldi	r27, 0x00	; 0
     62e:	e6 e2       	ldi	r30, 0x26	; 38
     630:	f0 e0       	ldi	r31, 0x00	; 0
     632:	80 81       	ld	r24, Z
     634:	82 60       	ori	r24, 0x02	; 2
     636:	8c 93       	st	X, r24
     638:	a6 e2       	ldi	r26, 0x26	; 38
     63a:	b0 e0       	ldi	r27, 0x00	; 0
     63c:	e6 e2       	ldi	r30, 0x26	; 38
     63e:	f0 e0       	ldi	r31, 0x00	; 0
     640:	80 81       	ld	r24, Z
     642:	8e 7f       	andi	r24, 0xFE	; 254
     644:	8c 93       	st	X, r24
     646:	2b c0       	rjmp	.+86     	; 0x69e <ADC_Init+0x60c>
     648:	a6 e2       	ldi	r26, 0x26	; 38
     64a:	b0 e0       	ldi	r27, 0x00	; 0
     64c:	e6 e2       	ldi	r30, 0x26	; 38
     64e:	f0 e0       	ldi	r31, 0x00	; 0
     650:	80 81       	ld	r24, Z
     652:	84 60       	ori	r24, 0x04	; 4
     654:	8c 93       	st	X, r24
     656:	a6 e2       	ldi	r26, 0x26	; 38
     658:	b0 e0       	ldi	r27, 0x00	; 0
     65a:	e6 e2       	ldi	r30, 0x26	; 38
     65c:	f0 e0       	ldi	r31, 0x00	; 0
     65e:	80 81       	ld	r24, Z
     660:	82 60       	ori	r24, 0x02	; 2
     662:	8c 93       	st	X, r24
     664:	a6 e2       	ldi	r26, 0x26	; 38
     666:	b0 e0       	ldi	r27, 0x00	; 0
     668:	e6 e2       	ldi	r30, 0x26	; 38
     66a:	f0 e0       	ldi	r31, 0x00	; 0
     66c:	80 81       	ld	r24, Z
     66e:	81 60       	ori	r24, 0x01	; 1
     670:	8c 93       	st	X, r24
     672:	15 c0       	rjmp	.+42     	; 0x69e <ADC_Init+0x60c>
     674:	a6 e2       	ldi	r26, 0x26	; 38
     676:	b0 e0       	ldi	r27, 0x00	; 0
     678:	e6 e2       	ldi	r30, 0x26	; 38
     67a:	f0 e0       	ldi	r31, 0x00	; 0
     67c:	80 81       	ld	r24, Z
     67e:	84 60       	ori	r24, 0x04	; 4
     680:	8c 93       	st	X, r24
     682:	a6 e2       	ldi	r26, 0x26	; 38
     684:	b0 e0       	ldi	r27, 0x00	; 0
     686:	e6 e2       	ldi	r30, 0x26	; 38
     688:	f0 e0       	ldi	r31, 0x00	; 0
     68a:	80 81       	ld	r24, Z
     68c:	8d 7f       	andi	r24, 0xFD	; 253
     68e:	8c 93       	st	X, r24
     690:	a6 e2       	ldi	r26, 0x26	; 38
     692:	b0 e0       	ldi	r27, 0x00	; 0
     694:	e6 e2       	ldi	r30, 0x26	; 38
     696:	f0 e0       	ldi	r31, 0x00	; 0
     698:	80 81       	ld	r24, Z
     69a:	8e 7f       	andi	r24, 0xFE	; 254
     69c:	8c 93       	st	X, r24
     69e:	80 91 b0 00 	lds	r24, 0x00B0
     6a2:	28 2f       	mov	r18, r24
     6a4:	30 e0       	ldi	r19, 0x00	; 0
     6a6:	3a 83       	std	Y+2, r19	; 0x02
     6a8:	29 83       	std	Y+1, r18	; 0x01
     6aa:	89 81       	ldd	r24, Y+1	; 0x01
     6ac:	9a 81       	ldd	r25, Y+2	; 0x02
     6ae:	82 30       	cpi	r24, 0x02	; 2
     6b0:	91 05       	cpc	r25, r1
     6b2:	a1 f1       	breq	.+104    	; 0x71c <ADC_Init+0x68a>
     6b4:	29 81       	ldd	r18, Y+1	; 0x01
     6b6:	3a 81       	ldd	r19, Y+2	; 0x02
     6b8:	23 30       	cpi	r18, 0x03	; 3
     6ba:	31 05       	cpc	r19, r1
     6bc:	2c f4       	brge	.+10     	; 0x6c8 <ADC_Init+0x636>
     6be:	89 81       	ldd	r24, Y+1	; 0x01
     6c0:	9a 81       	ldd	r25, Y+2	; 0x02
     6c2:	00 97       	sbiw	r24, 0x00	; 0
     6c4:	71 f0       	breq	.+28     	; 0x6e2 <ADC_Init+0x650>
     6c6:	6b c0       	rjmp	.+214    	; 0x79e <ADC_Init+0x70c>
     6c8:	29 81       	ldd	r18, Y+1	; 0x01
     6ca:	3a 81       	ldd	r19, Y+2	; 0x02
     6cc:	23 30       	cpi	r18, 0x03	; 3
     6ce:	31 05       	cpc	r19, r1
     6d0:	09 f4       	brne	.+2      	; 0x6d4 <ADC_Init+0x642>
     6d2:	41 c0       	rjmp	.+130    	; 0x756 <ADC_Init+0x6c4>
     6d4:	89 81       	ldd	r24, Y+1	; 0x01
     6d6:	9a 81       	ldd	r25, Y+2	; 0x02
     6d8:	84 30       	cpi	r24, 0x04	; 4
     6da:	91 05       	cpc	r25, r1
     6dc:	09 f4       	brne	.+2      	; 0x6e0 <ADC_Init+0x64e>
     6de:	58 c0       	rjmp	.+176    	; 0x790 <ADC_Init+0x6fe>
     6e0:	5e c0       	rjmp	.+188    	; 0x79e <ADC_Init+0x70c>
     6e2:	a6 e2       	ldi	r26, 0x26	; 38
     6e4:	b0 e0       	ldi	r27, 0x00	; 0
     6e6:	e6 e2       	ldi	r30, 0x26	; 38
     6e8:	f0 e0       	ldi	r31, 0x00	; 0
     6ea:	80 81       	ld	r24, Z
     6ec:	80 62       	ori	r24, 0x20	; 32
     6ee:	8c 93       	st	X, r24
     6f0:	a0 e5       	ldi	r26, 0x50	; 80
     6f2:	b0 e0       	ldi	r27, 0x00	; 0
     6f4:	e0 e5       	ldi	r30, 0x50	; 80
     6f6:	f0 e0       	ldi	r31, 0x00	; 0
     6f8:	80 81       	ld	r24, Z
     6fa:	8f 77       	andi	r24, 0x7F	; 127
     6fc:	8c 93       	st	X, r24
     6fe:	a0 e5       	ldi	r26, 0x50	; 80
     700:	b0 e0       	ldi	r27, 0x00	; 0
     702:	e0 e5       	ldi	r30, 0x50	; 80
     704:	f0 e0       	ldi	r31, 0x00	; 0
     706:	80 81       	ld	r24, Z
     708:	8f 7b       	andi	r24, 0xBF	; 191
     70a:	8c 93       	st	X, r24
     70c:	a0 e5       	ldi	r26, 0x50	; 80
     70e:	b0 e0       	ldi	r27, 0x00	; 0
     710:	e0 e5       	ldi	r30, 0x50	; 80
     712:	f0 e0       	ldi	r31, 0x00	; 0
     714:	80 81       	ld	r24, Z
     716:	8f 7d       	andi	r24, 0xDF	; 223
     718:	8c 93       	st	X, r24
     71a:	41 c0       	rjmp	.+130    	; 0x79e <ADC_Init+0x70c>
     71c:	a6 e2       	ldi	r26, 0x26	; 38
     71e:	b0 e0       	ldi	r27, 0x00	; 0
     720:	e6 e2       	ldi	r30, 0x26	; 38
     722:	f0 e0       	ldi	r31, 0x00	; 0
     724:	80 81       	ld	r24, Z
     726:	80 62       	ori	r24, 0x20	; 32
     728:	8c 93       	st	X, r24
     72a:	a0 e5       	ldi	r26, 0x50	; 80
     72c:	b0 e0       	ldi	r27, 0x00	; 0
     72e:	e0 e5       	ldi	r30, 0x50	; 80
     730:	f0 e0       	ldi	r31, 0x00	; 0
     732:	80 81       	ld	r24, Z
     734:	8f 77       	andi	r24, 0x7F	; 127
     736:	8c 93       	st	X, r24
     738:	a0 e5       	ldi	r26, 0x50	; 80
     73a:	b0 e0       	ldi	r27, 0x00	; 0
     73c:	e0 e5       	ldi	r30, 0x50	; 80
     73e:	f0 e0       	ldi	r31, 0x00	; 0
     740:	80 81       	ld	r24, Z
     742:	80 64       	ori	r24, 0x40	; 64
     744:	8c 93       	st	X, r24
     746:	a0 e5       	ldi	r26, 0x50	; 80
     748:	b0 e0       	ldi	r27, 0x00	; 0
     74a:	e0 e5       	ldi	r30, 0x50	; 80
     74c:	f0 e0       	ldi	r31, 0x00	; 0
     74e:	80 81       	ld	r24, Z
     750:	8f 7d       	andi	r24, 0xDF	; 223
     752:	8c 93       	st	X, r24
     754:	24 c0       	rjmp	.+72     	; 0x79e <ADC_Init+0x70c>
     756:	a6 e2       	ldi	r26, 0x26	; 38
     758:	b0 e0       	ldi	r27, 0x00	; 0
     75a:	e6 e2       	ldi	r30, 0x26	; 38
     75c:	f0 e0       	ldi	r31, 0x00	; 0
     75e:	80 81       	ld	r24, Z
     760:	80 62       	ori	r24, 0x20	; 32
     762:	8c 93       	st	X, r24
     764:	a0 e5       	ldi	r26, 0x50	; 80
     766:	b0 e0       	ldi	r27, 0x00	; 0
     768:	e0 e5       	ldi	r30, 0x50	; 80
     76a:	f0 e0       	ldi	r31, 0x00	; 0
     76c:	80 81       	ld	r24, Z
     76e:	8f 77       	andi	r24, 0x7F	; 127
     770:	8c 93       	st	X, r24
     772:	a0 e5       	ldi	r26, 0x50	; 80
     774:	b0 e0       	ldi	r27, 0x00	; 0
     776:	e0 e5       	ldi	r30, 0x50	; 80
     778:	f0 e0       	ldi	r31, 0x00	; 0
     77a:	80 81       	ld	r24, Z
     77c:	80 64       	ori	r24, 0x40	; 64
     77e:	8c 93       	st	X, r24
     780:	a0 e5       	ldi	r26, 0x50	; 80
     782:	b0 e0       	ldi	r27, 0x00	; 0
     784:	e0 e5       	ldi	r30, 0x50	; 80
     786:	f0 e0       	ldi	r31, 0x00	; 0
     788:	80 81       	ld	r24, Z
     78a:	80 62       	ori	r24, 0x20	; 32
     78c:	8c 93       	st	X, r24
     78e:	07 c0       	rjmp	.+14     	; 0x79e <ADC_Init+0x70c>
     790:	a6 e2       	ldi	r26, 0x26	; 38
     792:	b0 e0       	ldi	r27, 0x00	; 0
     794:	e6 e2       	ldi	r30, 0x26	; 38
     796:	f0 e0       	ldi	r31, 0x00	; 0
     798:	80 81       	ld	r24, Z
     79a:	8f 7d       	andi	r24, 0xDF	; 223
     79c:	8c 93       	st	X, r24
     79e:	2c 96       	adiw	r28, 0x0c	; 12
     7a0:	0f b6       	in	r0, 0x3f	; 63
     7a2:	f8 94       	cli
     7a4:	de bf       	out	0x3e, r29	; 62
     7a6:	0f be       	out	0x3f, r0	; 63
     7a8:	cd bf       	out	0x3d, r28	; 61
     7aa:	cf 91       	pop	r28
     7ac:	df 91       	pop	r29
     7ae:	08 95       	ret

000007b0 <ADC_SelectChannel>:
 * Outputs:			Digital uint16 Data
 *
 * Return:			NULL
 *******************************************************************************/
void ADC_SelectChannel(EnmADCAnalogChannel_t a_ChannelNumber)
{
     7b0:	df 93       	push	r29
     7b2:	cf 93       	push	r28
     7b4:	0f 92       	push	r0
     7b6:	cd b7       	in	r28, 0x3d	; 61
     7b8:	de b7       	in	r29, 0x3e	; 62
     7ba:	89 83       	std	Y+1, r24	; 0x01
	/* channel number must be from 0 --> 7 */
	/* clear first 5 bits in the ADMUX (channel number MUX4:0 bits) before set the required channel */
	/* choose the correct channel by setting the channel number in MUX4:0 bits */
	ADC_ADMUX = (ADC_ADMUX & 0xE0)|(a_ChannelNumber);
     7bc:	a7 e2       	ldi	r26, 0x27	; 39
     7be:	b0 e0       	ldi	r27, 0x00	; 0
     7c0:	e7 e2       	ldi	r30, 0x27	; 39
     7c2:	f0 e0       	ldi	r31, 0x00	; 0
     7c4:	80 81       	ld	r24, Z
     7c6:	98 2f       	mov	r25, r24
     7c8:	90 7e       	andi	r25, 0xE0	; 224
     7ca:	89 81       	ldd	r24, Y+1	; 0x01
     7cc:	89 2b       	or	r24, r25
     7ce:	8c 93       	st	X, r24
}
     7d0:	0f 90       	pop	r0
     7d2:	cf 91       	pop	r28
     7d4:	df 91       	pop	r29
     7d6:	08 95       	ret

000007d8 <ADC_StartConversion>:

void ADC_StartConversion(void)
{
     7d8:	df 93       	push	r29
     7da:	cf 93       	push	r28
     7dc:	cd b7       	in	r28, 0x3d	; 61
     7de:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(ADC_ADCSRA,ADC_ADSC); /* start conversion write '1' to ADSC */
     7e0:	a6 e2       	ldi	r26, 0x26	; 38
     7e2:	b0 e0       	ldi	r27, 0x00	; 0
     7e4:	e6 e2       	ldi	r30, 0x26	; 38
     7e6:	f0 e0       	ldi	r31, 0x00	; 0
     7e8:	80 81       	ld	r24, Z
     7ea:	80 64       	ori	r24, 0x40	; 64
     7ec:	8c 93       	st	X, r24
	switch(ADC_Config.IntConfig)
     7ee:	80 91 b1 00 	lds	r24, 0x00B1
     7f2:	88 2f       	mov	r24, r24
     7f4:	90 e0       	ldi	r25, 0x00	; 0
     7f6:	00 97       	sbiw	r24, 0x00	; 0
     7f8:	91 f4       	brne	.+36     	; 0x81e <ADC_StartConversion+0x46>
	{
	case ADC_INTERRUPT_DISABLE:
		while(GET_BIT(ADC_ADCSRA,ADC_ADIF)==LOW);
     7fa:	e6 e2       	ldi	r30, 0x26	; 38
     7fc:	f0 e0       	ldi	r31, 0x00	; 0
     7fe:	80 81       	ld	r24, Z
     800:	82 95       	swap	r24
     802:	8f 70       	andi	r24, 0x0F	; 15
     804:	88 2f       	mov	r24, r24
     806:	90 e0       	ldi	r25, 0x00	; 0
     808:	81 70       	andi	r24, 0x01	; 1
     80a:	90 70       	andi	r25, 0x00	; 0
     80c:	00 97       	sbiw	r24, 0x00	; 0
     80e:	a9 f3       	breq	.-22     	; 0x7fa <ADC_StartConversion+0x22>
		SET_BIT(ADC_ADCSRA,ADC_ADIF); /* clear ADIF by write '1' to it :) */
     810:	a6 e2       	ldi	r26, 0x26	; 38
     812:	b0 e0       	ldi	r27, 0x00	; 0
     814:	e6 e2       	ldi	r30, 0x26	; 38
     816:	f0 e0       	ldi	r31, 0x00	; 0
     818:	80 81       	ld	r24, Z
     81a:	80 61       	ori	r24, 0x10	; 16
     81c:	8c 93       	st	X, r24
		break;
	default:
		/*DO Nothing*/
		break;
	}
}
     81e:	cf 91       	pop	r28
     820:	df 91       	pop	r29
     822:	08 95       	ret

00000824 <ADC_ReadChannel>:

uint16 ADC_ReadChannel(void)
{
     824:	df 93       	push	r29
     826:	cf 93       	push	r28
     828:	00 d0       	rcall	.+0      	; 0x82a <ADC_ReadChannel+0x6>
     82a:	cd b7       	in	r28, 0x3d	; 61
     82c:	de b7       	in	r29, 0x3e	; 62
	uint16 ReturnVal;
	if(ADC_Config.Adjustment == LEFT_ADJUSTMENT)
     82e:	80 91 ad 00 	lds	r24, 0x00AD
     832:	81 30       	cpi	r24, 0x01	; 1
     834:	81 f4       	brne	.+32     	; 0x856 <ADC_ReadChannel+0x32>
	{
		ReturnVal = (ADC_Data>>6);
     836:	e4 e2       	ldi	r30, 0x24	; 36
     838:	f0 e0       	ldi	r31, 0x00	; 0
     83a:	80 81       	ld	r24, Z
     83c:	91 81       	ldd	r25, Z+1	; 0x01
     83e:	00 24       	eor	r0, r0
     840:	88 0f       	add	r24, r24
     842:	99 1f       	adc	r25, r25
     844:	00 1c       	adc	r0, r0
     846:	88 0f       	add	r24, r24
     848:	99 1f       	adc	r25, r25
     84a:	00 1c       	adc	r0, r0
     84c:	89 2f       	mov	r24, r25
     84e:	90 2d       	mov	r25, r0
     850:	9a 83       	std	Y+2, r25	; 0x02
     852:	89 83       	std	Y+1, r24	; 0x01
     854:	06 c0       	rjmp	.+12     	; 0x862 <__stack+0x3>
	}
	else
	{
		ReturnVal = ADC_Data;
     856:	e4 e2       	ldi	r30, 0x24	; 36
     858:	f0 e0       	ldi	r31, 0x00	; 0
     85a:	80 81       	ld	r24, Z
     85c:	91 81       	ldd	r25, Z+1	; 0x01
     85e:	9a 83       	std	Y+2, r25	; 0x02
     860:	89 83       	std	Y+1, r24	; 0x01
	}
	return ReturnVal;
     862:	89 81       	ldd	r24, Y+1	; 0x01
     864:	9a 81       	ldd	r25, Y+2	; 0x02
}
     866:	0f 90       	pop	r0
     868:	0f 90       	pop	r0
     86a:	cf 91       	pop	r28
     86c:	df 91       	pop	r29
     86e:	08 95       	ret

00000870 <ADC_DeInit>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void ADC_DeInit(void)
{
     870:	df 93       	push	r29
     872:	cf 93       	push	r28
     874:	cd b7       	in	r28, 0x3d	; 61
     876:	de b7       	in	r29, 0x3e	; 62
	CLEAR_BIT(ADC_ADCSRA,ADC_ADEN);
     878:	a6 e2       	ldi	r26, 0x26	; 38
     87a:	b0 e0       	ldi	r27, 0x00	; 0
     87c:	e6 e2       	ldi	r30, 0x26	; 38
     87e:	f0 e0       	ldi	r31, 0x00	; 0
     880:	80 81       	ld	r24, Z
     882:	8f 77       	andi	r24, 0x7F	; 127
     884:	8c 93       	st	X, r24
	CLEAR_BIT(ADC_ADCSRA,ADC_ADIE);
     886:	a6 e2       	ldi	r26, 0x26	; 38
     888:	b0 e0       	ldi	r27, 0x00	; 0
     88a:	e6 e2       	ldi	r30, 0x26	; 38
     88c:	f0 e0       	ldi	r31, 0x00	; 0
     88e:	80 81       	ld	r24, Z
     890:	87 7f       	andi	r24, 0xF7	; 247
     892:	8c 93       	st	X, r24
}
     894:	cf 91       	pop	r28
     896:	df 91       	pop	r29
     898:	08 95       	ret

0000089a <DIO_WritePin>:
#include "DIO.h"



void DIO_WritePin(uint8 PinNum,uint8 PinValue)
{
     89a:	df 93       	push	r29
     89c:	cf 93       	push	r28
     89e:	00 d0       	rcall	.+0      	; 0x8a0 <DIO_WritePin+0x6>
     8a0:	cd b7       	in	r28, 0x3d	; 61
     8a2:	de b7       	in	r29, 0x3e	; 62
     8a4:	89 83       	std	Y+1, r24	; 0x01
     8a6:	6a 83       	std	Y+2, r22	; 0x02
	if(PinValue==HIGH)
     8a8:	8a 81       	ldd	r24, Y+2	; 0x02
     8aa:	81 30       	cpi	r24, 0x01	; 1
     8ac:	09 f0       	breq	.+2      	; 0x8b0 <DIO_WritePin+0x16>
     8ae:	6d c0       	rjmp	.+218    	; 0x98a <DIO_WritePin+0xf0>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     8b0:	89 81       	ldd	r24, Y+1	; 0x01
     8b2:	88 30       	cpi	r24, 0x08	; 8
     8b4:	a0 f4       	brcc	.+40     	; 0x8de <DIO_WritePin+0x44>
		{
			SET_BIT(DIO_PORTA,PinNum);
     8b6:	ab e3       	ldi	r26, 0x3B	; 59
     8b8:	b0 e0       	ldi	r27, 0x00	; 0
     8ba:	eb e3       	ldi	r30, 0x3B	; 59
     8bc:	f0 e0       	ldi	r31, 0x00	; 0
     8be:	80 81       	ld	r24, Z
     8c0:	48 2f       	mov	r20, r24
     8c2:	89 81       	ldd	r24, Y+1	; 0x01
     8c4:	28 2f       	mov	r18, r24
     8c6:	30 e0       	ldi	r19, 0x00	; 0
     8c8:	81 e0       	ldi	r24, 0x01	; 1
     8ca:	90 e0       	ldi	r25, 0x00	; 0
     8cc:	02 2e       	mov	r0, r18
     8ce:	02 c0       	rjmp	.+4      	; 0x8d4 <DIO_WritePin+0x3a>
     8d0:	88 0f       	add	r24, r24
     8d2:	99 1f       	adc	r25, r25
     8d4:	0a 94       	dec	r0
     8d6:	e2 f7       	brpl	.-8      	; 0x8d0 <DIO_WritePin+0x36>
     8d8:	84 2b       	or	r24, r20
     8da:	8c 93       	st	X, r24
     8dc:	c8 c0       	rjmp	.+400    	; 0xa6e <DIO_WritePin+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     8de:	89 81       	ldd	r24, Y+1	; 0x01
     8e0:	88 30       	cpi	r24, 0x08	; 8
     8e2:	c8 f0       	brcs	.+50     	; 0x916 <DIO_WritePin+0x7c>
     8e4:	89 81       	ldd	r24, Y+1	; 0x01
     8e6:	80 31       	cpi	r24, 0x10	; 16
     8e8:	b0 f4       	brcc	.+44     	; 0x916 <DIO_WritePin+0x7c>
		{
			SET_BIT(DIO_PORTB,(PinNum-DIO_PIN8));
     8ea:	a8 e3       	ldi	r26, 0x38	; 56
     8ec:	b0 e0       	ldi	r27, 0x00	; 0
     8ee:	e8 e3       	ldi	r30, 0x38	; 56
     8f0:	f0 e0       	ldi	r31, 0x00	; 0
     8f2:	80 81       	ld	r24, Z
     8f4:	48 2f       	mov	r20, r24
     8f6:	89 81       	ldd	r24, Y+1	; 0x01
     8f8:	88 2f       	mov	r24, r24
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	08 97       	sbiw	r24, 0x08	; 8
     8fe:	9c 01       	movw	r18, r24
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	90 e0       	ldi	r25, 0x00	; 0
     904:	02 2e       	mov	r0, r18
     906:	02 c0       	rjmp	.+4      	; 0x90c <DIO_WritePin+0x72>
     908:	88 0f       	add	r24, r24
     90a:	99 1f       	adc	r25, r25
     90c:	0a 94       	dec	r0
     90e:	e2 f7       	brpl	.-8      	; 0x908 <DIO_WritePin+0x6e>
     910:	84 2b       	or	r24, r20
     912:	8c 93       	st	X, r24
     914:	ac c0       	rjmp	.+344    	; 0xa6e <DIO_WritePin+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     916:	89 81       	ldd	r24, Y+1	; 0x01
     918:	80 31       	cpi	r24, 0x10	; 16
     91a:	c8 f0       	brcs	.+50     	; 0x94e <DIO_WritePin+0xb4>
     91c:	89 81       	ldd	r24, Y+1	; 0x01
     91e:	88 31       	cpi	r24, 0x18	; 24
     920:	b0 f4       	brcc	.+44     	; 0x94e <DIO_WritePin+0xb4>
		{
			SET_BIT(DIO_PORTC,(PinNum-DIO_PIN16));
     922:	a5 e3       	ldi	r26, 0x35	; 53
     924:	b0 e0       	ldi	r27, 0x00	; 0
     926:	e5 e3       	ldi	r30, 0x35	; 53
     928:	f0 e0       	ldi	r31, 0x00	; 0
     92a:	80 81       	ld	r24, Z
     92c:	48 2f       	mov	r20, r24
     92e:	89 81       	ldd	r24, Y+1	; 0x01
     930:	88 2f       	mov	r24, r24
     932:	90 e0       	ldi	r25, 0x00	; 0
     934:	40 97       	sbiw	r24, 0x10	; 16
     936:	9c 01       	movw	r18, r24
     938:	81 e0       	ldi	r24, 0x01	; 1
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	02 2e       	mov	r0, r18
     93e:	02 c0       	rjmp	.+4      	; 0x944 <DIO_WritePin+0xaa>
     940:	88 0f       	add	r24, r24
     942:	99 1f       	adc	r25, r25
     944:	0a 94       	dec	r0
     946:	e2 f7       	brpl	.-8      	; 0x940 <DIO_WritePin+0xa6>
     948:	84 2b       	or	r24, r20
     94a:	8c 93       	st	X, r24
     94c:	90 c0       	rjmp	.+288    	; 0xa6e <DIO_WritePin+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     94e:	89 81       	ldd	r24, Y+1	; 0x01
     950:	88 31       	cpi	r24, 0x18	; 24
     952:	08 f4       	brcc	.+2      	; 0x956 <DIO_WritePin+0xbc>
     954:	8c c0       	rjmp	.+280    	; 0xa6e <DIO_WritePin+0x1d4>
     956:	89 81       	ldd	r24, Y+1	; 0x01
     958:	80 32       	cpi	r24, 0x20	; 32
     95a:	08 f0       	brcs	.+2      	; 0x95e <DIO_WritePin+0xc4>
     95c:	88 c0       	rjmp	.+272    	; 0xa6e <DIO_WritePin+0x1d4>
		{
			SET_BIT(DIO_PORTD,(PinNum-DIO_PIN24));
     95e:	a2 e3       	ldi	r26, 0x32	; 50
     960:	b0 e0       	ldi	r27, 0x00	; 0
     962:	e2 e3       	ldi	r30, 0x32	; 50
     964:	f0 e0       	ldi	r31, 0x00	; 0
     966:	80 81       	ld	r24, Z
     968:	48 2f       	mov	r20, r24
     96a:	89 81       	ldd	r24, Y+1	; 0x01
     96c:	88 2f       	mov	r24, r24
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	48 97       	sbiw	r24, 0x18	; 24
     972:	9c 01       	movw	r18, r24
     974:	81 e0       	ldi	r24, 0x01	; 1
     976:	90 e0       	ldi	r25, 0x00	; 0
     978:	02 2e       	mov	r0, r18
     97a:	02 c0       	rjmp	.+4      	; 0x980 <DIO_WritePin+0xe6>
     97c:	88 0f       	add	r24, r24
     97e:	99 1f       	adc	r25, r25
     980:	0a 94       	dec	r0
     982:	e2 f7       	brpl	.-8      	; 0x97c <DIO_WritePin+0xe2>
     984:	84 2b       	or	r24, r20
     986:	8c 93       	st	X, r24
     988:	72 c0       	rjmp	.+228    	; 0xa6e <DIO_WritePin+0x1d4>
		}
	}
	else if(PinValue==DIO_PIN0)
     98a:	8a 81       	ldd	r24, Y+2	; 0x02
     98c:	88 23       	and	r24, r24
     98e:	09 f0       	breq	.+2      	; 0x992 <DIO_WritePin+0xf8>
     990:	6e c0       	rjmp	.+220    	; 0xa6e <DIO_WritePin+0x1d4>
	{

		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     992:	89 81       	ldd	r24, Y+1	; 0x01
     994:	88 30       	cpi	r24, 0x08	; 8
     996:	a8 f4       	brcc	.+42     	; 0x9c2 <DIO_WritePin+0x128>
		{
			CLEAR_BIT(DIO_PORTA,PinNum);
     998:	ab e3       	ldi	r26, 0x3B	; 59
     99a:	b0 e0       	ldi	r27, 0x00	; 0
     99c:	eb e3       	ldi	r30, 0x3B	; 59
     99e:	f0 e0       	ldi	r31, 0x00	; 0
     9a0:	80 81       	ld	r24, Z
     9a2:	48 2f       	mov	r20, r24
     9a4:	89 81       	ldd	r24, Y+1	; 0x01
     9a6:	28 2f       	mov	r18, r24
     9a8:	30 e0       	ldi	r19, 0x00	; 0
     9aa:	81 e0       	ldi	r24, 0x01	; 1
     9ac:	90 e0       	ldi	r25, 0x00	; 0
     9ae:	02 2e       	mov	r0, r18
     9b0:	02 c0       	rjmp	.+4      	; 0x9b6 <DIO_WritePin+0x11c>
     9b2:	88 0f       	add	r24, r24
     9b4:	99 1f       	adc	r25, r25
     9b6:	0a 94       	dec	r0
     9b8:	e2 f7       	brpl	.-8      	; 0x9b2 <DIO_WritePin+0x118>
     9ba:	80 95       	com	r24
     9bc:	84 23       	and	r24, r20
     9be:	8c 93       	st	X, r24
     9c0:	56 c0       	rjmp	.+172    	; 0xa6e <DIO_WritePin+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     9c2:	89 81       	ldd	r24, Y+1	; 0x01
     9c4:	88 30       	cpi	r24, 0x08	; 8
     9c6:	d0 f0       	brcs	.+52     	; 0x9fc <DIO_WritePin+0x162>
     9c8:	89 81       	ldd	r24, Y+1	; 0x01
     9ca:	80 31       	cpi	r24, 0x10	; 16
     9cc:	b8 f4       	brcc	.+46     	; 0x9fc <DIO_WritePin+0x162>
		{
			CLEAR_BIT(DIO_PORTB,(PinNum-DIO_PIN8));
     9ce:	a8 e3       	ldi	r26, 0x38	; 56
     9d0:	b0 e0       	ldi	r27, 0x00	; 0
     9d2:	e8 e3       	ldi	r30, 0x38	; 56
     9d4:	f0 e0       	ldi	r31, 0x00	; 0
     9d6:	80 81       	ld	r24, Z
     9d8:	48 2f       	mov	r20, r24
     9da:	89 81       	ldd	r24, Y+1	; 0x01
     9dc:	88 2f       	mov	r24, r24
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	08 97       	sbiw	r24, 0x08	; 8
     9e2:	9c 01       	movw	r18, r24
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	90 e0       	ldi	r25, 0x00	; 0
     9e8:	02 2e       	mov	r0, r18
     9ea:	02 c0       	rjmp	.+4      	; 0x9f0 <DIO_WritePin+0x156>
     9ec:	88 0f       	add	r24, r24
     9ee:	99 1f       	adc	r25, r25
     9f0:	0a 94       	dec	r0
     9f2:	e2 f7       	brpl	.-8      	; 0x9ec <DIO_WritePin+0x152>
     9f4:	80 95       	com	r24
     9f6:	84 23       	and	r24, r20
     9f8:	8c 93       	st	X, r24
     9fa:	39 c0       	rjmp	.+114    	; 0xa6e <DIO_WritePin+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     9fc:	89 81       	ldd	r24, Y+1	; 0x01
     9fe:	80 31       	cpi	r24, 0x10	; 16
     a00:	d0 f0       	brcs	.+52     	; 0xa36 <DIO_WritePin+0x19c>
     a02:	89 81       	ldd	r24, Y+1	; 0x01
     a04:	88 31       	cpi	r24, 0x18	; 24
     a06:	b8 f4       	brcc	.+46     	; 0xa36 <DIO_WritePin+0x19c>
		{
			CLEAR_BIT(DIO_PORTC,(PinNum-DIO_PIN16));
     a08:	a5 e3       	ldi	r26, 0x35	; 53
     a0a:	b0 e0       	ldi	r27, 0x00	; 0
     a0c:	e5 e3       	ldi	r30, 0x35	; 53
     a0e:	f0 e0       	ldi	r31, 0x00	; 0
     a10:	80 81       	ld	r24, Z
     a12:	48 2f       	mov	r20, r24
     a14:	89 81       	ldd	r24, Y+1	; 0x01
     a16:	88 2f       	mov	r24, r24
     a18:	90 e0       	ldi	r25, 0x00	; 0
     a1a:	40 97       	sbiw	r24, 0x10	; 16
     a1c:	9c 01       	movw	r18, r24
     a1e:	81 e0       	ldi	r24, 0x01	; 1
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	02 2e       	mov	r0, r18
     a24:	02 c0       	rjmp	.+4      	; 0xa2a <DIO_WritePin+0x190>
     a26:	88 0f       	add	r24, r24
     a28:	99 1f       	adc	r25, r25
     a2a:	0a 94       	dec	r0
     a2c:	e2 f7       	brpl	.-8      	; 0xa26 <DIO_WritePin+0x18c>
     a2e:	80 95       	com	r24
     a30:	84 23       	and	r24, r20
     a32:	8c 93       	st	X, r24
     a34:	1c c0       	rjmp	.+56     	; 0xa6e <DIO_WritePin+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     a36:	89 81       	ldd	r24, Y+1	; 0x01
     a38:	88 31       	cpi	r24, 0x18	; 24
     a3a:	c8 f0       	brcs	.+50     	; 0xa6e <DIO_WritePin+0x1d4>
     a3c:	89 81       	ldd	r24, Y+1	; 0x01
     a3e:	80 32       	cpi	r24, 0x20	; 32
     a40:	b0 f4       	brcc	.+44     	; 0xa6e <DIO_WritePin+0x1d4>
		{
			CLEAR_BIT(DIO_PORTD,(PinNum-DIO_PIN24));
     a42:	a2 e3       	ldi	r26, 0x32	; 50
     a44:	b0 e0       	ldi	r27, 0x00	; 0
     a46:	e2 e3       	ldi	r30, 0x32	; 50
     a48:	f0 e0       	ldi	r31, 0x00	; 0
     a4a:	80 81       	ld	r24, Z
     a4c:	48 2f       	mov	r20, r24
     a4e:	89 81       	ldd	r24, Y+1	; 0x01
     a50:	88 2f       	mov	r24, r24
     a52:	90 e0       	ldi	r25, 0x00	; 0
     a54:	48 97       	sbiw	r24, 0x18	; 24
     a56:	9c 01       	movw	r18, r24
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	90 e0       	ldi	r25, 0x00	; 0
     a5c:	02 2e       	mov	r0, r18
     a5e:	02 c0       	rjmp	.+4      	; 0xa64 <DIO_WritePin+0x1ca>
     a60:	88 0f       	add	r24, r24
     a62:	99 1f       	adc	r25, r25
     a64:	0a 94       	dec	r0
     a66:	e2 f7       	brpl	.-8      	; 0xa60 <DIO_WritePin+0x1c6>
     a68:	80 95       	com	r24
     a6a:	84 23       	and	r24, r20
     a6c:	8c 93       	st	X, r24

		}
	}

}
     a6e:	0f 90       	pop	r0
     a70:	0f 90       	pop	r0
     a72:	cf 91       	pop	r28
     a74:	df 91       	pop	r29
     a76:	08 95       	ret

00000a78 <DIO_ReadPin>:
uint8 DIO_ReadPin(uint8 PinNum)
{
     a78:	df 93       	push	r29
     a7a:	cf 93       	push	r28
     a7c:	00 d0       	rcall	.+0      	; 0xa7e <DIO_ReadPin+0x6>
     a7e:	cd b7       	in	r28, 0x3d	; 61
     a80:	de b7       	in	r29, 0x3e	; 62
     a82:	89 83       	std	Y+1, r24	; 0x01
	if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     a84:	89 81       	ldd	r24, Y+1	; 0x01
     a86:	88 30       	cpi	r24, 0x08	; 8
     a88:	98 f4       	brcc	.+38     	; 0xab0 <DIO_ReadPin+0x38>
	{
		return GET_BIT(DIO_PINA,PinNum);
     a8a:	e9 e3       	ldi	r30, 0x39	; 57
     a8c:	f0 e0       	ldi	r31, 0x00	; 0
     a8e:	80 81       	ld	r24, Z
     a90:	28 2f       	mov	r18, r24
     a92:	30 e0       	ldi	r19, 0x00	; 0
     a94:	89 81       	ldd	r24, Y+1	; 0x01
     a96:	88 2f       	mov	r24, r24
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a9 01       	movw	r20, r18
     a9c:	02 c0       	rjmp	.+4      	; 0xaa2 <DIO_ReadPin+0x2a>
     a9e:	55 95       	asr	r21
     aa0:	47 95       	ror	r20
     aa2:	8a 95       	dec	r24
     aa4:	e2 f7       	brpl	.-8      	; 0xa9e <DIO_ReadPin+0x26>
     aa6:	ca 01       	movw	r24, r20
     aa8:	58 2f       	mov	r21, r24
     aaa:	51 70       	andi	r21, 0x01	; 1
     aac:	5a 83       	std	Y+2, r21	; 0x02
     aae:	50 c0       	rjmp	.+160    	; 0xb50 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     ab0:	89 81       	ldd	r24, Y+1	; 0x01
     ab2:	88 30       	cpi	r24, 0x08	; 8
     ab4:	b8 f0       	brcs	.+46     	; 0xae4 <DIO_ReadPin+0x6c>
     ab6:	89 81       	ldd	r24, Y+1	; 0x01
     ab8:	80 31       	cpi	r24, 0x10	; 16
     aba:	a0 f4       	brcc	.+40     	; 0xae4 <DIO_ReadPin+0x6c>
	{
		return GET_BIT(DIO_PINB,(PinNum-DIO_PIN8));
     abc:	e6 e3       	ldi	r30, 0x36	; 54
     abe:	f0 e0       	ldi	r31, 0x00	; 0
     ac0:	80 81       	ld	r24, Z
     ac2:	28 2f       	mov	r18, r24
     ac4:	30 e0       	ldi	r19, 0x00	; 0
     ac6:	89 81       	ldd	r24, Y+1	; 0x01
     ac8:	88 2f       	mov	r24, r24
     aca:	90 e0       	ldi	r25, 0x00	; 0
     acc:	08 97       	sbiw	r24, 0x08	; 8
     ace:	a9 01       	movw	r20, r18
     ad0:	02 c0       	rjmp	.+4      	; 0xad6 <DIO_ReadPin+0x5e>
     ad2:	55 95       	asr	r21
     ad4:	47 95       	ror	r20
     ad6:	8a 95       	dec	r24
     ad8:	e2 f7       	brpl	.-8      	; 0xad2 <DIO_ReadPin+0x5a>
     ada:	ca 01       	movw	r24, r20
     adc:	58 2f       	mov	r21, r24
     ade:	51 70       	andi	r21, 0x01	; 1
     ae0:	5a 83       	std	Y+2, r21	; 0x02
     ae2:	36 c0       	rjmp	.+108    	; 0xb50 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     ae4:	89 81       	ldd	r24, Y+1	; 0x01
     ae6:	80 31       	cpi	r24, 0x10	; 16
     ae8:	b8 f0       	brcs	.+46     	; 0xb18 <DIO_ReadPin+0xa0>
     aea:	89 81       	ldd	r24, Y+1	; 0x01
     aec:	88 31       	cpi	r24, 0x18	; 24
     aee:	a0 f4       	brcc	.+40     	; 0xb18 <DIO_ReadPin+0xa0>
	{
		return GET_BIT(DIO_PINC,(PinNum-DIO_PIN16));
     af0:	e3 e3       	ldi	r30, 0x33	; 51
     af2:	f0 e0       	ldi	r31, 0x00	; 0
     af4:	80 81       	ld	r24, Z
     af6:	28 2f       	mov	r18, r24
     af8:	30 e0       	ldi	r19, 0x00	; 0
     afa:	89 81       	ldd	r24, Y+1	; 0x01
     afc:	88 2f       	mov	r24, r24
     afe:	90 e0       	ldi	r25, 0x00	; 0
     b00:	40 97       	sbiw	r24, 0x10	; 16
     b02:	a9 01       	movw	r20, r18
     b04:	02 c0       	rjmp	.+4      	; 0xb0a <DIO_ReadPin+0x92>
     b06:	55 95       	asr	r21
     b08:	47 95       	ror	r20
     b0a:	8a 95       	dec	r24
     b0c:	e2 f7       	brpl	.-8      	; 0xb06 <DIO_ReadPin+0x8e>
     b0e:	ca 01       	movw	r24, r20
     b10:	58 2f       	mov	r21, r24
     b12:	51 70       	andi	r21, 0x01	; 1
     b14:	5a 83       	std	Y+2, r21	; 0x02
     b16:	1c c0       	rjmp	.+56     	; 0xb50 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     b18:	89 81       	ldd	r24, Y+1	; 0x01
     b1a:	88 31       	cpi	r24, 0x18	; 24
     b1c:	b8 f0       	brcs	.+46     	; 0xb4c <DIO_ReadPin+0xd4>
     b1e:	89 81       	ldd	r24, Y+1	; 0x01
     b20:	80 32       	cpi	r24, 0x20	; 32
     b22:	a0 f4       	brcc	.+40     	; 0xb4c <DIO_ReadPin+0xd4>
	{
		return GET_BIT(DIO_PIND,(PinNum-DIO_PIN24));
     b24:	e0 e3       	ldi	r30, 0x30	; 48
     b26:	f0 e0       	ldi	r31, 0x00	; 0
     b28:	80 81       	ld	r24, Z
     b2a:	28 2f       	mov	r18, r24
     b2c:	30 e0       	ldi	r19, 0x00	; 0
     b2e:	89 81       	ldd	r24, Y+1	; 0x01
     b30:	88 2f       	mov	r24, r24
     b32:	90 e0       	ldi	r25, 0x00	; 0
     b34:	48 97       	sbiw	r24, 0x18	; 24
     b36:	a9 01       	movw	r20, r18
     b38:	02 c0       	rjmp	.+4      	; 0xb3e <DIO_ReadPin+0xc6>
     b3a:	55 95       	asr	r21
     b3c:	47 95       	ror	r20
     b3e:	8a 95       	dec	r24
     b40:	e2 f7       	brpl	.-8      	; 0xb3a <DIO_ReadPin+0xc2>
     b42:	ca 01       	movw	r24, r20
     b44:	58 2f       	mov	r21, r24
     b46:	51 70       	andi	r21, 0x01	; 1
     b48:	5a 83       	std	Y+2, r21	; 0x02
     b4a:	02 c0       	rjmp	.+4      	; 0xb50 <DIO_ReadPin+0xd8>
	}
	return DIO_PIN8;
     b4c:	88 e0       	ldi	r24, 0x08	; 8
     b4e:	8a 83       	std	Y+2, r24	; 0x02
     b50:	8a 81       	ldd	r24, Y+2	; 0x02
}
     b52:	0f 90       	pop	r0
     b54:	0f 90       	pop	r0
     b56:	cf 91       	pop	r28
     b58:	df 91       	pop	r29
     b5a:	08 95       	ret

00000b5c <DIO_SetPinDirection>:
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection)
{
     b5c:	df 93       	push	r29
     b5e:	cf 93       	push	r28
     b60:	00 d0       	rcall	.+0      	; 0xb62 <DIO_SetPinDirection+0x6>
     b62:	cd b7       	in	r28, 0x3d	; 61
     b64:	de b7       	in	r29, 0x3e	; 62
     b66:	89 83       	std	Y+1, r24	; 0x01
     b68:	6a 83       	std	Y+2, r22	; 0x02
	if(PinDirection==INPUT)
     b6a:	8a 81       	ldd	r24, Y+2	; 0x02
     b6c:	88 23       	and	r24, r24
     b6e:	09 f0       	breq	.+2      	; 0xb72 <DIO_SetPinDirection+0x16>
     b70:	71 c0       	rjmp	.+226    	; 0xc54 <DIO_SetPinDirection+0xf8>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     b72:	89 81       	ldd	r24, Y+1	; 0x01
     b74:	88 30       	cpi	r24, 0x08	; 8
     b76:	a8 f4       	brcc	.+42     	; 0xba2 <DIO_SetPinDirection+0x46>
		{
			CLEAR_BIT(DIO_DDRA,PinNum);
     b78:	aa e3       	ldi	r26, 0x3A	; 58
     b7a:	b0 e0       	ldi	r27, 0x00	; 0
     b7c:	ea e3       	ldi	r30, 0x3A	; 58
     b7e:	f0 e0       	ldi	r31, 0x00	; 0
     b80:	80 81       	ld	r24, Z
     b82:	48 2f       	mov	r20, r24
     b84:	89 81       	ldd	r24, Y+1	; 0x01
     b86:	28 2f       	mov	r18, r24
     b88:	30 e0       	ldi	r19, 0x00	; 0
     b8a:	81 e0       	ldi	r24, 0x01	; 1
     b8c:	90 e0       	ldi	r25, 0x00	; 0
     b8e:	02 2e       	mov	r0, r18
     b90:	02 c0       	rjmp	.+4      	; 0xb96 <DIO_SetPinDirection+0x3a>
     b92:	88 0f       	add	r24, r24
     b94:	99 1f       	adc	r25, r25
     b96:	0a 94       	dec	r0
     b98:	e2 f7       	brpl	.-8      	; 0xb92 <DIO_SetPinDirection+0x36>
     b9a:	80 95       	com	r24
     b9c:	84 23       	and	r24, r20
     b9e:	8c 93       	st	X, r24
     ba0:	c7 c0       	rjmp	.+398    	; 0xd30 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     ba2:	89 81       	ldd	r24, Y+1	; 0x01
     ba4:	88 30       	cpi	r24, 0x08	; 8
     ba6:	d0 f0       	brcs	.+52     	; 0xbdc <DIO_SetPinDirection+0x80>
     ba8:	89 81       	ldd	r24, Y+1	; 0x01
     baa:	80 31       	cpi	r24, 0x10	; 16
     bac:	b8 f4       	brcc	.+46     	; 0xbdc <DIO_SetPinDirection+0x80>
		{
			CLEAR_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     bae:	a7 e3       	ldi	r26, 0x37	; 55
     bb0:	b0 e0       	ldi	r27, 0x00	; 0
     bb2:	e7 e3       	ldi	r30, 0x37	; 55
     bb4:	f0 e0       	ldi	r31, 0x00	; 0
     bb6:	80 81       	ld	r24, Z
     bb8:	48 2f       	mov	r20, r24
     bba:	89 81       	ldd	r24, Y+1	; 0x01
     bbc:	88 2f       	mov	r24, r24
     bbe:	90 e0       	ldi	r25, 0x00	; 0
     bc0:	08 97       	sbiw	r24, 0x08	; 8
     bc2:	9c 01       	movw	r18, r24
     bc4:	81 e0       	ldi	r24, 0x01	; 1
     bc6:	90 e0       	ldi	r25, 0x00	; 0
     bc8:	02 2e       	mov	r0, r18
     bca:	02 c0       	rjmp	.+4      	; 0xbd0 <DIO_SetPinDirection+0x74>
     bcc:	88 0f       	add	r24, r24
     bce:	99 1f       	adc	r25, r25
     bd0:	0a 94       	dec	r0
     bd2:	e2 f7       	brpl	.-8      	; 0xbcc <DIO_SetPinDirection+0x70>
     bd4:	80 95       	com	r24
     bd6:	84 23       	and	r24, r20
     bd8:	8c 93       	st	X, r24
     bda:	aa c0       	rjmp	.+340    	; 0xd30 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     bdc:	89 81       	ldd	r24, Y+1	; 0x01
     bde:	80 31       	cpi	r24, 0x10	; 16
     be0:	d0 f0       	brcs	.+52     	; 0xc16 <DIO_SetPinDirection+0xba>
     be2:	89 81       	ldd	r24, Y+1	; 0x01
     be4:	88 31       	cpi	r24, 0x18	; 24
     be6:	b8 f4       	brcc	.+46     	; 0xc16 <DIO_SetPinDirection+0xba>
		{
			CLEAR_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     be8:	a4 e3       	ldi	r26, 0x34	; 52
     bea:	b0 e0       	ldi	r27, 0x00	; 0
     bec:	e4 e3       	ldi	r30, 0x34	; 52
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	80 81       	ld	r24, Z
     bf2:	48 2f       	mov	r20, r24
     bf4:	89 81       	ldd	r24, Y+1	; 0x01
     bf6:	88 2f       	mov	r24, r24
     bf8:	90 e0       	ldi	r25, 0x00	; 0
     bfa:	40 97       	sbiw	r24, 0x10	; 16
     bfc:	9c 01       	movw	r18, r24
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	90 e0       	ldi	r25, 0x00	; 0
     c02:	02 2e       	mov	r0, r18
     c04:	02 c0       	rjmp	.+4      	; 0xc0a <DIO_SetPinDirection+0xae>
     c06:	88 0f       	add	r24, r24
     c08:	99 1f       	adc	r25, r25
     c0a:	0a 94       	dec	r0
     c0c:	e2 f7       	brpl	.-8      	; 0xc06 <DIO_SetPinDirection+0xaa>
     c0e:	80 95       	com	r24
     c10:	84 23       	and	r24, r20
     c12:	8c 93       	st	X, r24
     c14:	8d c0       	rjmp	.+282    	; 0xd30 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     c16:	89 81       	ldd	r24, Y+1	; 0x01
     c18:	88 31       	cpi	r24, 0x18	; 24
     c1a:	08 f4       	brcc	.+2      	; 0xc1e <DIO_SetPinDirection+0xc2>
     c1c:	89 c0       	rjmp	.+274    	; 0xd30 <DIO_SetPinDirection+0x1d4>
     c1e:	89 81       	ldd	r24, Y+1	; 0x01
     c20:	80 32       	cpi	r24, 0x20	; 32
     c22:	08 f0       	brcs	.+2      	; 0xc26 <DIO_SetPinDirection+0xca>
     c24:	85 c0       	rjmp	.+266    	; 0xd30 <DIO_SetPinDirection+0x1d4>
		{
			CLEAR_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     c26:	a1 e3       	ldi	r26, 0x31	; 49
     c28:	b0 e0       	ldi	r27, 0x00	; 0
     c2a:	e1 e3       	ldi	r30, 0x31	; 49
     c2c:	f0 e0       	ldi	r31, 0x00	; 0
     c2e:	80 81       	ld	r24, Z
     c30:	48 2f       	mov	r20, r24
     c32:	89 81       	ldd	r24, Y+1	; 0x01
     c34:	88 2f       	mov	r24, r24
     c36:	90 e0       	ldi	r25, 0x00	; 0
     c38:	48 97       	sbiw	r24, 0x18	; 24
     c3a:	9c 01       	movw	r18, r24
     c3c:	81 e0       	ldi	r24, 0x01	; 1
     c3e:	90 e0       	ldi	r25, 0x00	; 0
     c40:	02 2e       	mov	r0, r18
     c42:	02 c0       	rjmp	.+4      	; 0xc48 <DIO_SetPinDirection+0xec>
     c44:	88 0f       	add	r24, r24
     c46:	99 1f       	adc	r25, r25
     c48:	0a 94       	dec	r0
     c4a:	e2 f7       	brpl	.-8      	; 0xc44 <DIO_SetPinDirection+0xe8>
     c4c:	80 95       	com	r24
     c4e:	84 23       	and	r24, r20
     c50:	8c 93       	st	X, r24
     c52:	6e c0       	rjmp	.+220    	; 0xd30 <DIO_SetPinDirection+0x1d4>
		}
	}
	else if(PinDirection==OUTPUT)
     c54:	8a 81       	ldd	r24, Y+2	; 0x02
     c56:	81 30       	cpi	r24, 0x01	; 1
     c58:	09 f0       	breq	.+2      	; 0xc5c <DIO_SetPinDirection+0x100>
     c5a:	6a c0       	rjmp	.+212    	; 0xd30 <DIO_SetPinDirection+0x1d4>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     c5c:	89 81       	ldd	r24, Y+1	; 0x01
     c5e:	88 30       	cpi	r24, 0x08	; 8
     c60:	a0 f4       	brcc	.+40     	; 0xc8a <DIO_SetPinDirection+0x12e>
		{
			SET_BIT(DIO_DDRA,PinNum);
     c62:	aa e3       	ldi	r26, 0x3A	; 58
     c64:	b0 e0       	ldi	r27, 0x00	; 0
     c66:	ea e3       	ldi	r30, 0x3A	; 58
     c68:	f0 e0       	ldi	r31, 0x00	; 0
     c6a:	80 81       	ld	r24, Z
     c6c:	48 2f       	mov	r20, r24
     c6e:	89 81       	ldd	r24, Y+1	; 0x01
     c70:	28 2f       	mov	r18, r24
     c72:	30 e0       	ldi	r19, 0x00	; 0
     c74:	81 e0       	ldi	r24, 0x01	; 1
     c76:	90 e0       	ldi	r25, 0x00	; 0
     c78:	02 2e       	mov	r0, r18
     c7a:	02 c0       	rjmp	.+4      	; 0xc80 <DIO_SetPinDirection+0x124>
     c7c:	88 0f       	add	r24, r24
     c7e:	99 1f       	adc	r25, r25
     c80:	0a 94       	dec	r0
     c82:	e2 f7       	brpl	.-8      	; 0xc7c <DIO_SetPinDirection+0x120>
     c84:	84 2b       	or	r24, r20
     c86:	8c 93       	st	X, r24
     c88:	53 c0       	rjmp	.+166    	; 0xd30 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     c8a:	89 81       	ldd	r24, Y+1	; 0x01
     c8c:	88 30       	cpi	r24, 0x08	; 8
     c8e:	c8 f0       	brcs	.+50     	; 0xcc2 <DIO_SetPinDirection+0x166>
     c90:	89 81       	ldd	r24, Y+1	; 0x01
     c92:	80 31       	cpi	r24, 0x10	; 16
     c94:	b0 f4       	brcc	.+44     	; 0xcc2 <DIO_SetPinDirection+0x166>
		{
			SET_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     c96:	a7 e3       	ldi	r26, 0x37	; 55
     c98:	b0 e0       	ldi	r27, 0x00	; 0
     c9a:	e7 e3       	ldi	r30, 0x37	; 55
     c9c:	f0 e0       	ldi	r31, 0x00	; 0
     c9e:	80 81       	ld	r24, Z
     ca0:	48 2f       	mov	r20, r24
     ca2:	89 81       	ldd	r24, Y+1	; 0x01
     ca4:	88 2f       	mov	r24, r24
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	08 97       	sbiw	r24, 0x08	; 8
     caa:	9c 01       	movw	r18, r24
     cac:	81 e0       	ldi	r24, 0x01	; 1
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	02 2e       	mov	r0, r18
     cb2:	02 c0       	rjmp	.+4      	; 0xcb8 <DIO_SetPinDirection+0x15c>
     cb4:	88 0f       	add	r24, r24
     cb6:	99 1f       	adc	r25, r25
     cb8:	0a 94       	dec	r0
     cba:	e2 f7       	brpl	.-8      	; 0xcb4 <DIO_SetPinDirection+0x158>
     cbc:	84 2b       	or	r24, r20
     cbe:	8c 93       	st	X, r24
     cc0:	37 c0       	rjmp	.+110    	; 0xd30 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     cc2:	89 81       	ldd	r24, Y+1	; 0x01
     cc4:	80 31       	cpi	r24, 0x10	; 16
     cc6:	c8 f0       	brcs	.+50     	; 0xcfa <DIO_SetPinDirection+0x19e>
     cc8:	89 81       	ldd	r24, Y+1	; 0x01
     cca:	88 31       	cpi	r24, 0x18	; 24
     ccc:	b0 f4       	brcc	.+44     	; 0xcfa <DIO_SetPinDirection+0x19e>
		{
			SET_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     cce:	a4 e3       	ldi	r26, 0x34	; 52
     cd0:	b0 e0       	ldi	r27, 0x00	; 0
     cd2:	e4 e3       	ldi	r30, 0x34	; 52
     cd4:	f0 e0       	ldi	r31, 0x00	; 0
     cd6:	80 81       	ld	r24, Z
     cd8:	48 2f       	mov	r20, r24
     cda:	89 81       	ldd	r24, Y+1	; 0x01
     cdc:	88 2f       	mov	r24, r24
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	40 97       	sbiw	r24, 0x10	; 16
     ce2:	9c 01       	movw	r18, r24
     ce4:	81 e0       	ldi	r24, 0x01	; 1
     ce6:	90 e0       	ldi	r25, 0x00	; 0
     ce8:	02 2e       	mov	r0, r18
     cea:	02 c0       	rjmp	.+4      	; 0xcf0 <DIO_SetPinDirection+0x194>
     cec:	88 0f       	add	r24, r24
     cee:	99 1f       	adc	r25, r25
     cf0:	0a 94       	dec	r0
     cf2:	e2 f7       	brpl	.-8      	; 0xcec <DIO_SetPinDirection+0x190>
     cf4:	84 2b       	or	r24, r20
     cf6:	8c 93       	st	X, r24
     cf8:	1b c0       	rjmp	.+54     	; 0xd30 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     cfa:	89 81       	ldd	r24, Y+1	; 0x01
     cfc:	88 31       	cpi	r24, 0x18	; 24
     cfe:	c0 f0       	brcs	.+48     	; 0xd30 <DIO_SetPinDirection+0x1d4>
     d00:	89 81       	ldd	r24, Y+1	; 0x01
     d02:	80 32       	cpi	r24, 0x20	; 32
     d04:	a8 f4       	brcc	.+42     	; 0xd30 <DIO_SetPinDirection+0x1d4>
		{
			SET_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     d06:	a1 e3       	ldi	r26, 0x31	; 49
     d08:	b0 e0       	ldi	r27, 0x00	; 0
     d0a:	e1 e3       	ldi	r30, 0x31	; 49
     d0c:	f0 e0       	ldi	r31, 0x00	; 0
     d0e:	80 81       	ld	r24, Z
     d10:	48 2f       	mov	r20, r24
     d12:	89 81       	ldd	r24, Y+1	; 0x01
     d14:	88 2f       	mov	r24, r24
     d16:	90 e0       	ldi	r25, 0x00	; 0
     d18:	48 97       	sbiw	r24, 0x18	; 24
     d1a:	9c 01       	movw	r18, r24
     d1c:	81 e0       	ldi	r24, 0x01	; 1
     d1e:	90 e0       	ldi	r25, 0x00	; 0
     d20:	02 2e       	mov	r0, r18
     d22:	02 c0       	rjmp	.+4      	; 0xd28 <DIO_SetPinDirection+0x1cc>
     d24:	88 0f       	add	r24, r24
     d26:	99 1f       	adc	r25, r25
     d28:	0a 94       	dec	r0
     d2a:	e2 f7       	brpl	.-8      	; 0xd24 <DIO_SetPinDirection+0x1c8>
     d2c:	84 2b       	or	r24, r20
     d2e:	8c 93       	st	X, r24
		}
	}


}
     d30:	0f 90       	pop	r0
     d32:	0f 90       	pop	r0
     d34:	cf 91       	pop	r28
     d36:	df 91       	pop	r29
     d38:	08 95       	ret

00000d3a <PushButton_Init>:
 * Outputs:         NULL
 *
 * Return:          NULL
 *******************************************************************************/
void PushButton_Init(void)
{
     d3a:	df 93       	push	r29
     d3c:	cf 93       	push	r28
     d3e:	cd b7       	in	r28, 0x3d	; 61
     d40:	de b7       	in	r29, 0x3e	; 62
    /*set Pins Of Push Button*/
    DIO_SetPinDirection(DIO_PIN10 , INPUT);
     d42:	8a e0       	ldi	r24, 0x0A	; 10
     d44:	60 e0       	ldi	r22, 0x00	; 0
     d46:	0e 94 ae 05 	call	0xb5c	; 0xb5c <DIO_SetPinDirection>
    DIO_SetPinDirection(DIO_PIN20 , INPUT);
     d4a:	84 e1       	ldi	r24, 0x14	; 20
     d4c:	60 e0       	ldi	r22, 0x00	; 0
     d4e:	0e 94 ae 05 	call	0xb5c	; 0xb5c <DIO_SetPinDirection>


}
     d52:	cf 91       	pop	r28
     d54:	df 91       	pop	r29
     d56:	08 95       	ret

00000d58 <Buttons_getPressedButton>:
 * Outputs:         NULL
 *
 * Return:          pressed Push Button (uint8_t)
 *******************************************************************************/
uint8 Buttons_getPressedButton(void)
{
     d58:	df 93       	push	r29
     d5a:	cf 93       	push	r28
     d5c:	0f 92       	push	r0
     d5e:	cd b7       	in	r28, 0x3d	; 61
     d60:	de b7       	in	r29, 0x3e	; 62
    /*return value*/
    uint8 ReturnVal=10;
     d62:	8a e0       	ldi	r24, 0x0A	; 10
     d64:	89 83       	std	Y+1, r24	; 0x01


    /*Loop to check if button is pressed to return its value*/

    if(DIO_ReadPin(DIO_PIN10) == 1)
     d66:	8a e0       	ldi	r24, 0x0A	; 10
     d68:	0e 94 3c 05 	call	0xa78	; 0xa78 <DIO_ReadPin>
     d6c:	81 30       	cpi	r24, 0x01	; 1
     d6e:	19 f4       	brne	.+6      	; 0xd76 <Buttons_getPressedButton+0x1e>
    {
        ReturnVal = 2;
     d70:	82 e0       	ldi	r24, 0x02	; 2
     d72:	89 83       	std	Y+1, r24	; 0x01
     d74:	07 c0       	rjmp	.+14     	; 0xd84 <Buttons_getPressedButton+0x2c>
    }
    else if(DIO_ReadPin(DIO_PIN20) == 1)
     d76:	84 e1       	ldi	r24, 0x14	; 20
     d78:	0e 94 3c 05 	call	0xa78	; 0xa78 <DIO_ReadPin>
     d7c:	81 30       	cpi	r24, 0x01	; 1
     d7e:	11 f4       	brne	.+4      	; 0xd84 <Buttons_getPressedButton+0x2c>
    {
        ReturnVal = 1;
     d80:	81 e0       	ldi	r24, 0x01	; 1
     d82:	89 83       	std	Y+1, r24	; 0x01
    }
    else
    {
        /*Do Nothing*/
    }
    return ReturnVal;
     d84:	89 81       	ldd	r24, Y+1	; 0x01
}
     d86:	0f 90       	pop	r0
     d88:	cf 91       	pop	r28
     d8a:	df 91       	pop	r29
     d8c:	08 95       	ret

00000d8e <UART_Init>:
 *  rate,Baud rate mood,Data size,Number of stop bits,Parity Mood and_		*
 *  interrupts mood.															*
 *																			*
 *****************************************************************************/
Status_t UART_Init(void)
{
     d8e:	df 93       	push	r29
     d90:	cf 93       	push	r28
     d92:	00 d0       	rcall	.+0      	; 0xd94 <UART_Init+0x6>
     d94:	00 d0       	rcall	.+0      	; 0xd96 <UART_Init+0x8>
     d96:	0f 92       	push	r0
     d98:	cd b7       	in	r28, 0x3d	; 61
     d9a:	de b7       	in	r29, 0x3e	; 62
	Status_t ReturnValue=NOT_OK;
     d9c:	19 82       	std	Y+1, r1	; 0x01
	/*select Baud rate mood*/
	if((UART_Config.Init_DoubleSpeed)==Dou_Speed)
     d9e:	80 91 ba 00 	lds	r24, 0x00BA
     da2:	81 30       	cpi	r24, 0x01	; 1
     da4:	09 f5       	brne	.+66     	; 0xde8 <UART_Init+0x5a>
	{
		SET_BIT(USART_UCSRA,Bit_U2X);
     da6:	ab e2       	ldi	r26, 0x2B	; 43
     da8:	b0 e0       	ldi	r27, 0x00	; 0
     daa:	eb e2       	ldi	r30, 0x2B	; 43
     dac:	f0 e0       	ldi	r31, 0x00	; 0
     dae:	80 81       	ld	r24, Z
     db0:	82 60       	ori	r24, 0x02	; 2
     db2:	8c 93       	st	X, r24
		USART_BaudRateLow=UART_Config.BuadRate;
     db4:	e9 e2       	ldi	r30, 0x29	; 41
     db6:	f0 e0       	ldi	r31, 0x00	; 0
     db8:	80 91 b2 00 	lds	r24, 0x00B2
     dbc:	90 91 b3 00 	lds	r25, 0x00B3
     dc0:	80 83       	st	Z, r24
		CLEAR_BIT(USART_BaudRateHigh,SelectRegister_URSEL);
     dc2:	a0 e4       	ldi	r26, 0x40	; 64
     dc4:	b0 e0       	ldi	r27, 0x00	; 0
     dc6:	e0 e4       	ldi	r30, 0x40	; 64
     dc8:	f0 e0       	ldi	r31, 0x00	; 0
     dca:	80 81       	ld	r24, Z
     dcc:	8f 77       	andi	r24, 0x7F	; 127
     dce:	8c 93       	st	X, r24
		USART_BaudRateHigh=((UART_Config.BuadRate)>>8);
     dd0:	e0 e4       	ldi	r30, 0x40	; 64
     dd2:	f0 e0       	ldi	r31, 0x00	; 0
     dd4:	80 91 b2 00 	lds	r24, 0x00B2
     dd8:	90 91 b3 00 	lds	r25, 0x00B3
     ddc:	89 2f       	mov	r24, r25
     dde:	99 27       	eor	r25, r25
     de0:	80 83       	st	Z, r24
		ReturnValue=OK;
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	89 83       	std	Y+1, r24	; 0x01
     de6:	16 c0       	rjmp	.+44     	; 0xe14 <UART_Init+0x86>
	}
	else if((UART_Config.Init_DoubleSpeed)==NormalSpeed)
     de8:	80 91 ba 00 	lds	r24, 0x00BA
     dec:	88 23       	and	r24, r24
     dee:	89 f4       	brne	.+34     	; 0xe12 <UART_Init+0x84>
	{
		CLEAR_BIT(USART_UCSRA,Bit_U2X);
     df0:	ab e2       	ldi	r26, 0x2B	; 43
     df2:	b0 e0       	ldi	r27, 0x00	; 0
     df4:	eb e2       	ldi	r30, 0x2B	; 43
     df6:	f0 e0       	ldi	r31, 0x00	; 0
     df8:	80 81       	ld	r24, Z
     dfa:	8d 7f       	andi	r24, 0xFD	; 253
     dfc:	8c 93       	st	X, r24
		USART_BaudRateLow=UART_Config.BuadRate;
     dfe:	e9 e2       	ldi	r30, 0x29	; 41
     e00:	f0 e0       	ldi	r31, 0x00	; 0
     e02:	80 91 b2 00 	lds	r24, 0x00B2
     e06:	90 91 b3 00 	lds	r25, 0x00B3
     e0a:	80 83       	st	Z, r24
		ReturnValue=OK;
     e0c:	81 e0       	ldi	r24, 0x01	; 1
     e0e:	89 83       	std	Y+1, r24	; 0x01
     e10:	01 c0       	rjmp	.+2      	; 0xe14 <UART_Init+0x86>
	}
	else
		ReturnValue=NOT_OK;
     e12:	19 82       	std	Y+1, r1	; 0x01
	/*select parity mood*/
	switch(UART_Config.Init_Parity)
     e14:	80 91 b4 00 	lds	r24, 0x00B4
     e18:	28 2f       	mov	r18, r24
     e1a:	30 e0       	ldi	r19, 0x00	; 0
     e1c:	3d 83       	std	Y+5, r19	; 0x05
     e1e:	2c 83       	std	Y+4, r18	; 0x04
     e20:	8c 81       	ldd	r24, Y+4	; 0x04
     e22:	9d 81       	ldd	r25, Y+5	; 0x05
     e24:	81 30       	cpi	r24, 0x01	; 1
     e26:	91 05       	cpc	r25, r1
     e28:	d9 f0       	breq	.+54     	; 0xe60 <UART_Init+0xd2>
     e2a:	2c 81       	ldd	r18, Y+4	; 0x04
     e2c:	3d 81       	ldd	r19, Y+5	; 0x05
     e2e:	22 30       	cpi	r18, 0x02	; 2
     e30:	31 05       	cpc	r19, r1
     e32:	69 f0       	breq	.+26     	; 0xe4e <UART_Init+0xc0>
     e34:	8c 81       	ldd	r24, Y+4	; 0x04
     e36:	9d 81       	ldd	r25, Y+5	; 0x05
     e38:	00 97       	sbiw	r24, 0x00	; 0
     e3a:	d1 f4       	brne	.+52     	; 0xe70 <UART_Init+0xe2>
	{
	case NoParity:
		USART_UCSRC=(USART_UCSRC|0x80)&(~(1<<Bit0_UPM0))&(~(1<<Bit1_UPM1));
     e3c:	a0 e4       	ldi	r26, 0x40	; 64
     e3e:	b0 e0       	ldi	r27, 0x00	; 0
     e40:	e0 e4       	ldi	r30, 0x40	; 64
     e42:	f0 e0       	ldi	r31, 0x00	; 0
     e44:	80 81       	ld	r24, Z
     e46:	8f 74       	andi	r24, 0x4F	; 79
     e48:	80 68       	ori	r24, 0x80	; 128
     e4a:	8c 93       	st	X, r24
     e4c:	12 c0       	rjmp	.+36     	; 0xe72 <UART_Init+0xe4>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	case EvenParity:
		USART_UCSRC=(USART_UCSRC|0xA0)&(~(1<<Bit0_UPM0));
     e4e:	a0 e4       	ldi	r26, 0x40	; 64
     e50:	b0 e0       	ldi	r27, 0x00	; 0
     e52:	e0 e4       	ldi	r30, 0x40	; 64
     e54:	f0 e0       	ldi	r31, 0x00	; 0
     e56:	80 81       	ld	r24, Z
     e58:	8f 74       	andi	r24, 0x4F	; 79
     e5a:	80 6a       	ori	r24, 0xA0	; 160
     e5c:	8c 93       	st	X, r24
     e5e:	09 c0       	rjmp	.+18     	; 0xe72 <UART_Init+0xe4>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	case OddParity:
		USART_UCSRC=(USART_UCSRC|0xB0);
     e60:	a0 e4       	ldi	r26, 0x40	; 64
     e62:	b0 e0       	ldi	r27, 0x00	; 0
     e64:	e0 e4       	ldi	r30, 0x40	; 64
     e66:	f0 e0       	ldi	r31, 0x00	; 0
     e68:	80 81       	ld	r24, Z
     e6a:	80 6b       	ori	r24, 0xB0	; 176
     e6c:	8c 93       	st	X, r24
     e6e:	01 c0       	rjmp	.+2      	; 0xe72 <UART_Init+0xe4>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	default:
		ReturnValue=NOT_OK;
     e70:	19 82       	std	Y+1, r1	; 0x01
	}
	/*select number of stop bits*/
	if(UART_Config.Init_Stop==OneStopBit)
     e72:	80 91 b5 00 	lds	r24, 0x00B5
     e76:	88 23       	and	r24, r24
     e78:	49 f4       	brne	.+18     	; 0xe8c <UART_Init+0xfe>
	{
		USART_UCSRC=(USART_UCSRC|0x80)&(~(1<<StopBits_USBS));
     e7a:	a0 e4       	ldi	r26, 0x40	; 64
     e7c:	b0 e0       	ldi	r27, 0x00	; 0
     e7e:	e0 e4       	ldi	r30, 0x40	; 64
     e80:	f0 e0       	ldi	r31, 0x00	; 0
     e82:	80 81       	ld	r24, Z
     e84:	87 77       	andi	r24, 0x77	; 119
     e86:	80 68       	ori	r24, 0x80	; 128
     e88:	8c 93       	st	X, r24
     e8a:	0d c0       	rjmp	.+26     	; 0xea6 <UART_Init+0x118>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else if(UART_Config.Init_Stop==TwoStopBit)
     e8c:	80 91 b5 00 	lds	r24, 0x00B5
     e90:	81 30       	cpi	r24, 0x01	; 1
     e92:	41 f4       	brne	.+16     	; 0xea4 <UART_Init+0x116>
	{
		USART_UCSRC=(USART_UCSRC|0x88);
     e94:	a0 e4       	ldi	r26, 0x40	; 64
     e96:	b0 e0       	ldi	r27, 0x00	; 0
     e98:	e0 e4       	ldi	r30, 0x40	; 64
     e9a:	f0 e0       	ldi	r31, 0x00	; 0
     e9c:	80 81       	ld	r24, Z
     e9e:	88 68       	ori	r24, 0x88	; 136
     ea0:	8c 93       	st	X, r24
     ea2:	01 c0       	rjmp	.+2      	; 0xea6 <UART_Init+0x118>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else
		ReturnValue=NOT_OK;
     ea4:	19 82       	std	Y+1, r1	; 0x01
	/*select data size*/
	switch(UART_Config.Init_DataSize)
     ea6:	80 91 b6 00 	lds	r24, 0x00B6
     eaa:	28 2f       	mov	r18, r24
     eac:	30 e0       	ldi	r19, 0x00	; 0
     eae:	3b 83       	std	Y+3, r19	; 0x03
     eb0:	2a 83       	std	Y+2, r18	; 0x02
     eb2:	8a 81       	ldd	r24, Y+2	; 0x02
     eb4:	9b 81       	ldd	r25, Y+3	; 0x03
     eb6:	82 30       	cpi	r24, 0x02	; 2
     eb8:	91 05       	cpc	r25, r1
     eba:	d9 f1       	breq	.+118    	; 0xf32 <UART_Init+0x1a4>
     ebc:	2a 81       	ldd	r18, Y+2	; 0x02
     ebe:	3b 81       	ldd	r19, Y+3	; 0x03
     ec0:	23 30       	cpi	r18, 0x03	; 3
     ec2:	31 05       	cpc	r19, r1
     ec4:	54 f4       	brge	.+20     	; 0xeda <UART_Init+0x14c>
     ec6:	8a 81       	ldd	r24, Y+2	; 0x02
     ec8:	9b 81       	ldd	r25, Y+3	; 0x03
     eca:	00 97       	sbiw	r24, 0x00	; 0
     ecc:	91 f0       	breq	.+36     	; 0xef2 <UART_Init+0x164>
     ece:	2a 81       	ldd	r18, Y+2	; 0x02
     ed0:	3b 81       	ldd	r19, Y+3	; 0x03
     ed2:	21 30       	cpi	r18, 0x01	; 1
     ed4:	31 05       	cpc	r19, r1
     ed6:	e9 f0       	breq	.+58     	; 0xf12 <UART_Init+0x184>
     ed8:	5a c0       	rjmp	.+180    	; 0xf8e <UART_Init+0x200>
     eda:	8a 81       	ldd	r24, Y+2	; 0x02
     edc:	9b 81       	ldd	r25, Y+3	; 0x03
     ede:	83 30       	cpi	r24, 0x03	; 3
     ee0:	91 05       	cpc	r25, r1
     ee2:	b9 f1       	breq	.+110    	; 0xf52 <UART_Init+0x1c4>
     ee4:	2a 81       	ldd	r18, Y+2	; 0x02
     ee6:	3b 81       	ldd	r19, Y+3	; 0x03
     ee8:	24 30       	cpi	r18, 0x04	; 4
     eea:	31 05       	cpc	r19, r1
     eec:	09 f4       	brne	.+2      	; 0xef0 <UART_Init+0x162>
     eee:	40 c0       	rjmp	.+128    	; 0xf70 <UART_Init+0x1e2>
     ef0:	4e c0       	rjmp	.+156    	; 0xf8e <UART_Init+0x200>
	{
	case _5_bit:
		USART_UCSRC=(USART_UCSRC|0x80)&(~(1<<Bit0_UCSZ0))&(~(1<<Bit1_UCSZ1));
     ef2:	a0 e4       	ldi	r26, 0x40	; 64
     ef4:	b0 e0       	ldi	r27, 0x00	; 0
     ef6:	e0 e4       	ldi	r30, 0x40	; 64
     ef8:	f0 e0       	ldi	r31, 0x00	; 0
     efa:	80 81       	ld	r24, Z
     efc:	89 77       	andi	r24, 0x79	; 121
     efe:	80 68       	ori	r24, 0x80	; 128
     f00:	8c 93       	st	X, r24
		CLEAR_BIT(USART_UCSRB,Bit2_UCSZ2);
     f02:	aa e2       	ldi	r26, 0x2A	; 42
     f04:	b0 e0       	ldi	r27, 0x00	; 0
     f06:	ea e2       	ldi	r30, 0x2A	; 42
     f08:	f0 e0       	ldi	r31, 0x00	; 0
     f0a:	80 81       	ld	r24, Z
     f0c:	8b 7f       	andi	r24, 0xFB	; 251
     f0e:	8c 93       	st	X, r24
     f10:	3f c0       	rjmp	.+126    	; 0xf90 <UART_Init+0x202>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	case _6_bit:
		USART_UCSRC=(USART_UCSRC|0x82)&(~(1<<Bit1_UCSZ1));
     f12:	a0 e4       	ldi	r26, 0x40	; 64
     f14:	b0 e0       	ldi	r27, 0x00	; 0
     f16:	e0 e4       	ldi	r30, 0x40	; 64
     f18:	f0 e0       	ldi	r31, 0x00	; 0
     f1a:	80 81       	ld	r24, Z
     f1c:	89 77       	andi	r24, 0x79	; 121
     f1e:	82 68       	ori	r24, 0x82	; 130
     f20:	8c 93       	st	X, r24
		CLEAR_BIT(USART_UCSRB,Bit2_UCSZ2);
     f22:	aa e2       	ldi	r26, 0x2A	; 42
     f24:	b0 e0       	ldi	r27, 0x00	; 0
     f26:	ea e2       	ldi	r30, 0x2A	; 42
     f28:	f0 e0       	ldi	r31, 0x00	; 0
     f2a:	80 81       	ld	r24, Z
     f2c:	8b 7f       	andi	r24, 0xFB	; 251
     f2e:	8c 93       	st	X, r24
     f30:	2f c0       	rjmp	.+94     	; 0xf90 <UART_Init+0x202>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	case _7_bit:
		USART_UCSRC=(USART_UCSRC|0x84)&(~(1<<Bit0_UCSZ0));
     f32:	a0 e4       	ldi	r26, 0x40	; 64
     f34:	b0 e0       	ldi	r27, 0x00	; 0
     f36:	e0 e4       	ldi	r30, 0x40	; 64
     f38:	f0 e0       	ldi	r31, 0x00	; 0
     f3a:	80 81       	ld	r24, Z
     f3c:	89 77       	andi	r24, 0x79	; 121
     f3e:	84 68       	ori	r24, 0x84	; 132
     f40:	8c 93       	st	X, r24
		CLEAR_BIT(USART_UCSRB,Bit2_UCSZ2);
     f42:	aa e2       	ldi	r26, 0x2A	; 42
     f44:	b0 e0       	ldi	r27, 0x00	; 0
     f46:	ea e2       	ldi	r30, 0x2A	; 42
     f48:	f0 e0       	ldi	r31, 0x00	; 0
     f4a:	80 81       	ld	r24, Z
     f4c:	8b 7f       	andi	r24, 0xFB	; 251
     f4e:	8c 93       	st	X, r24
     f50:	1f c0       	rjmp	.+62     	; 0xf90 <UART_Init+0x202>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	case _8_bit:
		USART_UCSRC=(USART_UCSRC|0x86);
     f52:	a0 e4       	ldi	r26, 0x40	; 64
     f54:	b0 e0       	ldi	r27, 0x00	; 0
     f56:	e0 e4       	ldi	r30, 0x40	; 64
     f58:	f0 e0       	ldi	r31, 0x00	; 0
     f5a:	80 81       	ld	r24, Z
     f5c:	86 68       	ori	r24, 0x86	; 134
     f5e:	8c 93       	st	X, r24
		CLEAR_BIT(USART_UCSRB,Bit2_UCSZ2);
     f60:	aa e2       	ldi	r26, 0x2A	; 42
     f62:	b0 e0       	ldi	r27, 0x00	; 0
     f64:	ea e2       	ldi	r30, 0x2A	; 42
     f66:	f0 e0       	ldi	r31, 0x00	; 0
     f68:	80 81       	ld	r24, Z
     f6a:	8b 7f       	andi	r24, 0xFB	; 251
     f6c:	8c 93       	st	X, r24
     f6e:	10 c0       	rjmp	.+32     	; 0xf90 <UART_Init+0x202>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	case _9_bit:
		USART_UCSRC=(USART_UCSRC|0x86);
     f70:	a0 e4       	ldi	r26, 0x40	; 64
     f72:	b0 e0       	ldi	r27, 0x00	; 0
     f74:	e0 e4       	ldi	r30, 0x40	; 64
     f76:	f0 e0       	ldi	r31, 0x00	; 0
     f78:	80 81       	ld	r24, Z
     f7a:	86 68       	ori	r24, 0x86	; 134
     f7c:	8c 93       	st	X, r24
		SET_BIT(USART_UCSRB,Bit2_UCSZ2);
     f7e:	aa e2       	ldi	r26, 0x2A	; 42
     f80:	b0 e0       	ldi	r27, 0x00	; 0
     f82:	ea e2       	ldi	r30, 0x2A	; 42
     f84:	f0 e0       	ldi	r31, 0x00	; 0
     f86:	80 81       	ld	r24, Z
     f88:	84 60       	ori	r24, 0x04	; 4
     f8a:	8c 93       	st	X, r24
     f8c:	01 c0       	rjmp	.+2      	; 0xf90 <UART_Init+0x202>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	default:
		ReturnValue=NOT_OK;
     f8e:	19 82       	std	Y+1, r1	; 0x01
	}
	/*enable or disable empty data register interrupt*/
	if(UART_Config.Init_Em)
     f90:	80 91 b7 00 	lds	r24, 0x00B7
     f94:	88 23       	and	r24, r24
     f96:	41 f0       	breq	.+16     	; 0xfa8 <UART_Init+0x21a>
	{
		CLEAR_BIT(USART_UCSRB,InterruptEnable_UDRIE);
     f98:	aa e2       	ldi	r26, 0x2A	; 42
     f9a:	b0 e0       	ldi	r27, 0x00	; 0
     f9c:	ea e2       	ldi	r30, 0x2A	; 42
     f9e:	f0 e0       	ldi	r31, 0x00	; 0
     fa0:	80 81       	ld	r24, Z
     fa2:	8f 7d       	andi	r24, 0xDF	; 223
     fa4:	8c 93       	st	X, r24
     fa6:	0d c0       	rjmp	.+26     	; 0xfc2 <UART_Init+0x234>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else if((UART_Config.Init_Em)==EnableEM)
     fa8:	80 91 b7 00 	lds	r24, 0x00B7
     fac:	88 23       	and	r24, r24
     fae:	41 f4       	brne	.+16     	; 0xfc0 <UART_Init+0x232>
	{
		SET_BIT(USART_UCSRB,InterruptEnable_UDRIE);
     fb0:	aa e2       	ldi	r26, 0x2A	; 42
     fb2:	b0 e0       	ldi	r27, 0x00	; 0
     fb4:	ea e2       	ldi	r30, 0x2A	; 42
     fb6:	f0 e0       	ldi	r31, 0x00	; 0
     fb8:	80 81       	ld	r24, Z
     fba:	80 62       	ori	r24, 0x20	; 32
     fbc:	8c 93       	st	X, r24
     fbe:	01 c0       	rjmp	.+2      	; 0xfc2 <UART_Init+0x234>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else
		ReturnValue=NOT_OK;
     fc0:	19 82       	std	Y+1, r1	; 0x01
	/*enable or disable transmitter interrupt*/
	if(UART_Config.Init_TX)
     fc2:	80 91 b8 00 	lds	r24, 0x00B8
     fc6:	88 23       	and	r24, r24
     fc8:	41 f0       	breq	.+16     	; 0xfda <UART_Init+0x24c>
	{
		CLEAR_BIT(USART_UCSRB,InterruptEnable_TXCIE);
     fca:	aa e2       	ldi	r26, 0x2A	; 42
     fcc:	b0 e0       	ldi	r27, 0x00	; 0
     fce:	ea e2       	ldi	r30, 0x2A	; 42
     fd0:	f0 e0       	ldi	r31, 0x00	; 0
     fd2:	80 81       	ld	r24, Z
     fd4:	8f 7b       	andi	r24, 0xBF	; 191
     fd6:	8c 93       	st	X, r24
     fd8:	0d c0       	rjmp	.+26     	; 0xff4 <UART_Init+0x266>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else if((UART_Config.Init_TX)==EnableTX)
     fda:	80 91 b8 00 	lds	r24, 0x00B8
     fde:	88 23       	and	r24, r24
     fe0:	41 f4       	brne	.+16     	; 0xff2 <UART_Init+0x264>
	{
		SET_BIT(USART_UCSRB,InterruptEnable_TXCIE);
     fe2:	aa e2       	ldi	r26, 0x2A	; 42
     fe4:	b0 e0       	ldi	r27, 0x00	; 0
     fe6:	ea e2       	ldi	r30, 0x2A	; 42
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	80 81       	ld	r24, Z
     fec:	80 64       	ori	r24, 0x40	; 64
     fee:	8c 93       	st	X, r24
     ff0:	01 c0       	rjmp	.+2      	; 0xff4 <UART_Init+0x266>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else
		ReturnValue=NOT_OK;
     ff2:	19 82       	std	Y+1, r1	; 0x01
	/*enable or disable receiver interrupt*/
	if(UART_Config.Init_RX)
     ff4:	80 91 b9 00 	lds	r24, 0x00B9
     ff8:	88 23       	and	r24, r24
     ffa:	41 f0       	breq	.+16     	; 0x100c <UART_Init+0x27e>
	{
		CLEAR_BIT(USART_UCSRB,InterruptEnable_RXCIE);
     ffc:	aa e2       	ldi	r26, 0x2A	; 42
     ffe:	b0 e0       	ldi	r27, 0x00	; 0
    1000:	ea e2       	ldi	r30, 0x2A	; 42
    1002:	f0 e0       	ldi	r31, 0x00	; 0
    1004:	80 81       	ld	r24, Z
    1006:	8f 77       	andi	r24, 0x7F	; 127
    1008:	8c 93       	st	X, r24
    100a:	0d c0       	rjmp	.+26     	; 0x1026 <UART_Init+0x298>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else if((UART_Config.Init_RX)==EnableRX)
    100c:	80 91 b9 00 	lds	r24, 0x00B9
    1010:	88 23       	and	r24, r24
    1012:	41 f4       	brne	.+16     	; 0x1024 <UART_Init+0x296>
	{
		SET_BIT(USART_UCSRB,InterruptEnable_RXCIE);
    1014:	aa e2       	ldi	r26, 0x2A	; 42
    1016:	b0 e0       	ldi	r27, 0x00	; 0
    1018:	ea e2       	ldi	r30, 0x2A	; 42
    101a:	f0 e0       	ldi	r31, 0x00	; 0
    101c:	80 81       	ld	r24, Z
    101e:	80 68       	ori	r24, 0x80	; 128
    1020:	8c 93       	st	X, r24
    1022:	01 c0       	rjmp	.+2      	; 0x1026 <UART_Init+0x298>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else
		ReturnValue=NOT_OK;
    1024:	19 82       	std	Y+1, r1	; 0x01
	SET_BIT(USART_UCSRB,Enable_RXEN);
    1026:	aa e2       	ldi	r26, 0x2A	; 42
    1028:	b0 e0       	ldi	r27, 0x00	; 0
    102a:	ea e2       	ldi	r30, 0x2A	; 42
    102c:	f0 e0       	ldi	r31, 0x00	; 0
    102e:	80 81       	ld	r24, Z
    1030:	80 61       	ori	r24, 0x10	; 16
    1032:	8c 93       	st	X, r24
	return ReturnValue;
    1034:	89 81       	ldd	r24, Y+1	; 0x01
}
    1036:	0f 90       	pop	r0
    1038:	0f 90       	pop	r0
    103a:	0f 90       	pop	r0
    103c:	0f 90       	pop	r0
    103e:	0f 90       	pop	r0
    1040:	cf 91       	pop	r28
    1042:	df 91       	pop	r29
    1044:	08 95       	ret

00001046 <UART_ReceiveChar>:
 *	                                                       				    *
 *4-this function's role is return data that is received by UART				*
 *																			*
 *****************************************************************************/
Status_t UART_ReceiveChar(uint8* a_data_ptr)
{
    1046:	df 93       	push	r29
    1048:	cf 93       	push	r28
    104a:	00 d0       	rcall	.+0      	; 0x104c <UART_ReceiveChar+0x6>
    104c:	00 d0       	rcall	.+0      	; 0x104e <UART_ReceiveChar+0x8>
    104e:	0f 92       	push	r0
    1050:	cd b7       	in	r28, 0x3d	; 61
    1052:	de b7       	in	r29, 0x3e	; 62
    1054:	9d 83       	std	Y+5, r25	; 0x05
    1056:	8c 83       	std	Y+4, r24	; 0x04
	uint16 dummy;
	Status_t ReturnValue;

	/*check if pulling is selected*/
	if(!(GET_BIT(USART_UCSRB,InterruptEnable_RXCIE)))
    1058:	ea e2       	ldi	r30, 0x2A	; 42
    105a:	f0 e0       	ldi	r31, 0x00	; 0
    105c:	80 81       	ld	r24, Z
    105e:	88 23       	and	r24, r24
    1060:	2c f0       	brlt	.+10     	; 0x106c <UART_ReceiveChar+0x26>
	{
		/*pull on receive flag*/
		while(!(GET_BIT(USART_UCSRA,Flag_RXC)));
    1062:	eb e2       	ldi	r30, 0x2B	; 43
    1064:	f0 e0       	ldi	r31, 0x00	; 0
    1066:	80 81       	ld	r24, Z
    1068:	88 23       	and	r24, r24
    106a:	dc f7       	brge	.-10     	; 0x1062 <UART_ReceiveChar+0x1c>
	}
	/*get Data from data register of UART*/
	if(USART_UCSRA&((1<<Flag_PE)|(1<<Flag_DOR)|(1<<Flag_FE)))
    106c:	eb e2       	ldi	r30, 0x2B	; 43
    106e:	f0 e0       	ldi	r31, 0x00	; 0
    1070:	80 81       	ld	r24, Z
    1072:	88 2f       	mov	r24, r24
    1074:	90 e0       	ldi	r25, 0x00	; 0
    1076:	8c 71       	andi	r24, 0x1C	; 28
    1078:	90 70       	andi	r25, 0x00	; 0
    107a:	00 97       	sbiw	r24, 0x00	; 0
    107c:	49 f0       	breq	.+18     	; 0x1090 <UART_ReceiveChar+0x4a>
	{
		dummy=USART_DataRegister;
    107e:	ec e2       	ldi	r30, 0x2C	; 44
    1080:	f0 e0       	ldi	r31, 0x00	; 0
    1082:	80 81       	ld	r24, Z
    1084:	88 2f       	mov	r24, r24
    1086:	90 e0       	ldi	r25, 0x00	; 0
    1088:	9b 83       	std	Y+3, r25	; 0x03
    108a:	8a 83       	std	Y+2, r24	; 0x02
		ReturnValue=NOT_OK;
    108c:	19 82       	std	Y+1, r1	; 0x01
    108e:	08 c0       	rjmp	.+16     	; 0x10a0 <UART_ReceiveChar+0x5a>
	}
	else
	{
		*a_data_ptr=USART_DataRegister;
    1090:	ec e2       	ldi	r30, 0x2C	; 44
    1092:	f0 e0       	ldi	r31, 0x00	; 0
    1094:	80 81       	ld	r24, Z
    1096:	ec 81       	ldd	r30, Y+4	; 0x04
    1098:	fd 81       	ldd	r31, Y+5	; 0x05
    109a:	80 83       	st	Z, r24
		ReturnValue=OK;
    109c:	81 e0       	ldi	r24, 0x01	; 1
    109e:	89 83       	std	Y+1, r24	; 0x01
	}
	return ReturnValue;
    10a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    10a2:	0f 90       	pop	r0
    10a4:	0f 90       	pop	r0
    10a6:	0f 90       	pop	r0
    10a8:	0f 90       	pop	r0
    10aa:	0f 90       	pop	r0
    10ac:	cf 91       	pop	r28
    10ae:	df 91       	pop	r29
    10b0:	08 95       	ret

000010b2 <UART_SendChar>:
 *	                                                       				    *
 *4-this function's role is send data from user by UART						*
 *																			*
 *****************************************************************************/
Status_t UART_SendChar(uint8 a_data)
{
    10b2:	df 93       	push	r29
    10b4:	cf 93       	push	r28
    10b6:	00 d0       	rcall	.+0      	; 0x10b8 <UART_SendChar+0x6>
    10b8:	cd b7       	in	r28, 0x3d	; 61
    10ba:	de b7       	in	r29, 0x3e	; 62
    10bc:	8a 83       	std	Y+2, r24	; 0x02
	Status_t ReturnValue;
	/*check if pulling is selected*/
	if(!(GET_BIT(USART_UCSRB,InterruptEnable_UDRIE)))
    10be:	ea e2       	ldi	r30, 0x2A	; 42
    10c0:	f0 e0       	ldi	r31, 0x00	; 0
    10c2:	80 81       	ld	r24, Z
    10c4:	82 95       	swap	r24
    10c6:	86 95       	lsr	r24
    10c8:	87 70       	andi	r24, 0x07	; 7
    10ca:	88 2f       	mov	r24, r24
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	81 70       	andi	r24, 0x01	; 1
    10d0:	90 70       	andi	r25, 0x00	; 0
    10d2:	00 97       	sbiw	r24, 0x00	; 0
    10d4:	61 f4       	brne	.+24     	; 0x10ee <UART_SendChar+0x3c>
		/*pull on empty Data register flag*/
		while(!(GET_BIT(USART_UCSRA,Flag_UDRE)));
    10d6:	eb e2       	ldi	r30, 0x2B	; 43
    10d8:	f0 e0       	ldi	r31, 0x00	; 0
    10da:	80 81       	ld	r24, Z
    10dc:	82 95       	swap	r24
    10de:	86 95       	lsr	r24
    10e0:	87 70       	andi	r24, 0x07	; 7
    10e2:	88 2f       	mov	r24, r24
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	81 70       	andi	r24, 0x01	; 1
    10e8:	90 70       	andi	r25, 0x00	; 0
    10ea:	00 97       	sbiw	r24, 0x00	; 0
    10ec:	a1 f3       	breq	.-24     	; 0x10d6 <UART_SendChar+0x24>
	/*put Data on data register of UART*/
	if(GET_BIT(USART_UCSRB,Enable_TXEN))
    10ee:	ea e2       	ldi	r30, 0x2A	; 42
    10f0:	f0 e0       	ldi	r31, 0x00	; 0
    10f2:	80 81       	ld	r24, Z
    10f4:	86 95       	lsr	r24
    10f6:	86 95       	lsr	r24
    10f8:	86 95       	lsr	r24
    10fa:	88 2f       	mov	r24, r24
    10fc:	90 e0       	ldi	r25, 0x00	; 0
    10fe:	81 70       	andi	r24, 0x01	; 1
    1100:	90 70       	andi	r25, 0x00	; 0
    1102:	88 23       	and	r24, r24
    1104:	39 f0       	breq	.+14     	; 0x1114 <UART_SendChar+0x62>
	{
		USART_DataRegister=a_data;
    1106:	ec e2       	ldi	r30, 0x2C	; 44
    1108:	f0 e0       	ldi	r31, 0x00	; 0
    110a:	8a 81       	ldd	r24, Y+2	; 0x02
    110c:	80 83       	st	Z, r24
		ReturnValue=OK;
    110e:	81 e0       	ldi	r24, 0x01	; 1
    1110:	89 83       	std	Y+1, r24	; 0x01
    1112:	01 c0       	rjmp	.+2      	; 0x1116 <UART_SendChar+0x64>
	}
	else
		ReturnValue=NOT_OK;
    1114:	19 82       	std	Y+1, r1	; 0x01
	return ReturnValue;
    1116:	89 81       	ldd	r24, Y+1	; 0x01
}
    1118:	0f 90       	pop	r0
    111a:	0f 90       	pop	r0
    111c:	cf 91       	pop	r28
    111e:	df 91       	pop	r29
    1120:	08 95       	ret

00001122 <UART_Receive>:
 *	                                                       				    *
 *4-this function's role is return string that is received by UART			*
 *																			*
 *****************************************************************************/
Status_t UART_Receive( uint8* const a_data_ptr)
{
    1122:	df 93       	push	r29
    1124:	cf 93       	push	r28
    1126:	00 d0       	rcall	.+0      	; 0x1128 <UART_Receive+0x6>
    1128:	00 d0       	rcall	.+0      	; 0x112a <UART_Receive+0x8>
    112a:	0f 92       	push	r0
    112c:	cd b7       	in	r28, 0x3d	; 61
    112e:	de b7       	in	r29, 0x3e	; 62
    1130:	9c 83       	std	Y+4, r25	; 0x04
    1132:	8b 83       	std	Y+3, r24	; 0x03
	Status_t ReturnValue;
	/*Loop to Receive string by UART*/
	for(uint8 Count=0;a_data_ptr[Count-1]!='\0';Count++)
    1134:	19 82       	std	Y+1, r1	; 0x01
    1136:	13 c0       	rjmp	.+38     	; 0x115e <UART_Receive+0x3c>
	{
		ReturnValue=UART_ReceiveChar(&(a_data_ptr[Count]));
    1138:	89 81       	ldd	r24, Y+1	; 0x01
    113a:	28 2f       	mov	r18, r24
    113c:	30 e0       	ldi	r19, 0x00	; 0
    113e:	8b 81       	ldd	r24, Y+3	; 0x03
    1140:	9c 81       	ldd	r25, Y+4	; 0x04
    1142:	82 0f       	add	r24, r18
    1144:	93 1f       	adc	r25, r19
    1146:	0e 94 23 08 	call	0x1046	; 0x1046 <UART_ReceiveChar>
    114a:	8a 83       	std	Y+2, r24	; 0x02
		if(!(ReturnValue))
    114c:	8a 81       	ldd	r24, Y+2	; 0x02
    114e:	88 23       	and	r24, r24
    1150:	19 f4       	brne	.+6      	; 0x1158 <UART_Receive+0x36>
			return ReturnValue;
    1152:	8a 81       	ldd	r24, Y+2	; 0x02
    1154:	8d 83       	std	Y+5, r24	; 0x05
    1156:	13 c0       	rjmp	.+38     	; 0x117e <UART_Receive+0x5c>
 *****************************************************************************/
Status_t UART_Receive( uint8* const a_data_ptr)
{
	Status_t ReturnValue;
	/*Loop to Receive string by UART*/
	for(uint8 Count=0;a_data_ptr[Count-1]!='\0';Count++)
    1158:	89 81       	ldd	r24, Y+1	; 0x01
    115a:	8f 5f       	subi	r24, 0xFF	; 255
    115c:	89 83       	std	Y+1, r24	; 0x01
    115e:	89 81       	ldd	r24, Y+1	; 0x01
    1160:	88 2f       	mov	r24, r24
    1162:	90 e0       	ldi	r25, 0x00	; 0
    1164:	9c 01       	movw	r18, r24
    1166:	21 50       	subi	r18, 0x01	; 1
    1168:	30 40       	sbci	r19, 0x00	; 0
    116a:	8b 81       	ldd	r24, Y+3	; 0x03
    116c:	9c 81       	ldd	r25, Y+4	; 0x04
    116e:	fc 01       	movw	r30, r24
    1170:	e2 0f       	add	r30, r18
    1172:	f3 1f       	adc	r31, r19
    1174:	80 81       	ld	r24, Z
    1176:	88 23       	and	r24, r24
    1178:	f9 f6       	brne	.-66     	; 0x1138 <UART_Receive+0x16>
	{
		ReturnValue=UART_ReceiveChar(&(a_data_ptr[Count]));
		if(!(ReturnValue))
			return ReturnValue;
	}
	return ReturnValue;
    117a:	8a 81       	ldd	r24, Y+2	; 0x02
    117c:	8d 83       	std	Y+5, r24	; 0x05
    117e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1180:	0f 90       	pop	r0
    1182:	0f 90       	pop	r0
    1184:	0f 90       	pop	r0
    1186:	0f 90       	pop	r0
    1188:	0f 90       	pop	r0
    118a:	cf 91       	pop	r28
    118c:	df 91       	pop	r29
    118e:	08 95       	ret

00001190 <UART_Send>:
 *	                                                       				    *
 *4-this function's role is send string from user by UART					*
 *																			*
 *****************************************************************************/
Status_t UART_Send(uint8* a_data_ptr)
{
    1190:	df 93       	push	r29
    1192:	cf 93       	push	r28
    1194:	00 d0       	rcall	.+0      	; 0x1196 <UART_Send+0x6>
    1196:	00 d0       	rcall	.+0      	; 0x1198 <UART_Send+0x8>
    1198:	0f 92       	push	r0
    119a:	cd b7       	in	r28, 0x3d	; 61
    119c:	de b7       	in	r29, 0x3e	; 62
    119e:	9c 83       	std	Y+4, r25	; 0x04
    11a0:	8b 83       	std	Y+3, r24	; 0x03
	Status_t ReturnValue;
	/*Loop on string to send by UART*/
	for(uint8 Count=0;a_data_ptr[Count]!='\0';Count++)
    11a2:	19 82       	std	Y+1, r1	; 0x01
    11a4:	15 c0       	rjmp	.+42     	; 0x11d0 <UART_Send+0x40>
	{
		ReturnValue=UART_SendChar((a_data_ptr[Count]));
    11a6:	89 81       	ldd	r24, Y+1	; 0x01
    11a8:	28 2f       	mov	r18, r24
    11aa:	30 e0       	ldi	r19, 0x00	; 0
    11ac:	8b 81       	ldd	r24, Y+3	; 0x03
    11ae:	9c 81       	ldd	r25, Y+4	; 0x04
    11b0:	fc 01       	movw	r30, r24
    11b2:	e2 0f       	add	r30, r18
    11b4:	f3 1f       	adc	r31, r19
    11b6:	80 81       	ld	r24, Z
    11b8:	0e 94 59 08 	call	0x10b2	; 0x10b2 <UART_SendChar>
    11bc:	8a 83       	std	Y+2, r24	; 0x02
		if(!(ReturnValue))
    11be:	8a 81       	ldd	r24, Y+2	; 0x02
    11c0:	88 23       	and	r24, r24
    11c2:	19 f4       	brne	.+6      	; 0x11ca <UART_Send+0x3a>
			return ReturnValue;
    11c4:	8a 81       	ldd	r24, Y+2	; 0x02
    11c6:	8d 83       	std	Y+5, r24	; 0x05
    11c8:	10 c0       	rjmp	.+32     	; 0x11ea <UART_Send+0x5a>
 *****************************************************************************/
Status_t UART_Send(uint8* a_data_ptr)
{
	Status_t ReturnValue;
	/*Loop on string to send by UART*/
	for(uint8 Count=0;a_data_ptr[Count]!='\0';Count++)
    11ca:	89 81       	ldd	r24, Y+1	; 0x01
    11cc:	8f 5f       	subi	r24, 0xFF	; 255
    11ce:	89 83       	std	Y+1, r24	; 0x01
    11d0:	89 81       	ldd	r24, Y+1	; 0x01
    11d2:	28 2f       	mov	r18, r24
    11d4:	30 e0       	ldi	r19, 0x00	; 0
    11d6:	8b 81       	ldd	r24, Y+3	; 0x03
    11d8:	9c 81       	ldd	r25, Y+4	; 0x04
    11da:	fc 01       	movw	r30, r24
    11dc:	e2 0f       	add	r30, r18
    11de:	f3 1f       	adc	r31, r19
    11e0:	80 81       	ld	r24, Z
    11e2:	88 23       	and	r24, r24
    11e4:	01 f7       	brne	.-64     	; 0x11a6 <UART_Send+0x16>
	{
		ReturnValue=UART_SendChar((a_data_ptr[Count]));
		if(!(ReturnValue))
			return ReturnValue;
	}
	return ReturnValue;
    11e6:	8a 81       	ldd	r24, Y+2	; 0x02
    11e8:	8d 83       	std	Y+5, r24	; 0x05
    11ea:	8d 81       	ldd	r24, Y+5	; 0x05
}
    11ec:	0f 90       	pop	r0
    11ee:	0f 90       	pop	r0
    11f0:	0f 90       	pop	r0
    11f2:	0f 90       	pop	r0
    11f4:	0f 90       	pop	r0
    11f6:	cf 91       	pop	r28
    11f8:	df 91       	pop	r29
    11fa:	08 95       	ret

000011fc <UART_StartComm>:
 *4-this function's role is starting UART communication_		*
 *  by Set Enable Bits for receive and transmit.				*
 *																*
 * **************************************************************/
Status_t UART_StartComm(void)
{
    11fc:	df 93       	push	r29
    11fe:	cf 93       	push	r28
    1200:	0f 92       	push	r0
    1202:	cd b7       	in	r28, 0x3d	; 61
    1204:	de b7       	in	r29, 0x3e	; 62
	Status_t ReturnValue;
	SET_BIT(USART_UCSRB,Enable_TXEN);
    1206:	aa e2       	ldi	r26, 0x2A	; 42
    1208:	b0 e0       	ldi	r27, 0x00	; 0
    120a:	ea e2       	ldi	r30, 0x2A	; 42
    120c:	f0 e0       	ldi	r31, 0x00	; 0
    120e:	80 81       	ld	r24, Z
    1210:	88 60       	ori	r24, 0x08	; 8
    1212:	8c 93       	st	X, r24
	SET_BIT(USART_UCSRB,Enable_RXEN);
    1214:	aa e2       	ldi	r26, 0x2A	; 42
    1216:	b0 e0       	ldi	r27, 0x00	; 0
    1218:	ea e2       	ldi	r30, 0x2A	; 42
    121a:	f0 e0       	ldi	r31, 0x00	; 0
    121c:	80 81       	ld	r24, Z
    121e:	80 61       	ori	r24, 0x10	; 16
    1220:	8c 93       	st	X, r24
	if((GET_BIT(USART_UCSRB,Enable_TXEN)))
    1222:	ea e2       	ldi	r30, 0x2A	; 42
    1224:	f0 e0       	ldi	r31, 0x00	; 0
    1226:	80 81       	ld	r24, Z
    1228:	86 95       	lsr	r24
    122a:	86 95       	lsr	r24
    122c:	86 95       	lsr	r24
    122e:	88 2f       	mov	r24, r24
    1230:	90 e0       	ldi	r25, 0x00	; 0
    1232:	81 70       	andi	r24, 0x01	; 1
    1234:	90 70       	andi	r25, 0x00	; 0
    1236:	88 23       	and	r24, r24
    1238:	81 f0       	breq	.+32     	; 0x125a <UART_StartComm+0x5e>
	{
		if((GET_BIT(USART_UCSRB,Enable_RXEN)))
    123a:	ea e2       	ldi	r30, 0x2A	; 42
    123c:	f0 e0       	ldi	r31, 0x00	; 0
    123e:	80 81       	ld	r24, Z
    1240:	82 95       	swap	r24
    1242:	8f 70       	andi	r24, 0x0F	; 15
    1244:	88 2f       	mov	r24, r24
    1246:	90 e0       	ldi	r25, 0x00	; 0
    1248:	81 70       	andi	r24, 0x01	; 1
    124a:	90 70       	andi	r25, 0x00	; 0
    124c:	88 23       	and	r24, r24
    124e:	19 f0       	breq	.+6      	; 0x1256 <UART_StartComm+0x5a>
			ReturnValue=OK;
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	89 83       	std	Y+1, r24	; 0x01
    1254:	03 c0       	rjmp	.+6      	; 0x125c <UART_StartComm+0x60>
		else
			ReturnValue=NOT_OK;
    1256:	19 82       	std	Y+1, r1	; 0x01
    1258:	01 c0       	rjmp	.+2      	; 0x125c <UART_StartComm+0x60>
	}
	else
		ReturnValue=NOT_OK;
    125a:	19 82       	std	Y+1, r1	; 0x01
	return ReturnValue;
    125c:	89 81       	ldd	r24, Y+1	; 0x01

}
    125e:	0f 90       	pop	r0
    1260:	cf 91       	pop	r28
    1262:	df 91       	pop	r29
    1264:	08 95       	ret

00001266 <UART_StopComm>:
 *4-this function's role is stopping UART communication_		*
 *  by Clear Enable Bits for receive and transmit.				*
 *																*
 * **************************************************************/
Status_t UART_StopComm(void)
{
    1266:	df 93       	push	r29
    1268:	cf 93       	push	r28
    126a:	0f 92       	push	r0
    126c:	cd b7       	in	r28, 0x3d	; 61
    126e:	de b7       	in	r29, 0x3e	; 62
	Status_t ReturnValue;
	while((GET_BIT(USART_UCSRA,Flag_UDRE))==0);
    1270:	eb e2       	ldi	r30, 0x2B	; 43
    1272:	f0 e0       	ldi	r31, 0x00	; 0
    1274:	80 81       	ld	r24, Z
    1276:	82 95       	swap	r24
    1278:	86 95       	lsr	r24
    127a:	87 70       	andi	r24, 0x07	; 7
    127c:	88 2f       	mov	r24, r24
    127e:	90 e0       	ldi	r25, 0x00	; 0
    1280:	81 70       	andi	r24, 0x01	; 1
    1282:	90 70       	andi	r25, 0x00	; 0
    1284:	00 97       	sbiw	r24, 0x00	; 0
    1286:	a1 f3       	breq	.-24     	; 0x1270 <UART_StopComm+0xa>
	CLEAR_BIT(USART_UCSRB,Enable_TXEN);
    1288:	aa e2       	ldi	r26, 0x2A	; 42
    128a:	b0 e0       	ldi	r27, 0x00	; 0
    128c:	ea e2       	ldi	r30, 0x2A	; 42
    128e:	f0 e0       	ldi	r31, 0x00	; 0
    1290:	80 81       	ld	r24, Z
    1292:	87 7f       	andi	r24, 0xF7	; 247
    1294:	8c 93       	st	X, r24
	CLEAR_BIT(USART_UCSRB,Enable_RXEN);
    1296:	aa e2       	ldi	r26, 0x2A	; 42
    1298:	b0 e0       	ldi	r27, 0x00	; 0
    129a:	ea e2       	ldi	r30, 0x2A	; 42
    129c:	f0 e0       	ldi	r31, 0x00	; 0
    129e:	80 81       	ld	r24, Z
    12a0:	8f 7e       	andi	r24, 0xEF	; 239
    12a2:	8c 93       	st	X, r24
	CLEAR_BIT(USART_UCSRB,InterruptEnable_UDRIE);
    12a4:	aa e2       	ldi	r26, 0x2A	; 42
    12a6:	b0 e0       	ldi	r27, 0x00	; 0
    12a8:	ea e2       	ldi	r30, 0x2A	; 42
    12aa:	f0 e0       	ldi	r31, 0x00	; 0
    12ac:	80 81       	ld	r24, Z
    12ae:	8f 7d       	andi	r24, 0xDF	; 223
    12b0:	8c 93       	st	X, r24
	CLEAR_BIT(USART_UCSRB,InterruptEnable_TXCIE);
    12b2:	aa e2       	ldi	r26, 0x2A	; 42
    12b4:	b0 e0       	ldi	r27, 0x00	; 0
    12b6:	ea e2       	ldi	r30, 0x2A	; 42
    12b8:	f0 e0       	ldi	r31, 0x00	; 0
    12ba:	80 81       	ld	r24, Z
    12bc:	8f 7b       	andi	r24, 0xBF	; 191
    12be:	8c 93       	st	X, r24
	CLEAR_BIT(USART_UCSRB,InterruptEnable_RXCIE);
    12c0:	aa e2       	ldi	r26, 0x2A	; 42
    12c2:	b0 e0       	ldi	r27, 0x00	; 0
    12c4:	ea e2       	ldi	r30, 0x2A	; 42
    12c6:	f0 e0       	ldi	r31, 0x00	; 0
    12c8:	80 81       	ld	r24, Z
    12ca:	8f 77       	andi	r24, 0x7F	; 127
    12cc:	8c 93       	st	X, r24
	if(!(GET_BIT(USART_UCSRB,Enable_TXEN)))
    12ce:	ea e2       	ldi	r30, 0x2A	; 42
    12d0:	f0 e0       	ldi	r31, 0x00	; 0
    12d2:	80 81       	ld	r24, Z
    12d4:	86 95       	lsr	r24
    12d6:	86 95       	lsr	r24
    12d8:	86 95       	lsr	r24
    12da:	88 2f       	mov	r24, r24
    12dc:	90 e0       	ldi	r25, 0x00	; 0
    12de:	81 70       	andi	r24, 0x01	; 1
    12e0:	90 70       	andi	r25, 0x00	; 0
    12e2:	00 97       	sbiw	r24, 0x00	; 0
    12e4:	81 f4       	brne	.+32     	; 0x1306 <UART_StopComm+0xa0>
	{
		if(!(GET_BIT(USART_UCSRB,Enable_RXEN)))
    12e6:	ea e2       	ldi	r30, 0x2A	; 42
    12e8:	f0 e0       	ldi	r31, 0x00	; 0
    12ea:	80 81       	ld	r24, Z
    12ec:	82 95       	swap	r24
    12ee:	8f 70       	andi	r24, 0x0F	; 15
    12f0:	88 2f       	mov	r24, r24
    12f2:	90 e0       	ldi	r25, 0x00	; 0
    12f4:	81 70       	andi	r24, 0x01	; 1
    12f6:	90 70       	andi	r25, 0x00	; 0
    12f8:	00 97       	sbiw	r24, 0x00	; 0
    12fa:	19 f4       	brne	.+6      	; 0x1302 <UART_StopComm+0x9c>
			ReturnValue=OK;
    12fc:	81 e0       	ldi	r24, 0x01	; 1
    12fe:	89 83       	std	Y+1, r24	; 0x01
    1300:	03 c0       	rjmp	.+6      	; 0x1308 <UART_StopComm+0xa2>
		else
			ReturnValue=NOT_OK;
    1302:	19 82       	std	Y+1, r1	; 0x01
    1304:	01 c0       	rjmp	.+2      	; 0x1308 <UART_StopComm+0xa2>
	}
	else
		ReturnValue=NOT_OK;
    1306:	19 82       	std	Y+1, r1	; 0x01
	return ReturnValue;
    1308:	89 81       	ldd	r24, Y+1	; 0x01
}
    130a:	0f 90       	pop	r0
    130c:	cf 91       	pop	r28
    130e:	df 91       	pop	r29
    1310:	08 95       	ret

00001312 <UART_EmptyRegisterInterrupt>:
 *4-this function's role enable or disable empty register		*
 *interrupt.													*
 *																*
 * **************************************************************/
Status_t UART_EmptyRegisterInterrupt(void)
{
    1312:	df 93       	push	r29
    1314:	cf 93       	push	r28
    1316:	0f 92       	push	r0
    1318:	cd b7       	in	r28, 0x3d	; 61
    131a:	de b7       	in	r29, 0x3e	; 62
	Status_t ReturnValue=NOT_OK;
    131c:	19 82       	std	Y+1, r1	; 0x01
	/*enable or disable empty data register interrupt*/
	if(UART_Config.Init_Em)
    131e:	80 91 b7 00 	lds	r24, 0x00B7
    1322:	88 23       	and	r24, r24
    1324:	41 f0       	breq	.+16     	; 0x1336 <UART_EmptyRegisterInterrupt+0x24>
	{
		CLEAR_BIT(USART_UCSRB,InterruptEnable_UDRIE);
    1326:	aa e2       	ldi	r26, 0x2A	; 42
    1328:	b0 e0       	ldi	r27, 0x00	; 0
    132a:	ea e2       	ldi	r30, 0x2A	; 42
    132c:	f0 e0       	ldi	r31, 0x00	; 0
    132e:	80 81       	ld	r24, Z
    1330:	8f 7d       	andi	r24, 0xDF	; 223
    1332:	8c 93       	st	X, r24
    1334:	0d c0       	rjmp	.+26     	; 0x1350 <UART_EmptyRegisterInterrupt+0x3e>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else if((UART_Config.Init_Em)==EnableEM)
    1336:	80 91 b7 00 	lds	r24, 0x00B7
    133a:	88 23       	and	r24, r24
    133c:	41 f4       	brne	.+16     	; 0x134e <UART_EmptyRegisterInterrupt+0x3c>
	{
		SET_BIT(USART_UCSRB,InterruptEnable_UDRIE);
    133e:	aa e2       	ldi	r26, 0x2A	; 42
    1340:	b0 e0       	ldi	r27, 0x00	; 0
    1342:	ea e2       	ldi	r30, 0x2A	; 42
    1344:	f0 e0       	ldi	r31, 0x00	; 0
    1346:	80 81       	ld	r24, Z
    1348:	80 62       	ori	r24, 0x20	; 32
    134a:	8c 93       	st	X, r24
    134c:	01 c0       	rjmp	.+2      	; 0x1350 <UART_EmptyRegisterInterrupt+0x3e>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else
		ReturnValue=NOT_OK;
    134e:	19 82       	std	Y+1, r1	; 0x01
	return ReturnValue;
    1350:	89 81       	ldd	r24, Y+1	; 0x01
}
    1352:	0f 90       	pop	r0
    1354:	cf 91       	pop	r28
    1356:	df 91       	pop	r29
    1358:	08 95       	ret

0000135a <UART_ReceiveInterrupt>:
 *	                                                            *
 *4-this function's role enable or disable receive interrupt.	*													*
 *																*
 * **************************************************************/
Status_t UART_ReceiveInterrupt(void)
{
    135a:	df 93       	push	r29
    135c:	cf 93       	push	r28
    135e:	0f 92       	push	r0
    1360:	cd b7       	in	r28, 0x3d	; 61
    1362:	de b7       	in	r29, 0x3e	; 62
	Status_t ReturnValue=NOT_OK;
    1364:	19 82       	std	Y+1, r1	; 0x01
	/*enable or disable receiver interrupt*/
	if(UART_Config.Init_RX)
    1366:	80 91 b9 00 	lds	r24, 0x00B9
    136a:	88 23       	and	r24, r24
    136c:	41 f0       	breq	.+16     	; 0x137e <UART_ReceiveInterrupt+0x24>
	{
		CLEAR_BIT(USART_UCSRB,InterruptEnable_RXCIE);
    136e:	aa e2       	ldi	r26, 0x2A	; 42
    1370:	b0 e0       	ldi	r27, 0x00	; 0
    1372:	ea e2       	ldi	r30, 0x2A	; 42
    1374:	f0 e0       	ldi	r31, 0x00	; 0
    1376:	80 81       	ld	r24, Z
    1378:	8f 77       	andi	r24, 0x7F	; 127
    137a:	8c 93       	st	X, r24
    137c:	0d c0       	rjmp	.+26     	; 0x1398 <UART_ReceiveInterrupt+0x3e>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else if((UART_Config.Init_RX)==EnableRX)
    137e:	80 91 b9 00 	lds	r24, 0x00B9
    1382:	88 23       	and	r24, r24
    1384:	41 f4       	brne	.+16     	; 0x1396 <UART_ReceiveInterrupt+0x3c>
	{
		SET_BIT(USART_UCSRB,InterruptEnable_RXCIE);
    1386:	aa e2       	ldi	r26, 0x2A	; 42
    1388:	b0 e0       	ldi	r27, 0x00	; 0
    138a:	ea e2       	ldi	r30, 0x2A	; 42
    138c:	f0 e0       	ldi	r31, 0x00	; 0
    138e:	80 81       	ld	r24, Z
    1390:	80 68       	ori	r24, 0x80	; 128
    1392:	8c 93       	st	X, r24
    1394:	01 c0       	rjmp	.+2      	; 0x1398 <UART_ReceiveInterrupt+0x3e>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else
		ReturnValue=NOT_OK;
    1396:	19 82       	std	Y+1, r1	; 0x01
	return ReturnValue;
    1398:	89 81       	ldd	r24, Y+1	; 0x01
}
    139a:	0f 90       	pop	r0
    139c:	cf 91       	pop	r28
    139e:	df 91       	pop	r29
    13a0:	08 95       	ret

000013a2 <UART_transmitInterrupt>:
 *	                                                            *
 *4-this function's role enable or disable transmit interrupt.	*													*
 *																*
 * **************************************************************/
Status_t UART_transmitInterrupt(void)
{
    13a2:	df 93       	push	r29
    13a4:	cf 93       	push	r28
    13a6:	0f 92       	push	r0
    13a8:	cd b7       	in	r28, 0x3d	; 61
    13aa:	de b7       	in	r29, 0x3e	; 62
	Status_t ReturnValue=NOT_OK;
    13ac:	19 82       	std	Y+1, r1	; 0x01
	/*enable or disable transmitter interrupt*/
		if(UART_Config.Init_TX)
    13ae:	80 91 b8 00 	lds	r24, 0x00B8
    13b2:	88 23       	and	r24, r24
    13b4:	41 f0       	breq	.+16     	; 0x13c6 <UART_transmitInterrupt+0x24>
		{
			CLEAR_BIT(USART_UCSRB,InterruptEnable_TXCIE);
    13b6:	aa e2       	ldi	r26, 0x2A	; 42
    13b8:	b0 e0       	ldi	r27, 0x00	; 0
    13ba:	ea e2       	ldi	r30, 0x2A	; 42
    13bc:	f0 e0       	ldi	r31, 0x00	; 0
    13be:	80 81       	ld	r24, Z
    13c0:	8f 7b       	andi	r24, 0xBF	; 191
    13c2:	8c 93       	st	X, r24
    13c4:	0d c0       	rjmp	.+26     	; 0x13e0 <UART_transmitInterrupt+0x3e>
			if(ReturnValue==OK)
				ReturnValue=OK;
		}
		else if((UART_Config.Init_TX)==EnableTX)
    13c6:	80 91 b8 00 	lds	r24, 0x00B8
    13ca:	88 23       	and	r24, r24
    13cc:	41 f4       	brne	.+16     	; 0x13de <UART_transmitInterrupt+0x3c>
		{
			SET_BIT(USART_UCSRB,InterruptEnable_TXCIE);
    13ce:	aa e2       	ldi	r26, 0x2A	; 42
    13d0:	b0 e0       	ldi	r27, 0x00	; 0
    13d2:	ea e2       	ldi	r30, 0x2A	; 42
    13d4:	f0 e0       	ldi	r31, 0x00	; 0
    13d6:	80 81       	ld	r24, Z
    13d8:	80 64       	ori	r24, 0x40	; 64
    13da:	8c 93       	st	X, r24
    13dc:	01 c0       	rjmp	.+2      	; 0x13e0 <UART_transmitInterrupt+0x3e>
			if(ReturnValue==OK)
				ReturnValue=OK;
		}
		else
			ReturnValue=NOT_OK;
    13de:	19 82       	std	Y+1, r1	; 0x01
	return ReturnValue;
    13e0:	89 81       	ldd	r24, Y+1	; 0x01
}
    13e2:	0f 90       	pop	r0
    13e4:	cf 91       	pop	r28
    13e6:	df 91       	pop	r29
    13e8:	08 95       	ret

000013ea <init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void init_Task(void * a_Task_ptr)
{
    13ea:	ef 92       	push	r14
    13ec:	ff 92       	push	r15
    13ee:	0f 93       	push	r16
    13f0:	df 93       	push	r29
    13f2:	cf 93       	push	r28
    13f4:	00 d0       	rcall	.+0      	; 0x13f6 <init_Task+0xc>
    13f6:	cd b7       	in	r28, 0x3d	; 61
    13f8:	de b7       	in	r29, 0x3e	; 62
    13fa:	9a 83       	std	Y+2, r25	; 0x02
    13fc:	89 83       	std	Y+1, r24	; 0x01
	/*initialize all HW and preipherals*/
	PushButton_Init();
    13fe:	0e 94 9d 06 	call	0xd3a	; 0xd3a <PushButton_Init>
	UART_Init();
    1402:	0e 94 c7 06 	call	0xd8e	; 0xd8e <UART_Init>
	DIO_SetPinDirection(DIO_PIN1,INPUT);
    1406:	81 e0       	ldi	r24, 0x01	; 1
    1408:	60 e0       	ldi	r22, 0x00	; 0
    140a:	0e 94 ae 05 	call	0xb5c	; 0xb5c <DIO_SetPinDirection>
	ADC_Init();
    140e:	0e 94 49 00 	call	0x92	; 0x92 <ADC_Init>
	ADC_StartConversion();
    1412:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <ADC_StartConversion>
	LCD_init();
    1416:	0e 94 0a 10 	call	0x2014	; 0x2014 <LCD_init>

	/*Create Queues*/
	Queue_PushButton = xQueueCreate( 3 , sizeof(uint8) );
    141a:	83 e0       	ldi	r24, 0x03	; 3
    141c:	61 e0       	ldi	r22, 0x01	; 1
    141e:	40 e0       	ldi	r20, 0x00	; 0
    1420:	0e 94 69 16 	call	0x2cd2	; 0x2cd2 <xQueueGenericCreate>
    1424:	90 93 c3 00 	sts	0x00C3, r25
    1428:	80 93 c2 00 	sts	0x00C2, r24
	Queue_Temp_Sensor_Task = xQueueCreate( 3 , sizeof(uint32) );
    142c:	83 e0       	ldi	r24, 0x03	; 3
    142e:	64 e0       	ldi	r22, 0x04	; 4
    1430:	40 e0       	ldi	r20, 0x00	; 0
    1432:	0e 94 69 16 	call	0x2cd2	; 0x2cd2 <xQueueGenericCreate>
    1436:	90 93 c7 00 	sts	0x00C7, r25
    143a:	80 93 c6 00 	sts	0x00C6, r24
	Queue_UART_Task = xQueueCreate( 3 , sizeof(uint8) );
    143e:	83 e0       	ldi	r24, 0x03	; 3
    1440:	61 e0       	ldi	r22, 0x01	; 1
    1442:	40 e0       	ldi	r20, 0x00	; 0
    1444:	0e 94 69 16 	call	0x2cd2	; 0x2cd2 <xQueueGenericCreate>
    1448:	90 93 c5 00 	sts	0x00C5, r25
    144c:	80 93 c4 00 	sts	0x00C4, r24

	/*Create 4 Tasks*/
	/*create Push Button task to reset LCD*/
	xTaskCreate(PushButton_Task  , "PushButton_Task" , 100 ,
    1450:	8e e6       	ldi	r24, 0x6E	; 110
    1452:	9a e0       	ldi	r25, 0x0A	; 10
    1454:	20 e6       	ldi	r18, 0x60	; 96
    1456:	30 e0       	ldi	r19, 0x00	; 0
    1458:	b9 01       	movw	r22, r18
    145a:	44 e6       	ldi	r20, 0x64	; 100
    145c:	50 e0       	ldi	r21, 0x00	; 0
    145e:	20 e0       	ldi	r18, 0x00	; 0
    1460:	30 e0       	ldi	r19, 0x00	; 0
    1462:	01 e0       	ldi	r16, 0x01	; 1
    1464:	ee 24       	eor	r14, r14
    1466:	ff 24       	eor	r15, r15
    1468:	0e 94 99 24 	call	0x4932	; 0x4932 <xTaskCreate>
			NULL , (1 | portPRIVILEGE_BIT) , NULL);

	/*create UART Task to receive Data by UART*/
	xTaskCreate(UART_Task  , "UART_Task" , configMINIMAL_STACK_SIZE ,
    146c:	85 e2       	ldi	r24, 0x25	; 37
    146e:	9c e0       	ldi	r25, 0x0C	; 12
    1470:	20 e7       	ldi	r18, 0x70	; 112
    1472:	30 e0       	ldi	r19, 0x00	; 0
    1474:	b9 01       	movw	r22, r18
    1476:	46 e9       	ldi	r20, 0x96	; 150
    1478:	50 e0       	ldi	r21, 0x00	; 0
    147a:	20 e0       	ldi	r18, 0x00	; 0
    147c:	30 e0       	ldi	r19, 0x00	; 0
    147e:	03 e0       	ldi	r16, 0x03	; 3
    1480:	ee 24       	eor	r14, r14
    1482:	ff 24       	eor	r15, r15
    1484:	0e 94 99 24 	call	0x4932	; 0x4932 <xTaskCreate>
			NULL , (3 | portPRIVILEGE_BIT) , NULL);

	/*create ADC task to read temperature sensor*/
	xTaskCreate(ADC_Task  , "ADC_Task" , 100 ,
    1488:	8f ec       	ldi	r24, 0xCF	; 207
    148a:	9a e0       	ldi	r25, 0x0A	; 10
    148c:	2a e7       	ldi	r18, 0x7A	; 122
    148e:	30 e0       	ldi	r19, 0x00	; 0
    1490:	b9 01       	movw	r22, r18
    1492:	44 e6       	ldi	r20, 0x64	; 100
    1494:	50 e0       	ldi	r21, 0x00	; 0
    1496:	20 e0       	ldi	r18, 0x00	; 0
    1498:	30 e0       	ldi	r19, 0x00	; 0
    149a:	02 e0       	ldi	r16, 0x02	; 2
    149c:	ee 24       	eor	r14, r14
    149e:	ff 24       	eor	r15, r15
    14a0:	0e 94 99 24 	call	0x4932	; 0x4932 <xTaskCreate>
			NULL , (2 | portPRIVILEGE_BIT) , NULL);

	/*create LCD task to display other tasks on LCD*/
	xTaskCreate(LCD_Task  , "LCD_Task" , configMINIMAL_STACK_SIZE,
    14a4:	89 e2       	ldi	r24, 0x29	; 41
    14a6:	9b e0       	ldi	r25, 0x0B	; 11
    14a8:	23 e8       	ldi	r18, 0x83	; 131
    14aa:	30 e0       	ldi	r19, 0x00	; 0
    14ac:	b9 01       	movw	r22, r18
    14ae:	46 e9       	ldi	r20, 0x96	; 150
    14b0:	50 e0       	ldi	r21, 0x00	; 0
    14b2:	20 e0       	ldi	r18, 0x00	; 0
    14b4:	30 e0       	ldi	r19, 0x00	; 0
    14b6:	04 e0       	ldi	r16, 0x04	; 4
    14b8:	ee 24       	eor	r14, r14
    14ba:	ff 24       	eor	r15, r15
    14bc:	0e 94 99 24 	call	0x4932	; 0x4932 <xTaskCreate>
			NULL , (4 | portPRIVILEGE_BIT) , NULL);

	/*suspend this task*/
	vTaskSuspend(InitTask_Flag);
    14c0:	80 91 c0 00 	lds	r24, 0x00C0
    14c4:	90 91 c1 00 	lds	r25, 0x00C1
    14c8:	0e 94 d9 26 	call	0x4db2	; 0x4db2 <vTaskSuspend>
}
    14cc:	0f 90       	pop	r0
    14ce:	0f 90       	pop	r0
    14d0:	cf 91       	pop	r28
    14d2:	df 91       	pop	r29
    14d4:	0f 91       	pop	r16
    14d6:	ff 90       	pop	r15
    14d8:	ef 90       	pop	r14
    14da:	08 95       	ret

000014dc <PushButton_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void PushButton_Task(void * a_Task_ptr)
{
    14dc:	df 93       	push	r29
    14de:	cf 93       	push	r28
    14e0:	00 d0       	rcall	.+0      	; 0x14e2 <PushButton_Task+0x6>
    14e2:	00 d0       	rcall	.+0      	; 0x14e4 <PushButton_Task+0x8>
    14e4:	0f 92       	push	r0
    14e6:	cd b7       	in	r28, 0x3d	; 61
    14e8:	de b7       	in	r29, 0x3e	; 62
    14ea:	9d 83       	std	Y+5, r25	; 0x05
    14ec:	8c 83       	std	Y+4, r24	; 0x04
	vTaskDelay(50);
    14ee:	82 e3       	ldi	r24, 0x32	; 50
    14f0:	90 e0       	ldi	r25, 0x00	; 0
    14f2:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 1;
    14f6:	81 e0       	ldi	r24, 0x01	; 1
    14f8:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
    14fa:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
    14fc:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*Check if Button is pressed and enable de_bouncing*/
		if(Debouncing == 0 && Buttons_getPressedButton()==2)
    14fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1500:	88 23       	and	r24, r24
    1502:	79 f4       	brne	.+30     	; 0x1522 <PushButton_Task+0x46>
    1504:	0e 94 ac 06 	call	0xd58	; 0xd58 <Buttons_getPressedButton>
    1508:	82 30       	cpi	r24, 0x02	; 2
    150a:	59 f4       	brne	.+22     	; 0x1522 <PushButton_Task+0x46>
		{
			OldPressedValue =  Buttons_getPressedButton();
    150c:	0e 94 ac 06 	call	0xd58	; 0xd58 <Buttons_getPressedButton>
    1510:	89 83       	std	Y+1, r24	; 0x01
			Debouncing++;
    1512:	8a 81       	ldd	r24, Y+2	; 0x02
    1514:	8f 5f       	subi	r24, 0xFF	; 255
    1516:	8a 83       	std	Y+2, r24	; 0x02
			/*de_bouncing Delay*/
			vTaskDelay(10);
    1518:	8a e0       	ldi	r24, 0x0A	; 10
    151a:	90 e0       	ldi	r25, 0x00	; 0
    151c:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
    1520:	ee cf       	rjmp	.-36     	; 0x14fe <PushButton_Task+0x22>
		}
		else if(Debouncing == 1)
    1522:	8a 81       	ldd	r24, Y+2	; 0x02
    1524:	81 30       	cpi	r24, 0x01	; 1
    1526:	e9 f4       	brne	.+58     	; 0x1562 <PushButton_Task+0x86>
    1528:	13 c0       	rjmp	.+38     	; 0x1550 <PushButton_Task+0x74>
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
			{
				SendData = 1;
    152a:	81 e0       	ldi	r24, 0x01	; 1
    152c:	8b 83       	std	Y+3, r24	; 0x03
				/*Send push Button was pressed to Lcd by queue*/
				xQueueSend(Queue_PushButton , &SendData , 100);
    152e:	80 91 c2 00 	lds	r24, 0x00C2
    1532:	90 91 c3 00 	lds	r25, 0x00C3
    1536:	9e 01       	movw	r18, r28
    1538:	2d 5f       	subi	r18, 0xFD	; 253
    153a:	3f 4f       	sbci	r19, 0xFF	; 255
    153c:	b9 01       	movw	r22, r18
    153e:	44 e6       	ldi	r20, 0x64	; 100
    1540:	50 e0       	ldi	r21, 0x00	; 0
    1542:	20 e0       	ldi	r18, 0x00	; 0
    1544:	0e 94 f5 16 	call	0x2dea	; 0x2dea <xQueueGenericSend>
				vTaskDelay(20);
    1548:	84 e1       	ldi	r24, 0x14	; 20
    154a:	90 e0       	ldi	r25, 0x00	; 0
    154c:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
			vTaskDelay(10);
		}
		else if(Debouncing == 1)
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
    1550:	0e 94 ac 06 	call	0xd58	; 0xd58 <Buttons_getPressedButton>
    1554:	98 2f       	mov	r25, r24
    1556:	89 81       	ldd	r24, Y+1	; 0x01
    1558:	98 17       	cp	r25, r24
    155a:	39 f3       	breq	.-50     	; 0x152a <PushButton_Task+0x4e>
				SendData = 1;
				/*Send push Button was pressed to Lcd by queue*/
				xQueueSend(Queue_PushButton , &SendData , 100);
				vTaskDelay(20);
			}
			Debouncing = 2;
    155c:	82 e0       	ldi	r24, 0x02	; 2
    155e:	8a 83       	std	Y+2, r24	; 0x02
    1560:	ce cf       	rjmp	.-100    	; 0x14fe <PushButton_Task+0x22>
		}
		else if(Debouncing == 2)
    1562:	8a 81       	ldd	r24, Y+2	; 0x02
    1564:	82 30       	cpi	r24, 0x02	; 2
    1566:	39 f4       	brne	.+14     	; 0x1576 <PushButton_Task+0x9a>
		{
			SendData = 0;
    1568:	1b 82       	std	Y+3, r1	; 0x03
			/*Send push Button was released to Lcd by queue*/
			Debouncing = 0;
    156a:	1a 82       	std	Y+2, r1	; 0x02
			vTaskDelay(20);
    156c:	84 e1       	ldi	r24, 0x14	; 20
    156e:	90 e0       	ldi	r25, 0x00	; 0
    1570:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
    1574:	c4 cf       	rjmp	.-120    	; 0x14fe <PushButton_Task+0x22>
		}
		else
		{
			/*Send push Button is in Idle state to Lcd by queue*/
			SendData = 3;
    1576:	83 e0       	ldi	r24, 0x03	; 3
    1578:	8b 83       	std	Y+3, r24	; 0x03
			xQueueSend(Queue_PushButton , &SendData , 100);
    157a:	80 91 c2 00 	lds	r24, 0x00C2
    157e:	90 91 c3 00 	lds	r25, 0x00C3
    1582:	9e 01       	movw	r18, r28
    1584:	2d 5f       	subi	r18, 0xFD	; 253
    1586:	3f 4f       	sbci	r19, 0xFF	; 255
    1588:	b9 01       	movw	r22, r18
    158a:	44 e6       	ldi	r20, 0x64	; 100
    158c:	50 e0       	ldi	r21, 0x00	; 0
    158e:	20 e0       	ldi	r18, 0x00	; 0
    1590:	0e 94 f5 16 	call	0x2dea	; 0x2dea <xQueueGenericSend>
			vTaskDelay(20);
    1594:	84 e1       	ldi	r24, 0x14	; 20
    1596:	90 e0       	ldi	r25, 0x00	; 0
    1598:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
    159c:	b0 cf       	rjmp	.-160    	; 0x14fe <PushButton_Task+0x22>

0000159e <ADC_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void ADC_Task(void * a_Task_ptr)
{
    159e:	df 93       	push	r29
    15a0:	cf 93       	push	r28
    15a2:	cd b7       	in	r28, 0x3d	; 61
    15a4:	de b7       	in	r29, 0x3e	; 62
    15a6:	2a 97       	sbiw	r28, 0x0a	; 10
    15a8:	0f b6       	in	r0, 0x3f	; 63
    15aa:	f8 94       	cli
    15ac:	de bf       	out	0x3e, r29	; 62
    15ae:	0f be       	out	0x3f, r0	; 63
    15b0:	cd bf       	out	0x3d, r28	; 61
    15b2:	9a 87       	std	Y+10, r25	; 0x0a
    15b4:	89 87       	std	Y+9, r24	; 0x09
	vTaskDelay(150);
    15b6:	86 e9       	ldi	r24, 0x96	; 150
    15b8:	90 e0       	ldi	r25, 0x00	; 0
    15ba:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>

	/*temperature sensor sample value*/
	uint32 temp;

	/*compare with old value of temperature*/
	uint32 oldtemp = 0;
    15be:	19 82       	std	Y+1, r1	; 0x01
    15c0:	1a 82       	std	Y+2, r1	; 0x02
    15c2:	1b 82       	std	Y+3, r1	; 0x03
    15c4:	1c 82       	std	Y+4, r1	; 0x04
	while(1)
	{
		/*temperature sensor equation*/
		temp= (((uint32)ADC_ReadChannel()*750)/(1534))/2; /* calculate the temp from the ADC value*/
    15c6:	0e 94 12 04 	call	0x824	; 0x824 <ADC_ReadChannel>
    15ca:	cc 01       	movw	r24, r24
    15cc:	a0 e0       	ldi	r26, 0x00	; 0
    15ce:	b0 e0       	ldi	r27, 0x00	; 0
    15d0:	2e ee       	ldi	r18, 0xEE	; 238
    15d2:	32 e0       	ldi	r19, 0x02	; 2
    15d4:	40 e0       	ldi	r20, 0x00	; 0
    15d6:	50 e0       	ldi	r21, 0x00	; 0
    15d8:	bc 01       	movw	r22, r24
    15da:	cd 01       	movw	r24, r26
    15dc:	0e 94 b2 31 	call	0x6364	; 0x6364 <__mulsi3>
    15e0:	dc 01       	movw	r26, r24
    15e2:	cb 01       	movw	r24, r22
    15e4:	2c ef       	ldi	r18, 0xFC	; 252
    15e6:	3b e0       	ldi	r19, 0x0B	; 11
    15e8:	40 e0       	ldi	r20, 0x00	; 0
    15ea:	50 e0       	ldi	r21, 0x00	; 0
    15ec:	bc 01       	movw	r22, r24
    15ee:	cd 01       	movw	r24, r26
    15f0:	0e 94 dd 31 	call	0x63ba	; 0x63ba <__udivmodsi4>
    15f4:	da 01       	movw	r26, r20
    15f6:	c9 01       	movw	r24, r18
    15f8:	8d 83       	std	Y+5, r24	; 0x05
    15fa:	9e 83       	std	Y+6, r25	; 0x06
    15fc:	af 83       	std	Y+7, r26	; 0x07
    15fe:	b8 87       	std	Y+8, r27	; 0x08
		if (temp!=oldtemp)
    1600:	2d 81       	ldd	r18, Y+5	; 0x05
    1602:	3e 81       	ldd	r19, Y+6	; 0x06
    1604:	4f 81       	ldd	r20, Y+7	; 0x07
    1606:	58 85       	ldd	r21, Y+8	; 0x08
    1608:	89 81       	ldd	r24, Y+1	; 0x01
    160a:	9a 81       	ldd	r25, Y+2	; 0x02
    160c:	ab 81       	ldd	r26, Y+3	; 0x03
    160e:	bc 81       	ldd	r27, Y+4	; 0x04
    1610:	28 17       	cp	r18, r24
    1612:	39 07       	cpc	r19, r25
    1614:	4a 07       	cpc	r20, r26
    1616:	5b 07       	cpc	r21, r27
    1618:	a9 f0       	breq	.+42     	; 0x1644 <ADC_Task+0xa6>
		{
			oldtemp=temp;
    161a:	8d 81       	ldd	r24, Y+5	; 0x05
    161c:	9e 81       	ldd	r25, Y+6	; 0x06
    161e:	af 81       	ldd	r26, Y+7	; 0x07
    1620:	b8 85       	ldd	r27, Y+8	; 0x08
    1622:	89 83       	std	Y+1, r24	; 0x01
    1624:	9a 83       	std	Y+2, r25	; 0x02
    1626:	ab 83       	std	Y+3, r26	; 0x03
    1628:	bc 83       	std	Y+4, r27	; 0x04

			/*send new temperature to LCD task to display it on LCD*/
			xQueueSend(Queue_Temp_Sensor_Task , &temp , 10);
    162a:	80 91 c6 00 	lds	r24, 0x00C6
    162e:	90 91 c7 00 	lds	r25, 0x00C7
    1632:	9e 01       	movw	r18, r28
    1634:	2b 5f       	subi	r18, 0xFB	; 251
    1636:	3f 4f       	sbci	r19, 0xFF	; 255
    1638:	b9 01       	movw	r22, r18
    163a:	4a e0       	ldi	r20, 0x0A	; 10
    163c:	50 e0       	ldi	r21, 0x00	; 0
    163e:	20 e0       	ldi	r18, 0x00	; 0
    1640:	0e 94 f5 16 	call	0x2dea	; 0x2dea <xQueueGenericSend>
		}

		/*start a new sample*/
		ADC_StartConversion();
    1644:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <ADC_StartConversion>
		vTaskDelay(200);
    1648:	88 ec       	ldi	r24, 0xC8	; 200
    164a:	90 e0       	ldi	r25, 0x00	; 0
    164c:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
    1650:	ba cf       	rjmp	.-140    	; 0x15c6 <ADC_Task+0x28>

00001652 <LCD_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_Task(void * a_Task_ptr)
{
    1652:	ef 92       	push	r14
    1654:	ff 92       	push	r15
    1656:	0f 93       	push	r16
    1658:	1f 93       	push	r17
    165a:	df 93       	push	r29
    165c:	cf 93       	push	r28
    165e:	cd b7       	in	r28, 0x3d	; 61
    1660:	de b7       	in	r29, 0x3e	; 62
    1662:	a6 97       	sbiw	r28, 0x26	; 38
    1664:	0f b6       	in	r0, 0x3f	; 63
    1666:	f8 94       	cli
    1668:	de bf       	out	0x3e, r29	; 62
    166a:	0f be       	out	0x3f, r0	; 63
    166c:	cd bf       	out	0x3d, r28	; 61
    166e:	9c 8f       	std	Y+28, r25	; 0x1c
    1670:	8b 8f       	std	Y+27, r24	; 0x1b
	vTaskDelay(100);
    1672:	84 e6       	ldi	r24, 0x64	; 100
    1674:	90 e0       	ldi	r25, 0x00	; 0
    1676:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	/*received data from Push Button Task to display button state on LCD*/
	uint8 PushButton_Task_Data = 0;
    167a:	1c 82       	std	Y+4, r1	; 0x04

	/*received message from ADC Task to display button state on LCD*/
	uint32 Temp_Task_Data = 0;
    167c:	1d 82       	std	Y+5, r1	; 0x05
    167e:	1e 82       	std	Y+6, r1	; 0x06
    1680:	1f 82       	std	Y+7, r1	; 0x07
    1682:	18 86       	std	Y+8, r1	; 0x08

	/*received message from UART Task to display button state on LCD*/
	uint8 UART_Task_Data = 0;
    1684:	19 86       	std	Y+9, r1	; 0x09

	/*dummy & TenPowerDigit & DigitCounter buffers to convert integer number to string*/
	uint8 DigitCounter = 0;
    1686:	1b 82       	std	Y+3, r1	; 0x03
	uint8 dummy = 0;
    1688:	1a 82       	std	Y+2, r1	; 0x02
	uint8 TenPowerDigit = 1;
    168a:	81 e0       	ldi	r24, 0x01	; 1
    168c:	89 83       	std	Y+1, r24	; 0x01

	/*LCD strings*/
	uint8 Temperature_String[] = "Temp=";
    168e:	ce 01       	movw	r24, r28
    1690:	0a 96       	adiw	r24, 0x0a	; 10
    1692:	9e 8f       	std	Y+30, r25	; 0x1e
    1694:	8d 8f       	std	Y+29, r24	; 0x1d
    1696:	ec e8       	ldi	r30, 0x8C	; 140
    1698:	f0 e0       	ldi	r31, 0x00	; 0
    169a:	f8 a3       	std	Y+32, r31	; 0x20
    169c:	ef 8f       	std	Y+31, r30	; 0x1f
    169e:	f6 e0       	ldi	r31, 0x06	; 6
    16a0:	f9 a3       	std	Y+33, r31	; 0x21
    16a2:	ef 8d       	ldd	r30, Y+31	; 0x1f
    16a4:	f8 a1       	ldd	r31, Y+32	; 0x20
    16a6:	00 80       	ld	r0, Z
    16a8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    16aa:	98 a1       	ldd	r25, Y+32	; 0x20
    16ac:	01 96       	adiw	r24, 0x01	; 1
    16ae:	98 a3       	std	Y+32, r25	; 0x20
    16b0:	8f 8f       	std	Y+31, r24	; 0x1f
    16b2:	ed 8d       	ldd	r30, Y+29	; 0x1d
    16b4:	fe 8d       	ldd	r31, Y+30	; 0x1e
    16b6:	00 82       	st	Z, r0
    16b8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    16ba:	9e 8d       	ldd	r25, Y+30	; 0x1e
    16bc:	01 96       	adiw	r24, 0x01	; 1
    16be:	9e 8f       	std	Y+30, r25	; 0x1e
    16c0:	8d 8f       	std	Y+29, r24	; 0x1d
    16c2:	99 a1       	ldd	r25, Y+33	; 0x21
    16c4:	91 50       	subi	r25, 0x01	; 1
    16c6:	99 a3       	std	Y+33, r25	; 0x21
    16c8:	e9 a1       	ldd	r30, Y+33	; 0x21
    16ca:	ee 23       	and	r30, r30
    16cc:	51 f7       	brne	.-44     	; 0x16a2 <LCD_Task+0x50>
	uint8 UART_String[] = "UART DATA=";
    16ce:	ce 01       	movw	r24, r28
    16d0:	40 96       	adiw	r24, 0x10	; 16
    16d2:	9b a3       	std	Y+35, r25	; 0x23
    16d4:	8a a3       	std	Y+34, r24	; 0x22
    16d6:	e2 e9       	ldi	r30, 0x92	; 146
    16d8:	f0 e0       	ldi	r31, 0x00	; 0
    16da:	fd a3       	std	Y+37, r31	; 0x25
    16dc:	ec a3       	std	Y+36, r30	; 0x24
    16de:	fb e0       	ldi	r31, 0x0B	; 11
    16e0:	fe a3       	std	Y+38, r31	; 0x26
    16e2:	ec a1       	ldd	r30, Y+36	; 0x24
    16e4:	fd a1       	ldd	r31, Y+37	; 0x25
    16e6:	00 80       	ld	r0, Z
    16e8:	8c a1       	ldd	r24, Y+36	; 0x24
    16ea:	9d a1       	ldd	r25, Y+37	; 0x25
    16ec:	01 96       	adiw	r24, 0x01	; 1
    16ee:	9d a3       	std	Y+37, r25	; 0x25
    16f0:	8c a3       	std	Y+36, r24	; 0x24
    16f2:	ea a1       	ldd	r30, Y+34	; 0x22
    16f4:	fb a1       	ldd	r31, Y+35	; 0x23
    16f6:	00 82       	st	Z, r0
    16f8:	8a a1       	ldd	r24, Y+34	; 0x22
    16fa:	9b a1       	ldd	r25, Y+35	; 0x23
    16fc:	01 96       	adiw	r24, 0x01	; 1
    16fe:	9b a3       	std	Y+35, r25	; 0x23
    1700:	8a a3       	std	Y+34, r24	; 0x22
    1702:	9e a1       	ldd	r25, Y+38	; 0x26
    1704:	91 50       	subi	r25, 0x01	; 1
    1706:	9e a3       	std	Y+38, r25	; 0x26
    1708:	ee a1       	ldd	r30, Y+38	; 0x26
    170a:	ee 23       	and	r30, r30
    170c:	51 f7       	brne	.-44     	; 0x16e2 <LCD_Task+0x90>
	while(1)
	{
		/*receive messages from other tasks by queues*/
		xQueueReceive(Queue_PushButton , &PushButton_Task_Data , 10);
    170e:	80 91 c2 00 	lds	r24, 0x00C2
    1712:	90 91 c3 00 	lds	r25, 0x00C3
    1716:	9e 01       	movw	r18, r28
    1718:	2c 5f       	subi	r18, 0xFC	; 252
    171a:	3f 4f       	sbci	r19, 0xFF	; 255
    171c:	b9 01       	movw	r22, r18
    171e:	4a e0       	ldi	r20, 0x0A	; 10
    1720:	50 e0       	ldi	r21, 0x00	; 0
    1722:	0e 94 4a 18 	call	0x3094	; 0x3094 <xQueueReceive>
		xQueueReceive(Queue_Temp_Sensor_Task , &Temp_Task_Data , 10);
    1726:	80 91 c6 00 	lds	r24, 0x00C6
    172a:	90 91 c7 00 	lds	r25, 0x00C7
    172e:	9e 01       	movw	r18, r28
    1730:	2b 5f       	subi	r18, 0xFB	; 251
    1732:	3f 4f       	sbci	r19, 0xFF	; 255
    1734:	b9 01       	movw	r22, r18
    1736:	4a e0       	ldi	r20, 0x0A	; 10
    1738:	50 e0       	ldi	r21, 0x00	; 0
    173a:	0e 94 4a 18 	call	0x3094	; 0x3094 <xQueueReceive>
		xQueueReceive(Queue_UART_Task , &UART_Task_Data , 10);
    173e:	80 91 c4 00 	lds	r24, 0x00C4
    1742:	90 91 c5 00 	lds	r25, 0x00C5
    1746:	9e 01       	movw	r18, r28
    1748:	27 5f       	subi	r18, 0xF7	; 247
    174a:	3f 4f       	sbci	r19, 0xFF	; 255
    174c:	b9 01       	movw	r22, r18
    174e:	4a e0       	ldi	r20, 0x0A	; 10
    1750:	50 e0       	ldi	r21, 0x00	; 0
    1752:	0e 94 4a 18 	call	0x3094	; 0x3094 <xQueueReceive>

		dummy = Temp_Task_Data;
    1756:	8d 81       	ldd	r24, Y+5	; 0x05
    1758:	9e 81       	ldd	r25, Y+6	; 0x06
    175a:	af 81       	ldd	r26, Y+7	; 0x07
    175c:	b8 85       	ldd	r27, Y+8	; 0x08
    175e:	8a 83       	std	Y+2, r24	; 0x02
		TenPowerDigit = 1;
    1760:	81 e0       	ldi	r24, 0x01	; 1
    1762:	89 83       	std	Y+1, r24	; 0x01

		/*Clear LCD if Push button is pressed*/
		if(PushButton_Task_Data == 1)
    1764:	8c 81       	ldd	r24, Y+4	; 0x04
    1766:	81 30       	cpi	r24, 0x01	; 1
    1768:	19 f4       	brne	.+6      	; 0x1770 <LCD_Task+0x11e>
		{
			LCD_clearScreen();
    176a:	0e 94 89 11 	call	0x2312	; 0x2312 <LCD_clearScreen>
    176e:	68 c0       	rjmp	.+208    	; 0x1840 <LCD_Task+0x1ee>
		}
		/*display temperature and received messages from UART on LCD*/
		else
		{
			LCD_displayStringRowColumn(0 , 0 , Temperature_String);
    1770:	9e 01       	movw	r18, r28
    1772:	26 5f       	subi	r18, 0xF6	; 246
    1774:	3f 4f       	sbci	r19, 0xFF	; 255
    1776:	80 e0       	ldi	r24, 0x00	; 0
    1778:	60 e0       	ldi	r22, 0x00	; 0
    177a:	a9 01       	movw	r20, r18
    177c:	0e 94 70 11 	call	0x22e0	; 0x22e0 <LCD_displayStringRowColumn>
    1780:	17 c0       	rjmp	.+46     	; 0x17b0 <LCD_Task+0x15e>

			/*Convert integer to string*/
			for(;dummy != 0;)
			{
				DigitCounter++;
    1782:	8b 81       	ldd	r24, Y+3	; 0x03
    1784:	8f 5f       	subi	r24, 0xFF	; 255
    1786:	8b 83       	std	Y+3, r24	; 0x03
				TenPowerDigit *= 10;
    1788:	89 81       	ldd	r24, Y+1	; 0x01
    178a:	88 2f       	mov	r24, r24
    178c:	90 e0       	ldi	r25, 0x00	; 0
    178e:	9c 01       	movw	r18, r24
    1790:	22 0f       	add	r18, r18
    1792:	33 1f       	adc	r19, r19
    1794:	c9 01       	movw	r24, r18
    1796:	88 0f       	add	r24, r24
    1798:	99 1f       	adc	r25, r25
    179a:	88 0f       	add	r24, r24
    179c:	99 1f       	adc	r25, r25
    179e:	82 0f       	add	r24, r18
    17a0:	93 1f       	adc	r25, r19
    17a2:	89 83       	std	Y+1, r24	; 0x01
				dummy /= 10;
    17a4:	8a 81       	ldd	r24, Y+2	; 0x02
    17a6:	9a e0       	ldi	r25, 0x0A	; 10
    17a8:	69 2f       	mov	r22, r25
    17aa:	0e 94 d1 31 	call	0x63a2	; 0x63a2 <__udivmodqi4>
    17ae:	8a 83       	std	Y+2, r24	; 0x02
		else
		{
			LCD_displayStringRowColumn(0 , 0 , Temperature_String);

			/*Convert integer to string*/
			for(;dummy != 0;)
    17b0:	8a 81       	ldd	r24, Y+2	; 0x02
    17b2:	88 23       	and	r24, r24
    17b4:	31 f7       	brne	.-52     	; 0x1782 <LCD_Task+0x130>
    17b6:	36 c0       	rjmp	.+108    	; 0x1824 <LCD_Task+0x1d2>
				TenPowerDigit *= 10;
				dummy /= 10;
			}
			for(;DigitCounter > 0;DigitCounter--)
			{
				LCD_displayCharacter((Temp_Task_Data/(TenPowerDigit/10))+48);
    17b8:	ed 80       	ldd	r14, Y+5	; 0x05
    17ba:	fe 80       	ldd	r15, Y+6	; 0x06
    17bc:	0f 81       	ldd	r16, Y+7	; 0x07
    17be:	18 85       	ldd	r17, Y+8	; 0x08
    17c0:	89 81       	ldd	r24, Y+1	; 0x01
    17c2:	9a e0       	ldi	r25, 0x0A	; 10
    17c4:	69 2f       	mov	r22, r25
    17c6:	0e 94 d1 31 	call	0x63a2	; 0x63a2 <__udivmodqi4>
    17ca:	28 2f       	mov	r18, r24
    17cc:	30 e0       	ldi	r19, 0x00	; 0
    17ce:	40 e0       	ldi	r20, 0x00	; 0
    17d0:	50 e0       	ldi	r21, 0x00	; 0
    17d2:	c8 01       	movw	r24, r16
    17d4:	b7 01       	movw	r22, r14
    17d6:	0e 94 dd 31 	call	0x63ba	; 0x63ba <__udivmodsi4>
    17da:	da 01       	movw	r26, r20
    17dc:	c9 01       	movw	r24, r18
    17de:	80 5d       	subi	r24, 0xD0	; 208
    17e0:	0e 94 98 10 	call	0x2130	; 0x2130 <LCD_displayCharacter>
				Temp_Task_Data %=(TenPowerDigit/10);
    17e4:	ed 80       	ldd	r14, Y+5	; 0x05
    17e6:	fe 80       	ldd	r15, Y+6	; 0x06
    17e8:	0f 81       	ldd	r16, Y+7	; 0x07
    17ea:	18 85       	ldd	r17, Y+8	; 0x08
    17ec:	89 81       	ldd	r24, Y+1	; 0x01
    17ee:	9a e0       	ldi	r25, 0x0A	; 10
    17f0:	69 2f       	mov	r22, r25
    17f2:	0e 94 d1 31 	call	0x63a2	; 0x63a2 <__udivmodqi4>
    17f6:	28 2f       	mov	r18, r24
    17f8:	30 e0       	ldi	r19, 0x00	; 0
    17fa:	40 e0       	ldi	r20, 0x00	; 0
    17fc:	50 e0       	ldi	r21, 0x00	; 0
    17fe:	c8 01       	movw	r24, r16
    1800:	b7 01       	movw	r22, r14
    1802:	0e 94 dd 31 	call	0x63ba	; 0x63ba <__udivmodsi4>
    1806:	dc 01       	movw	r26, r24
    1808:	cb 01       	movw	r24, r22
    180a:	8d 83       	std	Y+5, r24	; 0x05
    180c:	9e 83       	std	Y+6, r25	; 0x06
    180e:	af 83       	std	Y+7, r26	; 0x07
    1810:	b8 87       	std	Y+8, r27	; 0x08
				TenPowerDigit /= 10;
    1812:	89 81       	ldd	r24, Y+1	; 0x01
    1814:	9a e0       	ldi	r25, 0x0A	; 10
    1816:	69 2f       	mov	r22, r25
    1818:	0e 94 d1 31 	call	0x63a2	; 0x63a2 <__udivmodqi4>
    181c:	89 83       	std	Y+1, r24	; 0x01
			{
				DigitCounter++;
				TenPowerDigit *= 10;
				dummy /= 10;
			}
			for(;DigitCounter > 0;DigitCounter--)
    181e:	8b 81       	ldd	r24, Y+3	; 0x03
    1820:	81 50       	subi	r24, 0x01	; 1
    1822:	8b 83       	std	Y+3, r24	; 0x03
    1824:	8b 81       	ldd	r24, Y+3	; 0x03
    1826:	88 23       	and	r24, r24
    1828:	39 f6       	brne	.-114    	; 0x17b8 <LCD_Task+0x166>
				Temp_Task_Data %=(TenPowerDigit/10);
				TenPowerDigit /= 10;
			}

			/*display UART received Data*/
			LCD_displayStringRowColumn(1 , 0 , UART_String);
    182a:	9e 01       	movw	r18, r28
    182c:	20 5f       	subi	r18, 0xF0	; 240
    182e:	3f 4f       	sbci	r19, 0xFF	; 255
    1830:	81 e0       	ldi	r24, 0x01	; 1
    1832:	60 e0       	ldi	r22, 0x00	; 0
    1834:	a9 01       	movw	r20, r18
    1836:	0e 94 70 11 	call	0x22e0	; 0x22e0 <LCD_displayStringRowColumn>
			LCD_displayCharacter(UART_Task_Data);
    183a:	89 85       	ldd	r24, Y+9	; 0x09
    183c:	0e 94 98 10 	call	0x2130	; 0x2130 <LCD_displayCharacter>
		}
		vTaskDelay(50);
    1840:	82 e3       	ldi	r24, 0x32	; 50
    1842:	90 e0       	ldi	r25, 0x00	; 0
    1844:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
    1848:	62 cf       	rjmp	.-316    	; 0x170e <LCD_Task+0xbc>

0000184a <UART_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void UART_Task(void * a_Task_ptr)
{
    184a:	df 93       	push	r29
    184c:	cf 93       	push	r28
    184e:	00 d0       	rcall	.+0      	; 0x1850 <UART_Task+0x6>
    1850:	0f 92       	push	r0
    1852:	cd b7       	in	r28, 0x3d	; 61
    1854:	de b7       	in	r29, 0x3e	; 62
    1856:	9b 83       	std	Y+3, r25	; 0x03
    1858:	8a 83       	std	Y+2, r24	; 0x02

	vTaskDelay(100);
    185a:	84 e6       	ldi	r24, 0x64	; 100
    185c:	90 e0       	ldi	r25, 0x00	; 0
    185e:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	uint8 UART_Data = 8;
    1862:	88 e0       	ldi	r24, 0x08	; 8
    1864:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		/*receive data from UART*/
		UART_Data = USART_DataRegister;
    1866:	ec e2       	ldi	r30, 0x2C	; 44
    1868:	f0 e0       	ldi	r31, 0x00	; 0
    186a:	80 81       	ld	r24, Z
    186c:	89 83       	std	Y+1, r24	; 0x01

		/* Data is sent to LCD by Queue*/
		xQueueSend(Queue_UART_Task , &UART_Data , 100);
    186e:	80 91 c4 00 	lds	r24, 0x00C4
    1872:	90 91 c5 00 	lds	r25, 0x00C5
    1876:	9e 01       	movw	r18, r28
    1878:	2f 5f       	subi	r18, 0xFF	; 255
    187a:	3f 4f       	sbci	r19, 0xFF	; 255
    187c:	b9 01       	movw	r22, r18
    187e:	44 e6       	ldi	r20, 0x64	; 100
    1880:	50 e0       	ldi	r21, 0x00	; 0
    1882:	20 e0       	ldi	r18, 0x00	; 0
    1884:	0e 94 f5 16 	call	0x2dea	; 0x2dea <xQueueGenericSend>
		vTaskDelay(200);
    1888:	88 ec       	ldi	r24, 0xC8	; 200
    188a:	90 e0       	ldi	r25, 0x00	; 0
    188c:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
    1890:	ea cf       	rjmp	.-44     	; 0x1866 <UART_Task+0x1c>

00001892 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    1892:	df 93       	push	r29
    1894:	cf 93       	push	r28
    1896:	00 d0       	rcall	.+0      	; 0x1898 <xEventGroupCreate+0x6>
    1898:	cd b7       	in	r28, 0x3d	; 61
    189a:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    189c:	8b e0       	ldi	r24, 0x0B	; 11
    189e:	90 e0       	ldi	r25, 0x00	; 0
    18a0:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <pvPortMalloc>
    18a4:	9a 83       	std	Y+2, r25	; 0x02
    18a6:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    18a8:	89 81       	ldd	r24, Y+1	; 0x01
    18aa:	9a 81       	ldd	r25, Y+2	; 0x02
    18ac:	00 97       	sbiw	r24, 0x00	; 0
    18ae:	49 f0       	breq	.+18     	; 0x18c2 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
    18b0:	e9 81       	ldd	r30, Y+1	; 0x01
    18b2:	fa 81       	ldd	r31, Y+2	; 0x02
    18b4:	11 82       	std	Z+1, r1	; 0x01
    18b6:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    18b8:	89 81       	ldd	r24, Y+1	; 0x01
    18ba:	9a 81       	ldd	r25, Y+2	; 0x02
    18bc:	02 96       	adiw	r24, 0x02	; 2
    18be:	0e 94 bc 11 	call	0x2378	; 0x2378 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    18c2:	89 81       	ldd	r24, Y+1	; 0x01
    18c4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    18c6:	0f 90       	pop	r0
    18c8:	0f 90       	pop	r0
    18ca:	cf 91       	pop	r28
    18cc:	df 91       	pop	r29
    18ce:	08 95       	ret

000018d0 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    18d0:	df 93       	push	r29
    18d2:	cf 93       	push	r28
    18d4:	cd b7       	in	r28, 0x3d	; 61
    18d6:	de b7       	in	r29, 0x3e	; 62
    18d8:	60 97       	sbiw	r28, 0x10	; 16
    18da:	0f b6       	in	r0, 0x3f	; 63
    18dc:	f8 94       	cli
    18de:	de bf       	out	0x3e, r29	; 62
    18e0:	0f be       	out	0x3f, r0	; 63
    18e2:	cd bf       	out	0x3d, r28	; 61
    18e4:	9a 87       	std	Y+10, r25	; 0x0a
    18e6:	89 87       	std	Y+9, r24	; 0x09
    18e8:	7c 87       	std	Y+12, r23	; 0x0c
    18ea:	6b 87       	std	Y+11, r22	; 0x0b
    18ec:	5e 87       	std	Y+14, r21	; 0x0e
    18ee:	4d 87       	std	Y+13, r20	; 0x0d
    18f0:	38 8b       	std	Y+16, r19	; 0x10
    18f2:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    18f4:	89 85       	ldd	r24, Y+9	; 0x09
    18f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    18f8:	9c 83       	std	Y+4, r25	; 0x04
    18fa:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    18fc:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    18fe:	0e 94 84 28 	call	0x5108	; 0x5108 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1902:	eb 81       	ldd	r30, Y+3	; 0x03
    1904:	fc 81       	ldd	r31, Y+4	; 0x04
    1906:	80 81       	ld	r24, Z
    1908:	91 81       	ldd	r25, Z+1	; 0x01
    190a:	98 87       	std	Y+8, r25	; 0x08
    190c:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    190e:	89 85       	ldd	r24, Y+9	; 0x09
    1910:	9a 85       	ldd	r25, Y+10	; 0x0a
    1912:	2b 85       	ldd	r18, Y+11	; 0x0b
    1914:	3c 85       	ldd	r19, Y+12	; 0x0c
    1916:	b9 01       	movw	r22, r18
    1918:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    191c:	2f 81       	ldd	r18, Y+7	; 0x07
    191e:	38 85       	ldd	r19, Y+8	; 0x08
    1920:	8b 85       	ldd	r24, Y+11	; 0x0b
    1922:	9c 85       	ldd	r25, Y+12	; 0x0c
    1924:	28 2b       	or	r18, r24
    1926:	39 2b       	or	r19, r25
    1928:	8d 85       	ldd	r24, Y+13	; 0x0d
    192a:	9e 85       	ldd	r25, Y+14	; 0x0e
    192c:	28 23       	and	r18, r24
    192e:	39 23       	and	r19, r25
    1930:	8d 85       	ldd	r24, Y+13	; 0x0d
    1932:	9e 85       	ldd	r25, Y+14	; 0x0e
    1934:	28 17       	cp	r18, r24
    1936:	39 07       	cpc	r19, r25
    1938:	c9 f4       	brne	.+50     	; 0x196c <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    193a:	2f 81       	ldd	r18, Y+7	; 0x07
    193c:	38 85       	ldd	r19, Y+8	; 0x08
    193e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1940:	9c 85       	ldd	r25, Y+12	; 0x0c
    1942:	82 2b       	or	r24, r18
    1944:	93 2b       	or	r25, r19
    1946:	9e 83       	std	Y+6, r25	; 0x06
    1948:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    194a:	eb 81       	ldd	r30, Y+3	; 0x03
    194c:	fc 81       	ldd	r31, Y+4	; 0x04
    194e:	20 81       	ld	r18, Z
    1950:	31 81       	ldd	r19, Z+1	; 0x01
    1952:	8d 85       	ldd	r24, Y+13	; 0x0d
    1954:	9e 85       	ldd	r25, Y+14	; 0x0e
    1956:	80 95       	com	r24
    1958:	90 95       	com	r25
    195a:	82 23       	and	r24, r18
    195c:	93 23       	and	r25, r19
    195e:	eb 81       	ldd	r30, Y+3	; 0x03
    1960:	fc 81       	ldd	r31, Y+4	; 0x04
    1962:	91 83       	std	Z+1, r25	; 0x01
    1964:	80 83       	st	Z, r24

			xTicksToWait = 0;
    1966:	18 8a       	std	Y+16, r1	; 0x10
    1968:	1f 86       	std	Y+15, r1	; 0x0f
    196a:	1e c0       	rjmp	.+60     	; 0x19a8 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    196c:	8f 85       	ldd	r24, Y+15	; 0x0f
    196e:	98 89       	ldd	r25, Y+16	; 0x10
    1970:	00 97       	sbiw	r24, 0x00	; 0
    1972:	91 f0       	breq	.+36     	; 0x1998 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1974:	8b 81       	ldd	r24, Y+3	; 0x03
    1976:	9c 81       	ldd	r25, Y+4	; 0x04
    1978:	bc 01       	movw	r22, r24
    197a:	6e 5f       	subi	r22, 0xFE	; 254
    197c:	7f 4f       	sbci	r23, 0xFF	; 255
    197e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1980:	9e 85       	ldd	r25, Y+14	; 0x0e
    1982:	9c 01       	movw	r18, r24
    1984:	35 60       	ori	r19, 0x05	; 5
    1986:	4f 85       	ldd	r20, Y+15	; 0x0f
    1988:	58 89       	ldd	r21, Y+16	; 0x10
    198a:	cb 01       	movw	r24, r22
    198c:	b9 01       	movw	r22, r18
    198e:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1992:	1e 82       	std	Y+6, r1	; 0x06
    1994:	1d 82       	std	Y+5, r1	; 0x05
    1996:	08 c0       	rjmp	.+16     	; 0x19a8 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1998:	eb 81       	ldd	r30, Y+3	; 0x03
    199a:	fc 81       	ldd	r31, Y+4	; 0x04
    199c:	80 81       	ld	r24, Z
    199e:	91 81       	ldd	r25, Z+1	; 0x01
    19a0:	9e 83       	std	Y+6, r25	; 0x06
    19a2:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
    19a4:	81 e0       	ldi	r24, 0x01	; 1
    19a6:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    19a8:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
    19ac:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    19ae:	8f 85       	ldd	r24, Y+15	; 0x0f
    19b0:	98 89       	ldd	r25, Y+16	; 0x10
    19b2:	00 97       	sbiw	r24, 0x00	; 0
    19b4:	09 f4       	brne	.+2      	; 0x19b8 <xEventGroupSync+0xe8>
    19b6:	3a c0       	rjmp	.+116    	; 0x1a2c <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
    19b8:	8a 81       	ldd	r24, Y+2	; 0x02
    19ba:	88 23       	and	r24, r24
    19bc:	11 f4       	brne	.+4      	; 0x19c2 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
    19be:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    19c2:	0e 94 67 2d 	call	0x5ace	; 0x5ace <uxTaskResetEventItemValue>
    19c6:	9e 83       	std	Y+6, r25	; 0x06
    19c8:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    19ca:	8d 81       	ldd	r24, Y+5	; 0x05
    19cc:	9e 81       	ldd	r25, Y+6	; 0x06
    19ce:	80 70       	andi	r24, 0x00	; 0
    19d0:	92 70       	andi	r25, 0x02	; 2
    19d2:	00 97       	sbiw	r24, 0x00	; 0
    19d4:	31 f5       	brne	.+76     	; 0x1a22 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    19d6:	0f b6       	in	r0, 0x3f	; 63
    19d8:	f8 94       	cli
    19da:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    19dc:	eb 81       	ldd	r30, Y+3	; 0x03
    19de:	fc 81       	ldd	r31, Y+4	; 0x04
    19e0:	80 81       	ld	r24, Z
    19e2:	91 81       	ldd	r25, Z+1	; 0x01
    19e4:	9e 83       	std	Y+6, r25	; 0x06
    19e6:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    19e8:	2d 81       	ldd	r18, Y+5	; 0x05
    19ea:	3e 81       	ldd	r19, Y+6	; 0x06
    19ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    19ee:	9e 85       	ldd	r25, Y+14	; 0x0e
    19f0:	28 23       	and	r18, r24
    19f2:	39 23       	and	r19, r25
    19f4:	8d 85       	ldd	r24, Y+13	; 0x0d
    19f6:	9e 85       	ldd	r25, Y+14	; 0x0e
    19f8:	28 17       	cp	r18, r24
    19fa:	39 07       	cpc	r19, r25
    19fc:	71 f4       	brne	.+28     	; 0x1a1a <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    19fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1a00:	fc 81       	ldd	r31, Y+4	; 0x04
    1a02:	20 81       	ld	r18, Z
    1a04:	31 81       	ldd	r19, Z+1	; 0x01
    1a06:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a08:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a0a:	80 95       	com	r24
    1a0c:	90 95       	com	r25
    1a0e:	82 23       	and	r24, r18
    1a10:	93 23       	and	r25, r19
    1a12:	eb 81       	ldd	r30, Y+3	; 0x03
    1a14:	fc 81       	ldd	r31, Y+4	; 0x04
    1a16:	91 83       	std	Z+1, r25	; 0x01
    1a18:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1a1a:	0f 90       	pop	r0
    1a1c:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    1a1e:	81 e0       	ldi	r24, 0x01	; 1
    1a20:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1a22:	8d 81       	ldd	r24, Y+5	; 0x05
    1a24:	9e 81       	ldd	r25, Y+6	; 0x06
    1a26:	90 70       	andi	r25, 0x00	; 0
    1a28:	9e 83       	std	Y+6, r25	; 0x06
    1a2a:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    1a2c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a2e:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1a30:	60 96       	adiw	r28, 0x10	; 16
    1a32:	0f b6       	in	r0, 0x3f	; 63
    1a34:	f8 94       	cli
    1a36:	de bf       	out	0x3e, r29	; 62
    1a38:	0f be       	out	0x3f, r0	; 63
    1a3a:	cd bf       	out	0x3d, r28	; 61
    1a3c:	cf 91       	pop	r28
    1a3e:	df 91       	pop	r29
    1a40:	08 95       	ret

00001a42 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    1a42:	0f 93       	push	r16
    1a44:	1f 93       	push	r17
    1a46:	df 93       	push	r29
    1a48:	cf 93       	push	r28
    1a4a:	cd b7       	in	r28, 0x3d	; 61
    1a4c:	de b7       	in	r29, 0x3e	; 62
    1a4e:	63 97       	sbiw	r28, 0x13	; 19
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	f8 94       	cli
    1a54:	de bf       	out	0x3e, r29	; 62
    1a56:	0f be       	out	0x3f, r0	; 63
    1a58:	cd bf       	out	0x3d, r28	; 61
    1a5a:	9d 87       	std	Y+13, r25	; 0x0d
    1a5c:	8c 87       	std	Y+12, r24	; 0x0c
    1a5e:	7f 87       	std	Y+15, r23	; 0x0f
    1a60:	6e 87       	std	Y+14, r22	; 0x0e
    1a62:	48 8b       	std	Y+16, r20	; 0x10
    1a64:	29 8b       	std	Y+17, r18	; 0x11
    1a66:	1b 8b       	std	Y+19, r17	; 0x13
    1a68:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    1a6a:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a6c:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a6e:	9b 87       	std	Y+11, r25	; 0x0b
    1a70:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    1a72:	1f 82       	std	Y+7, r1	; 0x07
    1a74:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1a76:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1a78:	0e 94 84 28 	call	0x5108	; 0x5108 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1a7c:	ea 85       	ldd	r30, Y+10	; 0x0a
    1a7e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1a80:	80 81       	ld	r24, Z
    1a82:	91 81       	ldd	r25, Z+1	; 0x01
    1a84:	9a 83       	std	Y+2, r25	; 0x02
    1a86:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    1a88:	89 81       	ldd	r24, Y+1	; 0x01
    1a8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a8c:	2e 85       	ldd	r18, Y+14	; 0x0e
    1a8e:	3f 85       	ldd	r19, Y+15	; 0x0f
    1a90:	b9 01       	movw	r22, r18
    1a92:	49 89       	ldd	r20, Y+17	; 0x11
    1a94:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <prvTestWaitCondition>
    1a98:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    1a9a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a9c:	88 23       	and	r24, r24
    1a9e:	c1 f0       	breq	.+48     	; 0x1ad0 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    1aa0:	89 81       	ldd	r24, Y+1	; 0x01
    1aa2:	9a 81       	ldd	r25, Y+2	; 0x02
    1aa4:	99 87       	std	Y+9, r25	; 0x09
    1aa6:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    1aa8:	1b 8a       	std	Y+19, r1	; 0x13
    1aaa:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    1aac:	88 89       	ldd	r24, Y+16	; 0x10
    1aae:	88 23       	and	r24, r24
    1ab0:	e9 f1       	breq	.+122    	; 0x1b2c <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1ab2:	ea 85       	ldd	r30, Y+10	; 0x0a
    1ab4:	fb 85       	ldd	r31, Y+11	; 0x0b
    1ab6:	20 81       	ld	r18, Z
    1ab8:	31 81       	ldd	r19, Z+1	; 0x01
    1aba:	8e 85       	ldd	r24, Y+14	; 0x0e
    1abc:	9f 85       	ldd	r25, Y+15	; 0x0f
    1abe:	80 95       	com	r24
    1ac0:	90 95       	com	r25
    1ac2:	82 23       	and	r24, r18
    1ac4:	93 23       	and	r25, r19
    1ac6:	ea 85       	ldd	r30, Y+10	; 0x0a
    1ac8:	fb 85       	ldd	r31, Y+11	; 0x0b
    1aca:	91 83       	std	Z+1, r25	; 0x01
    1acc:	80 83       	st	Z, r24
    1ace:	2e c0       	rjmp	.+92     	; 0x1b2c <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    1ad0:	8a 89       	ldd	r24, Y+18	; 0x12
    1ad2:	9b 89       	ldd	r25, Y+19	; 0x13
    1ad4:	00 97       	sbiw	r24, 0x00	; 0
    1ad6:	39 f4       	brne	.+14     	; 0x1ae6 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    1ad8:	89 81       	ldd	r24, Y+1	; 0x01
    1ada:	9a 81       	ldd	r25, Y+2	; 0x02
    1adc:	99 87       	std	Y+9, r25	; 0x09
    1ade:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
    1ae0:	81 e0       	ldi	r24, 0x01	; 1
    1ae2:	8b 83       	std	Y+3, r24	; 0x03
    1ae4:	23 c0       	rjmp	.+70     	; 0x1b2c <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    1ae6:	88 89       	ldd	r24, Y+16	; 0x10
    1ae8:	88 23       	and	r24, r24
    1aea:	29 f0       	breq	.+10     	; 0x1af6 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1aec:	8e 81       	ldd	r24, Y+6	; 0x06
    1aee:	9f 81       	ldd	r25, Y+7	; 0x07
    1af0:	91 60       	ori	r25, 0x01	; 1
    1af2:	9f 83       	std	Y+7, r25	; 0x07
    1af4:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    1af6:	89 89       	ldd	r24, Y+17	; 0x11
    1af8:	88 23       	and	r24, r24
    1afa:	29 f0       	breq	.+10     	; 0x1b06 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1afc:	8e 81       	ldd	r24, Y+6	; 0x06
    1afe:	9f 81       	ldd	r25, Y+7	; 0x07
    1b00:	94 60       	ori	r25, 0x04	; 4
    1b02:	9f 83       	std	Y+7, r25	; 0x07
    1b04:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1b06:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b08:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b0a:	bc 01       	movw	r22, r24
    1b0c:	6e 5f       	subi	r22, 0xFE	; 254
    1b0e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b10:	2e 85       	ldd	r18, Y+14	; 0x0e
    1b12:	3f 85       	ldd	r19, Y+15	; 0x0f
    1b14:	8e 81       	ldd	r24, Y+6	; 0x06
    1b16:	9f 81       	ldd	r25, Y+7	; 0x07
    1b18:	28 2b       	or	r18, r24
    1b1a:	39 2b       	or	r19, r25
    1b1c:	4a 89       	ldd	r20, Y+18	; 0x12
    1b1e:	5b 89       	ldd	r21, Y+19	; 0x13
    1b20:	cb 01       	movw	r24, r22
    1b22:	b9 01       	movw	r22, r18
    1b24:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    1b28:	19 86       	std	Y+9, r1	; 0x09
    1b2a:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1b2c:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
    1b30:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    1b32:	8a 89       	ldd	r24, Y+18	; 0x12
    1b34:	9b 89       	ldd	r25, Y+19	; 0x13
    1b36:	00 97       	sbiw	r24, 0x00	; 0
    1b38:	09 f4       	brne	.+2      	; 0x1b3c <xEventGroupWaitBits+0xfa>
    1b3a:	3c c0       	rjmp	.+120    	; 0x1bb4 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
    1b3c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b3e:	88 23       	and	r24, r24
    1b40:	11 f4       	brne	.+4      	; 0x1b46 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    1b42:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1b46:	0e 94 67 2d 	call	0x5ace	; 0x5ace <uxTaskResetEventItemValue>
    1b4a:	99 87       	std	Y+9, r25	; 0x09
    1b4c:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1b4e:	88 85       	ldd	r24, Y+8	; 0x08
    1b50:	99 85       	ldd	r25, Y+9	; 0x09
    1b52:	80 70       	andi	r24, 0x00	; 0
    1b54:	92 70       	andi	r25, 0x02	; 2
    1b56:	00 97       	sbiw	r24, 0x00	; 0
    1b58:	41 f5       	brne	.+80     	; 0x1baa <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    1b5a:	0f b6       	in	r0, 0x3f	; 63
    1b5c:	f8 94       	cli
    1b5e:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1b60:	ea 85       	ldd	r30, Y+10	; 0x0a
    1b62:	fb 85       	ldd	r31, Y+11	; 0x0b
    1b64:	80 81       	ld	r24, Z
    1b66:	91 81       	ldd	r25, Z+1	; 0x01
    1b68:	99 87       	std	Y+9, r25	; 0x09
    1b6a:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1b6c:	88 85       	ldd	r24, Y+8	; 0x08
    1b6e:	99 85       	ldd	r25, Y+9	; 0x09
    1b70:	2e 85       	ldd	r18, Y+14	; 0x0e
    1b72:	3f 85       	ldd	r19, Y+15	; 0x0f
    1b74:	b9 01       	movw	r22, r18
    1b76:	49 89       	ldd	r20, Y+17	; 0x11
    1b78:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <prvTestWaitCondition>
    1b7c:	88 23       	and	r24, r24
    1b7e:	89 f0       	breq	.+34     	; 0x1ba2 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
    1b80:	88 89       	ldd	r24, Y+16	; 0x10
    1b82:	88 23       	and	r24, r24
    1b84:	71 f0       	breq	.+28     	; 0x1ba2 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1b86:	ea 85       	ldd	r30, Y+10	; 0x0a
    1b88:	fb 85       	ldd	r31, Y+11	; 0x0b
    1b8a:	20 81       	ld	r18, Z
    1b8c:	31 81       	ldd	r19, Z+1	; 0x01
    1b8e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b90:	9f 85       	ldd	r25, Y+15	; 0x0f
    1b92:	80 95       	com	r24
    1b94:	90 95       	com	r25
    1b96:	82 23       	and	r24, r18
    1b98:	93 23       	and	r25, r19
    1b9a:	ea 85       	ldd	r30, Y+10	; 0x0a
    1b9c:	fb 85       	ldd	r31, Y+11	; 0x0b
    1b9e:	91 83       	std	Z+1, r25	; 0x01
    1ba0:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    1ba2:	81 e0       	ldi	r24, 0x01	; 1
    1ba4:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
    1ba6:	0f 90       	pop	r0
    1ba8:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1baa:	88 85       	ldd	r24, Y+8	; 0x08
    1bac:	99 85       	ldd	r25, Y+9	; 0x09
    1bae:	90 70       	andi	r25, 0x00	; 0
    1bb0:	99 87       	std	Y+9, r25	; 0x09
    1bb2:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    1bb4:	88 85       	ldd	r24, Y+8	; 0x08
    1bb6:	99 85       	ldd	r25, Y+9	; 0x09
}
    1bb8:	63 96       	adiw	r28, 0x13	; 19
    1bba:	0f b6       	in	r0, 0x3f	; 63
    1bbc:	f8 94       	cli
    1bbe:	de bf       	out	0x3e, r29	; 62
    1bc0:	0f be       	out	0x3f, r0	; 63
    1bc2:	cd bf       	out	0x3d, r28	; 61
    1bc4:	cf 91       	pop	r28
    1bc6:	df 91       	pop	r29
    1bc8:	1f 91       	pop	r17
    1bca:	0f 91       	pop	r16
    1bcc:	08 95       	ret

00001bce <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    1bce:	df 93       	push	r29
    1bd0:	cf 93       	push	r28
    1bd2:	cd b7       	in	r28, 0x3d	; 61
    1bd4:	de b7       	in	r29, 0x3e	; 62
    1bd6:	28 97       	sbiw	r28, 0x08	; 8
    1bd8:	0f b6       	in	r0, 0x3f	; 63
    1bda:	f8 94       	cli
    1bdc:	de bf       	out	0x3e, r29	; 62
    1bde:	0f be       	out	0x3f, r0	; 63
    1be0:	cd bf       	out	0x3d, r28	; 61
    1be2:	9e 83       	std	Y+6, r25	; 0x06
    1be4:	8d 83       	std	Y+5, r24	; 0x05
    1be6:	78 87       	std	Y+8, r23	; 0x08
    1be8:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    1bea:	8d 81       	ldd	r24, Y+5	; 0x05
    1bec:	9e 81       	ldd	r25, Y+6	; 0x06
    1bee:	9c 83       	std	Y+4, r25	; 0x04
    1bf0:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    1bf2:	0f b6       	in	r0, 0x3f	; 63
    1bf4:	f8 94       	cli
    1bf6:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    1bf8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bfa:	fc 81       	ldd	r31, Y+4	; 0x04
    1bfc:	80 81       	ld	r24, Z
    1bfe:	91 81       	ldd	r25, Z+1	; 0x01
    1c00:	9a 83       	std	Y+2, r25	; 0x02
    1c02:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1c04:	eb 81       	ldd	r30, Y+3	; 0x03
    1c06:	fc 81       	ldd	r31, Y+4	; 0x04
    1c08:	20 81       	ld	r18, Z
    1c0a:	31 81       	ldd	r19, Z+1	; 0x01
    1c0c:	8f 81       	ldd	r24, Y+7	; 0x07
    1c0e:	98 85       	ldd	r25, Y+8	; 0x08
    1c10:	80 95       	com	r24
    1c12:	90 95       	com	r25
    1c14:	82 23       	and	r24, r18
    1c16:	93 23       	and	r25, r19
    1c18:	eb 81       	ldd	r30, Y+3	; 0x03
    1c1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c1c:	91 83       	std	Z+1, r25	; 0x01
    1c1e:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    1c20:	0f 90       	pop	r0
    1c22:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1c24:	89 81       	ldd	r24, Y+1	; 0x01
    1c26:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1c28:	28 96       	adiw	r28, 0x08	; 8
    1c2a:	0f b6       	in	r0, 0x3f	; 63
    1c2c:	f8 94       	cli
    1c2e:	de bf       	out	0x3e, r29	; 62
    1c30:	0f be       	out	0x3f, r0	; 63
    1c32:	cd bf       	out	0x3d, r28	; 61
    1c34:	cf 91       	pop	r28
    1c36:	df 91       	pop	r29
    1c38:	08 95       	ret

00001c3a <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1c3a:	df 93       	push	r29
    1c3c:	cf 93       	push	r28
    1c3e:	cd b7       	in	r28, 0x3d	; 61
    1c40:	de b7       	in	r29, 0x3e	; 62
    1c42:	27 97       	sbiw	r28, 0x07	; 7
    1c44:	0f b6       	in	r0, 0x3f	; 63
    1c46:	f8 94       	cli
    1c48:	de bf       	out	0x3e, r29	; 62
    1c4a:	0f be       	out	0x3f, r0	; 63
    1c4c:	cd bf       	out	0x3d, r28	; 61
    1c4e:	9f 83       	std	Y+7, r25	; 0x07
    1c50:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    1c52:	8e 81       	ldd	r24, Y+6	; 0x06
    1c54:	9f 81       	ldd	r25, Y+7	; 0x07
    1c56:	9c 83       	std	Y+4, r25	; 0x04
    1c58:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1c5a:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    1c5c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c5e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c60:	80 81       	ld	r24, Z
    1c62:	91 81       	ldd	r25, Z+1	; 0x01
    1c64:	9a 83       	std	Y+2, r25	; 0x02
    1c66:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    1c68:	89 81       	ldd	r24, Y+1	; 0x01
    1c6a:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1c6c:	27 96       	adiw	r28, 0x07	; 7
    1c6e:	0f b6       	in	r0, 0x3f	; 63
    1c70:	f8 94       	cli
    1c72:	de bf       	out	0x3e, r29	; 62
    1c74:	0f be       	out	0x3f, r0	; 63
    1c76:	cd bf       	out	0x3d, r28	; 61
    1c78:	cf 91       	pop	r28
    1c7a:	df 91       	pop	r29
    1c7c:	08 95       	ret

00001c7e <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    1c7e:	df 93       	push	r29
    1c80:	cf 93       	push	r28
    1c82:	cd b7       	in	r28, 0x3d	; 61
    1c84:	de b7       	in	r29, 0x3e	; 62
    1c86:	65 97       	sbiw	r28, 0x15	; 21
    1c88:	0f b6       	in	r0, 0x3f	; 63
    1c8a:	f8 94       	cli
    1c8c:	de bf       	out	0x3e, r29	; 62
    1c8e:	0f be       	out	0x3f, r0	; 63
    1c90:	cd bf       	out	0x3d, r28	; 61
    1c92:	9b 8b       	std	Y+19, r25	; 0x13
    1c94:	8a 8b       	std	Y+18, r24	; 0x12
    1c96:	7d 8b       	std	Y+21, r23	; 0x15
    1c98:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1c9a:	19 86       	std	Y+9, r1	; 0x09
    1c9c:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
    1c9e:	8a 89       	ldd	r24, Y+18	; 0x12
    1ca0:	9b 89       	ldd	r25, Y+19	; 0x13
    1ca2:	9b 83       	std	Y+3, r25	; 0x03
    1ca4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    1ca6:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    1ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    1caa:	9b 81       	ldd	r25, Y+3	; 0x03
    1cac:	02 96       	adiw	r24, 0x02	; 2
    1cae:	9b 87       	std	Y+11, r25	; 0x0b
    1cb0:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1cb2:	8a 85       	ldd	r24, Y+10	; 0x0a
    1cb4:	9b 85       	ldd	r25, Y+11	; 0x0b
    1cb6:	03 96       	adiw	r24, 0x03	; 3
    1cb8:	9d 87       	std	Y+13, r25	; 0x0d
    1cba:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    1cbc:	0e 94 84 28 	call	0x5108	; 0x5108 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    1cc0:	ea 85       	ldd	r30, Y+10	; 0x0a
    1cc2:	fb 85       	ldd	r31, Y+11	; 0x0b
    1cc4:	85 81       	ldd	r24, Z+5	; 0x05
    1cc6:	96 81       	ldd	r25, Z+6	; 0x06
    1cc8:	99 8b       	std	Y+17, r25	; 0x11
    1cca:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    1ccc:	ea 81       	ldd	r30, Y+2	; 0x02
    1cce:	fb 81       	ldd	r31, Y+3	; 0x03
    1cd0:	20 81       	ld	r18, Z
    1cd2:	31 81       	ldd	r19, Z+1	; 0x01
    1cd4:	8c 89       	ldd	r24, Y+20	; 0x14
    1cd6:	9d 89       	ldd	r25, Y+21	; 0x15
    1cd8:	82 2b       	or	r24, r18
    1cda:	93 2b       	or	r25, r19
    1cdc:	ea 81       	ldd	r30, Y+2	; 0x02
    1cde:	fb 81       	ldd	r31, Y+3	; 0x03
    1ce0:	91 83       	std	Z+1, r25	; 0x01
    1ce2:	80 83       	st	Z, r24
    1ce4:	59 c0       	rjmp	.+178    	; 0x1d98 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    1ce6:	e8 89       	ldd	r30, Y+16	; 0x10
    1ce8:	f9 89       	ldd	r31, Y+17	; 0x11
    1cea:	82 81       	ldd	r24, Z+2	; 0x02
    1cec:	93 81       	ldd	r25, Z+3	; 0x03
    1cee:	9f 87       	std	Y+15, r25	; 0x0f
    1cf0:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1cf2:	e8 89       	ldd	r30, Y+16	; 0x10
    1cf4:	f9 89       	ldd	r31, Y+17	; 0x11
    1cf6:	80 81       	ld	r24, Z
    1cf8:	91 81       	ldd	r25, Z+1	; 0x01
    1cfa:	9f 83       	std	Y+7, r25	; 0x07
    1cfc:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    1cfe:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1d00:	8e 81       	ldd	r24, Y+6	; 0x06
    1d02:	9f 81       	ldd	r25, Y+7	; 0x07
    1d04:	80 70       	andi	r24, 0x00	; 0
    1d06:	9d 83       	std	Y+5, r25	; 0x05
    1d08:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1d0a:	8e 81       	ldd	r24, Y+6	; 0x06
    1d0c:	9f 81       	ldd	r25, Y+7	; 0x07
    1d0e:	90 70       	andi	r25, 0x00	; 0
    1d10:	9f 83       	std	Y+7, r25	; 0x07
    1d12:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1d14:	8c 81       	ldd	r24, Y+4	; 0x04
    1d16:	9d 81       	ldd	r25, Y+5	; 0x05
    1d18:	80 70       	andi	r24, 0x00	; 0
    1d1a:	94 70       	andi	r25, 0x04	; 4
    1d1c:	00 97       	sbiw	r24, 0x00	; 0
    1d1e:	69 f4       	brne	.+26     	; 0x1d3a <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1d20:	ea 81       	ldd	r30, Y+2	; 0x02
    1d22:	fb 81       	ldd	r31, Y+3	; 0x03
    1d24:	20 81       	ld	r18, Z
    1d26:	31 81       	ldd	r19, Z+1	; 0x01
    1d28:	8e 81       	ldd	r24, Y+6	; 0x06
    1d2a:	9f 81       	ldd	r25, Y+7	; 0x07
    1d2c:	82 23       	and	r24, r18
    1d2e:	93 23       	and	r25, r19
    1d30:	00 97       	sbiw	r24, 0x00	; 0
    1d32:	91 f0       	breq	.+36     	; 0x1d58 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    1d34:	81 e0       	ldi	r24, 0x01	; 1
    1d36:	89 83       	std	Y+1, r24	; 0x01
    1d38:	0f c0       	rjmp	.+30     	; 0x1d58 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1d3a:	ea 81       	ldd	r30, Y+2	; 0x02
    1d3c:	fb 81       	ldd	r31, Y+3	; 0x03
    1d3e:	20 81       	ld	r18, Z
    1d40:	31 81       	ldd	r19, Z+1	; 0x01
    1d42:	8e 81       	ldd	r24, Y+6	; 0x06
    1d44:	9f 81       	ldd	r25, Y+7	; 0x07
    1d46:	28 23       	and	r18, r24
    1d48:	39 23       	and	r19, r25
    1d4a:	8e 81       	ldd	r24, Y+6	; 0x06
    1d4c:	9f 81       	ldd	r25, Y+7	; 0x07
    1d4e:	28 17       	cp	r18, r24
    1d50:	39 07       	cpc	r19, r25
    1d52:	11 f4       	brne	.+4      	; 0x1d58 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    1d54:	81 e0       	ldi	r24, 0x01	; 1
    1d56:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    1d58:	89 81       	ldd	r24, Y+1	; 0x01
    1d5a:	88 23       	and	r24, r24
    1d5c:	c9 f0       	breq	.+50     	; 0x1d90 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1d5e:	8c 81       	ldd	r24, Y+4	; 0x04
    1d60:	9d 81       	ldd	r25, Y+5	; 0x05
    1d62:	80 70       	andi	r24, 0x00	; 0
    1d64:	91 70       	andi	r25, 0x01	; 1
    1d66:	00 97       	sbiw	r24, 0x00	; 0
    1d68:	41 f0       	breq	.+16     	; 0x1d7a <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    1d6a:	88 85       	ldd	r24, Y+8	; 0x08
    1d6c:	99 85       	ldd	r25, Y+9	; 0x09
    1d6e:	2e 81       	ldd	r18, Y+6	; 0x06
    1d70:	3f 81       	ldd	r19, Y+7	; 0x07
    1d72:	82 2b       	or	r24, r18
    1d74:	93 2b       	or	r25, r19
    1d76:	99 87       	std	Y+9, r25	; 0x09
    1d78:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1d7a:	ea 81       	ldd	r30, Y+2	; 0x02
    1d7c:	fb 81       	ldd	r31, Y+3	; 0x03
    1d7e:	80 81       	ld	r24, Z
    1d80:	91 81       	ldd	r25, Z+1	; 0x01
    1d82:	9c 01       	movw	r18, r24
    1d84:	32 60       	ori	r19, 0x02	; 2
    1d86:	88 89       	ldd	r24, Y+16	; 0x10
    1d88:	99 89       	ldd	r25, Y+17	; 0x11
    1d8a:	b9 01       	movw	r22, r18
    1d8c:	0e 94 8f 2b 	call	0x571e	; 0x571e <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    1d90:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d92:	9f 85       	ldd	r25, Y+15	; 0x0f
    1d94:	99 8b       	std	Y+17, r25	; 0x11
    1d96:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    1d98:	28 89       	ldd	r18, Y+16	; 0x10
    1d9a:	39 89       	ldd	r19, Y+17	; 0x11
    1d9c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1d9e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1da0:	28 17       	cp	r18, r24
    1da2:	39 07       	cpc	r19, r25
    1da4:	09 f0       	breq	.+2      	; 0x1da8 <xEventGroupSetBits+0x12a>
    1da6:	9f cf       	rjmp	.-194    	; 0x1ce6 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1da8:	ea 81       	ldd	r30, Y+2	; 0x02
    1daa:	fb 81       	ldd	r31, Y+3	; 0x03
    1dac:	20 81       	ld	r18, Z
    1dae:	31 81       	ldd	r19, Z+1	; 0x01
    1db0:	88 85       	ldd	r24, Y+8	; 0x08
    1db2:	99 85       	ldd	r25, Y+9	; 0x09
    1db4:	80 95       	com	r24
    1db6:	90 95       	com	r25
    1db8:	82 23       	and	r24, r18
    1dba:	93 23       	and	r25, r19
    1dbc:	ea 81       	ldd	r30, Y+2	; 0x02
    1dbe:	fb 81       	ldd	r31, Y+3	; 0x03
    1dc0:	91 83       	std	Z+1, r25	; 0x01
    1dc2:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    1dc4:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    1dc8:	ea 81       	ldd	r30, Y+2	; 0x02
    1dca:	fb 81       	ldd	r31, Y+3	; 0x03
    1dcc:	80 81       	ld	r24, Z
    1dce:	91 81       	ldd	r25, Z+1	; 0x01
}
    1dd0:	65 96       	adiw	r28, 0x15	; 21
    1dd2:	0f b6       	in	r0, 0x3f	; 63
    1dd4:	f8 94       	cli
    1dd6:	de bf       	out	0x3e, r29	; 62
    1dd8:	0f be       	out	0x3f, r0	; 63
    1dda:	cd bf       	out	0x3d, r28	; 61
    1ddc:	cf 91       	pop	r28
    1dde:	df 91       	pop	r29
    1de0:	08 95       	ret

00001de2 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1de2:	df 93       	push	r29
    1de4:	cf 93       	push	r28
    1de6:	00 d0       	rcall	.+0      	; 0x1de8 <vEventGroupDelete+0x6>
    1de8:	00 d0       	rcall	.+0      	; 0x1dea <vEventGroupDelete+0x8>
    1dea:	00 d0       	rcall	.+0      	; 0x1dec <vEventGroupDelete+0xa>
    1dec:	cd b7       	in	r28, 0x3d	; 61
    1dee:	de b7       	in	r29, 0x3e	; 62
    1df0:	9e 83       	std	Y+6, r25	; 0x06
    1df2:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    1df4:	8d 81       	ldd	r24, Y+5	; 0x05
    1df6:	9e 81       	ldd	r25, Y+6	; 0x06
    1df8:	9c 83       	std	Y+4, r25	; 0x04
    1dfa:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1dfc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dfe:	9c 81       	ldd	r25, Y+4	; 0x04
    1e00:	02 96       	adiw	r24, 0x02	; 2
    1e02:	9a 83       	std	Y+2, r25	; 0x02
    1e04:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    1e06:	0e 94 84 28 	call	0x5108	; 0x5108 <vTaskSuspendAll>
    1e0a:	08 c0       	rjmp	.+16     	; 0x1e1c <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1e0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e10:	85 81       	ldd	r24, Z+5	; 0x05
    1e12:	96 81       	ldd	r25, Z+6	; 0x06
    1e14:	60 e0       	ldi	r22, 0x00	; 0
    1e16:	72 e0       	ldi	r23, 0x02	; 2
    1e18:	0e 94 8f 2b 	call	0x571e	; 0x571e <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1e1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e20:	80 81       	ld	r24, Z
    1e22:	88 23       	and	r24, r24
    1e24:	99 f7       	brne	.-26     	; 0x1e0c <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    1e26:	8b 81       	ldd	r24, Y+3	; 0x03
    1e28:	9c 81       	ldd	r25, Y+4	; 0x04
    1e2a:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    1e2e:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
}
    1e32:	26 96       	adiw	r28, 0x06	; 6
    1e34:	0f b6       	in	r0, 0x3f	; 63
    1e36:	f8 94       	cli
    1e38:	de bf       	out	0x3e, r29	; 62
    1e3a:	0f be       	out	0x3f, r0	; 63
    1e3c:	cd bf       	out	0x3d, r28	; 61
    1e3e:	cf 91       	pop	r28
    1e40:	df 91       	pop	r29
    1e42:	08 95       	ret

00001e44 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    1e44:	df 93       	push	r29
    1e46:	cf 93       	push	r28
    1e48:	00 d0       	rcall	.+0      	; 0x1e4a <vEventGroupSetBitsCallback+0x6>
    1e4a:	00 d0       	rcall	.+0      	; 0x1e4c <vEventGroupSetBitsCallback+0x8>
    1e4c:	00 d0       	rcall	.+0      	; 0x1e4e <vEventGroupSetBitsCallback+0xa>
    1e4e:	cd b7       	in	r28, 0x3d	; 61
    1e50:	de b7       	in	r29, 0x3e	; 62
    1e52:	9a 83       	std	Y+2, r25	; 0x02
    1e54:	89 83       	std	Y+1, r24	; 0x01
    1e56:	4b 83       	std	Y+3, r20	; 0x03
    1e58:	5c 83       	std	Y+4, r21	; 0x04
    1e5a:	6d 83       	std	Y+5, r22	; 0x05
    1e5c:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1e5e:	89 81       	ldd	r24, Y+1	; 0x01
    1e60:	9a 81       	ldd	r25, Y+2	; 0x02
    1e62:	2b 81       	ldd	r18, Y+3	; 0x03
    1e64:	3c 81       	ldd	r19, Y+4	; 0x04
    1e66:	b9 01       	movw	r22, r18
    1e68:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <xEventGroupSetBits>
}
    1e6c:	26 96       	adiw	r28, 0x06	; 6
    1e6e:	0f b6       	in	r0, 0x3f	; 63
    1e70:	f8 94       	cli
    1e72:	de bf       	out	0x3e, r29	; 62
    1e74:	0f be       	out	0x3f, r0	; 63
    1e76:	cd bf       	out	0x3d, r28	; 61
    1e78:	cf 91       	pop	r28
    1e7a:	df 91       	pop	r29
    1e7c:	08 95       	ret

00001e7e <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    1e7e:	df 93       	push	r29
    1e80:	cf 93       	push	r28
    1e82:	00 d0       	rcall	.+0      	; 0x1e84 <vEventGroupClearBitsCallback+0x6>
    1e84:	00 d0       	rcall	.+0      	; 0x1e86 <vEventGroupClearBitsCallback+0x8>
    1e86:	00 d0       	rcall	.+0      	; 0x1e88 <vEventGroupClearBitsCallback+0xa>
    1e88:	cd b7       	in	r28, 0x3d	; 61
    1e8a:	de b7       	in	r29, 0x3e	; 62
    1e8c:	9a 83       	std	Y+2, r25	; 0x02
    1e8e:	89 83       	std	Y+1, r24	; 0x01
    1e90:	4b 83       	std	Y+3, r20	; 0x03
    1e92:	5c 83       	std	Y+4, r21	; 0x04
    1e94:	6d 83       	std	Y+5, r22	; 0x05
    1e96:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1e98:	89 81       	ldd	r24, Y+1	; 0x01
    1e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e9c:	2b 81       	ldd	r18, Y+3	; 0x03
    1e9e:	3c 81       	ldd	r19, Y+4	; 0x04
    1ea0:	b9 01       	movw	r22, r18
    1ea2:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <xEventGroupClearBits>
}
    1ea6:	26 96       	adiw	r28, 0x06	; 6
    1ea8:	0f b6       	in	r0, 0x3f	; 63
    1eaa:	f8 94       	cli
    1eac:	de bf       	out	0x3e, r29	; 62
    1eae:	0f be       	out	0x3f, r0	; 63
    1eb0:	cd bf       	out	0x3d, r28	; 61
    1eb2:	cf 91       	pop	r28
    1eb4:	df 91       	pop	r29
    1eb6:	08 95       	ret

00001eb8 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    1eb8:	df 93       	push	r29
    1eba:	cf 93       	push	r28
    1ebc:	00 d0       	rcall	.+0      	; 0x1ebe <prvTestWaitCondition+0x6>
    1ebe:	00 d0       	rcall	.+0      	; 0x1ec0 <prvTestWaitCondition+0x8>
    1ec0:	00 d0       	rcall	.+0      	; 0x1ec2 <prvTestWaitCondition+0xa>
    1ec2:	cd b7       	in	r28, 0x3d	; 61
    1ec4:	de b7       	in	r29, 0x3e	; 62
    1ec6:	9b 83       	std	Y+3, r25	; 0x03
    1ec8:	8a 83       	std	Y+2, r24	; 0x02
    1eca:	7d 83       	std	Y+5, r23	; 0x05
    1ecc:	6c 83       	std	Y+4, r22	; 0x04
    1ece:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    1ed0:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    1ed2:	8e 81       	ldd	r24, Y+6	; 0x06
    1ed4:	88 23       	and	r24, r24
    1ed6:	59 f4       	brne	.+22     	; 0x1eee <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1ed8:	8a 81       	ldd	r24, Y+2	; 0x02
    1eda:	9b 81       	ldd	r25, Y+3	; 0x03
    1edc:	2c 81       	ldd	r18, Y+4	; 0x04
    1ede:	3d 81       	ldd	r19, Y+5	; 0x05
    1ee0:	82 23       	and	r24, r18
    1ee2:	93 23       	and	r25, r19
    1ee4:	00 97       	sbiw	r24, 0x00	; 0
    1ee6:	81 f0       	breq	.+32     	; 0x1f08 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1ee8:	81 e0       	ldi	r24, 0x01	; 1
    1eea:	89 83       	std	Y+1, r24	; 0x01
    1eec:	0d c0       	rjmp	.+26     	; 0x1f08 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1eee:	2a 81       	ldd	r18, Y+2	; 0x02
    1ef0:	3b 81       	ldd	r19, Y+3	; 0x03
    1ef2:	8c 81       	ldd	r24, Y+4	; 0x04
    1ef4:	9d 81       	ldd	r25, Y+5	; 0x05
    1ef6:	28 23       	and	r18, r24
    1ef8:	39 23       	and	r19, r25
    1efa:	8c 81       	ldd	r24, Y+4	; 0x04
    1efc:	9d 81       	ldd	r25, Y+5	; 0x05
    1efe:	28 17       	cp	r18, r24
    1f00:	39 07       	cpc	r19, r25
    1f02:	11 f4       	brne	.+4      	; 0x1f08 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1f04:	81 e0       	ldi	r24, 0x01	; 1
    1f06:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    1f08:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f0a:	26 96       	adiw	r28, 0x06	; 6
    1f0c:	0f b6       	in	r0, 0x3f	; 63
    1f0e:	f8 94       	cli
    1f10:	de bf       	out	0x3e, r29	; 62
    1f12:	0f be       	out	0x3f, r0	; 63
    1f14:	cd bf       	out	0x3d, r28	; 61
    1f16:	cf 91       	pop	r28
    1f18:	df 91       	pop	r29
    1f1a:	08 95       	ret

00001f1c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1f1c:	df 93       	push	r29
    1f1e:	cf 93       	push	r28
    1f20:	00 d0       	rcall	.+0      	; 0x1f22 <pvPortMalloc+0x6>
    1f22:	00 d0       	rcall	.+0      	; 0x1f24 <pvPortMalloc+0x8>
    1f24:	cd b7       	in	r28, 0x3d	; 61
    1f26:	de b7       	in	r29, 0x3e	; 62
    1f28:	9c 83       	std	Y+4, r25	; 0x04
    1f2a:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    1f2c:	1a 82       	std	Y+2, r1	; 0x02
    1f2e:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1f30:	0e 94 84 28 	call	0x5108	; 0x5108 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1f34:	80 91 ca 00 	lds	r24, 0x00CA
    1f38:	90 91 cb 00 	lds	r25, 0x00CB
    1f3c:	00 97       	sbiw	r24, 0x00	; 0
    1f3e:	31 f4       	brne	.+12     	; 0x1f4c <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1f40:	8d ec       	ldi	r24, 0xCD	; 205
    1f42:	90 e0       	ldi	r25, 0x00	; 0
    1f44:	90 93 cb 00 	sts	0x00CB, r25
    1f48:	80 93 ca 00 	sts	0x00CA, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1f4c:	80 91 c8 00 	lds	r24, 0x00C8
    1f50:	90 91 c9 00 	lds	r25, 0x00C9
    1f54:	2b 81       	ldd	r18, Y+3	; 0x03
    1f56:	3c 81       	ldd	r19, Y+4	; 0x04
    1f58:	82 0f       	add	r24, r18
    1f5a:	93 1f       	adc	r25, r19
    1f5c:	25 e0       	ldi	r18, 0x05	; 5
    1f5e:	8b 3d       	cpi	r24, 0xDB	; 219
    1f60:	92 07       	cpc	r25, r18
    1f62:	38 f5       	brcc	.+78     	; 0x1fb2 <pvPortMalloc+0x96>
    1f64:	20 91 c8 00 	lds	r18, 0x00C8
    1f68:	30 91 c9 00 	lds	r19, 0x00C9
    1f6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f6e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f70:	28 0f       	add	r18, r24
    1f72:	39 1f       	adc	r19, r25
    1f74:	80 91 c8 00 	lds	r24, 0x00C8
    1f78:	90 91 c9 00 	lds	r25, 0x00C9
    1f7c:	82 17       	cp	r24, r18
    1f7e:	93 07       	cpc	r25, r19
    1f80:	c0 f4       	brcc	.+48     	; 0x1fb2 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1f82:	20 91 ca 00 	lds	r18, 0x00CA
    1f86:	30 91 cb 00 	lds	r19, 0x00CB
    1f8a:	80 91 c8 00 	lds	r24, 0x00C8
    1f8e:	90 91 c9 00 	lds	r25, 0x00C9
    1f92:	82 0f       	add	r24, r18
    1f94:	93 1f       	adc	r25, r19
    1f96:	9a 83       	std	Y+2, r25	; 0x02
    1f98:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1f9a:	20 91 c8 00 	lds	r18, 0x00C8
    1f9e:	30 91 c9 00 	lds	r19, 0x00C9
    1fa2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fa6:	82 0f       	add	r24, r18
    1fa8:	93 1f       	adc	r25, r19
    1faa:	90 93 c9 00 	sts	0x00C9, r25
    1fae:	80 93 c8 00 	sts	0x00C8, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1fb2:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    1fb6:	89 81       	ldd	r24, Y+1	; 0x01
    1fb8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1fba:	0f 90       	pop	r0
    1fbc:	0f 90       	pop	r0
    1fbe:	0f 90       	pop	r0
    1fc0:	0f 90       	pop	r0
    1fc2:	cf 91       	pop	r28
    1fc4:	df 91       	pop	r29
    1fc6:	08 95       	ret

00001fc8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1fc8:	df 93       	push	r29
    1fca:	cf 93       	push	r28
    1fcc:	00 d0       	rcall	.+0      	; 0x1fce <vPortFree+0x6>
    1fce:	cd b7       	in	r28, 0x3d	; 61
    1fd0:	de b7       	in	r29, 0x3e	; 62
    1fd2:	9a 83       	std	Y+2, r25	; 0x02
    1fd4:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1fd6:	0f 90       	pop	r0
    1fd8:	0f 90       	pop	r0
    1fda:	cf 91       	pop	r28
    1fdc:	df 91       	pop	r29
    1fde:	08 95       	ret

00001fe0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1fe0:	df 93       	push	r29
    1fe2:	cf 93       	push	r28
    1fe4:	cd b7       	in	r28, 0x3d	; 61
    1fe6:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1fe8:	10 92 c9 00 	sts	0x00C9, r1
    1fec:	10 92 c8 00 	sts	0x00C8, r1
}
    1ff0:	cf 91       	pop	r28
    1ff2:	df 91       	pop	r29
    1ff4:	08 95       	ret

00001ff6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1ff6:	df 93       	push	r29
    1ff8:	cf 93       	push	r28
    1ffa:	cd b7       	in	r28, 0x3d	; 61
    1ffc:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1ffe:	20 91 c8 00 	lds	r18, 0x00C8
    2002:	30 91 c9 00 	lds	r19, 0x00C9
    2006:	8b ed       	ldi	r24, 0xDB	; 219
    2008:	95 e0       	ldi	r25, 0x05	; 5
    200a:	82 1b       	sub	r24, r18
    200c:	93 0b       	sbc	r25, r19
}
    200e:	cf 91       	pop	r28
    2010:	df 91       	pop	r29
    2012:	08 95       	ret

00002014 <LCD_init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_init(void)
{
    2014:	df 93       	push	r29
    2016:	cf 93       	push	r28
    2018:	cd b7       	in	r28, 0x3d	; 61
    201a:	de b7       	in	r29, 0x3e	; 62

	LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW); /* Configure the control pins(E,RS,RW) as output pins */
    201c:	aa e3       	ldi	r26, 0x3A	; 58
    201e:	b0 e0       	ldi	r27, 0x00	; 0
    2020:	ea e3       	ldi	r30, 0x3A	; 58
    2022:	f0 e0       	ldi	r31, 0x00	; 0
    2024:	80 81       	ld	r24, Z
    2026:	8e 60       	ori	r24, 0x0E	; 14
    2028:	8c 93       	st	X, r24

#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT_DIR |= 0xF0; /* Configure the highest 4 bits of the data port as output pins */
    202a:	aa e3       	ldi	r26, 0x3A	; 58
    202c:	b0 e0       	ldi	r27, 0x00	; 0
    202e:	ea e3       	ldi	r30, 0x3A	; 58
    2030:	f0 e0       	ldi	r31, 0x00	; 0
    2032:	80 81       	ld	r24, Z
    2034:	80 6f       	ori	r24, 0xF0	; 240
    2036:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT_DIR |= 0x0F; /* Configure the lowest 4 bits of the data port as output pins */
#endif

	LCD_sendCommand(FOUR_BITS_DATA_MODE); /* initialize LCD in 4-bit mode */
    2038:	82 e0       	ldi	r24, 0x02	; 2
    203a:	0e 94 2b 10 	call	0x2056	; 0x2056 <LCD_sendCommand>

	LCD_sendCommand(TWO_LINE_LCD_Four_BIT_MODE); /* use 2-line lcd + 4-bit Data Mode + 5*7 dot display Mode */
    203e:	88 e2       	ldi	r24, 0x28	; 40
    2040:	0e 94 2b 10 	call	0x2056	; 0x2056 <LCD_sendCommand>
#elif (DATA_BITS_MODE == 8)
	LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
	LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
#endif

	LCD_sendCommand(CURSOR_OFF); /* cursor off */
    2044:	8c e0       	ldi	r24, 0x0C	; 12
    2046:	0e 94 2b 10 	call	0x2056	; 0x2056 <LCD_sendCommand>
	LCD_sendCommand(CLEAR_COMMAND); /* clear LCD at the beginning */
    204a:	81 e0       	ldi	r24, 0x01	; 1
    204c:	0e 94 2b 10 	call	0x2056	; 0x2056 <LCD_sendCommand>

}
    2050:	cf 91       	pop	r28
    2052:	df 91       	pop	r29
    2054:	08 95       	ret

00002056 <LCD_sendCommand>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_sendCommand(uint8 command)
{
    2056:	df 93       	push	r29
    2058:	cf 93       	push	r28
    205a:	0f 92       	push	r0
    205c:	cd b7       	in	r28, 0x3d	; 61
    205e:	de b7       	in	r29, 0x3e	; 62
    2060:	89 83       	std	Y+1, r24	; 0x01
	CLEAR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
    2062:	ab e3       	ldi	r26, 0x3B	; 59
    2064:	b0 e0       	ldi	r27, 0x00	; 0
    2066:	eb e3       	ldi	r30, 0x3B	; 59
    2068:	f0 e0       	ldi	r31, 0x00	; 0
    206a:	80 81       	ld	r24, Z
    206c:	8d 7f       	andi	r24, 0xFD	; 253
    206e:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    2070:	ab e3       	ldi	r26, 0x3B	; 59
    2072:	b0 e0       	ldi	r27, 0x00	; 0
    2074:	eb e3       	ldi	r30, 0x3B	; 59
    2076:	f0 e0       	ldi	r31, 0x00	; 0
    2078:	80 81       	ld	r24, Z
    207a:	8b 7f       	andi	r24, 0xFB	; 251
    207c:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    207e:	81 e0       	ldi	r24, 0x01	; 1
    2080:	90 e0       	ldi	r25, 0x00	; 0
    2082:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    2086:	ab e3       	ldi	r26, 0x3B	; 59
    2088:	b0 e0       	ldi	r27, 0x00	; 0
    208a:	eb e3       	ldi	r30, 0x3B	; 59
    208c:	f0 e0       	ldi	r31, 0x00	; 0
    208e:	80 81       	ld	r24, Z
    2090:	88 60       	ori	r24, 0x08	; 8
    2092:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    2094:	81 e0       	ldi	r24, 0x01	; 1
    2096:	90 e0       	ldi	r25, 0x00	; 0
    2098:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (command & 0xF0);
    209c:	ab e3       	ldi	r26, 0x3B	; 59
    209e:	b0 e0       	ldi	r27, 0x00	; 0
    20a0:	eb e3       	ldi	r30, 0x3B	; 59
    20a2:	f0 e0       	ldi	r31, 0x00	; 0
    20a4:	80 81       	ld	r24, Z
    20a6:	98 2f       	mov	r25, r24
    20a8:	9f 70       	andi	r25, 0x0F	; 15
    20aa:	89 81       	ldd	r24, Y+1	; 0x01
    20ac:	80 7f       	andi	r24, 0xF0	; 240
    20ae:	89 2b       	or	r24, r25
    20b0:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((command & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    20b2:	81 e0       	ldi	r24, 0x01	; 1
    20b4:	90 e0       	ldi	r25, 0x00	; 0
    20b6:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    20ba:	ab e3       	ldi	r26, 0x3B	; 59
    20bc:	b0 e0       	ldi	r27, 0x00	; 0
    20be:	eb e3       	ldi	r30, 0x3B	; 59
    20c0:	f0 e0       	ldi	r31, 0x00	; 0
    20c2:	80 81       	ld	r24, Z
    20c4:	87 7f       	andi	r24, 0xF7	; 247
    20c6:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    20c8:	81 e0       	ldi	r24, 0x01	; 1
    20ca:	90 e0       	ldi	r25, 0x00	; 0
    20cc:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    20d0:	ab e3       	ldi	r26, 0x3B	; 59
    20d2:	b0 e0       	ldi	r27, 0x00	; 0
    20d4:	eb e3       	ldi	r30, 0x3B	; 59
    20d6:	f0 e0       	ldi	r31, 0x00	; 0
    20d8:	80 81       	ld	r24, Z
    20da:	88 60       	ori	r24, 0x08	; 8
    20dc:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    20de:	81 e0       	ldi	r24, 0x01	; 1
    20e0:	90 e0       	ldi	r25, 0x00	; 0
    20e2:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>

	/* out the lowest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((command & 0x0F) << 4);
    20e6:	ab e3       	ldi	r26, 0x3B	; 59
    20e8:	b0 e0       	ldi	r27, 0x00	; 0
    20ea:	eb e3       	ldi	r30, 0x3B	; 59
    20ec:	f0 e0       	ldi	r31, 0x00	; 0
    20ee:	80 81       	ld	r24, Z
    20f0:	28 2f       	mov	r18, r24
    20f2:	2f 70       	andi	r18, 0x0F	; 15
    20f4:	89 81       	ldd	r24, Y+1	; 0x01
    20f6:	88 2f       	mov	r24, r24
    20f8:	90 e0       	ldi	r25, 0x00	; 0
    20fa:	82 95       	swap	r24
    20fc:	92 95       	swap	r25
    20fe:	90 7f       	andi	r25, 0xF0	; 240
    2100:	98 27       	eor	r25, r24
    2102:	80 7f       	andi	r24, 0xF0	; 240
    2104:	98 27       	eor	r25, r24
    2106:	82 2b       	or	r24, r18
    2108:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (command & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    210a:	81 e0       	ldi	r24, 0x01	; 1
    210c:	90 e0       	ldi	r25, 0x00	; 0
    210e:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    2112:	ab e3       	ldi	r26, 0x3B	; 59
    2114:	b0 e0       	ldi	r27, 0x00	; 0
    2116:	eb e3       	ldi	r30, 0x3B	; 59
    2118:	f0 e0       	ldi	r31, 0x00	; 0
    211a:	80 81       	ld	r24, Z
    211c:	87 7f       	andi	r24, 0xF7	; 247
    211e:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    2120:	81 e0       	ldi	r24, 0x01	; 1
    2122:	90 e0       	ldi	r25, 0x00	; 0
    2124:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    2128:	0f 90       	pop	r0
    212a:	cf 91       	pop	r28
    212c:	df 91       	pop	r29
    212e:	08 95       	ret

00002130 <LCD_displayCharacter>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayCharacter(uint8 data)
{
    2130:	df 93       	push	r29
    2132:	cf 93       	push	r28
    2134:	0f 92       	push	r0
    2136:	cd b7       	in	r28, 0x3d	; 61
    2138:	de b7       	in	r29, 0x3e	; 62
    213a:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
    213c:	ab e3       	ldi	r26, 0x3B	; 59
    213e:	b0 e0       	ldi	r27, 0x00	; 0
    2140:	eb e3       	ldi	r30, 0x3B	; 59
    2142:	f0 e0       	ldi	r31, 0x00	; 0
    2144:	80 81       	ld	r24, Z
    2146:	82 60       	ori	r24, 0x02	; 2
    2148:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    214a:	ab e3       	ldi	r26, 0x3B	; 59
    214c:	b0 e0       	ldi	r27, 0x00	; 0
    214e:	eb e3       	ldi	r30, 0x3B	; 59
    2150:	f0 e0       	ldi	r31, 0x00	; 0
    2152:	80 81       	ld	r24, Z
    2154:	8b 7f       	andi	r24, 0xFB	; 251
    2156:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    2158:	81 e0       	ldi	r24, 0x01	; 1
    215a:	90 e0       	ldi	r25, 0x00	; 0
    215c:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    2160:	ab e3       	ldi	r26, 0x3B	; 59
    2162:	b0 e0       	ldi	r27, 0x00	; 0
    2164:	eb e3       	ldi	r30, 0x3B	; 59
    2166:	f0 e0       	ldi	r31, 0x00	; 0
    2168:	80 81       	ld	r24, Z
    216a:	88 60       	ori	r24, 0x08	; 8
    216c:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    216e:	81 e0       	ldi	r24, 0x01	; 1
    2170:	90 e0       	ldi	r25, 0x00	; 0
    2172:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (data & 0xF0);
    2176:	ab e3       	ldi	r26, 0x3B	; 59
    2178:	b0 e0       	ldi	r27, 0x00	; 0
    217a:	eb e3       	ldi	r30, 0x3B	; 59
    217c:	f0 e0       	ldi	r31, 0x00	; 0
    217e:	80 81       	ld	r24, Z
    2180:	98 2f       	mov	r25, r24
    2182:	9f 70       	andi	r25, 0x0F	; 15
    2184:	89 81       	ldd	r24, Y+1	; 0x01
    2186:	80 7f       	andi	r24, 0xF0	; 240
    2188:	89 2b       	or	r24, r25
    218a:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((data & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    218c:	81 e0       	ldi	r24, 0x01	; 1
    218e:	90 e0       	ldi	r25, 0x00	; 0
    2190:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    2194:	ab e3       	ldi	r26, 0x3B	; 59
    2196:	b0 e0       	ldi	r27, 0x00	; 0
    2198:	eb e3       	ldi	r30, 0x3B	; 59
    219a:	f0 e0       	ldi	r31, 0x00	; 0
    219c:	80 81       	ld	r24, Z
    219e:	87 7f       	andi	r24, 0xF7	; 247
    21a0:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    21a2:	81 e0       	ldi	r24, 0x01	; 1
    21a4:	90 e0       	ldi	r25, 0x00	; 0
    21a6:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    21aa:	ab e3       	ldi	r26, 0x3B	; 59
    21ac:	b0 e0       	ldi	r27, 0x00	; 0
    21ae:	eb e3       	ldi	r30, 0x3B	; 59
    21b0:	f0 e0       	ldi	r31, 0x00	; 0
    21b2:	80 81       	ld	r24, Z
    21b4:	88 60       	ori	r24, 0x08	; 8
    21b6:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    21b8:	81 e0       	ldi	r24, 0x01	; 1
    21ba:	90 e0       	ldi	r25, 0x00	; 0
    21bc:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>

	/* out the lowest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((data & 0x0F) << 4);
    21c0:	ab e3       	ldi	r26, 0x3B	; 59
    21c2:	b0 e0       	ldi	r27, 0x00	; 0
    21c4:	eb e3       	ldi	r30, 0x3B	; 59
    21c6:	f0 e0       	ldi	r31, 0x00	; 0
    21c8:	80 81       	ld	r24, Z
    21ca:	28 2f       	mov	r18, r24
    21cc:	2f 70       	andi	r18, 0x0F	; 15
    21ce:	89 81       	ldd	r24, Y+1	; 0x01
    21d0:	88 2f       	mov	r24, r24
    21d2:	90 e0       	ldi	r25, 0x00	; 0
    21d4:	82 95       	swap	r24
    21d6:	92 95       	swap	r25
    21d8:	90 7f       	andi	r25, 0xF0	; 240
    21da:	98 27       	eor	r25, r24
    21dc:	80 7f       	andi	r24, 0xF0	; 240
    21de:	98 27       	eor	r25, r24
    21e0:	82 2b       	or	r24, r18
    21e2:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (data & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    21e4:	81 e0       	ldi	r24, 0x01	; 1
    21e6:	90 e0       	ldi	r25, 0x00	; 0
    21e8:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    21ec:	ab e3       	ldi	r26, 0x3B	; 59
    21ee:	b0 e0       	ldi	r27, 0x00	; 0
    21f0:	eb e3       	ldi	r30, 0x3B	; 59
    21f2:	f0 e0       	ldi	r31, 0x00	; 0
    21f4:	80 81       	ld	r24, Z
    21f6:	87 7f       	andi	r24, 0xF7	; 247
    21f8:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    21fa:	81 e0       	ldi	r24, 0x01	; 1
    21fc:	90 e0       	ldi	r25, 0x00	; 0
    21fe:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    2202:	0f 90       	pop	r0
    2204:	cf 91       	pop	r28
    2206:	df 91       	pop	r29
    2208:	08 95       	ret

0000220a <LCD_displayString>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
    220a:	df 93       	push	r29
    220c:	cf 93       	push	r28
    220e:	00 d0       	rcall	.+0      	; 0x2210 <LCD_displayString+0x6>
    2210:	0f 92       	push	r0
    2212:	cd b7       	in	r28, 0x3d	; 61
    2214:	de b7       	in	r29, 0x3e	; 62
    2216:	9b 83       	std	Y+3, r25	; 0x03
    2218:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    221a:	19 82       	std	Y+1, r1	; 0x01
    221c:	0e c0       	rjmp	.+28     	; 0x223a <LCD_displayString+0x30>
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    221e:	89 81       	ldd	r24, Y+1	; 0x01
    2220:	28 2f       	mov	r18, r24
    2222:	30 e0       	ldi	r19, 0x00	; 0
    2224:	8a 81       	ldd	r24, Y+2	; 0x02
    2226:	9b 81       	ldd	r25, Y+3	; 0x03
    2228:	fc 01       	movw	r30, r24
    222a:	e2 0f       	add	r30, r18
    222c:	f3 1f       	adc	r31, r19
    222e:	80 81       	ld	r24, Z
    2230:	0e 94 98 10 	call	0x2130	; 0x2130 <LCD_displayCharacter>
		i++;
    2234:	89 81       	ldd	r24, Y+1	; 0x01
    2236:	8f 5f       	subi	r24, 0xFF	; 255
    2238:	89 83       	std	Y+1, r24	; 0x01
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
	uint8 i = 0;
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
    223a:	89 81       	ldd	r24, Y+1	; 0x01
    223c:	28 2f       	mov	r18, r24
    223e:	30 e0       	ldi	r19, 0x00	; 0
    2240:	8a 81       	ldd	r24, Y+2	; 0x02
    2242:	9b 81       	ldd	r25, Y+3	; 0x03
    2244:	fc 01       	movw	r30, r24
    2246:	e2 0f       	add	r30, r18
    2248:	f3 1f       	adc	r31, r19
    224a:	80 81       	ld	r24, Z
    224c:	88 23       	and	r24, r24
    224e:	39 f7       	brne	.-50     	; 0x221e <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	 *********************************************************/
}
    2250:	0f 90       	pop	r0
    2252:	0f 90       	pop	r0
    2254:	0f 90       	pop	r0
    2256:	cf 91       	pop	r28
    2258:	df 91       	pop	r29
    225a:	08 95       	ret

0000225c <LCD_goToRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_goToRowColumn(uint8 row,uint8 col)
{
    225c:	df 93       	push	r29
    225e:	cf 93       	push	r28
    2260:	00 d0       	rcall	.+0      	; 0x2262 <LCD_goToRowColumn+0x6>
    2262:	00 d0       	rcall	.+0      	; 0x2264 <LCD_goToRowColumn+0x8>
    2264:	0f 92       	push	r0
    2266:	cd b7       	in	r28, 0x3d	; 61
    2268:	de b7       	in	r29, 0x3e	; 62
    226a:	8a 83       	std	Y+2, r24	; 0x02
    226c:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;

	/* first of all calculate the required address */
	switch(row)
    226e:	8a 81       	ldd	r24, Y+2	; 0x02
    2270:	28 2f       	mov	r18, r24
    2272:	30 e0       	ldi	r19, 0x00	; 0
    2274:	3d 83       	std	Y+5, r19	; 0x05
    2276:	2c 83       	std	Y+4, r18	; 0x04
    2278:	8c 81       	ldd	r24, Y+4	; 0x04
    227a:	9d 81       	ldd	r25, Y+5	; 0x05
    227c:	81 30       	cpi	r24, 0x01	; 1
    227e:	91 05       	cpc	r25, r1
    2280:	c1 f0       	breq	.+48     	; 0x22b2 <LCD_goToRowColumn+0x56>
    2282:	2c 81       	ldd	r18, Y+4	; 0x04
    2284:	3d 81       	ldd	r19, Y+5	; 0x05
    2286:	22 30       	cpi	r18, 0x02	; 2
    2288:	31 05       	cpc	r19, r1
    228a:	2c f4       	brge	.+10     	; 0x2296 <LCD_goToRowColumn+0x3a>
    228c:	8c 81       	ldd	r24, Y+4	; 0x04
    228e:	9d 81       	ldd	r25, Y+5	; 0x05
    2290:	00 97       	sbiw	r24, 0x00	; 0
    2292:	61 f0       	breq	.+24     	; 0x22ac <LCD_goToRowColumn+0x50>
    2294:	19 c0       	rjmp	.+50     	; 0x22c8 <LCD_goToRowColumn+0x6c>
    2296:	2c 81       	ldd	r18, Y+4	; 0x04
    2298:	3d 81       	ldd	r19, Y+5	; 0x05
    229a:	22 30       	cpi	r18, 0x02	; 2
    229c:	31 05       	cpc	r19, r1
    229e:	69 f0       	breq	.+26     	; 0x22ba <LCD_goToRowColumn+0x5e>
    22a0:	8c 81       	ldd	r24, Y+4	; 0x04
    22a2:	9d 81       	ldd	r25, Y+5	; 0x05
    22a4:	83 30       	cpi	r24, 0x03	; 3
    22a6:	91 05       	cpc	r25, r1
    22a8:	61 f0       	breq	.+24     	; 0x22c2 <LCD_goToRowColumn+0x66>
    22aa:	0e c0       	rjmp	.+28     	; 0x22c8 <LCD_goToRowColumn+0x6c>
	{
	case 0:
		Address=col;
    22ac:	8b 81       	ldd	r24, Y+3	; 0x03
    22ae:	89 83       	std	Y+1, r24	; 0x01
    22b0:	0b c0       	rjmp	.+22     	; 0x22c8 <LCD_goToRowColumn+0x6c>
		break;
	case 1:
		Address=col+0x40;
    22b2:	8b 81       	ldd	r24, Y+3	; 0x03
    22b4:	80 5c       	subi	r24, 0xC0	; 192
    22b6:	89 83       	std	Y+1, r24	; 0x01
    22b8:	07 c0       	rjmp	.+14     	; 0x22c8 <LCD_goToRowColumn+0x6c>
		break;
	case 2:
		Address=col+0x10;
    22ba:	8b 81       	ldd	r24, Y+3	; 0x03
    22bc:	80 5f       	subi	r24, 0xF0	; 240
    22be:	89 83       	std	Y+1, r24	; 0x01
    22c0:	03 c0       	rjmp	.+6      	; 0x22c8 <LCD_goToRowColumn+0x6c>
		break;
	case 3:
		Address=col+0x50;
    22c2:	8b 81       	ldd	r24, Y+3	; 0x03
    22c4:	80 5b       	subi	r24, 0xB0	; 176
    22c6:	89 83       	std	Y+1, r24	; 0x01
		break;
	}					
	/* to write to a specific address in the LCD 
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION); 
    22c8:	89 81       	ldd	r24, Y+1	; 0x01
    22ca:	80 68       	ori	r24, 0x80	; 128
    22cc:	0e 94 2b 10 	call	0x2056	; 0x2056 <LCD_sendCommand>
}
    22d0:	0f 90       	pop	r0
    22d2:	0f 90       	pop	r0
    22d4:	0f 90       	pop	r0
    22d6:	0f 90       	pop	r0
    22d8:	0f 90       	pop	r0
    22da:	cf 91       	pop	r28
    22dc:	df 91       	pop	r29
    22de:	08 95       	ret

000022e0 <LCD_displayStringRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayStringRowColumn(uint8 row,uint8 col,const uint8 *Str)
{
    22e0:	df 93       	push	r29
    22e2:	cf 93       	push	r28
    22e4:	00 d0       	rcall	.+0      	; 0x22e6 <LCD_displayStringRowColumn+0x6>
    22e6:	00 d0       	rcall	.+0      	; 0x22e8 <LCD_displayStringRowColumn+0x8>
    22e8:	cd b7       	in	r28, 0x3d	; 61
    22ea:	de b7       	in	r29, 0x3e	; 62
    22ec:	89 83       	std	Y+1, r24	; 0x01
    22ee:	6a 83       	std	Y+2, r22	; 0x02
    22f0:	5c 83       	std	Y+4, r21	; 0x04
    22f2:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    22f4:	89 81       	ldd	r24, Y+1	; 0x01
    22f6:	6a 81       	ldd	r22, Y+2	; 0x02
    22f8:	0e 94 2e 11 	call	0x225c	; 0x225c <LCD_goToRowColumn>
	LCD_displayString(Str); /* display the string */
    22fc:	8b 81       	ldd	r24, Y+3	; 0x03
    22fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2300:	0e 94 05 11 	call	0x220a	; 0x220a <LCD_displayString>
}
    2304:	0f 90       	pop	r0
    2306:	0f 90       	pop	r0
    2308:	0f 90       	pop	r0
    230a:	0f 90       	pop	r0
    230c:	cf 91       	pop	r28
    230e:	df 91       	pop	r29
    2310:	08 95       	ret

00002312 <LCD_clearScreen>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_clearScreen(void)
{
    2312:	df 93       	push	r29
    2314:	cf 93       	push	r28
    2316:	cd b7       	in	r28, 0x3d	; 61
    2318:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(CLEAR_COMMAND); //clear display 
    231a:	81 e0       	ldi	r24, 0x01	; 1
    231c:	0e 94 2b 10 	call	0x2056	; 0x2056 <LCD_sendCommand>
}
    2320:	cf 91       	pop	r28
    2322:	df 91       	pop	r29
    2324:	08 95       	ret

00002326 <LCD_intgerToString>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_intgerToString(uint32 data)
{
    2326:	df 93       	push	r29
    2328:	cf 93       	push	r28
    232a:	cd b7       	in	r28, 0x3d	; 61
    232c:	de b7       	in	r29, 0x3e	; 62
    232e:	64 97       	sbiw	r28, 0x14	; 20
    2330:	0f b6       	in	r0, 0x3f	; 63
    2332:	f8 94       	cli
    2334:	de bf       	out	0x3e, r29	; 62
    2336:	0f be       	out	0x3f, r0	; 63
    2338:	cd bf       	out	0x3d, r28	; 61
    233a:	69 8b       	std	Y+17, r22	; 0x11
    233c:	7a 8b       	std	Y+18, r23	; 0x12
    233e:	8b 8b       	std	Y+19, r24	; 0x13
    2340:	9c 8b       	std	Y+20, r25	; 0x14
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* 10 for decimal */
    2342:	89 89       	ldd	r24, Y+17	; 0x11
    2344:	9a 89       	ldd	r25, Y+18	; 0x12
    2346:	ab 89       	ldd	r26, Y+19	; 0x13
    2348:	bc 89       	ldd	r27, Y+20	; 0x14
    234a:	bc 01       	movw	r22, r24
    234c:	cd 01       	movw	r24, r26
    234e:	9e 01       	movw	r18, r28
    2350:	2f 5f       	subi	r18, 0xFF	; 255
    2352:	3f 4f       	sbci	r19, 0xFF	; 255
    2354:	a9 01       	movw	r20, r18
    2356:	2a e0       	ldi	r18, 0x0A	; 10
    2358:	30 e0       	ldi	r19, 0x00	; 0
    235a:	0e 94 0f 32 	call	0x641e	; 0x641e <itoa>
   LCD_displayString(buff);
    235e:	ce 01       	movw	r24, r28
    2360:	01 96       	adiw	r24, 0x01	; 1
    2362:	0e 94 05 11 	call	0x220a	; 0x220a <LCD_displayString>
}
    2366:	64 96       	adiw	r28, 0x14	; 20
    2368:	0f b6       	in	r0, 0x3f	; 63
    236a:	f8 94       	cli
    236c:	de bf       	out	0x3e, r29	; 62
    236e:	0f be       	out	0x3f, r0	; 63
    2370:	cd bf       	out	0x3d, r28	; 61
    2372:	cf 91       	pop	r28
    2374:	df 91       	pop	r29
    2376:	08 95       	ret

00002378 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2378:	df 93       	push	r29
    237a:	cf 93       	push	r28
    237c:	00 d0       	rcall	.+0      	; 0x237e <vListInitialise+0x6>
    237e:	cd b7       	in	r28, 0x3d	; 61
    2380:	de b7       	in	r29, 0x3e	; 62
    2382:	9a 83       	std	Y+2, r25	; 0x02
    2384:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2386:	89 81       	ldd	r24, Y+1	; 0x01
    2388:	9a 81       	ldd	r25, Y+2	; 0x02
    238a:	03 96       	adiw	r24, 0x03	; 3
    238c:	e9 81       	ldd	r30, Y+1	; 0x01
    238e:	fa 81       	ldd	r31, Y+2	; 0x02
    2390:	92 83       	std	Z+2, r25	; 0x02
    2392:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2394:	e9 81       	ldd	r30, Y+1	; 0x01
    2396:	fa 81       	ldd	r31, Y+2	; 0x02
    2398:	8f ef       	ldi	r24, 0xFF	; 255
    239a:	9f ef       	ldi	r25, 0xFF	; 255
    239c:	94 83       	std	Z+4, r25	; 0x04
    239e:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    23a0:	89 81       	ldd	r24, Y+1	; 0x01
    23a2:	9a 81       	ldd	r25, Y+2	; 0x02
    23a4:	03 96       	adiw	r24, 0x03	; 3
    23a6:	e9 81       	ldd	r30, Y+1	; 0x01
    23a8:	fa 81       	ldd	r31, Y+2	; 0x02
    23aa:	96 83       	std	Z+6, r25	; 0x06
    23ac:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    23ae:	89 81       	ldd	r24, Y+1	; 0x01
    23b0:	9a 81       	ldd	r25, Y+2	; 0x02
    23b2:	03 96       	adiw	r24, 0x03	; 3
    23b4:	e9 81       	ldd	r30, Y+1	; 0x01
    23b6:	fa 81       	ldd	r31, Y+2	; 0x02
    23b8:	90 87       	std	Z+8, r25	; 0x08
    23ba:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    23bc:	e9 81       	ldd	r30, Y+1	; 0x01
    23be:	fa 81       	ldd	r31, Y+2	; 0x02
    23c0:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    23c2:	0f 90       	pop	r0
    23c4:	0f 90       	pop	r0
    23c6:	cf 91       	pop	r28
    23c8:	df 91       	pop	r29
    23ca:	08 95       	ret

000023cc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    23cc:	df 93       	push	r29
    23ce:	cf 93       	push	r28
    23d0:	00 d0       	rcall	.+0      	; 0x23d2 <vListInitialiseItem+0x6>
    23d2:	cd b7       	in	r28, 0x3d	; 61
    23d4:	de b7       	in	r29, 0x3e	; 62
    23d6:	9a 83       	std	Y+2, r25	; 0x02
    23d8:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    23da:	e9 81       	ldd	r30, Y+1	; 0x01
    23dc:	fa 81       	ldd	r31, Y+2	; 0x02
    23de:	11 86       	std	Z+9, r1	; 0x09
    23e0:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    23e2:	0f 90       	pop	r0
    23e4:	0f 90       	pop	r0
    23e6:	cf 91       	pop	r28
    23e8:	df 91       	pop	r29
    23ea:	08 95       	ret

000023ec <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    23ec:	df 93       	push	r29
    23ee:	cf 93       	push	r28
    23f0:	00 d0       	rcall	.+0      	; 0x23f2 <vListInsertEnd+0x6>
    23f2:	00 d0       	rcall	.+0      	; 0x23f4 <vListInsertEnd+0x8>
    23f4:	00 d0       	rcall	.+0      	; 0x23f6 <vListInsertEnd+0xa>
    23f6:	cd b7       	in	r28, 0x3d	; 61
    23f8:	de b7       	in	r29, 0x3e	; 62
    23fa:	9c 83       	std	Y+4, r25	; 0x04
    23fc:	8b 83       	std	Y+3, r24	; 0x03
    23fe:	7e 83       	std	Y+6, r23	; 0x06
    2400:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    2402:	eb 81       	ldd	r30, Y+3	; 0x03
    2404:	fc 81       	ldd	r31, Y+4	; 0x04
    2406:	81 81       	ldd	r24, Z+1	; 0x01
    2408:	92 81       	ldd	r25, Z+2	; 0x02
    240a:	9a 83       	std	Y+2, r25	; 0x02
    240c:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    240e:	ed 81       	ldd	r30, Y+5	; 0x05
    2410:	fe 81       	ldd	r31, Y+6	; 0x06
    2412:	89 81       	ldd	r24, Y+1	; 0x01
    2414:	9a 81       	ldd	r25, Y+2	; 0x02
    2416:	93 83       	std	Z+3, r25	; 0x03
    2418:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    241a:	e9 81       	ldd	r30, Y+1	; 0x01
    241c:	fa 81       	ldd	r31, Y+2	; 0x02
    241e:	84 81       	ldd	r24, Z+4	; 0x04
    2420:	95 81       	ldd	r25, Z+5	; 0x05
    2422:	ed 81       	ldd	r30, Y+5	; 0x05
    2424:	fe 81       	ldd	r31, Y+6	; 0x06
    2426:	95 83       	std	Z+5, r25	; 0x05
    2428:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    242a:	e9 81       	ldd	r30, Y+1	; 0x01
    242c:	fa 81       	ldd	r31, Y+2	; 0x02
    242e:	04 80       	ldd	r0, Z+4	; 0x04
    2430:	f5 81       	ldd	r31, Z+5	; 0x05
    2432:	e0 2d       	mov	r30, r0
    2434:	8d 81       	ldd	r24, Y+5	; 0x05
    2436:	9e 81       	ldd	r25, Y+6	; 0x06
    2438:	93 83       	std	Z+3, r25	; 0x03
    243a:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    243c:	e9 81       	ldd	r30, Y+1	; 0x01
    243e:	fa 81       	ldd	r31, Y+2	; 0x02
    2440:	8d 81       	ldd	r24, Y+5	; 0x05
    2442:	9e 81       	ldd	r25, Y+6	; 0x06
    2444:	95 83       	std	Z+5, r25	; 0x05
    2446:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    2448:	ed 81       	ldd	r30, Y+5	; 0x05
    244a:	fe 81       	ldd	r31, Y+6	; 0x06
    244c:	8b 81       	ldd	r24, Y+3	; 0x03
    244e:	9c 81       	ldd	r25, Y+4	; 0x04
    2450:	91 87       	std	Z+9, r25	; 0x09
    2452:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2454:	eb 81       	ldd	r30, Y+3	; 0x03
    2456:	fc 81       	ldd	r31, Y+4	; 0x04
    2458:	80 81       	ld	r24, Z
    245a:	8f 5f       	subi	r24, 0xFF	; 255
    245c:	eb 81       	ldd	r30, Y+3	; 0x03
    245e:	fc 81       	ldd	r31, Y+4	; 0x04
    2460:	80 83       	st	Z, r24
}
    2462:	26 96       	adiw	r28, 0x06	; 6
    2464:	0f b6       	in	r0, 0x3f	; 63
    2466:	f8 94       	cli
    2468:	de bf       	out	0x3e, r29	; 62
    246a:	0f be       	out	0x3f, r0	; 63
    246c:	cd bf       	out	0x3d, r28	; 61
    246e:	cf 91       	pop	r28
    2470:	df 91       	pop	r29
    2472:	08 95       	ret

00002474 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2474:	df 93       	push	r29
    2476:	cf 93       	push	r28
    2478:	cd b7       	in	r28, 0x3d	; 61
    247a:	de b7       	in	r29, 0x3e	; 62
    247c:	28 97       	sbiw	r28, 0x08	; 8
    247e:	0f b6       	in	r0, 0x3f	; 63
    2480:	f8 94       	cli
    2482:	de bf       	out	0x3e, r29	; 62
    2484:	0f be       	out	0x3f, r0	; 63
    2486:	cd bf       	out	0x3d, r28	; 61
    2488:	9e 83       	std	Y+6, r25	; 0x06
    248a:	8d 83       	std	Y+5, r24	; 0x05
    248c:	78 87       	std	Y+8, r23	; 0x08
    248e:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2490:	ef 81       	ldd	r30, Y+7	; 0x07
    2492:	f8 85       	ldd	r31, Y+8	; 0x08
    2494:	80 81       	ld	r24, Z
    2496:	91 81       	ldd	r25, Z+1	; 0x01
    2498:	9a 83       	std	Y+2, r25	; 0x02
    249a:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    249c:	89 81       	ldd	r24, Y+1	; 0x01
    249e:	9a 81       	ldd	r25, Y+2	; 0x02
    24a0:	2f ef       	ldi	r18, 0xFF	; 255
    24a2:	8f 3f       	cpi	r24, 0xFF	; 255
    24a4:	92 07       	cpc	r25, r18
    24a6:	39 f4       	brne	.+14     	; 0x24b6 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    24a8:	ed 81       	ldd	r30, Y+5	; 0x05
    24aa:	fe 81       	ldd	r31, Y+6	; 0x06
    24ac:	87 81       	ldd	r24, Z+7	; 0x07
    24ae:	90 85       	ldd	r25, Z+8	; 0x08
    24b0:	9c 83       	std	Y+4, r25	; 0x04
    24b2:	8b 83       	std	Y+3, r24	; 0x03
    24b4:	18 c0       	rjmp	.+48     	; 0x24e6 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    24b6:	8d 81       	ldd	r24, Y+5	; 0x05
    24b8:	9e 81       	ldd	r25, Y+6	; 0x06
    24ba:	03 96       	adiw	r24, 0x03	; 3
    24bc:	9c 83       	std	Y+4, r25	; 0x04
    24be:	8b 83       	std	Y+3, r24	; 0x03
    24c0:	06 c0       	rjmp	.+12     	; 0x24ce <vListInsert+0x5a>
    24c2:	eb 81       	ldd	r30, Y+3	; 0x03
    24c4:	fc 81       	ldd	r31, Y+4	; 0x04
    24c6:	82 81       	ldd	r24, Z+2	; 0x02
    24c8:	93 81       	ldd	r25, Z+3	; 0x03
    24ca:	9c 83       	std	Y+4, r25	; 0x04
    24cc:	8b 83       	std	Y+3, r24	; 0x03
    24ce:	eb 81       	ldd	r30, Y+3	; 0x03
    24d0:	fc 81       	ldd	r31, Y+4	; 0x04
    24d2:	02 80       	ldd	r0, Z+2	; 0x02
    24d4:	f3 81       	ldd	r31, Z+3	; 0x03
    24d6:	e0 2d       	mov	r30, r0
    24d8:	20 81       	ld	r18, Z
    24da:	31 81       	ldd	r19, Z+1	; 0x01
    24dc:	89 81       	ldd	r24, Y+1	; 0x01
    24de:	9a 81       	ldd	r25, Y+2	; 0x02
    24e0:	82 17       	cp	r24, r18
    24e2:	93 07       	cpc	r25, r19
    24e4:	70 f7       	brcc	.-36     	; 0x24c2 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    24e6:	eb 81       	ldd	r30, Y+3	; 0x03
    24e8:	fc 81       	ldd	r31, Y+4	; 0x04
    24ea:	82 81       	ldd	r24, Z+2	; 0x02
    24ec:	93 81       	ldd	r25, Z+3	; 0x03
    24ee:	ef 81       	ldd	r30, Y+7	; 0x07
    24f0:	f8 85       	ldd	r31, Y+8	; 0x08
    24f2:	93 83       	std	Z+3, r25	; 0x03
    24f4:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    24f6:	ef 81       	ldd	r30, Y+7	; 0x07
    24f8:	f8 85       	ldd	r31, Y+8	; 0x08
    24fa:	02 80       	ldd	r0, Z+2	; 0x02
    24fc:	f3 81       	ldd	r31, Z+3	; 0x03
    24fe:	e0 2d       	mov	r30, r0
    2500:	8f 81       	ldd	r24, Y+7	; 0x07
    2502:	98 85       	ldd	r25, Y+8	; 0x08
    2504:	95 83       	std	Z+5, r25	; 0x05
    2506:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2508:	ef 81       	ldd	r30, Y+7	; 0x07
    250a:	f8 85       	ldd	r31, Y+8	; 0x08
    250c:	8b 81       	ldd	r24, Y+3	; 0x03
    250e:	9c 81       	ldd	r25, Y+4	; 0x04
    2510:	95 83       	std	Z+5, r25	; 0x05
    2512:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2514:	eb 81       	ldd	r30, Y+3	; 0x03
    2516:	fc 81       	ldd	r31, Y+4	; 0x04
    2518:	8f 81       	ldd	r24, Y+7	; 0x07
    251a:	98 85       	ldd	r25, Y+8	; 0x08
    251c:	93 83       	std	Z+3, r25	; 0x03
    251e:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    2520:	ef 81       	ldd	r30, Y+7	; 0x07
    2522:	f8 85       	ldd	r31, Y+8	; 0x08
    2524:	8d 81       	ldd	r24, Y+5	; 0x05
    2526:	9e 81       	ldd	r25, Y+6	; 0x06
    2528:	91 87       	std	Z+9, r25	; 0x09
    252a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    252c:	ed 81       	ldd	r30, Y+5	; 0x05
    252e:	fe 81       	ldd	r31, Y+6	; 0x06
    2530:	80 81       	ld	r24, Z
    2532:	8f 5f       	subi	r24, 0xFF	; 255
    2534:	ed 81       	ldd	r30, Y+5	; 0x05
    2536:	fe 81       	ldd	r31, Y+6	; 0x06
    2538:	80 83       	st	Z, r24
}
    253a:	28 96       	adiw	r28, 0x08	; 8
    253c:	0f b6       	in	r0, 0x3f	; 63
    253e:	f8 94       	cli
    2540:	de bf       	out	0x3e, r29	; 62
    2542:	0f be       	out	0x3f, r0	; 63
    2544:	cd bf       	out	0x3d, r28	; 61
    2546:	cf 91       	pop	r28
    2548:	df 91       	pop	r29
    254a:	08 95       	ret

0000254c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    254c:	df 93       	push	r29
    254e:	cf 93       	push	r28
    2550:	00 d0       	rcall	.+0      	; 0x2552 <uxListRemove+0x6>
    2552:	00 d0       	rcall	.+0      	; 0x2554 <uxListRemove+0x8>
    2554:	cd b7       	in	r28, 0x3d	; 61
    2556:	de b7       	in	r29, 0x3e	; 62
    2558:	9c 83       	std	Y+4, r25	; 0x04
    255a:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    255c:	eb 81       	ldd	r30, Y+3	; 0x03
    255e:	fc 81       	ldd	r31, Y+4	; 0x04
    2560:	80 85       	ldd	r24, Z+8	; 0x08
    2562:	91 85       	ldd	r25, Z+9	; 0x09
    2564:	9a 83       	std	Y+2, r25	; 0x02
    2566:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2568:	eb 81       	ldd	r30, Y+3	; 0x03
    256a:	fc 81       	ldd	r31, Y+4	; 0x04
    256c:	a2 81       	ldd	r26, Z+2	; 0x02
    256e:	b3 81       	ldd	r27, Z+3	; 0x03
    2570:	eb 81       	ldd	r30, Y+3	; 0x03
    2572:	fc 81       	ldd	r31, Y+4	; 0x04
    2574:	84 81       	ldd	r24, Z+4	; 0x04
    2576:	95 81       	ldd	r25, Z+5	; 0x05
    2578:	15 96       	adiw	r26, 0x05	; 5
    257a:	9c 93       	st	X, r25
    257c:	8e 93       	st	-X, r24
    257e:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2580:	eb 81       	ldd	r30, Y+3	; 0x03
    2582:	fc 81       	ldd	r31, Y+4	; 0x04
    2584:	a4 81       	ldd	r26, Z+4	; 0x04
    2586:	b5 81       	ldd	r27, Z+5	; 0x05
    2588:	eb 81       	ldd	r30, Y+3	; 0x03
    258a:	fc 81       	ldd	r31, Y+4	; 0x04
    258c:	82 81       	ldd	r24, Z+2	; 0x02
    258e:	93 81       	ldd	r25, Z+3	; 0x03
    2590:	13 96       	adiw	r26, 0x03	; 3
    2592:	9c 93       	st	X, r25
    2594:	8e 93       	st	-X, r24
    2596:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2598:	e9 81       	ldd	r30, Y+1	; 0x01
    259a:	fa 81       	ldd	r31, Y+2	; 0x02
    259c:	21 81       	ldd	r18, Z+1	; 0x01
    259e:	32 81       	ldd	r19, Z+2	; 0x02
    25a0:	8b 81       	ldd	r24, Y+3	; 0x03
    25a2:	9c 81       	ldd	r25, Y+4	; 0x04
    25a4:	28 17       	cp	r18, r24
    25a6:	39 07       	cpc	r19, r25
    25a8:	41 f4       	brne	.+16     	; 0x25ba <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    25aa:	eb 81       	ldd	r30, Y+3	; 0x03
    25ac:	fc 81       	ldd	r31, Y+4	; 0x04
    25ae:	84 81       	ldd	r24, Z+4	; 0x04
    25b0:	95 81       	ldd	r25, Z+5	; 0x05
    25b2:	e9 81       	ldd	r30, Y+1	; 0x01
    25b4:	fa 81       	ldd	r31, Y+2	; 0x02
    25b6:	92 83       	std	Z+2, r25	; 0x02
    25b8:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    25ba:	eb 81       	ldd	r30, Y+3	; 0x03
    25bc:	fc 81       	ldd	r31, Y+4	; 0x04
    25be:	11 86       	std	Z+9, r1	; 0x09
    25c0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    25c2:	e9 81       	ldd	r30, Y+1	; 0x01
    25c4:	fa 81       	ldd	r31, Y+2	; 0x02
    25c6:	80 81       	ld	r24, Z
    25c8:	81 50       	subi	r24, 0x01	; 1
    25ca:	e9 81       	ldd	r30, Y+1	; 0x01
    25cc:	fa 81       	ldd	r31, Y+2	; 0x02
    25ce:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    25d0:	e9 81       	ldd	r30, Y+1	; 0x01
    25d2:	fa 81       	ldd	r31, Y+2	; 0x02
    25d4:	80 81       	ld	r24, Z
}
    25d6:	0f 90       	pop	r0
    25d8:	0f 90       	pop	r0
    25da:	0f 90       	pop	r0
    25dc:	0f 90       	pop	r0
    25de:	cf 91       	pop	r28
    25e0:	df 91       	pop	r29
    25e2:	08 95       	ret

000025e4 <main>:

#include "UserTasks.h"


void main(void)
{
    25e4:	ef 92       	push	r14
    25e6:	ff 92       	push	r15
    25e8:	0f 93       	push	r16
    25ea:	df 93       	push	r29
    25ec:	cf 93       	push	r28
    25ee:	cd b7       	in	r28, 0x3d	; 61
    25f0:	de b7       	in	r29, 0x3e	; 62

	DIO_SetPinDirection(DIO_PIN12,OUTPUT);
    25f2:	8c e0       	ldi	r24, 0x0C	; 12
    25f4:	61 e0       	ldi	r22, 0x01	; 1
    25f6:	0e 94 ae 05 	call	0xb5c	; 0xb5c <DIO_SetPinDirection>
	xTaskCreate(init_Task  , "Init_Task" , 150,
    25fa:	85 ef       	ldi	r24, 0xF5	; 245
    25fc:	99 e0       	ldi	r25, 0x09	; 9
    25fe:	2d e9       	ldi	r18, 0x9D	; 157
    2600:	30 e0       	ldi	r19, 0x00	; 0
    2602:	e0 ec       	ldi	r30, 0xC0	; 192
    2604:	f0 e0       	ldi	r31, 0x00	; 0
    2606:	b9 01       	movw	r22, r18
    2608:	46 e9       	ldi	r20, 0x96	; 150
    260a:	50 e0       	ldi	r21, 0x00	; 0
    260c:	20 e0       	ldi	r18, 0x00	; 0
    260e:	30 e0       	ldi	r19, 0x00	; 0
    2610:	05 e0       	ldi	r16, 0x05	; 5
    2612:	7f 01       	movw	r14, r30
    2614:	0e 94 99 24 	call	0x4932	; 0x4932 <xTaskCreate>
			NULL , (5 | portPRIVILEGE_BIT) , &InitTask_Flag);


	/* Start Scheduler */

	vTaskStartScheduler();
    2618:	0e 94 46 28 	call	0x508c	; 0x508c <vTaskStartScheduler>
    261c:	ff cf       	rjmp	.-2      	; 0x261c <main+0x38>

0000261e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    261e:	df 93       	push	r29
    2620:	cf 93       	push	r28
    2622:	cd b7       	in	r28, 0x3d	; 61
    2624:	de b7       	in	r29, 0x3e	; 62
    2626:	28 97       	sbiw	r28, 0x08	; 8
    2628:	0f b6       	in	r0, 0x3f	; 63
    262a:	f8 94       	cli
    262c:	de bf       	out	0x3e, r29	; 62
    262e:	0f be       	out	0x3f, r0	; 63
    2630:	cd bf       	out	0x3d, r28	; 61
    2632:	9c 83       	std	Y+4, r25	; 0x04
    2634:	8b 83       	std	Y+3, r24	; 0x03
    2636:	7e 83       	std	Y+6, r23	; 0x06
    2638:	6d 83       	std	Y+5, r22	; 0x05
    263a:	58 87       	std	Y+8, r21	; 0x08
    263c:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    263e:	eb 81       	ldd	r30, Y+3	; 0x03
    2640:	fc 81       	ldd	r31, Y+4	; 0x04
    2642:	81 e1       	ldi	r24, 0x11	; 17
    2644:	80 83       	st	Z, r24
	pxTopOfStack--;
    2646:	8b 81       	ldd	r24, Y+3	; 0x03
    2648:	9c 81       	ldd	r25, Y+4	; 0x04
    264a:	01 97       	sbiw	r24, 0x01	; 1
    264c:	9c 83       	std	Y+4, r25	; 0x04
    264e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2650:	eb 81       	ldd	r30, Y+3	; 0x03
    2652:	fc 81       	ldd	r31, Y+4	; 0x04
    2654:	82 e2       	ldi	r24, 0x22	; 34
    2656:	80 83       	st	Z, r24
	pxTopOfStack--;
    2658:	8b 81       	ldd	r24, Y+3	; 0x03
    265a:	9c 81       	ldd	r25, Y+4	; 0x04
    265c:	01 97       	sbiw	r24, 0x01	; 1
    265e:	9c 83       	std	Y+4, r25	; 0x04
    2660:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2662:	eb 81       	ldd	r30, Y+3	; 0x03
    2664:	fc 81       	ldd	r31, Y+4	; 0x04
    2666:	83 e3       	ldi	r24, 0x33	; 51
    2668:	80 83       	st	Z, r24
	pxTopOfStack--;
    266a:	8b 81       	ldd	r24, Y+3	; 0x03
    266c:	9c 81       	ldd	r25, Y+4	; 0x04
    266e:	01 97       	sbiw	r24, 0x01	; 1
    2670:	9c 83       	std	Y+4, r25	; 0x04
    2672:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    2674:	8d 81       	ldd	r24, Y+5	; 0x05
    2676:	9e 81       	ldd	r25, Y+6	; 0x06
    2678:	9a 83       	std	Y+2, r25	; 0x02
    267a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    267c:	89 81       	ldd	r24, Y+1	; 0x01
    267e:	eb 81       	ldd	r30, Y+3	; 0x03
    2680:	fc 81       	ldd	r31, Y+4	; 0x04
    2682:	80 83       	st	Z, r24
	pxTopOfStack--;
    2684:	8b 81       	ldd	r24, Y+3	; 0x03
    2686:	9c 81       	ldd	r25, Y+4	; 0x04
    2688:	01 97       	sbiw	r24, 0x01	; 1
    268a:	9c 83       	std	Y+4, r25	; 0x04
    268c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    268e:	89 81       	ldd	r24, Y+1	; 0x01
    2690:	9a 81       	ldd	r25, Y+2	; 0x02
    2692:	89 2f       	mov	r24, r25
    2694:	99 27       	eor	r25, r25
    2696:	9a 83       	std	Y+2, r25	; 0x02
    2698:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    269a:	89 81       	ldd	r24, Y+1	; 0x01
    269c:	eb 81       	ldd	r30, Y+3	; 0x03
    269e:	fc 81       	ldd	r31, Y+4	; 0x04
    26a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    26a2:	8b 81       	ldd	r24, Y+3	; 0x03
    26a4:	9c 81       	ldd	r25, Y+4	; 0x04
    26a6:	01 97       	sbiw	r24, 0x01	; 1
    26a8:	9c 83       	std	Y+4, r25	; 0x04
    26aa:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    26ac:	eb 81       	ldd	r30, Y+3	; 0x03
    26ae:	fc 81       	ldd	r31, Y+4	; 0x04
    26b0:	10 82       	st	Z, r1
	pxTopOfStack--;
    26b2:	8b 81       	ldd	r24, Y+3	; 0x03
    26b4:	9c 81       	ldd	r25, Y+4	; 0x04
    26b6:	01 97       	sbiw	r24, 0x01	; 1
    26b8:	9c 83       	std	Y+4, r25	; 0x04
    26ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    26bc:	eb 81       	ldd	r30, Y+3	; 0x03
    26be:	fc 81       	ldd	r31, Y+4	; 0x04
    26c0:	80 e8       	ldi	r24, 0x80	; 128
    26c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    26c4:	8b 81       	ldd	r24, Y+3	; 0x03
    26c6:	9c 81       	ldd	r25, Y+4	; 0x04
    26c8:	01 97       	sbiw	r24, 0x01	; 1
    26ca:	9c 83       	std	Y+4, r25	; 0x04
    26cc:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    26ce:	eb 81       	ldd	r30, Y+3	; 0x03
    26d0:	fc 81       	ldd	r31, Y+4	; 0x04
    26d2:	10 82       	st	Z, r1
	pxTopOfStack--;
    26d4:	8b 81       	ldd	r24, Y+3	; 0x03
    26d6:	9c 81       	ldd	r25, Y+4	; 0x04
    26d8:	01 97       	sbiw	r24, 0x01	; 1
    26da:	9c 83       	std	Y+4, r25	; 0x04
    26dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    26de:	eb 81       	ldd	r30, Y+3	; 0x03
    26e0:	fc 81       	ldd	r31, Y+4	; 0x04
    26e2:	82 e0       	ldi	r24, 0x02	; 2
    26e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    26e6:	8b 81       	ldd	r24, Y+3	; 0x03
    26e8:	9c 81       	ldd	r25, Y+4	; 0x04
    26ea:	01 97       	sbiw	r24, 0x01	; 1
    26ec:	9c 83       	std	Y+4, r25	; 0x04
    26ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    26f0:	eb 81       	ldd	r30, Y+3	; 0x03
    26f2:	fc 81       	ldd	r31, Y+4	; 0x04
    26f4:	83 e0       	ldi	r24, 0x03	; 3
    26f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    26f8:	8b 81       	ldd	r24, Y+3	; 0x03
    26fa:	9c 81       	ldd	r25, Y+4	; 0x04
    26fc:	01 97       	sbiw	r24, 0x01	; 1
    26fe:	9c 83       	std	Y+4, r25	; 0x04
    2700:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2702:	eb 81       	ldd	r30, Y+3	; 0x03
    2704:	fc 81       	ldd	r31, Y+4	; 0x04
    2706:	84 e0       	ldi	r24, 0x04	; 4
    2708:	80 83       	st	Z, r24
	pxTopOfStack--;
    270a:	8b 81       	ldd	r24, Y+3	; 0x03
    270c:	9c 81       	ldd	r25, Y+4	; 0x04
    270e:	01 97       	sbiw	r24, 0x01	; 1
    2710:	9c 83       	std	Y+4, r25	; 0x04
    2712:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2714:	eb 81       	ldd	r30, Y+3	; 0x03
    2716:	fc 81       	ldd	r31, Y+4	; 0x04
    2718:	85 e0       	ldi	r24, 0x05	; 5
    271a:	80 83       	st	Z, r24
	pxTopOfStack--;
    271c:	8b 81       	ldd	r24, Y+3	; 0x03
    271e:	9c 81       	ldd	r25, Y+4	; 0x04
    2720:	01 97       	sbiw	r24, 0x01	; 1
    2722:	9c 83       	std	Y+4, r25	; 0x04
    2724:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2726:	eb 81       	ldd	r30, Y+3	; 0x03
    2728:	fc 81       	ldd	r31, Y+4	; 0x04
    272a:	86 e0       	ldi	r24, 0x06	; 6
    272c:	80 83       	st	Z, r24
	pxTopOfStack--;
    272e:	8b 81       	ldd	r24, Y+3	; 0x03
    2730:	9c 81       	ldd	r25, Y+4	; 0x04
    2732:	01 97       	sbiw	r24, 0x01	; 1
    2734:	9c 83       	std	Y+4, r25	; 0x04
    2736:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2738:	eb 81       	ldd	r30, Y+3	; 0x03
    273a:	fc 81       	ldd	r31, Y+4	; 0x04
    273c:	87 e0       	ldi	r24, 0x07	; 7
    273e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2740:	8b 81       	ldd	r24, Y+3	; 0x03
    2742:	9c 81       	ldd	r25, Y+4	; 0x04
    2744:	01 97       	sbiw	r24, 0x01	; 1
    2746:	9c 83       	std	Y+4, r25	; 0x04
    2748:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    274a:	eb 81       	ldd	r30, Y+3	; 0x03
    274c:	fc 81       	ldd	r31, Y+4	; 0x04
    274e:	88 e0       	ldi	r24, 0x08	; 8
    2750:	80 83       	st	Z, r24
	pxTopOfStack--;
    2752:	8b 81       	ldd	r24, Y+3	; 0x03
    2754:	9c 81       	ldd	r25, Y+4	; 0x04
    2756:	01 97       	sbiw	r24, 0x01	; 1
    2758:	9c 83       	std	Y+4, r25	; 0x04
    275a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    275c:	eb 81       	ldd	r30, Y+3	; 0x03
    275e:	fc 81       	ldd	r31, Y+4	; 0x04
    2760:	89 e0       	ldi	r24, 0x09	; 9
    2762:	80 83       	st	Z, r24
	pxTopOfStack--;
    2764:	8b 81       	ldd	r24, Y+3	; 0x03
    2766:	9c 81       	ldd	r25, Y+4	; 0x04
    2768:	01 97       	sbiw	r24, 0x01	; 1
    276a:	9c 83       	std	Y+4, r25	; 0x04
    276c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    276e:	eb 81       	ldd	r30, Y+3	; 0x03
    2770:	fc 81       	ldd	r31, Y+4	; 0x04
    2772:	80 e1       	ldi	r24, 0x10	; 16
    2774:	80 83       	st	Z, r24
	pxTopOfStack--;
    2776:	8b 81       	ldd	r24, Y+3	; 0x03
    2778:	9c 81       	ldd	r25, Y+4	; 0x04
    277a:	01 97       	sbiw	r24, 0x01	; 1
    277c:	9c 83       	std	Y+4, r25	; 0x04
    277e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2780:	eb 81       	ldd	r30, Y+3	; 0x03
    2782:	fc 81       	ldd	r31, Y+4	; 0x04
    2784:	81 e1       	ldi	r24, 0x11	; 17
    2786:	80 83       	st	Z, r24
	pxTopOfStack--;
    2788:	8b 81       	ldd	r24, Y+3	; 0x03
    278a:	9c 81       	ldd	r25, Y+4	; 0x04
    278c:	01 97       	sbiw	r24, 0x01	; 1
    278e:	9c 83       	std	Y+4, r25	; 0x04
    2790:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2792:	eb 81       	ldd	r30, Y+3	; 0x03
    2794:	fc 81       	ldd	r31, Y+4	; 0x04
    2796:	82 e1       	ldi	r24, 0x12	; 18
    2798:	80 83       	st	Z, r24
	pxTopOfStack--;
    279a:	8b 81       	ldd	r24, Y+3	; 0x03
    279c:	9c 81       	ldd	r25, Y+4	; 0x04
    279e:	01 97       	sbiw	r24, 0x01	; 1
    27a0:	9c 83       	std	Y+4, r25	; 0x04
    27a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    27a4:	eb 81       	ldd	r30, Y+3	; 0x03
    27a6:	fc 81       	ldd	r31, Y+4	; 0x04
    27a8:	83 e1       	ldi	r24, 0x13	; 19
    27aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    27ac:	8b 81       	ldd	r24, Y+3	; 0x03
    27ae:	9c 81       	ldd	r25, Y+4	; 0x04
    27b0:	01 97       	sbiw	r24, 0x01	; 1
    27b2:	9c 83       	std	Y+4, r25	; 0x04
    27b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    27b6:	eb 81       	ldd	r30, Y+3	; 0x03
    27b8:	fc 81       	ldd	r31, Y+4	; 0x04
    27ba:	84 e1       	ldi	r24, 0x14	; 20
    27bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    27be:	8b 81       	ldd	r24, Y+3	; 0x03
    27c0:	9c 81       	ldd	r25, Y+4	; 0x04
    27c2:	01 97       	sbiw	r24, 0x01	; 1
    27c4:	9c 83       	std	Y+4, r25	; 0x04
    27c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    27c8:	eb 81       	ldd	r30, Y+3	; 0x03
    27ca:	fc 81       	ldd	r31, Y+4	; 0x04
    27cc:	85 e1       	ldi	r24, 0x15	; 21
    27ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    27d0:	8b 81       	ldd	r24, Y+3	; 0x03
    27d2:	9c 81       	ldd	r25, Y+4	; 0x04
    27d4:	01 97       	sbiw	r24, 0x01	; 1
    27d6:	9c 83       	std	Y+4, r25	; 0x04
    27d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    27da:	eb 81       	ldd	r30, Y+3	; 0x03
    27dc:	fc 81       	ldd	r31, Y+4	; 0x04
    27de:	86 e1       	ldi	r24, 0x16	; 22
    27e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    27e2:	8b 81       	ldd	r24, Y+3	; 0x03
    27e4:	9c 81       	ldd	r25, Y+4	; 0x04
    27e6:	01 97       	sbiw	r24, 0x01	; 1
    27e8:	9c 83       	std	Y+4, r25	; 0x04
    27ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    27ec:	eb 81       	ldd	r30, Y+3	; 0x03
    27ee:	fc 81       	ldd	r31, Y+4	; 0x04
    27f0:	87 e1       	ldi	r24, 0x17	; 23
    27f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    27f4:	8b 81       	ldd	r24, Y+3	; 0x03
    27f6:	9c 81       	ldd	r25, Y+4	; 0x04
    27f8:	01 97       	sbiw	r24, 0x01	; 1
    27fa:	9c 83       	std	Y+4, r25	; 0x04
    27fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    27fe:	eb 81       	ldd	r30, Y+3	; 0x03
    2800:	fc 81       	ldd	r31, Y+4	; 0x04
    2802:	88 e1       	ldi	r24, 0x18	; 24
    2804:	80 83       	st	Z, r24
	pxTopOfStack--;
    2806:	8b 81       	ldd	r24, Y+3	; 0x03
    2808:	9c 81       	ldd	r25, Y+4	; 0x04
    280a:	01 97       	sbiw	r24, 0x01	; 1
    280c:	9c 83       	std	Y+4, r25	; 0x04
    280e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2810:	eb 81       	ldd	r30, Y+3	; 0x03
    2812:	fc 81       	ldd	r31, Y+4	; 0x04
    2814:	89 e1       	ldi	r24, 0x19	; 25
    2816:	80 83       	st	Z, r24
	pxTopOfStack--;
    2818:	8b 81       	ldd	r24, Y+3	; 0x03
    281a:	9c 81       	ldd	r25, Y+4	; 0x04
    281c:	01 97       	sbiw	r24, 0x01	; 1
    281e:	9c 83       	std	Y+4, r25	; 0x04
    2820:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2822:	eb 81       	ldd	r30, Y+3	; 0x03
    2824:	fc 81       	ldd	r31, Y+4	; 0x04
    2826:	80 e2       	ldi	r24, 0x20	; 32
    2828:	80 83       	st	Z, r24
	pxTopOfStack--;
    282a:	8b 81       	ldd	r24, Y+3	; 0x03
    282c:	9c 81       	ldd	r25, Y+4	; 0x04
    282e:	01 97       	sbiw	r24, 0x01	; 1
    2830:	9c 83       	std	Y+4, r25	; 0x04
    2832:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2834:	eb 81       	ldd	r30, Y+3	; 0x03
    2836:	fc 81       	ldd	r31, Y+4	; 0x04
    2838:	81 e2       	ldi	r24, 0x21	; 33
    283a:	80 83       	st	Z, r24
	pxTopOfStack--;
    283c:	8b 81       	ldd	r24, Y+3	; 0x03
    283e:	9c 81       	ldd	r25, Y+4	; 0x04
    2840:	01 97       	sbiw	r24, 0x01	; 1
    2842:	9c 83       	std	Y+4, r25	; 0x04
    2844:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2846:	eb 81       	ldd	r30, Y+3	; 0x03
    2848:	fc 81       	ldd	r31, Y+4	; 0x04
    284a:	82 e2       	ldi	r24, 0x22	; 34
    284c:	80 83       	st	Z, r24
	pxTopOfStack--;
    284e:	8b 81       	ldd	r24, Y+3	; 0x03
    2850:	9c 81       	ldd	r25, Y+4	; 0x04
    2852:	01 97       	sbiw	r24, 0x01	; 1
    2854:	9c 83       	std	Y+4, r25	; 0x04
    2856:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2858:	eb 81       	ldd	r30, Y+3	; 0x03
    285a:	fc 81       	ldd	r31, Y+4	; 0x04
    285c:	83 e2       	ldi	r24, 0x23	; 35
    285e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2860:	8b 81       	ldd	r24, Y+3	; 0x03
    2862:	9c 81       	ldd	r25, Y+4	; 0x04
    2864:	01 97       	sbiw	r24, 0x01	; 1
    2866:	9c 83       	std	Y+4, r25	; 0x04
    2868:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    286a:	8f 81       	ldd	r24, Y+7	; 0x07
    286c:	98 85       	ldd	r25, Y+8	; 0x08
    286e:	9a 83       	std	Y+2, r25	; 0x02
    2870:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2872:	89 81       	ldd	r24, Y+1	; 0x01
    2874:	eb 81       	ldd	r30, Y+3	; 0x03
    2876:	fc 81       	ldd	r31, Y+4	; 0x04
    2878:	80 83       	st	Z, r24
	pxTopOfStack--;
    287a:	8b 81       	ldd	r24, Y+3	; 0x03
    287c:	9c 81       	ldd	r25, Y+4	; 0x04
    287e:	01 97       	sbiw	r24, 0x01	; 1
    2880:	9c 83       	std	Y+4, r25	; 0x04
    2882:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2884:	89 81       	ldd	r24, Y+1	; 0x01
    2886:	9a 81       	ldd	r25, Y+2	; 0x02
    2888:	89 2f       	mov	r24, r25
    288a:	99 27       	eor	r25, r25
    288c:	9a 83       	std	Y+2, r25	; 0x02
    288e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2890:	89 81       	ldd	r24, Y+1	; 0x01
    2892:	eb 81       	ldd	r30, Y+3	; 0x03
    2894:	fc 81       	ldd	r31, Y+4	; 0x04
    2896:	80 83       	st	Z, r24
	pxTopOfStack--;
    2898:	8b 81       	ldd	r24, Y+3	; 0x03
    289a:	9c 81       	ldd	r25, Y+4	; 0x04
    289c:	01 97       	sbiw	r24, 0x01	; 1
    289e:	9c 83       	std	Y+4, r25	; 0x04
    28a0:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    28a2:	eb 81       	ldd	r30, Y+3	; 0x03
    28a4:	fc 81       	ldd	r31, Y+4	; 0x04
    28a6:	86 e2       	ldi	r24, 0x26	; 38
    28a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    28aa:	8b 81       	ldd	r24, Y+3	; 0x03
    28ac:	9c 81       	ldd	r25, Y+4	; 0x04
    28ae:	01 97       	sbiw	r24, 0x01	; 1
    28b0:	9c 83       	std	Y+4, r25	; 0x04
    28b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    28b4:	eb 81       	ldd	r30, Y+3	; 0x03
    28b6:	fc 81       	ldd	r31, Y+4	; 0x04
    28b8:	87 e2       	ldi	r24, 0x27	; 39
    28ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    28bc:	8b 81       	ldd	r24, Y+3	; 0x03
    28be:	9c 81       	ldd	r25, Y+4	; 0x04
    28c0:	01 97       	sbiw	r24, 0x01	; 1
    28c2:	9c 83       	std	Y+4, r25	; 0x04
    28c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    28c6:	eb 81       	ldd	r30, Y+3	; 0x03
    28c8:	fc 81       	ldd	r31, Y+4	; 0x04
    28ca:	88 e2       	ldi	r24, 0x28	; 40
    28cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    28ce:	8b 81       	ldd	r24, Y+3	; 0x03
    28d0:	9c 81       	ldd	r25, Y+4	; 0x04
    28d2:	01 97       	sbiw	r24, 0x01	; 1
    28d4:	9c 83       	std	Y+4, r25	; 0x04
    28d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    28d8:	eb 81       	ldd	r30, Y+3	; 0x03
    28da:	fc 81       	ldd	r31, Y+4	; 0x04
    28dc:	89 e2       	ldi	r24, 0x29	; 41
    28de:	80 83       	st	Z, r24
	pxTopOfStack--;
    28e0:	8b 81       	ldd	r24, Y+3	; 0x03
    28e2:	9c 81       	ldd	r25, Y+4	; 0x04
    28e4:	01 97       	sbiw	r24, 0x01	; 1
    28e6:	9c 83       	std	Y+4, r25	; 0x04
    28e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    28ea:	eb 81       	ldd	r30, Y+3	; 0x03
    28ec:	fc 81       	ldd	r31, Y+4	; 0x04
    28ee:	80 e3       	ldi	r24, 0x30	; 48
    28f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    28f2:	8b 81       	ldd	r24, Y+3	; 0x03
    28f4:	9c 81       	ldd	r25, Y+4	; 0x04
    28f6:	01 97       	sbiw	r24, 0x01	; 1
    28f8:	9c 83       	std	Y+4, r25	; 0x04
    28fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    28fc:	eb 81       	ldd	r30, Y+3	; 0x03
    28fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2900:	81 e3       	ldi	r24, 0x31	; 49
    2902:	80 83       	st	Z, r24
	pxTopOfStack--;
    2904:	8b 81       	ldd	r24, Y+3	; 0x03
    2906:	9c 81       	ldd	r25, Y+4	; 0x04
    2908:	01 97       	sbiw	r24, 0x01	; 1
    290a:	9c 83       	std	Y+4, r25	; 0x04
    290c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    290e:	8b 81       	ldd	r24, Y+3	; 0x03
    2910:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2912:	28 96       	adiw	r28, 0x08	; 8
    2914:	0f b6       	in	r0, 0x3f	; 63
    2916:	f8 94       	cli
    2918:	de bf       	out	0x3e, r29	; 62
    291a:	0f be       	out	0x3f, r0	; 63
    291c:	cd bf       	out	0x3d, r28	; 61
    291e:	cf 91       	pop	r28
    2920:	df 91       	pop	r29
    2922:	08 95       	ret

00002924 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2924:	df 93       	push	r29
    2926:	cf 93       	push	r28
    2928:	cd b7       	in	r28, 0x3d	; 61
    292a:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    292c:	0e 94 84 15 	call	0x2b08	; 0x2b08 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2930:	a0 91 a8 06 	lds	r26, 0x06A8
    2934:	b0 91 a9 06 	lds	r27, 0x06A9
    2938:	cd 91       	ld	r28, X+
    293a:	cd bf       	out	0x3d, r28	; 61
    293c:	dd 91       	ld	r29, X+
    293e:	de bf       	out	0x3e, r29	; 62
    2940:	ff 91       	pop	r31
    2942:	ef 91       	pop	r30
    2944:	df 91       	pop	r29
    2946:	cf 91       	pop	r28
    2948:	bf 91       	pop	r27
    294a:	af 91       	pop	r26
    294c:	9f 91       	pop	r25
    294e:	8f 91       	pop	r24
    2950:	7f 91       	pop	r23
    2952:	6f 91       	pop	r22
    2954:	5f 91       	pop	r21
    2956:	4f 91       	pop	r20
    2958:	3f 91       	pop	r19
    295a:	2f 91       	pop	r18
    295c:	1f 91       	pop	r17
    295e:	0f 91       	pop	r16
    2960:	ff 90       	pop	r15
    2962:	ef 90       	pop	r14
    2964:	df 90       	pop	r13
    2966:	cf 90       	pop	r12
    2968:	bf 90       	pop	r11
    296a:	af 90       	pop	r10
    296c:	9f 90       	pop	r9
    296e:	8f 90       	pop	r8
    2970:	7f 90       	pop	r7
    2972:	6f 90       	pop	r6
    2974:	5f 90       	pop	r5
    2976:	4f 90       	pop	r4
    2978:	3f 90       	pop	r3
    297a:	2f 90       	pop	r2
    297c:	1f 90       	pop	r1
    297e:	0f 90       	pop	r0
    2980:	0f be       	out	0x3f, r0	; 63
    2982:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2984:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2986:	81 e0       	ldi	r24, 0x01	; 1
}
    2988:	cf 91       	pop	r28
    298a:	df 91       	pop	r29
    298c:	08 95       	ret

0000298e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    298e:	df 93       	push	r29
    2990:	cf 93       	push	r28
    2992:	cd b7       	in	r28, 0x3d	; 61
    2994:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2996:	cf 91       	pop	r28
    2998:	df 91       	pop	r29
    299a:	08 95       	ret

0000299c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    299c:	0f 92       	push	r0
    299e:	0f b6       	in	r0, 0x3f	; 63
    29a0:	f8 94       	cli
    29a2:	0f 92       	push	r0
    29a4:	1f 92       	push	r1
    29a6:	11 24       	eor	r1, r1
    29a8:	2f 92       	push	r2
    29aa:	3f 92       	push	r3
    29ac:	4f 92       	push	r4
    29ae:	5f 92       	push	r5
    29b0:	6f 92       	push	r6
    29b2:	7f 92       	push	r7
    29b4:	8f 92       	push	r8
    29b6:	9f 92       	push	r9
    29b8:	af 92       	push	r10
    29ba:	bf 92       	push	r11
    29bc:	cf 92       	push	r12
    29be:	df 92       	push	r13
    29c0:	ef 92       	push	r14
    29c2:	ff 92       	push	r15
    29c4:	0f 93       	push	r16
    29c6:	1f 93       	push	r17
    29c8:	2f 93       	push	r18
    29ca:	3f 93       	push	r19
    29cc:	4f 93       	push	r20
    29ce:	5f 93       	push	r21
    29d0:	6f 93       	push	r22
    29d2:	7f 93       	push	r23
    29d4:	8f 93       	push	r24
    29d6:	9f 93       	push	r25
    29d8:	af 93       	push	r26
    29da:	bf 93       	push	r27
    29dc:	cf 93       	push	r28
    29de:	df 93       	push	r29
    29e0:	ef 93       	push	r30
    29e2:	ff 93       	push	r31
    29e4:	a0 91 a8 06 	lds	r26, 0x06A8
    29e8:	b0 91 a9 06 	lds	r27, 0x06A9
    29ec:	0d b6       	in	r0, 0x3d	; 61
    29ee:	0d 92       	st	X+, r0
    29f0:	0e b6       	in	r0, 0x3e	; 62
    29f2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    29f4:	0e 94 65 2a 	call	0x54ca	; 0x54ca <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    29f8:	a0 91 a8 06 	lds	r26, 0x06A8
    29fc:	b0 91 a9 06 	lds	r27, 0x06A9
    2a00:	cd 91       	ld	r28, X+
    2a02:	cd bf       	out	0x3d, r28	; 61
    2a04:	dd 91       	ld	r29, X+
    2a06:	de bf       	out	0x3e, r29	; 62
    2a08:	ff 91       	pop	r31
    2a0a:	ef 91       	pop	r30
    2a0c:	df 91       	pop	r29
    2a0e:	cf 91       	pop	r28
    2a10:	bf 91       	pop	r27
    2a12:	af 91       	pop	r26
    2a14:	9f 91       	pop	r25
    2a16:	8f 91       	pop	r24
    2a18:	7f 91       	pop	r23
    2a1a:	6f 91       	pop	r22
    2a1c:	5f 91       	pop	r21
    2a1e:	4f 91       	pop	r20
    2a20:	3f 91       	pop	r19
    2a22:	2f 91       	pop	r18
    2a24:	1f 91       	pop	r17
    2a26:	0f 91       	pop	r16
    2a28:	ff 90       	pop	r15
    2a2a:	ef 90       	pop	r14
    2a2c:	df 90       	pop	r13
    2a2e:	cf 90       	pop	r12
    2a30:	bf 90       	pop	r11
    2a32:	af 90       	pop	r10
    2a34:	9f 90       	pop	r9
    2a36:	8f 90       	pop	r8
    2a38:	7f 90       	pop	r7
    2a3a:	6f 90       	pop	r6
    2a3c:	5f 90       	pop	r5
    2a3e:	4f 90       	pop	r4
    2a40:	3f 90       	pop	r3
    2a42:	2f 90       	pop	r2
    2a44:	1f 90       	pop	r1
    2a46:	0f 90       	pop	r0
    2a48:	0f be       	out	0x3f, r0	; 63
    2a4a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2a4c:	08 95       	ret

00002a4e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2a4e:	0f 92       	push	r0
    2a50:	0f b6       	in	r0, 0x3f	; 63
    2a52:	f8 94       	cli
    2a54:	0f 92       	push	r0
    2a56:	1f 92       	push	r1
    2a58:	11 24       	eor	r1, r1
    2a5a:	2f 92       	push	r2
    2a5c:	3f 92       	push	r3
    2a5e:	4f 92       	push	r4
    2a60:	5f 92       	push	r5
    2a62:	6f 92       	push	r6
    2a64:	7f 92       	push	r7
    2a66:	8f 92       	push	r8
    2a68:	9f 92       	push	r9
    2a6a:	af 92       	push	r10
    2a6c:	bf 92       	push	r11
    2a6e:	cf 92       	push	r12
    2a70:	df 92       	push	r13
    2a72:	ef 92       	push	r14
    2a74:	ff 92       	push	r15
    2a76:	0f 93       	push	r16
    2a78:	1f 93       	push	r17
    2a7a:	2f 93       	push	r18
    2a7c:	3f 93       	push	r19
    2a7e:	4f 93       	push	r20
    2a80:	5f 93       	push	r21
    2a82:	6f 93       	push	r22
    2a84:	7f 93       	push	r23
    2a86:	8f 93       	push	r24
    2a88:	9f 93       	push	r25
    2a8a:	af 93       	push	r26
    2a8c:	bf 93       	push	r27
    2a8e:	cf 93       	push	r28
    2a90:	df 93       	push	r29
    2a92:	ef 93       	push	r30
    2a94:	ff 93       	push	r31
    2a96:	a0 91 a8 06 	lds	r26, 0x06A8
    2a9a:	b0 91 a9 06 	lds	r27, 0x06A9
    2a9e:	0d b6       	in	r0, 0x3d	; 61
    2aa0:	0d 92       	st	X+, r0
    2aa2:	0e b6       	in	r0, 0x3e	; 62
    2aa4:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2aa6:	0e 94 80 29 	call	0x5300	; 0x5300 <xTaskIncrementTick>
    2aaa:	88 23       	and	r24, r24
    2aac:	11 f0       	breq	.+4      	; 0x2ab2 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2aae:	0e 94 65 2a 	call	0x54ca	; 0x54ca <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2ab2:	a0 91 a8 06 	lds	r26, 0x06A8
    2ab6:	b0 91 a9 06 	lds	r27, 0x06A9
    2aba:	cd 91       	ld	r28, X+
    2abc:	cd bf       	out	0x3d, r28	; 61
    2abe:	dd 91       	ld	r29, X+
    2ac0:	de bf       	out	0x3e, r29	; 62
    2ac2:	ff 91       	pop	r31
    2ac4:	ef 91       	pop	r30
    2ac6:	df 91       	pop	r29
    2ac8:	cf 91       	pop	r28
    2aca:	bf 91       	pop	r27
    2acc:	af 91       	pop	r26
    2ace:	9f 91       	pop	r25
    2ad0:	8f 91       	pop	r24
    2ad2:	7f 91       	pop	r23
    2ad4:	6f 91       	pop	r22
    2ad6:	5f 91       	pop	r21
    2ad8:	4f 91       	pop	r20
    2ada:	3f 91       	pop	r19
    2adc:	2f 91       	pop	r18
    2ade:	1f 91       	pop	r17
    2ae0:	0f 91       	pop	r16
    2ae2:	ff 90       	pop	r15
    2ae4:	ef 90       	pop	r14
    2ae6:	df 90       	pop	r13
    2ae8:	cf 90       	pop	r12
    2aea:	bf 90       	pop	r11
    2aec:	af 90       	pop	r10
    2aee:	9f 90       	pop	r9
    2af0:	8f 90       	pop	r8
    2af2:	7f 90       	pop	r7
    2af4:	6f 90       	pop	r6
    2af6:	5f 90       	pop	r5
    2af8:	4f 90       	pop	r4
    2afa:	3f 90       	pop	r3
    2afc:	2f 90       	pop	r2
    2afe:	1f 90       	pop	r1
    2b00:	0f 90       	pop	r0
    2b02:	0f be       	out	0x3f, r0	; 63
    2b04:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2b06:	08 95       	ret

00002b08 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2b08:	df 93       	push	r29
    2b0a:	cf 93       	push	r28
    2b0c:	00 d0       	rcall	.+0      	; 0x2b0e <prvSetupTimerInterrupt+0x6>
    2b0e:	00 d0       	rcall	.+0      	; 0x2b10 <prvSetupTimerInterrupt+0x8>
    2b10:	00 d0       	rcall	.+0      	; 0x2b12 <prvSetupTimerInterrupt+0xa>
    2b12:	cd b7       	in	r28, 0x3d	; 61
    2b14:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2b16:	80 e4       	ldi	r24, 0x40	; 64
    2b18:	9f e1       	ldi	r25, 0x1F	; 31
    2b1a:	a0 e0       	ldi	r26, 0x00	; 0
    2b1c:	b0 e0       	ldi	r27, 0x00	; 0
    2b1e:	8b 83       	std	Y+3, r24	; 0x03
    2b20:	9c 83       	std	Y+4, r25	; 0x04
    2b22:	ad 83       	std	Y+5, r26	; 0x05
    2b24:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2b26:	8b 81       	ldd	r24, Y+3	; 0x03
    2b28:	9c 81       	ldd	r25, Y+4	; 0x04
    2b2a:	ad 81       	ldd	r26, Y+5	; 0x05
    2b2c:	be 81       	ldd	r27, Y+6	; 0x06
    2b2e:	68 94       	set
    2b30:	15 f8       	bld	r1, 5
    2b32:	b6 95       	lsr	r27
    2b34:	a7 95       	ror	r26
    2b36:	97 95       	ror	r25
    2b38:	87 95       	ror	r24
    2b3a:	16 94       	lsr	r1
    2b3c:	d1 f7       	brne	.-12     	; 0x2b32 <prvSetupTimerInterrupt+0x2a>
    2b3e:	8b 83       	std	Y+3, r24	; 0x03
    2b40:	9c 83       	std	Y+4, r25	; 0x04
    2b42:	ad 83       	std	Y+5, r26	; 0x05
    2b44:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    2b46:	8b 81       	ldd	r24, Y+3	; 0x03
    2b48:	9c 81       	ldd	r25, Y+4	; 0x04
    2b4a:	ad 81       	ldd	r26, Y+5	; 0x05
    2b4c:	be 81       	ldd	r27, Y+6	; 0x06
    2b4e:	01 97       	sbiw	r24, 0x01	; 1
    2b50:	a1 09       	sbc	r26, r1
    2b52:	b1 09       	sbc	r27, r1
    2b54:	8b 83       	std	Y+3, r24	; 0x03
    2b56:	9c 83       	std	Y+4, r25	; 0x04
    2b58:	ad 83       	std	Y+5, r26	; 0x05
    2b5a:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2b5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b5e:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    2b60:	8b 81       	ldd	r24, Y+3	; 0x03
    2b62:	9c 81       	ldd	r25, Y+4	; 0x04
    2b64:	ad 81       	ldd	r26, Y+5	; 0x05
    2b66:	be 81       	ldd	r27, Y+6	; 0x06
    2b68:	89 2f       	mov	r24, r25
    2b6a:	9a 2f       	mov	r25, r26
    2b6c:	ab 2f       	mov	r26, r27
    2b6e:	bb 27       	eor	r27, r27
    2b70:	8b 83       	std	Y+3, r24	; 0x03
    2b72:	9c 83       	std	Y+4, r25	; 0x04
    2b74:	ad 83       	std	Y+5, r26	; 0x05
    2b76:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2b78:	8b 81       	ldd	r24, Y+3	; 0x03
    2b7a:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2b7c:	eb e4       	ldi	r30, 0x4B	; 75
    2b7e:	f0 e0       	ldi	r31, 0x00	; 0
    2b80:	8a 81       	ldd	r24, Y+2	; 0x02
    2b82:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    2b84:	ea e4       	ldi	r30, 0x4A	; 74
    2b86:	f0 e0       	ldi	r31, 0x00	; 0
    2b88:	89 81       	ldd	r24, Y+1	; 0x01
    2b8a:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2b8c:	8b e0       	ldi	r24, 0x0B	; 11
    2b8e:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2b90:	ee e4       	ldi	r30, 0x4E	; 78
    2b92:	f0 e0       	ldi	r31, 0x00	; 0
    2b94:	89 81       	ldd	r24, Y+1	; 0x01
    2b96:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2b98:	e9 e5       	ldi	r30, 0x59	; 89
    2b9a:	f0 e0       	ldi	r31, 0x00	; 0
    2b9c:	80 81       	ld	r24, Z
    2b9e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2ba0:	89 81       	ldd	r24, Y+1	; 0x01
    2ba2:	80 61       	ori	r24, 0x10	; 16
    2ba4:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2ba6:	e9 e5       	ldi	r30, 0x59	; 89
    2ba8:	f0 e0       	ldi	r31, 0x00	; 0
    2baa:	89 81       	ldd	r24, Y+1	; 0x01
    2bac:	80 83       	st	Z, r24
}
    2bae:	26 96       	adiw	r28, 0x06	; 6
    2bb0:	0f b6       	in	r0, 0x3f	; 63
    2bb2:	f8 94       	cli
    2bb4:	de bf       	out	0x3e, r29	; 62
    2bb6:	0f be       	out	0x3f, r0	; 63
    2bb8:	cd bf       	out	0x3d, r28	; 61
    2bba:	cf 91       	pop	r28
    2bbc:	df 91       	pop	r29
    2bbe:	08 95       	ret

00002bc0 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2bc0:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vPortYieldFromTick>
		asm volatile ( "reti" );
    2bc4:	18 95       	reti

00002bc6 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2bc6:	df 93       	push	r29
    2bc8:	cf 93       	push	r28
    2bca:	00 d0       	rcall	.+0      	; 0x2bcc <xQueueGenericReset+0x6>
    2bcc:	00 d0       	rcall	.+0      	; 0x2bce <xQueueGenericReset+0x8>
    2bce:	0f 92       	push	r0
    2bd0:	cd b7       	in	r28, 0x3d	; 61
    2bd2:	de b7       	in	r29, 0x3e	; 62
    2bd4:	9c 83       	std	Y+4, r25	; 0x04
    2bd6:	8b 83       	std	Y+3, r24	; 0x03
    2bd8:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    2bda:	8b 81       	ldd	r24, Y+3	; 0x03
    2bdc:	9c 81       	ldd	r25, Y+4	; 0x04
    2bde:	9a 83       	std	Y+2, r25	; 0x02
    2be0:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2be2:	0f b6       	in	r0, 0x3f	; 63
    2be4:	f8 94       	cli
    2be6:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2be8:	e9 81       	ldd	r30, Y+1	; 0x01
    2bea:	fa 81       	ldd	r31, Y+2	; 0x02
    2bec:	40 81       	ld	r20, Z
    2bee:	51 81       	ldd	r21, Z+1	; 0x01
    2bf0:	e9 81       	ldd	r30, Y+1	; 0x01
    2bf2:	fa 81       	ldd	r31, Y+2	; 0x02
    2bf4:	83 8d       	ldd	r24, Z+27	; 0x1b
    2bf6:	28 2f       	mov	r18, r24
    2bf8:	30 e0       	ldi	r19, 0x00	; 0
    2bfa:	e9 81       	ldd	r30, Y+1	; 0x01
    2bfc:	fa 81       	ldd	r31, Y+2	; 0x02
    2bfe:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c00:	88 2f       	mov	r24, r24
    2c02:	90 e0       	ldi	r25, 0x00	; 0
    2c04:	bc 01       	movw	r22, r24
    2c06:	26 9f       	mul	r18, r22
    2c08:	c0 01       	movw	r24, r0
    2c0a:	27 9f       	mul	r18, r23
    2c0c:	90 0d       	add	r25, r0
    2c0e:	36 9f       	mul	r19, r22
    2c10:	90 0d       	add	r25, r0
    2c12:	11 24       	eor	r1, r1
    2c14:	84 0f       	add	r24, r20
    2c16:	95 1f       	adc	r25, r21
    2c18:	e9 81       	ldd	r30, Y+1	; 0x01
    2c1a:	fa 81       	ldd	r31, Y+2	; 0x02
    2c1c:	95 83       	std	Z+5, r25	; 0x05
    2c1e:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2c20:	e9 81       	ldd	r30, Y+1	; 0x01
    2c22:	fa 81       	ldd	r31, Y+2	; 0x02
    2c24:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2c26:	e9 81       	ldd	r30, Y+1	; 0x01
    2c28:	fa 81       	ldd	r31, Y+2	; 0x02
    2c2a:	80 81       	ld	r24, Z
    2c2c:	91 81       	ldd	r25, Z+1	; 0x01
    2c2e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c30:	fa 81       	ldd	r31, Y+2	; 0x02
    2c32:	93 83       	std	Z+3, r25	; 0x03
    2c34:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2c36:	e9 81       	ldd	r30, Y+1	; 0x01
    2c38:	fa 81       	ldd	r31, Y+2	; 0x02
    2c3a:	40 81       	ld	r20, Z
    2c3c:	51 81       	ldd	r21, Z+1	; 0x01
    2c3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c40:	fa 81       	ldd	r31, Y+2	; 0x02
    2c42:	83 8d       	ldd	r24, Z+27	; 0x1b
    2c44:	88 2f       	mov	r24, r24
    2c46:	90 e0       	ldi	r25, 0x00	; 0
    2c48:	9c 01       	movw	r18, r24
    2c4a:	21 50       	subi	r18, 0x01	; 1
    2c4c:	30 40       	sbci	r19, 0x00	; 0
    2c4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c50:	fa 81       	ldd	r31, Y+2	; 0x02
    2c52:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c54:	88 2f       	mov	r24, r24
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	bc 01       	movw	r22, r24
    2c5a:	26 9f       	mul	r18, r22
    2c5c:	c0 01       	movw	r24, r0
    2c5e:	27 9f       	mul	r18, r23
    2c60:	90 0d       	add	r25, r0
    2c62:	36 9f       	mul	r19, r22
    2c64:	90 0d       	add	r25, r0
    2c66:	11 24       	eor	r1, r1
    2c68:	84 0f       	add	r24, r20
    2c6a:	95 1f       	adc	r25, r21
    2c6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c70:	97 83       	std	Z+7, r25	; 0x07
    2c72:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    2c74:	e9 81       	ldd	r30, Y+1	; 0x01
    2c76:	fa 81       	ldd	r31, Y+2	; 0x02
    2c78:	8f ef       	ldi	r24, 0xFF	; 255
    2c7a:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    2c7c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c7e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c80:	8f ef       	ldi	r24, 0xFF	; 255
    2c82:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    2c84:	8d 81       	ldd	r24, Y+5	; 0x05
    2c86:	88 23       	and	r24, r24
    2c88:	79 f4       	brne	.+30     	; 0x2ca8 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c8c:	fa 81       	ldd	r31, Y+2	; 0x02
    2c8e:	80 85       	ldd	r24, Z+8	; 0x08
    2c90:	88 23       	and	r24, r24
    2c92:	a1 f0       	breq	.+40     	; 0x2cbc <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2c94:	89 81       	ldd	r24, Y+1	; 0x01
    2c96:	9a 81       	ldd	r25, Y+2	; 0x02
    2c98:	08 96       	adiw	r24, 0x08	; 8
    2c9a:	0e 94 24 2b 	call	0x5648	; 0x5648 <xTaskRemoveFromEventList>
    2c9e:	88 23       	and	r24, r24
    2ca0:	69 f0       	breq	.+26     	; 0x2cbc <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2ca2:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
    2ca6:	0a c0       	rjmp	.+20     	; 0x2cbc <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2ca8:	89 81       	ldd	r24, Y+1	; 0x01
    2caa:	9a 81       	ldd	r25, Y+2	; 0x02
    2cac:	08 96       	adiw	r24, 0x08	; 8
    2cae:	0e 94 bc 11 	call	0x2378	; 0x2378 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2cb2:	89 81       	ldd	r24, Y+1	; 0x01
    2cb4:	9a 81       	ldd	r25, Y+2	; 0x02
    2cb6:	41 96       	adiw	r24, 0x11	; 17
    2cb8:	0e 94 bc 11 	call	0x2378	; 0x2378 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2cbc:	0f 90       	pop	r0
    2cbe:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    2cc0:	81 e0       	ldi	r24, 0x01	; 1
}
    2cc2:	0f 90       	pop	r0
    2cc4:	0f 90       	pop	r0
    2cc6:	0f 90       	pop	r0
    2cc8:	0f 90       	pop	r0
    2cca:	0f 90       	pop	r0
    2ccc:	cf 91       	pop	r28
    2cce:	df 91       	pop	r29
    2cd0:	08 95       	ret

00002cd2 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    2cd2:	0f 93       	push	r16
    2cd4:	1f 93       	push	r17
    2cd6:	df 93       	push	r29
    2cd8:	cf 93       	push	r28
    2cda:	cd b7       	in	r28, 0x3d	; 61
    2cdc:	de b7       	in	r29, 0x3e	; 62
    2cde:	29 97       	sbiw	r28, 0x09	; 9
    2ce0:	0f b6       	in	r0, 0x3f	; 63
    2ce2:	f8 94       	cli
    2ce4:	de bf       	out	0x3e, r29	; 62
    2ce6:	0f be       	out	0x3f, r0	; 63
    2ce8:	cd bf       	out	0x3d, r28	; 61
    2cea:	8f 83       	std	Y+7, r24	; 0x07
    2cec:	68 87       	std	Y+8, r22	; 0x08
    2cee:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    2cf0:	88 85       	ldd	r24, Y+8	; 0x08
    2cf2:	88 23       	and	r24, r24
    2cf4:	19 f4       	brne	.+6      	; 0x2cfc <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    2cf6:	1c 82       	std	Y+4, r1	; 0x04
    2cf8:	1b 82       	std	Y+3, r1	; 0x03
    2cfa:	10 c0       	rjmp	.+32     	; 0x2d1c <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2cfc:	8f 81       	ldd	r24, Y+7	; 0x07
    2cfe:	28 2f       	mov	r18, r24
    2d00:	30 e0       	ldi	r19, 0x00	; 0
    2d02:	88 85       	ldd	r24, Y+8	; 0x08
    2d04:	88 2f       	mov	r24, r24
    2d06:	90 e0       	ldi	r25, 0x00	; 0
    2d08:	ac 01       	movw	r20, r24
    2d0a:	24 9f       	mul	r18, r20
    2d0c:	c0 01       	movw	r24, r0
    2d0e:	25 9f       	mul	r18, r21
    2d10:	90 0d       	add	r25, r0
    2d12:	34 9f       	mul	r19, r20
    2d14:	90 0d       	add	r25, r0
    2d16:	11 24       	eor	r1, r1
    2d18:	9c 83       	std	Y+4, r25	; 0x04
    2d1a:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2d1c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d1e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d20:	4f 96       	adiw	r24, 0x1f	; 31
    2d22:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <pvPortMalloc>
    2d26:	9e 83       	std	Y+6, r25	; 0x06
    2d28:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    2d2a:	8d 81       	ldd	r24, Y+5	; 0x05
    2d2c:	9e 81       	ldd	r25, Y+6	; 0x06
    2d2e:	00 97       	sbiw	r24, 0x00	; 0
    2d30:	a1 f0       	breq	.+40     	; 0x2d5a <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    2d32:	8d 81       	ldd	r24, Y+5	; 0x05
    2d34:	9e 81       	ldd	r25, Y+6	; 0x06
    2d36:	9a 83       	std	Y+2, r25	; 0x02
    2d38:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2d3a:	89 81       	ldd	r24, Y+1	; 0x01
    2d3c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d3e:	4f 96       	adiw	r24, 0x1f	; 31
    2d40:	9a 83       	std	Y+2, r25	; 0x02
    2d42:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    2d44:	29 81       	ldd	r18, Y+1	; 0x01
    2d46:	3a 81       	ldd	r19, Y+2	; 0x02
    2d48:	ed 81       	ldd	r30, Y+5	; 0x05
    2d4a:	fe 81       	ldd	r31, Y+6	; 0x06
    2d4c:	8f 81       	ldd	r24, Y+7	; 0x07
    2d4e:	68 85       	ldd	r22, Y+8	; 0x08
    2d50:	a9 01       	movw	r20, r18
    2d52:	29 85       	ldd	r18, Y+9	; 0x09
    2d54:	8f 01       	movw	r16, r30
    2d56:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    2d5a:	8d 81       	ldd	r24, Y+5	; 0x05
    2d5c:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    2d5e:	29 96       	adiw	r28, 0x09	; 9
    2d60:	0f b6       	in	r0, 0x3f	; 63
    2d62:	f8 94       	cli
    2d64:	de bf       	out	0x3e, r29	; 62
    2d66:	0f be       	out	0x3f, r0	; 63
    2d68:	cd bf       	out	0x3d, r28	; 61
    2d6a:	cf 91       	pop	r28
    2d6c:	df 91       	pop	r29
    2d6e:	1f 91       	pop	r17
    2d70:	0f 91       	pop	r16
    2d72:	08 95       	ret

00002d74 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    2d74:	0f 93       	push	r16
    2d76:	1f 93       	push	r17
    2d78:	df 93       	push	r29
    2d7a:	cf 93       	push	r28
    2d7c:	cd b7       	in	r28, 0x3d	; 61
    2d7e:	de b7       	in	r29, 0x3e	; 62
    2d80:	27 97       	sbiw	r28, 0x07	; 7
    2d82:	0f b6       	in	r0, 0x3f	; 63
    2d84:	f8 94       	cli
    2d86:	de bf       	out	0x3e, r29	; 62
    2d88:	0f be       	out	0x3f, r0	; 63
    2d8a:	cd bf       	out	0x3d, r28	; 61
    2d8c:	89 83       	std	Y+1, r24	; 0x01
    2d8e:	6a 83       	std	Y+2, r22	; 0x02
    2d90:	5c 83       	std	Y+4, r21	; 0x04
    2d92:	4b 83       	std	Y+3, r20	; 0x03
    2d94:	2d 83       	std	Y+5, r18	; 0x05
    2d96:	1f 83       	std	Y+7, r17	; 0x07
    2d98:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    2d9a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d9c:	88 23       	and	r24, r24
    2d9e:	39 f4       	brne	.+14     	; 0x2dae <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2da0:	8e 81       	ldd	r24, Y+6	; 0x06
    2da2:	9f 81       	ldd	r25, Y+7	; 0x07
    2da4:	ee 81       	ldd	r30, Y+6	; 0x06
    2da6:	ff 81       	ldd	r31, Y+7	; 0x07
    2da8:	91 83       	std	Z+1, r25	; 0x01
    2daa:	80 83       	st	Z, r24
    2dac:	06 c0       	rjmp	.+12     	; 0x2dba <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2dae:	8b 81       	ldd	r24, Y+3	; 0x03
    2db0:	9c 81       	ldd	r25, Y+4	; 0x04
    2db2:	ee 81       	ldd	r30, Y+6	; 0x06
    2db4:	ff 81       	ldd	r31, Y+7	; 0x07
    2db6:	91 83       	std	Z+1, r25	; 0x01
    2db8:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    2dba:	ee 81       	ldd	r30, Y+6	; 0x06
    2dbc:	ff 81       	ldd	r31, Y+7	; 0x07
    2dbe:	89 81       	ldd	r24, Y+1	; 0x01
    2dc0:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    2dc2:	ee 81       	ldd	r30, Y+6	; 0x06
    2dc4:	ff 81       	ldd	r31, Y+7	; 0x07
    2dc6:	8a 81       	ldd	r24, Y+2	; 0x02
    2dc8:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2dca:	8e 81       	ldd	r24, Y+6	; 0x06
    2dcc:	9f 81       	ldd	r25, Y+7	; 0x07
    2dce:	61 e0       	ldi	r22, 0x01	; 1
    2dd0:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    2dd4:	27 96       	adiw	r28, 0x07	; 7
    2dd6:	0f b6       	in	r0, 0x3f	; 63
    2dd8:	f8 94       	cli
    2dda:	de bf       	out	0x3e, r29	; 62
    2ddc:	0f be       	out	0x3f, r0	; 63
    2dde:	cd bf       	out	0x3d, r28	; 61
    2de0:	cf 91       	pop	r28
    2de2:	df 91       	pop	r29
    2de4:	1f 91       	pop	r17
    2de6:	0f 91       	pop	r16
    2de8:	08 95       	ret

00002dea <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2dea:	df 93       	push	r29
    2dec:	cf 93       	push	r28
    2dee:	cd b7       	in	r28, 0x3d	; 61
    2df0:	de b7       	in	r29, 0x3e	; 62
    2df2:	2f 97       	sbiw	r28, 0x0f	; 15
    2df4:	0f b6       	in	r0, 0x3f	; 63
    2df6:	f8 94       	cli
    2df8:	de bf       	out	0x3e, r29	; 62
    2dfa:	0f be       	out	0x3f, r0	; 63
    2dfc:	cd bf       	out	0x3d, r28	; 61
    2dfe:	99 87       	std	Y+9, r25	; 0x09
    2e00:	88 87       	std	Y+8, r24	; 0x08
    2e02:	7b 87       	std	Y+11, r23	; 0x0b
    2e04:	6a 87       	std	Y+10, r22	; 0x0a
    2e06:	5d 87       	std	Y+13, r21	; 0x0d
    2e08:	4c 87       	std	Y+12, r20	; 0x0c
    2e0a:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2e0c:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2e0e:	88 85       	ldd	r24, Y+8	; 0x08
    2e10:	99 85       	ldd	r25, Y+9	; 0x09
    2e12:	9a 83       	std	Y+2, r25	; 0x02
    2e14:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2e16:	0f b6       	in	r0, 0x3f	; 63
    2e18:	f8 94       	cli
    2e1a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2e1c:	e9 81       	ldd	r30, Y+1	; 0x01
    2e1e:	fa 81       	ldd	r31, Y+2	; 0x02
    2e20:	92 8d       	ldd	r25, Z+26	; 0x1a
    2e22:	e9 81       	ldd	r30, Y+1	; 0x01
    2e24:	fa 81       	ldd	r31, Y+2	; 0x02
    2e26:	83 8d       	ldd	r24, Z+27	; 0x1b
    2e28:	98 17       	cp	r25, r24
    2e2a:	18 f0       	brcs	.+6      	; 0x2e32 <xQueueGenericSend+0x48>
    2e2c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2e2e:	82 30       	cpi	r24, 0x02	; 2
    2e30:	11 f5       	brne	.+68     	; 0x2e76 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2e32:	89 81       	ldd	r24, Y+1	; 0x01
    2e34:	9a 81       	ldd	r25, Y+2	; 0x02
    2e36:	2a 85       	ldd	r18, Y+10	; 0x0a
    2e38:	3b 85       	ldd	r19, Y+11	; 0x0b
    2e3a:	b9 01       	movw	r22, r18
    2e3c:	4e 85       	ldd	r20, Y+14	; 0x0e
    2e3e:	0e 94 47 1b 	call	0x368e	; 0x368e <prvCopyDataToQueue>
    2e42:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2e44:	e9 81       	ldd	r30, Y+1	; 0x01
    2e46:	fa 81       	ldd	r31, Y+2	; 0x02
    2e48:	81 89       	ldd	r24, Z+17	; 0x11
    2e4a:	88 23       	and	r24, r24
    2e4c:	51 f0       	breq	.+20     	; 0x2e62 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2e4e:	89 81       	ldd	r24, Y+1	; 0x01
    2e50:	9a 81       	ldd	r25, Y+2	; 0x02
    2e52:	41 96       	adiw	r24, 0x11	; 17
    2e54:	0e 94 24 2b 	call	0x5648	; 0x5648 <xTaskRemoveFromEventList>
    2e58:	88 23       	and	r24, r24
    2e5a:	41 f0       	breq	.+16     	; 0x2e6c <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2e5c:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
    2e60:	05 c0       	rjmp	.+10     	; 0x2e6c <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2e62:	8b 81       	ldd	r24, Y+3	; 0x03
    2e64:	88 23       	and	r24, r24
    2e66:	11 f0       	breq	.+4      	; 0x2e6c <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2e68:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2e6c:	0f 90       	pop	r0
    2e6e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2e70:	81 e0       	ldi	r24, 0x01	; 1
    2e72:	8f 87       	std	Y+15, r24	; 0x0f
    2e74:	5c c0       	rjmp	.+184    	; 0x2f2e <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2e76:	8c 85       	ldd	r24, Y+12	; 0x0c
    2e78:	9d 85       	ldd	r25, Y+13	; 0x0d
    2e7a:	00 97       	sbiw	r24, 0x00	; 0
    2e7c:	21 f4       	brne	.+8      	; 0x2e86 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2e7e:	0f 90       	pop	r0
    2e80:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2e82:	1f 86       	std	Y+15, r1	; 0x0f
    2e84:	54 c0       	rjmp	.+168    	; 0x2f2e <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    2e86:	8c 81       	ldd	r24, Y+4	; 0x04
    2e88:	88 23       	and	r24, r24
    2e8a:	31 f4       	brne	.+12     	; 0x2e98 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2e8c:	ce 01       	movw	r24, r28
    2e8e:	05 96       	adiw	r24, 0x05	; 5
    2e90:	0e 94 0a 2c 	call	0x5814	; 0x5814 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2e94:	81 e0       	ldi	r24, 0x01	; 1
    2e96:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2e98:	0f 90       	pop	r0
    2e9a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2e9c:	0e 94 84 28 	call	0x5108	; 0x5108 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2ea0:	0f b6       	in	r0, 0x3f	; 63
    2ea2:	f8 94       	cli
    2ea4:	0f 92       	push	r0
    2ea6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ea8:	fa 81       	ldd	r31, Y+2	; 0x02
    2eaa:	85 8d       	ldd	r24, Z+29	; 0x1d
    2eac:	8f 3f       	cpi	r24, 0xFF	; 255
    2eae:	19 f4       	brne	.+6      	; 0x2eb6 <xQueueGenericSend+0xcc>
    2eb0:	e9 81       	ldd	r30, Y+1	; 0x01
    2eb2:	fa 81       	ldd	r31, Y+2	; 0x02
    2eb4:	15 8e       	std	Z+29, r1	; 0x1d
    2eb6:	e9 81       	ldd	r30, Y+1	; 0x01
    2eb8:	fa 81       	ldd	r31, Y+2	; 0x02
    2eba:	86 8d       	ldd	r24, Z+30	; 0x1e
    2ebc:	8f 3f       	cpi	r24, 0xFF	; 255
    2ebe:	19 f4       	brne	.+6      	; 0x2ec6 <xQueueGenericSend+0xdc>
    2ec0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ec2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ec4:	16 8e       	std	Z+30, r1	; 0x1e
    2ec6:	0f 90       	pop	r0
    2ec8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2eca:	ce 01       	movw	r24, r28
    2ecc:	05 96       	adiw	r24, 0x05	; 5
    2ece:	9e 01       	movw	r18, r28
    2ed0:	24 5f       	subi	r18, 0xF4	; 244
    2ed2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ed4:	b9 01       	movw	r22, r18
    2ed6:	0e 94 23 2c 	call	0x5846	; 0x5846 <xTaskCheckForTimeOut>
    2eda:	88 23       	and	r24, r24
    2edc:	09 f5       	brne	.+66     	; 0x2f20 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2ede:	89 81       	ldd	r24, Y+1	; 0x01
    2ee0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ee2:	0e 94 c3 1c 	call	0x3986	; 0x3986 <prvIsQueueFull>
    2ee6:	88 23       	and	r24, r24
    2ee8:	a1 f0       	breq	.+40     	; 0x2f12 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2eea:	89 81       	ldd	r24, Y+1	; 0x01
    2eec:	9a 81       	ldd	r25, Y+2	; 0x02
    2eee:	08 96       	adiw	r24, 0x08	; 8
    2ef0:	2c 85       	ldd	r18, Y+12	; 0x0c
    2ef2:	3d 85       	ldd	r19, Y+13	; 0x0d
    2ef4:	b9 01       	movw	r22, r18
    2ef6:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2efa:	89 81       	ldd	r24, Y+1	; 0x01
    2efc:	9a 81       	ldd	r25, Y+2	; 0x02
    2efe:	0e 94 34 1c 	call	0x3868	; 0x3868 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2f02:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
    2f06:	88 23       	and	r24, r24
    2f08:	09 f0       	breq	.+2      	; 0x2f0c <xQueueGenericSend+0x122>
    2f0a:	85 cf       	rjmp	.-246    	; 0x2e16 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2f0c:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
    2f10:	82 cf       	rjmp	.-252    	; 0x2e16 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2f12:	89 81       	ldd	r24, Y+1	; 0x01
    2f14:	9a 81       	ldd	r25, Y+2	; 0x02
    2f16:	0e 94 34 1c 	call	0x3868	; 0x3868 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2f1a:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
    2f1e:	7b cf       	rjmp	.-266    	; 0x2e16 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2f20:	89 81       	ldd	r24, Y+1	; 0x01
    2f22:	9a 81       	ldd	r25, Y+2	; 0x02
    2f24:	0e 94 34 1c 	call	0x3868	; 0x3868 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2f28:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2f2c:	1f 86       	std	Y+15, r1	; 0x0f
    2f2e:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    2f30:	2f 96       	adiw	r28, 0x0f	; 15
    2f32:	0f b6       	in	r0, 0x3f	; 63
    2f34:	f8 94       	cli
    2f36:	de bf       	out	0x3e, r29	; 62
    2f38:	0f be       	out	0x3f, r0	; 63
    2f3a:	cd bf       	out	0x3d, r28	; 61
    2f3c:	cf 91       	pop	r28
    2f3e:	df 91       	pop	r29
    2f40:	08 95       	ret

00002f42 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2f42:	df 93       	push	r29
    2f44:	cf 93       	push	r28
    2f46:	cd b7       	in	r28, 0x3d	; 61
    2f48:	de b7       	in	r29, 0x3e	; 62
    2f4a:	2c 97       	sbiw	r28, 0x0c	; 12
    2f4c:	0f b6       	in	r0, 0x3f	; 63
    2f4e:	f8 94       	cli
    2f50:	de bf       	out	0x3e, r29	; 62
    2f52:	0f be       	out	0x3f, r0	; 63
    2f54:	cd bf       	out	0x3d, r28	; 61
    2f56:	9f 83       	std	Y+7, r25	; 0x07
    2f58:	8e 83       	std	Y+6, r24	; 0x06
    2f5a:	79 87       	std	Y+9, r23	; 0x09
    2f5c:	68 87       	std	Y+8, r22	; 0x08
    2f5e:	5b 87       	std	Y+11, r21	; 0x0b
    2f60:	4a 87       	std	Y+10, r20	; 0x0a
    2f62:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2f64:	8e 81       	ldd	r24, Y+6	; 0x06
    2f66:	9f 81       	ldd	r25, Y+7	; 0x07
    2f68:	9b 83       	std	Y+3, r25	; 0x03
    2f6a:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2f6c:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2f6e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f70:	fb 81       	ldd	r31, Y+3	; 0x03
    2f72:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f74:	ea 81       	ldd	r30, Y+2	; 0x02
    2f76:	fb 81       	ldd	r31, Y+3	; 0x03
    2f78:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f7a:	98 17       	cp	r25, r24
    2f7c:	18 f0       	brcs	.+6      	; 0x2f84 <xQueueGenericSendFromISR+0x42>
    2f7e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f80:	82 30       	cpi	r24, 0x02	; 2
    2f82:	61 f5       	brne	.+88     	; 0x2fdc <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2f84:	ea 81       	ldd	r30, Y+2	; 0x02
    2f86:	fb 81       	ldd	r31, Y+3	; 0x03
    2f88:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f8a:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2f8c:	8a 81       	ldd	r24, Y+2	; 0x02
    2f8e:	9b 81       	ldd	r25, Y+3	; 0x03
    2f90:	28 85       	ldd	r18, Y+8	; 0x08
    2f92:	39 85       	ldd	r19, Y+9	; 0x09
    2f94:	b9 01       	movw	r22, r18
    2f96:	4c 85       	ldd	r20, Y+12	; 0x0c
    2f98:	0e 94 47 1b 	call	0x368e	; 0x368e <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2f9c:	89 81       	ldd	r24, Y+1	; 0x01
    2f9e:	8f 3f       	cpi	r24, 0xFF	; 255
    2fa0:	a9 f4       	brne	.+42     	; 0x2fcc <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2fa2:	ea 81       	ldd	r30, Y+2	; 0x02
    2fa4:	fb 81       	ldd	r31, Y+3	; 0x03
    2fa6:	81 89       	ldd	r24, Z+17	; 0x11
    2fa8:	88 23       	and	r24, r24
    2faa:	a9 f0       	breq	.+42     	; 0x2fd6 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2fac:	8a 81       	ldd	r24, Y+2	; 0x02
    2fae:	9b 81       	ldd	r25, Y+3	; 0x03
    2fb0:	41 96       	adiw	r24, 0x11	; 17
    2fb2:	0e 94 24 2b 	call	0x5648	; 0x5648 <xTaskRemoveFromEventList>
    2fb6:	88 23       	and	r24, r24
    2fb8:	71 f0       	breq	.+28     	; 0x2fd6 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2fba:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fbc:	9b 85       	ldd	r25, Y+11	; 0x0b
    2fbe:	00 97       	sbiw	r24, 0x00	; 0
    2fc0:	51 f0       	breq	.+20     	; 0x2fd6 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2fc2:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fc4:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fc6:	81 e0       	ldi	r24, 0x01	; 1
    2fc8:	80 83       	st	Z, r24
    2fca:	05 c0       	rjmp	.+10     	; 0x2fd6 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2fcc:	89 81       	ldd	r24, Y+1	; 0x01
    2fce:	8f 5f       	subi	r24, 0xFF	; 255
    2fd0:	ea 81       	ldd	r30, Y+2	; 0x02
    2fd2:	fb 81       	ldd	r31, Y+3	; 0x03
    2fd4:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2fd6:	81 e0       	ldi	r24, 0x01	; 1
    2fd8:	8d 83       	std	Y+5, r24	; 0x05
    2fda:	01 c0       	rjmp	.+2      	; 0x2fde <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2fdc:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2fde:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2fe0:	2c 96       	adiw	r28, 0x0c	; 12
    2fe2:	0f b6       	in	r0, 0x3f	; 63
    2fe4:	f8 94       	cli
    2fe6:	de bf       	out	0x3e, r29	; 62
    2fe8:	0f be       	out	0x3f, r0	; 63
    2fea:	cd bf       	out	0x3d, r28	; 61
    2fec:	cf 91       	pop	r28
    2fee:	df 91       	pop	r29
    2ff0:	08 95       	ret

00002ff2 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2ff2:	df 93       	push	r29
    2ff4:	cf 93       	push	r28
    2ff6:	cd b7       	in	r28, 0x3d	; 61
    2ff8:	de b7       	in	r29, 0x3e	; 62
    2ffa:	2a 97       	sbiw	r28, 0x0a	; 10
    2ffc:	0f b6       	in	r0, 0x3f	; 63
    2ffe:	f8 94       	cli
    3000:	de bf       	out	0x3e, r29	; 62
    3002:	0f be       	out	0x3f, r0	; 63
    3004:	cd bf       	out	0x3d, r28	; 61
    3006:	98 87       	std	Y+8, r25	; 0x08
    3008:	8f 83       	std	Y+7, r24	; 0x07
    300a:	7a 87       	std	Y+10, r23	; 0x0a
    300c:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    300e:	8f 81       	ldd	r24, Y+7	; 0x07
    3010:	98 85       	ldd	r25, Y+8	; 0x08
    3012:	9c 83       	std	Y+4, r25	; 0x04
    3014:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3016:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3018:	eb 81       	ldd	r30, Y+3	; 0x03
    301a:	fc 81       	ldd	r31, Y+4	; 0x04
    301c:	82 8d       	ldd	r24, Z+26	; 0x1a
    301e:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    3020:	eb 81       	ldd	r30, Y+3	; 0x03
    3022:	fc 81       	ldd	r31, Y+4	; 0x04
    3024:	93 8d       	ldd	r25, Z+27	; 0x1b
    3026:	8a 81       	ldd	r24, Y+2	; 0x02
    3028:	89 17       	cp	r24, r25
    302a:	48 f5       	brcc	.+82     	; 0x307e <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    302c:	eb 81       	ldd	r30, Y+3	; 0x03
    302e:	fc 81       	ldd	r31, Y+4	; 0x04
    3030:	86 8d       	ldd	r24, Z+30	; 0x1e
    3032:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3034:	8a 81       	ldd	r24, Y+2	; 0x02
    3036:	8f 5f       	subi	r24, 0xFF	; 255
    3038:	eb 81       	ldd	r30, Y+3	; 0x03
    303a:	fc 81       	ldd	r31, Y+4	; 0x04
    303c:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    303e:	89 81       	ldd	r24, Y+1	; 0x01
    3040:	8f 3f       	cpi	r24, 0xFF	; 255
    3042:	a9 f4       	brne	.+42     	; 0x306e <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3044:	eb 81       	ldd	r30, Y+3	; 0x03
    3046:	fc 81       	ldd	r31, Y+4	; 0x04
    3048:	81 89       	ldd	r24, Z+17	; 0x11
    304a:	88 23       	and	r24, r24
    304c:	a9 f0       	breq	.+42     	; 0x3078 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    304e:	8b 81       	ldd	r24, Y+3	; 0x03
    3050:	9c 81       	ldd	r25, Y+4	; 0x04
    3052:	41 96       	adiw	r24, 0x11	; 17
    3054:	0e 94 24 2b 	call	0x5648	; 0x5648 <xTaskRemoveFromEventList>
    3058:	88 23       	and	r24, r24
    305a:	71 f0       	breq	.+28     	; 0x3078 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    305c:	89 85       	ldd	r24, Y+9	; 0x09
    305e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3060:	00 97       	sbiw	r24, 0x00	; 0
    3062:	51 f0       	breq	.+20     	; 0x3078 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3064:	e9 85       	ldd	r30, Y+9	; 0x09
    3066:	fa 85       	ldd	r31, Y+10	; 0x0a
    3068:	81 e0       	ldi	r24, 0x01	; 1
    306a:	80 83       	st	Z, r24
    306c:	05 c0       	rjmp	.+10     	; 0x3078 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    306e:	89 81       	ldd	r24, Y+1	; 0x01
    3070:	8f 5f       	subi	r24, 0xFF	; 255
    3072:	eb 81       	ldd	r30, Y+3	; 0x03
    3074:	fc 81       	ldd	r31, Y+4	; 0x04
    3076:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3078:	81 e0       	ldi	r24, 0x01	; 1
    307a:	8e 83       	std	Y+6, r24	; 0x06
    307c:	01 c0       	rjmp	.+2      	; 0x3080 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    307e:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3080:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3082:	2a 96       	adiw	r28, 0x0a	; 10
    3084:	0f b6       	in	r0, 0x3f	; 63
    3086:	f8 94       	cli
    3088:	de bf       	out	0x3e, r29	; 62
    308a:	0f be       	out	0x3f, r0	; 63
    308c:	cd bf       	out	0x3d, r28	; 61
    308e:	cf 91       	pop	r28
    3090:	df 91       	pop	r29
    3092:	08 95       	ret

00003094 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    3094:	df 93       	push	r29
    3096:	cf 93       	push	r28
    3098:	cd b7       	in	r28, 0x3d	; 61
    309a:	de b7       	in	r29, 0x3e	; 62
    309c:	2e 97       	sbiw	r28, 0x0e	; 14
    309e:	0f b6       	in	r0, 0x3f	; 63
    30a0:	f8 94       	cli
    30a2:	de bf       	out	0x3e, r29	; 62
    30a4:	0f be       	out	0x3f, r0	; 63
    30a6:	cd bf       	out	0x3d, r28	; 61
    30a8:	99 87       	std	Y+9, r25	; 0x09
    30aa:	88 87       	std	Y+8, r24	; 0x08
    30ac:	7b 87       	std	Y+11, r23	; 0x0b
    30ae:	6a 87       	std	Y+10, r22	; 0x0a
    30b0:	5d 87       	std	Y+13, r21	; 0x0d
    30b2:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    30b4:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    30b6:	88 85       	ldd	r24, Y+8	; 0x08
    30b8:	99 85       	ldd	r25, Y+9	; 0x09
    30ba:	9b 83       	std	Y+3, r25	; 0x03
    30bc:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    30be:	0f b6       	in	r0, 0x3f	; 63
    30c0:	f8 94       	cli
    30c2:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    30c4:	ea 81       	ldd	r30, Y+2	; 0x02
    30c6:	fb 81       	ldd	r31, Y+3	; 0x03
    30c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    30ca:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    30cc:	89 81       	ldd	r24, Y+1	; 0x01
    30ce:	88 23       	and	r24, r24
    30d0:	f9 f0       	breq	.+62     	; 0x3110 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    30d2:	8a 81       	ldd	r24, Y+2	; 0x02
    30d4:	9b 81       	ldd	r25, Y+3	; 0x03
    30d6:	2a 85       	ldd	r18, Y+10	; 0x0a
    30d8:	3b 85       	ldd	r19, Y+11	; 0x0b
    30da:	b9 01       	movw	r22, r18
    30dc:	0e 94 ed 1b 	call	0x37da	; 0x37da <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    30e0:	89 81       	ldd	r24, Y+1	; 0x01
    30e2:	81 50       	subi	r24, 0x01	; 1
    30e4:	ea 81       	ldd	r30, Y+2	; 0x02
    30e6:	fb 81       	ldd	r31, Y+3	; 0x03
    30e8:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    30ea:	ea 81       	ldd	r30, Y+2	; 0x02
    30ec:	fb 81       	ldd	r31, Y+3	; 0x03
    30ee:	80 85       	ldd	r24, Z+8	; 0x08
    30f0:	88 23       	and	r24, r24
    30f2:	49 f0       	breq	.+18     	; 0x3106 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    30f4:	8a 81       	ldd	r24, Y+2	; 0x02
    30f6:	9b 81       	ldd	r25, Y+3	; 0x03
    30f8:	08 96       	adiw	r24, 0x08	; 8
    30fa:	0e 94 24 2b 	call	0x5648	; 0x5648 <xTaskRemoveFromEventList>
    30fe:	88 23       	and	r24, r24
    3100:	11 f0       	breq	.+4      	; 0x3106 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    3102:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3106:	0f 90       	pop	r0
    3108:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    310a:	81 e0       	ldi	r24, 0x01	; 1
    310c:	8e 87       	std	Y+14, r24	; 0x0e
    310e:	63 c0       	rjmp	.+198    	; 0x31d6 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3110:	8c 85       	ldd	r24, Y+12	; 0x0c
    3112:	9d 85       	ldd	r25, Y+13	; 0x0d
    3114:	00 97       	sbiw	r24, 0x00	; 0
    3116:	21 f4       	brne	.+8      	; 0x3120 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3118:	0f 90       	pop	r0
    311a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    311c:	1e 86       	std	Y+14, r1	; 0x0e
    311e:	5b c0       	rjmp	.+182    	; 0x31d6 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    3120:	8c 81       	ldd	r24, Y+4	; 0x04
    3122:	88 23       	and	r24, r24
    3124:	31 f4       	brne	.+12     	; 0x3132 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3126:	ce 01       	movw	r24, r28
    3128:	05 96       	adiw	r24, 0x05	; 5
    312a:	0e 94 0a 2c 	call	0x5814	; 0x5814 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    312e:	81 e0       	ldi	r24, 0x01	; 1
    3130:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3132:	0f 90       	pop	r0
    3134:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3136:	0e 94 84 28 	call	0x5108	; 0x5108 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    313a:	0f b6       	in	r0, 0x3f	; 63
    313c:	f8 94       	cli
    313e:	0f 92       	push	r0
    3140:	ea 81       	ldd	r30, Y+2	; 0x02
    3142:	fb 81       	ldd	r31, Y+3	; 0x03
    3144:	85 8d       	ldd	r24, Z+29	; 0x1d
    3146:	8f 3f       	cpi	r24, 0xFF	; 255
    3148:	19 f4       	brne	.+6      	; 0x3150 <xQueueReceive+0xbc>
    314a:	ea 81       	ldd	r30, Y+2	; 0x02
    314c:	fb 81       	ldd	r31, Y+3	; 0x03
    314e:	15 8e       	std	Z+29, r1	; 0x1d
    3150:	ea 81       	ldd	r30, Y+2	; 0x02
    3152:	fb 81       	ldd	r31, Y+3	; 0x03
    3154:	86 8d       	ldd	r24, Z+30	; 0x1e
    3156:	8f 3f       	cpi	r24, 0xFF	; 255
    3158:	19 f4       	brne	.+6      	; 0x3160 <xQueueReceive+0xcc>
    315a:	ea 81       	ldd	r30, Y+2	; 0x02
    315c:	fb 81       	ldd	r31, Y+3	; 0x03
    315e:	16 8e       	std	Z+30, r1	; 0x1e
    3160:	0f 90       	pop	r0
    3162:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3164:	ce 01       	movw	r24, r28
    3166:	05 96       	adiw	r24, 0x05	; 5
    3168:	9e 01       	movw	r18, r28
    316a:	24 5f       	subi	r18, 0xF4	; 244
    316c:	3f 4f       	sbci	r19, 0xFF	; 255
    316e:	b9 01       	movw	r22, r18
    3170:	0e 94 23 2c 	call	0x5846	; 0x5846 <xTaskCheckForTimeOut>
    3174:	88 23       	and	r24, r24
    3176:	09 f5       	brne	.+66     	; 0x31ba <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3178:	8a 81       	ldd	r24, Y+2	; 0x02
    317a:	9b 81       	ldd	r25, Y+3	; 0x03
    317c:	0e 94 87 1c 	call	0x390e	; 0x390e <prvIsQueueEmpty>
    3180:	88 23       	and	r24, r24
    3182:	a1 f0       	breq	.+40     	; 0x31ac <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3184:	8a 81       	ldd	r24, Y+2	; 0x02
    3186:	9b 81       	ldd	r25, Y+3	; 0x03
    3188:	41 96       	adiw	r24, 0x11	; 17
    318a:	2c 85       	ldd	r18, Y+12	; 0x0c
    318c:	3d 85       	ldd	r19, Y+13	; 0x0d
    318e:	b9 01       	movw	r22, r18
    3190:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3194:	8a 81       	ldd	r24, Y+2	; 0x02
    3196:	9b 81       	ldd	r25, Y+3	; 0x03
    3198:	0e 94 34 1c 	call	0x3868	; 0x3868 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    319c:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
    31a0:	88 23       	and	r24, r24
    31a2:	09 f0       	breq	.+2      	; 0x31a6 <xQueueReceive+0x112>
    31a4:	8c cf       	rjmp	.-232    	; 0x30be <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    31a6:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
    31aa:	89 cf       	rjmp	.-238    	; 0x30be <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    31ac:	8a 81       	ldd	r24, Y+2	; 0x02
    31ae:	9b 81       	ldd	r25, Y+3	; 0x03
    31b0:	0e 94 34 1c 	call	0x3868	; 0x3868 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    31b4:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
    31b8:	82 cf       	rjmp	.-252    	; 0x30be <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    31ba:	8a 81       	ldd	r24, Y+2	; 0x02
    31bc:	9b 81       	ldd	r25, Y+3	; 0x03
    31be:	0e 94 34 1c 	call	0x3868	; 0x3868 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    31c2:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    31c6:	8a 81       	ldd	r24, Y+2	; 0x02
    31c8:	9b 81       	ldd	r25, Y+3	; 0x03
    31ca:	0e 94 87 1c 	call	0x390e	; 0x390e <prvIsQueueEmpty>
    31ce:	88 23       	and	r24, r24
    31d0:	09 f4       	brne	.+2      	; 0x31d4 <xQueueReceive+0x140>
    31d2:	75 cf       	rjmp	.-278    	; 0x30be <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    31d4:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    31d6:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    31d8:	2e 96       	adiw	r28, 0x0e	; 14
    31da:	0f b6       	in	r0, 0x3f	; 63
    31dc:	f8 94       	cli
    31de:	de bf       	out	0x3e, r29	; 62
    31e0:	0f be       	out	0x3f, r0	; 63
    31e2:	cd bf       	out	0x3d, r28	; 61
    31e4:	cf 91       	pop	r28
    31e6:	df 91       	pop	r29
    31e8:	08 95       	ret

000031ea <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    31ea:	df 93       	push	r29
    31ec:	cf 93       	push	r28
    31ee:	cd b7       	in	r28, 0x3d	; 61
    31f0:	de b7       	in	r29, 0x3e	; 62
    31f2:	2c 97       	sbiw	r28, 0x0c	; 12
    31f4:	0f b6       	in	r0, 0x3f	; 63
    31f6:	f8 94       	cli
    31f8:	de bf       	out	0x3e, r29	; 62
    31fa:	0f be       	out	0x3f, r0	; 63
    31fc:	cd bf       	out	0x3d, r28	; 61
    31fe:	99 87       	std	Y+9, r25	; 0x09
    3200:	88 87       	std	Y+8, r24	; 0x08
    3202:	7b 87       	std	Y+11, r23	; 0x0b
    3204:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    3206:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3208:	88 85       	ldd	r24, Y+8	; 0x08
    320a:	99 85       	ldd	r25, Y+9	; 0x09
    320c:	9b 83       	std	Y+3, r25	; 0x03
    320e:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3210:	0f b6       	in	r0, 0x3f	; 63
    3212:	f8 94       	cli
    3214:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    3216:	ea 81       	ldd	r30, Y+2	; 0x02
    3218:	fb 81       	ldd	r31, Y+3	; 0x03
    321a:	82 8d       	ldd	r24, Z+26	; 0x1a
    321c:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    321e:	89 81       	ldd	r24, Y+1	; 0x01
    3220:	88 23       	and	r24, r24
    3222:	c1 f0       	breq	.+48     	; 0x3254 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3224:	89 81       	ldd	r24, Y+1	; 0x01
    3226:	81 50       	subi	r24, 0x01	; 1
    3228:	ea 81       	ldd	r30, Y+2	; 0x02
    322a:	fb 81       	ldd	r31, Y+3	; 0x03
    322c:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    322e:	ea 81       	ldd	r30, Y+2	; 0x02
    3230:	fb 81       	ldd	r31, Y+3	; 0x03
    3232:	80 85       	ldd	r24, Z+8	; 0x08
    3234:	88 23       	and	r24, r24
    3236:	49 f0       	breq	.+18     	; 0x324a <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3238:	8a 81       	ldd	r24, Y+2	; 0x02
    323a:	9b 81       	ldd	r25, Y+3	; 0x03
    323c:	08 96       	adiw	r24, 0x08	; 8
    323e:	0e 94 24 2b 	call	0x5648	; 0x5648 <xTaskRemoveFromEventList>
    3242:	88 23       	and	r24, r24
    3244:	11 f0       	breq	.+4      	; 0x324a <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    3246:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    324a:	0f 90       	pop	r0
    324c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    324e:	81 e0       	ldi	r24, 0x01	; 1
    3250:	8c 87       	std	Y+12, r24	; 0x0c
    3252:	63 c0       	rjmp	.+198    	; 0x331a <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3254:	8a 85       	ldd	r24, Y+10	; 0x0a
    3256:	9b 85       	ldd	r25, Y+11	; 0x0b
    3258:	00 97       	sbiw	r24, 0x00	; 0
    325a:	21 f4       	brne	.+8      	; 0x3264 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    325c:	0f 90       	pop	r0
    325e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3260:	1c 86       	std	Y+12, r1	; 0x0c
    3262:	5b c0       	rjmp	.+182    	; 0x331a <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    3264:	8c 81       	ldd	r24, Y+4	; 0x04
    3266:	88 23       	and	r24, r24
    3268:	31 f4       	brne	.+12     	; 0x3276 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    326a:	ce 01       	movw	r24, r28
    326c:	05 96       	adiw	r24, 0x05	; 5
    326e:	0e 94 0a 2c 	call	0x5814	; 0x5814 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3272:	81 e0       	ldi	r24, 0x01	; 1
    3274:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3276:	0f 90       	pop	r0
    3278:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    327a:	0e 94 84 28 	call	0x5108	; 0x5108 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    327e:	0f b6       	in	r0, 0x3f	; 63
    3280:	f8 94       	cli
    3282:	0f 92       	push	r0
    3284:	ea 81       	ldd	r30, Y+2	; 0x02
    3286:	fb 81       	ldd	r31, Y+3	; 0x03
    3288:	85 8d       	ldd	r24, Z+29	; 0x1d
    328a:	8f 3f       	cpi	r24, 0xFF	; 255
    328c:	19 f4       	brne	.+6      	; 0x3294 <xQueueSemaphoreTake+0xaa>
    328e:	ea 81       	ldd	r30, Y+2	; 0x02
    3290:	fb 81       	ldd	r31, Y+3	; 0x03
    3292:	15 8e       	std	Z+29, r1	; 0x1d
    3294:	ea 81       	ldd	r30, Y+2	; 0x02
    3296:	fb 81       	ldd	r31, Y+3	; 0x03
    3298:	86 8d       	ldd	r24, Z+30	; 0x1e
    329a:	8f 3f       	cpi	r24, 0xFF	; 255
    329c:	19 f4       	brne	.+6      	; 0x32a4 <xQueueSemaphoreTake+0xba>
    329e:	ea 81       	ldd	r30, Y+2	; 0x02
    32a0:	fb 81       	ldd	r31, Y+3	; 0x03
    32a2:	16 8e       	std	Z+30, r1	; 0x1e
    32a4:	0f 90       	pop	r0
    32a6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    32a8:	ce 01       	movw	r24, r28
    32aa:	05 96       	adiw	r24, 0x05	; 5
    32ac:	9e 01       	movw	r18, r28
    32ae:	26 5f       	subi	r18, 0xF6	; 246
    32b0:	3f 4f       	sbci	r19, 0xFF	; 255
    32b2:	b9 01       	movw	r22, r18
    32b4:	0e 94 23 2c 	call	0x5846	; 0x5846 <xTaskCheckForTimeOut>
    32b8:	88 23       	and	r24, r24
    32ba:	09 f5       	brne	.+66     	; 0x32fe <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    32bc:	8a 81       	ldd	r24, Y+2	; 0x02
    32be:	9b 81       	ldd	r25, Y+3	; 0x03
    32c0:	0e 94 87 1c 	call	0x390e	; 0x390e <prvIsQueueEmpty>
    32c4:	88 23       	and	r24, r24
    32c6:	a1 f0       	breq	.+40     	; 0x32f0 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    32c8:	8a 81       	ldd	r24, Y+2	; 0x02
    32ca:	9b 81       	ldd	r25, Y+3	; 0x03
    32cc:	41 96       	adiw	r24, 0x11	; 17
    32ce:	2a 85       	ldd	r18, Y+10	; 0x0a
    32d0:	3b 85       	ldd	r19, Y+11	; 0x0b
    32d2:	b9 01       	movw	r22, r18
    32d4:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    32d8:	8a 81       	ldd	r24, Y+2	; 0x02
    32da:	9b 81       	ldd	r25, Y+3	; 0x03
    32dc:	0e 94 34 1c 	call	0x3868	; 0x3868 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    32e0:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
    32e4:	88 23       	and	r24, r24
    32e6:	09 f0       	breq	.+2      	; 0x32ea <xQueueSemaphoreTake+0x100>
    32e8:	93 cf       	rjmp	.-218    	; 0x3210 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    32ea:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
    32ee:	90 cf       	rjmp	.-224    	; 0x3210 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    32f0:	8a 81       	ldd	r24, Y+2	; 0x02
    32f2:	9b 81       	ldd	r25, Y+3	; 0x03
    32f4:	0e 94 34 1c 	call	0x3868	; 0x3868 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    32f8:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
    32fc:	89 cf       	rjmp	.-238    	; 0x3210 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    32fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3300:	9b 81       	ldd	r25, Y+3	; 0x03
    3302:	0e 94 34 1c 	call	0x3868	; 0x3868 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3306:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    330a:	8a 81       	ldd	r24, Y+2	; 0x02
    330c:	9b 81       	ldd	r25, Y+3	; 0x03
    330e:	0e 94 87 1c 	call	0x390e	; 0x390e <prvIsQueueEmpty>
    3312:	88 23       	and	r24, r24
    3314:	09 f4       	brne	.+2      	; 0x3318 <xQueueSemaphoreTake+0x12e>
    3316:	7c cf       	rjmp	.-264    	; 0x3210 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3318:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    331a:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    331c:	2c 96       	adiw	r28, 0x0c	; 12
    331e:	0f b6       	in	r0, 0x3f	; 63
    3320:	f8 94       	cli
    3322:	de bf       	out	0x3e, r29	; 62
    3324:	0f be       	out	0x3f, r0	; 63
    3326:	cd bf       	out	0x3d, r28	; 61
    3328:	cf 91       	pop	r28
    332a:	df 91       	pop	r29
    332c:	08 95       	ret

0000332e <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    332e:	df 93       	push	r29
    3330:	cf 93       	push	r28
    3332:	cd b7       	in	r28, 0x3d	; 61
    3334:	de b7       	in	r29, 0x3e	; 62
    3336:	60 97       	sbiw	r28, 0x10	; 16
    3338:	0f b6       	in	r0, 0x3f	; 63
    333a:	f8 94       	cli
    333c:	de bf       	out	0x3e, r29	; 62
    333e:	0f be       	out	0x3f, r0	; 63
    3340:	cd bf       	out	0x3d, r28	; 61
    3342:	9b 87       	std	Y+11, r25	; 0x0b
    3344:	8a 87       	std	Y+10, r24	; 0x0a
    3346:	7d 87       	std	Y+13, r23	; 0x0d
    3348:	6c 87       	std	Y+12, r22	; 0x0c
    334a:	5f 87       	std	Y+15, r21	; 0x0f
    334c:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    334e:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    3350:	8a 85       	ldd	r24, Y+10	; 0x0a
    3352:	9b 85       	ldd	r25, Y+11	; 0x0b
    3354:	9b 83       	std	Y+3, r25	; 0x03
    3356:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3358:	0f b6       	in	r0, 0x3f	; 63
    335a:	f8 94       	cli
    335c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    335e:	ea 81       	ldd	r30, Y+2	; 0x02
    3360:	fb 81       	ldd	r31, Y+3	; 0x03
    3362:	82 8d       	ldd	r24, Z+26	; 0x1a
    3364:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3366:	89 81       	ldd	r24, Y+1	; 0x01
    3368:	88 23       	and	r24, r24
    336a:	31 f1       	breq	.+76     	; 0x33b8 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    336c:	ea 81       	ldd	r30, Y+2	; 0x02
    336e:	fb 81       	ldd	r31, Y+3	; 0x03
    3370:	86 81       	ldd	r24, Z+6	; 0x06
    3372:	97 81       	ldd	r25, Z+7	; 0x07
    3374:	9d 83       	std	Y+5, r25	; 0x05
    3376:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3378:	8a 81       	ldd	r24, Y+2	; 0x02
    337a:	9b 81       	ldd	r25, Y+3	; 0x03
    337c:	2c 85       	ldd	r18, Y+12	; 0x0c
    337e:	3d 85       	ldd	r19, Y+13	; 0x0d
    3380:	b9 01       	movw	r22, r18
    3382:	0e 94 ed 1b 	call	0x37da	; 0x37da <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3386:	ea 81       	ldd	r30, Y+2	; 0x02
    3388:	fb 81       	ldd	r31, Y+3	; 0x03
    338a:	8c 81       	ldd	r24, Y+4	; 0x04
    338c:	9d 81       	ldd	r25, Y+5	; 0x05
    338e:	97 83       	std	Z+7, r25	; 0x07
    3390:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3392:	ea 81       	ldd	r30, Y+2	; 0x02
    3394:	fb 81       	ldd	r31, Y+3	; 0x03
    3396:	81 89       	ldd	r24, Z+17	; 0x11
    3398:	88 23       	and	r24, r24
    339a:	49 f0       	breq	.+18     	; 0x33ae <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    339c:	8a 81       	ldd	r24, Y+2	; 0x02
    339e:	9b 81       	ldd	r25, Y+3	; 0x03
    33a0:	41 96       	adiw	r24, 0x11	; 17
    33a2:	0e 94 24 2b 	call	0x5648	; 0x5648 <xTaskRemoveFromEventList>
    33a6:	88 23       	and	r24, r24
    33a8:	11 f0       	breq	.+4      	; 0x33ae <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    33aa:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    33ae:	0f 90       	pop	r0
    33b0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    33b2:	81 e0       	ldi	r24, 0x01	; 1
    33b4:	88 8b       	std	Y+16, r24	; 0x10
    33b6:	63 c0       	rjmp	.+198    	; 0x347e <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    33b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    33ba:	9f 85       	ldd	r25, Y+15	; 0x0f
    33bc:	00 97       	sbiw	r24, 0x00	; 0
    33be:	21 f4       	brne	.+8      	; 0x33c8 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    33c0:	0f 90       	pop	r0
    33c2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    33c4:	18 8a       	std	Y+16, r1	; 0x10
    33c6:	5b c0       	rjmp	.+182    	; 0x347e <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    33c8:	8e 81       	ldd	r24, Y+6	; 0x06
    33ca:	88 23       	and	r24, r24
    33cc:	31 f4       	brne	.+12     	; 0x33da <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    33ce:	ce 01       	movw	r24, r28
    33d0:	07 96       	adiw	r24, 0x07	; 7
    33d2:	0e 94 0a 2c 	call	0x5814	; 0x5814 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    33d6:	81 e0       	ldi	r24, 0x01	; 1
    33d8:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    33da:	0f 90       	pop	r0
    33dc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    33de:	0e 94 84 28 	call	0x5108	; 0x5108 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    33e2:	0f b6       	in	r0, 0x3f	; 63
    33e4:	f8 94       	cli
    33e6:	0f 92       	push	r0
    33e8:	ea 81       	ldd	r30, Y+2	; 0x02
    33ea:	fb 81       	ldd	r31, Y+3	; 0x03
    33ec:	85 8d       	ldd	r24, Z+29	; 0x1d
    33ee:	8f 3f       	cpi	r24, 0xFF	; 255
    33f0:	19 f4       	brne	.+6      	; 0x33f8 <xQueuePeek+0xca>
    33f2:	ea 81       	ldd	r30, Y+2	; 0x02
    33f4:	fb 81       	ldd	r31, Y+3	; 0x03
    33f6:	15 8e       	std	Z+29, r1	; 0x1d
    33f8:	ea 81       	ldd	r30, Y+2	; 0x02
    33fa:	fb 81       	ldd	r31, Y+3	; 0x03
    33fc:	86 8d       	ldd	r24, Z+30	; 0x1e
    33fe:	8f 3f       	cpi	r24, 0xFF	; 255
    3400:	19 f4       	brne	.+6      	; 0x3408 <xQueuePeek+0xda>
    3402:	ea 81       	ldd	r30, Y+2	; 0x02
    3404:	fb 81       	ldd	r31, Y+3	; 0x03
    3406:	16 8e       	std	Z+30, r1	; 0x1e
    3408:	0f 90       	pop	r0
    340a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    340c:	ce 01       	movw	r24, r28
    340e:	07 96       	adiw	r24, 0x07	; 7
    3410:	9e 01       	movw	r18, r28
    3412:	22 5f       	subi	r18, 0xF2	; 242
    3414:	3f 4f       	sbci	r19, 0xFF	; 255
    3416:	b9 01       	movw	r22, r18
    3418:	0e 94 23 2c 	call	0x5846	; 0x5846 <xTaskCheckForTimeOut>
    341c:	88 23       	and	r24, r24
    341e:	09 f5       	brne	.+66     	; 0x3462 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3420:	8a 81       	ldd	r24, Y+2	; 0x02
    3422:	9b 81       	ldd	r25, Y+3	; 0x03
    3424:	0e 94 87 1c 	call	0x390e	; 0x390e <prvIsQueueEmpty>
    3428:	88 23       	and	r24, r24
    342a:	a1 f0       	breq	.+40     	; 0x3454 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    342c:	8a 81       	ldd	r24, Y+2	; 0x02
    342e:	9b 81       	ldd	r25, Y+3	; 0x03
    3430:	41 96       	adiw	r24, 0x11	; 17
    3432:	2e 85       	ldd	r18, Y+14	; 0x0e
    3434:	3f 85       	ldd	r19, Y+15	; 0x0f
    3436:	b9 01       	movw	r22, r18
    3438:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    343c:	8a 81       	ldd	r24, Y+2	; 0x02
    343e:	9b 81       	ldd	r25, Y+3	; 0x03
    3440:	0e 94 34 1c 	call	0x3868	; 0x3868 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3444:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
    3448:	88 23       	and	r24, r24
    344a:	09 f0       	breq	.+2      	; 0x344e <xQueuePeek+0x120>
    344c:	85 cf       	rjmp	.-246    	; 0x3358 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    344e:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
    3452:	82 cf       	rjmp	.-252    	; 0x3358 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    3454:	8a 81       	ldd	r24, Y+2	; 0x02
    3456:	9b 81       	ldd	r25, Y+3	; 0x03
    3458:	0e 94 34 1c 	call	0x3868	; 0x3868 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    345c:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
    3460:	7b cf       	rjmp	.-266    	; 0x3358 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    3462:	8a 81       	ldd	r24, Y+2	; 0x02
    3464:	9b 81       	ldd	r25, Y+3	; 0x03
    3466:	0e 94 34 1c 	call	0x3868	; 0x3868 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    346a:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    346e:	8a 81       	ldd	r24, Y+2	; 0x02
    3470:	9b 81       	ldd	r25, Y+3	; 0x03
    3472:	0e 94 87 1c 	call	0x390e	; 0x390e <prvIsQueueEmpty>
    3476:	88 23       	and	r24, r24
    3478:	09 f4       	brne	.+2      	; 0x347c <xQueuePeek+0x14e>
    347a:	6e cf       	rjmp	.-292    	; 0x3358 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    347c:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    347e:	88 89       	ldd	r24, Y+16	; 0x10
}
    3480:	60 96       	adiw	r28, 0x10	; 16
    3482:	0f b6       	in	r0, 0x3f	; 63
    3484:	f8 94       	cli
    3486:	de bf       	out	0x3e, r29	; 62
    3488:	0f be       	out	0x3f, r0	; 63
    348a:	cd bf       	out	0x3d, r28	; 61
    348c:	cf 91       	pop	r28
    348e:	df 91       	pop	r29
    3490:	08 95       	ret

00003492 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3492:	df 93       	push	r29
    3494:	cf 93       	push	r28
    3496:	cd b7       	in	r28, 0x3d	; 61
    3498:	de b7       	in	r29, 0x3e	; 62
    349a:	2c 97       	sbiw	r28, 0x0c	; 12
    349c:	0f b6       	in	r0, 0x3f	; 63
    349e:	f8 94       	cli
    34a0:	de bf       	out	0x3e, r29	; 62
    34a2:	0f be       	out	0x3f, r0	; 63
    34a4:	cd bf       	out	0x3d, r28	; 61
    34a6:	98 87       	std	Y+8, r25	; 0x08
    34a8:	8f 83       	std	Y+7, r24	; 0x07
    34aa:	7a 87       	std	Y+10, r23	; 0x0a
    34ac:	69 87       	std	Y+9, r22	; 0x09
    34ae:	5c 87       	std	Y+12, r21	; 0x0c
    34b0:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    34b2:	8f 81       	ldd	r24, Y+7	; 0x07
    34b4:	98 85       	ldd	r25, Y+8	; 0x08
    34b6:	9c 83       	std	Y+4, r25	; 0x04
    34b8:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    34ba:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    34bc:	eb 81       	ldd	r30, Y+3	; 0x03
    34be:	fc 81       	ldd	r31, Y+4	; 0x04
    34c0:	82 8d       	ldd	r24, Z+26	; 0x1a
    34c2:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    34c4:	8a 81       	ldd	r24, Y+2	; 0x02
    34c6:	88 23       	and	r24, r24
    34c8:	81 f1       	breq	.+96     	; 0x352a <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    34ca:	eb 81       	ldd	r30, Y+3	; 0x03
    34cc:	fc 81       	ldd	r31, Y+4	; 0x04
    34ce:	85 8d       	ldd	r24, Z+29	; 0x1d
    34d0:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    34d2:	8b 81       	ldd	r24, Y+3	; 0x03
    34d4:	9c 81       	ldd	r25, Y+4	; 0x04
    34d6:	29 85       	ldd	r18, Y+9	; 0x09
    34d8:	3a 85       	ldd	r19, Y+10	; 0x0a
    34da:	b9 01       	movw	r22, r18
    34dc:	0e 94 ed 1b 	call	0x37da	; 0x37da <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    34e0:	8a 81       	ldd	r24, Y+2	; 0x02
    34e2:	81 50       	subi	r24, 0x01	; 1
    34e4:	eb 81       	ldd	r30, Y+3	; 0x03
    34e6:	fc 81       	ldd	r31, Y+4	; 0x04
    34e8:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    34ea:	89 81       	ldd	r24, Y+1	; 0x01
    34ec:	8f 3f       	cpi	r24, 0xFF	; 255
    34ee:	a9 f4       	brne	.+42     	; 0x351a <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    34f0:	eb 81       	ldd	r30, Y+3	; 0x03
    34f2:	fc 81       	ldd	r31, Y+4	; 0x04
    34f4:	80 85       	ldd	r24, Z+8	; 0x08
    34f6:	88 23       	and	r24, r24
    34f8:	a9 f0       	breq	.+42     	; 0x3524 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    34fa:	8b 81       	ldd	r24, Y+3	; 0x03
    34fc:	9c 81       	ldd	r25, Y+4	; 0x04
    34fe:	08 96       	adiw	r24, 0x08	; 8
    3500:	0e 94 24 2b 	call	0x5648	; 0x5648 <xTaskRemoveFromEventList>
    3504:	88 23       	and	r24, r24
    3506:	71 f0       	breq	.+28     	; 0x3524 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3508:	8b 85       	ldd	r24, Y+11	; 0x0b
    350a:	9c 85       	ldd	r25, Y+12	; 0x0c
    350c:	00 97       	sbiw	r24, 0x00	; 0
    350e:	51 f0       	breq	.+20     	; 0x3524 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3510:	eb 85       	ldd	r30, Y+11	; 0x0b
    3512:	fc 85       	ldd	r31, Y+12	; 0x0c
    3514:	81 e0       	ldi	r24, 0x01	; 1
    3516:	80 83       	st	Z, r24
    3518:	05 c0       	rjmp	.+10     	; 0x3524 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    351a:	89 81       	ldd	r24, Y+1	; 0x01
    351c:	8f 5f       	subi	r24, 0xFF	; 255
    351e:	eb 81       	ldd	r30, Y+3	; 0x03
    3520:	fc 81       	ldd	r31, Y+4	; 0x04
    3522:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3524:	81 e0       	ldi	r24, 0x01	; 1
    3526:	8e 83       	std	Y+6, r24	; 0x06
    3528:	01 c0       	rjmp	.+2      	; 0x352c <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    352a:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    352c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    352e:	2c 96       	adiw	r28, 0x0c	; 12
    3530:	0f b6       	in	r0, 0x3f	; 63
    3532:	f8 94       	cli
    3534:	de bf       	out	0x3e, r29	; 62
    3536:	0f be       	out	0x3f, r0	; 63
    3538:	cd bf       	out	0x3d, r28	; 61
    353a:	cf 91       	pop	r28
    353c:	df 91       	pop	r29
    353e:	08 95       	ret

00003540 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3540:	df 93       	push	r29
    3542:	cf 93       	push	r28
    3544:	cd b7       	in	r28, 0x3d	; 61
    3546:	de b7       	in	r29, 0x3e	; 62
    3548:	2a 97       	sbiw	r28, 0x0a	; 10
    354a:	0f b6       	in	r0, 0x3f	; 63
    354c:	f8 94       	cli
    354e:	de bf       	out	0x3e, r29	; 62
    3550:	0f be       	out	0x3f, r0	; 63
    3552:	cd bf       	out	0x3d, r28	; 61
    3554:	98 87       	std	Y+8, r25	; 0x08
    3556:	8f 83       	std	Y+7, r24	; 0x07
    3558:	7a 87       	std	Y+10, r23	; 0x0a
    355a:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    355c:	8f 81       	ldd	r24, Y+7	; 0x07
    355e:	98 85       	ldd	r25, Y+8	; 0x08
    3560:	9a 83       	std	Y+2, r25	; 0x02
    3562:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3564:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3566:	e9 81       	ldd	r30, Y+1	; 0x01
    3568:	fa 81       	ldd	r31, Y+2	; 0x02
    356a:	82 8d       	ldd	r24, Z+26	; 0x1a
    356c:	88 23       	and	r24, r24
    356e:	b1 f0       	breq	.+44     	; 0x359c <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3570:	e9 81       	ldd	r30, Y+1	; 0x01
    3572:	fa 81       	ldd	r31, Y+2	; 0x02
    3574:	86 81       	ldd	r24, Z+6	; 0x06
    3576:	97 81       	ldd	r25, Z+7	; 0x07
    3578:	9c 83       	std	Y+4, r25	; 0x04
    357a:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    357c:	89 81       	ldd	r24, Y+1	; 0x01
    357e:	9a 81       	ldd	r25, Y+2	; 0x02
    3580:	29 85       	ldd	r18, Y+9	; 0x09
    3582:	3a 85       	ldd	r19, Y+10	; 0x0a
    3584:	b9 01       	movw	r22, r18
    3586:	0e 94 ed 1b 	call	0x37da	; 0x37da <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    358a:	e9 81       	ldd	r30, Y+1	; 0x01
    358c:	fa 81       	ldd	r31, Y+2	; 0x02
    358e:	8b 81       	ldd	r24, Y+3	; 0x03
    3590:	9c 81       	ldd	r25, Y+4	; 0x04
    3592:	97 83       	std	Z+7, r25	; 0x07
    3594:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    3596:	81 e0       	ldi	r24, 0x01	; 1
    3598:	8e 83       	std	Y+6, r24	; 0x06
    359a:	01 c0       	rjmp	.+2      	; 0x359e <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    359c:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    359e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    35a0:	2a 96       	adiw	r28, 0x0a	; 10
    35a2:	0f b6       	in	r0, 0x3f	; 63
    35a4:	f8 94       	cli
    35a6:	de bf       	out	0x3e, r29	; 62
    35a8:	0f be       	out	0x3f, r0	; 63
    35aa:	cd bf       	out	0x3d, r28	; 61
    35ac:	cf 91       	pop	r28
    35ae:	df 91       	pop	r29
    35b0:	08 95       	ret

000035b2 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    35b2:	df 93       	push	r29
    35b4:	cf 93       	push	r28
    35b6:	00 d0       	rcall	.+0      	; 0x35b8 <uxQueueMessagesWaiting+0x6>
    35b8:	0f 92       	push	r0
    35ba:	cd b7       	in	r28, 0x3d	; 61
    35bc:	de b7       	in	r29, 0x3e	; 62
    35be:	9b 83       	std	Y+3, r25	; 0x03
    35c0:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    35c2:	0f b6       	in	r0, 0x3f	; 63
    35c4:	f8 94       	cli
    35c6:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    35c8:	ea 81       	ldd	r30, Y+2	; 0x02
    35ca:	fb 81       	ldd	r31, Y+3	; 0x03
    35cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    35ce:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    35d0:	0f 90       	pop	r0
    35d2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    35d4:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    35d6:	0f 90       	pop	r0
    35d8:	0f 90       	pop	r0
    35da:	0f 90       	pop	r0
    35dc:	cf 91       	pop	r28
    35de:	df 91       	pop	r29
    35e0:	08 95       	ret

000035e2 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    35e2:	df 93       	push	r29
    35e4:	cf 93       	push	r28
    35e6:	00 d0       	rcall	.+0      	; 0x35e8 <uxQueueSpacesAvailable+0x6>
    35e8:	00 d0       	rcall	.+0      	; 0x35ea <uxQueueSpacesAvailable+0x8>
    35ea:	0f 92       	push	r0
    35ec:	cd b7       	in	r28, 0x3d	; 61
    35ee:	de b7       	in	r29, 0x3e	; 62
    35f0:	9d 83       	std	Y+5, r25	; 0x05
    35f2:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    35f4:	8c 81       	ldd	r24, Y+4	; 0x04
    35f6:	9d 81       	ldd	r25, Y+5	; 0x05
    35f8:	9a 83       	std	Y+2, r25	; 0x02
    35fa:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    35fc:	0f b6       	in	r0, 0x3f	; 63
    35fe:	f8 94       	cli
    3600:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3602:	e9 81       	ldd	r30, Y+1	; 0x01
    3604:	fa 81       	ldd	r31, Y+2	; 0x02
    3606:	93 8d       	ldd	r25, Z+27	; 0x1b
    3608:	e9 81       	ldd	r30, Y+1	; 0x01
    360a:	fa 81       	ldd	r31, Y+2	; 0x02
    360c:	82 8d       	ldd	r24, Z+26	; 0x1a
    360e:	29 2f       	mov	r18, r25
    3610:	28 1b       	sub	r18, r24
    3612:	82 2f       	mov	r24, r18
    3614:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    3616:	0f 90       	pop	r0
    3618:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    361a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    361c:	0f 90       	pop	r0
    361e:	0f 90       	pop	r0
    3620:	0f 90       	pop	r0
    3622:	0f 90       	pop	r0
    3624:	0f 90       	pop	r0
    3626:	cf 91       	pop	r28
    3628:	df 91       	pop	r29
    362a:	08 95       	ret

0000362c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    362c:	df 93       	push	r29
    362e:	cf 93       	push	r28
    3630:	00 d0       	rcall	.+0      	; 0x3632 <uxQueueMessagesWaitingFromISR+0x6>
    3632:	00 d0       	rcall	.+0      	; 0x3634 <uxQueueMessagesWaitingFromISR+0x8>
    3634:	0f 92       	push	r0
    3636:	cd b7       	in	r28, 0x3d	; 61
    3638:	de b7       	in	r29, 0x3e	; 62
    363a:	9d 83       	std	Y+5, r25	; 0x05
    363c:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    363e:	8c 81       	ldd	r24, Y+4	; 0x04
    3640:	9d 81       	ldd	r25, Y+5	; 0x05
    3642:	9a 83       	std	Y+2, r25	; 0x02
    3644:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    3646:	e9 81       	ldd	r30, Y+1	; 0x01
    3648:	fa 81       	ldd	r31, Y+2	; 0x02
    364a:	82 8d       	ldd	r24, Z+26	; 0x1a
    364c:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    364e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3650:	0f 90       	pop	r0
    3652:	0f 90       	pop	r0
    3654:	0f 90       	pop	r0
    3656:	0f 90       	pop	r0
    3658:	0f 90       	pop	r0
    365a:	cf 91       	pop	r28
    365c:	df 91       	pop	r29
    365e:	08 95       	ret

00003660 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3660:	df 93       	push	r29
    3662:	cf 93       	push	r28
    3664:	00 d0       	rcall	.+0      	; 0x3666 <vQueueDelete+0x6>
    3666:	00 d0       	rcall	.+0      	; 0x3668 <vQueueDelete+0x8>
    3668:	cd b7       	in	r28, 0x3d	; 61
    366a:	de b7       	in	r29, 0x3e	; 62
    366c:	9c 83       	std	Y+4, r25	; 0x04
    366e:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    3670:	8b 81       	ldd	r24, Y+3	; 0x03
    3672:	9c 81       	ldd	r25, Y+4	; 0x04
    3674:	9a 83       	std	Y+2, r25	; 0x02
    3676:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    3678:	89 81       	ldd	r24, Y+1	; 0x01
    367a:	9a 81       	ldd	r25, Y+2	; 0x02
    367c:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3680:	0f 90       	pop	r0
    3682:	0f 90       	pop	r0
    3684:	0f 90       	pop	r0
    3686:	0f 90       	pop	r0
    3688:	cf 91       	pop	r28
    368a:	df 91       	pop	r29
    368c:	08 95       	ret

0000368e <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    368e:	df 93       	push	r29
    3690:	cf 93       	push	r28
    3692:	cd b7       	in	r28, 0x3d	; 61
    3694:	de b7       	in	r29, 0x3e	; 62
    3696:	27 97       	sbiw	r28, 0x07	; 7
    3698:	0f b6       	in	r0, 0x3f	; 63
    369a:	f8 94       	cli
    369c:	de bf       	out	0x3e, r29	; 62
    369e:	0f be       	out	0x3f, r0	; 63
    36a0:	cd bf       	out	0x3d, r28	; 61
    36a2:	9c 83       	std	Y+4, r25	; 0x04
    36a4:	8b 83       	std	Y+3, r24	; 0x03
    36a6:	7e 83       	std	Y+6, r23	; 0x06
    36a8:	6d 83       	std	Y+5, r22	; 0x05
    36aa:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    36ac:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    36ae:	eb 81       	ldd	r30, Y+3	; 0x03
    36b0:	fc 81       	ldd	r31, Y+4	; 0x04
    36b2:	82 8d       	ldd	r24, Z+26	; 0x1a
    36b4:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    36b6:	eb 81       	ldd	r30, Y+3	; 0x03
    36b8:	fc 81       	ldd	r31, Y+4	; 0x04
    36ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    36bc:	88 23       	and	r24, r24
    36be:	09 f4       	brne	.+2      	; 0x36c2 <prvCopyDataToQueue+0x34>
    36c0:	7d c0       	rjmp	.+250    	; 0x37bc <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    36c2:	8f 81       	ldd	r24, Y+7	; 0x07
    36c4:	88 23       	and	r24, r24
    36c6:	99 f5       	brne	.+102    	; 0x372e <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    36c8:	eb 81       	ldd	r30, Y+3	; 0x03
    36ca:	fc 81       	ldd	r31, Y+4	; 0x04
    36cc:	62 81       	ldd	r22, Z+2	; 0x02
    36ce:	73 81       	ldd	r23, Z+3	; 0x03
    36d0:	eb 81       	ldd	r30, Y+3	; 0x03
    36d2:	fc 81       	ldd	r31, Y+4	; 0x04
    36d4:	84 8d       	ldd	r24, Z+28	; 0x1c
    36d6:	48 2f       	mov	r20, r24
    36d8:	50 e0       	ldi	r21, 0x00	; 0
    36da:	2d 81       	ldd	r18, Y+5	; 0x05
    36dc:	3e 81       	ldd	r19, Y+6	; 0x06
    36de:	cb 01       	movw	r24, r22
    36e0:	b9 01       	movw	r22, r18
    36e2:	0e 94 ff 31 	call	0x63fe	; 0x63fe <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    36e6:	eb 81       	ldd	r30, Y+3	; 0x03
    36e8:	fc 81       	ldd	r31, Y+4	; 0x04
    36ea:	22 81       	ldd	r18, Z+2	; 0x02
    36ec:	33 81       	ldd	r19, Z+3	; 0x03
    36ee:	eb 81       	ldd	r30, Y+3	; 0x03
    36f0:	fc 81       	ldd	r31, Y+4	; 0x04
    36f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    36f4:	88 2f       	mov	r24, r24
    36f6:	90 e0       	ldi	r25, 0x00	; 0
    36f8:	82 0f       	add	r24, r18
    36fa:	93 1f       	adc	r25, r19
    36fc:	eb 81       	ldd	r30, Y+3	; 0x03
    36fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3700:	93 83       	std	Z+3, r25	; 0x03
    3702:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3704:	eb 81       	ldd	r30, Y+3	; 0x03
    3706:	fc 81       	ldd	r31, Y+4	; 0x04
    3708:	22 81       	ldd	r18, Z+2	; 0x02
    370a:	33 81       	ldd	r19, Z+3	; 0x03
    370c:	eb 81       	ldd	r30, Y+3	; 0x03
    370e:	fc 81       	ldd	r31, Y+4	; 0x04
    3710:	84 81       	ldd	r24, Z+4	; 0x04
    3712:	95 81       	ldd	r25, Z+5	; 0x05
    3714:	28 17       	cp	r18, r24
    3716:	39 07       	cpc	r19, r25
    3718:	08 f4       	brcc	.+2      	; 0x371c <prvCopyDataToQueue+0x8e>
    371a:	50 c0       	rjmp	.+160    	; 0x37bc <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    371c:	eb 81       	ldd	r30, Y+3	; 0x03
    371e:	fc 81       	ldd	r31, Y+4	; 0x04
    3720:	80 81       	ld	r24, Z
    3722:	91 81       	ldd	r25, Z+1	; 0x01
    3724:	eb 81       	ldd	r30, Y+3	; 0x03
    3726:	fc 81       	ldd	r31, Y+4	; 0x04
    3728:	93 83       	std	Z+3, r25	; 0x03
    372a:	82 83       	std	Z+2, r24	; 0x02
    372c:	47 c0       	rjmp	.+142    	; 0x37bc <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    372e:	eb 81       	ldd	r30, Y+3	; 0x03
    3730:	fc 81       	ldd	r31, Y+4	; 0x04
    3732:	66 81       	ldd	r22, Z+6	; 0x06
    3734:	77 81       	ldd	r23, Z+7	; 0x07
    3736:	eb 81       	ldd	r30, Y+3	; 0x03
    3738:	fc 81       	ldd	r31, Y+4	; 0x04
    373a:	84 8d       	ldd	r24, Z+28	; 0x1c
    373c:	48 2f       	mov	r20, r24
    373e:	50 e0       	ldi	r21, 0x00	; 0
    3740:	2d 81       	ldd	r18, Y+5	; 0x05
    3742:	3e 81       	ldd	r19, Y+6	; 0x06
    3744:	cb 01       	movw	r24, r22
    3746:	b9 01       	movw	r22, r18
    3748:	0e 94 ff 31 	call	0x63fe	; 0x63fe <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    374c:	eb 81       	ldd	r30, Y+3	; 0x03
    374e:	fc 81       	ldd	r31, Y+4	; 0x04
    3750:	26 81       	ldd	r18, Z+6	; 0x06
    3752:	37 81       	ldd	r19, Z+7	; 0x07
    3754:	eb 81       	ldd	r30, Y+3	; 0x03
    3756:	fc 81       	ldd	r31, Y+4	; 0x04
    3758:	84 8d       	ldd	r24, Z+28	; 0x1c
    375a:	88 2f       	mov	r24, r24
    375c:	90 e0       	ldi	r25, 0x00	; 0
    375e:	90 95       	com	r25
    3760:	81 95       	neg	r24
    3762:	9f 4f       	sbci	r25, 0xFF	; 255
    3764:	82 0f       	add	r24, r18
    3766:	93 1f       	adc	r25, r19
    3768:	eb 81       	ldd	r30, Y+3	; 0x03
    376a:	fc 81       	ldd	r31, Y+4	; 0x04
    376c:	97 83       	std	Z+7, r25	; 0x07
    376e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3770:	eb 81       	ldd	r30, Y+3	; 0x03
    3772:	fc 81       	ldd	r31, Y+4	; 0x04
    3774:	26 81       	ldd	r18, Z+6	; 0x06
    3776:	37 81       	ldd	r19, Z+7	; 0x07
    3778:	eb 81       	ldd	r30, Y+3	; 0x03
    377a:	fc 81       	ldd	r31, Y+4	; 0x04
    377c:	80 81       	ld	r24, Z
    377e:	91 81       	ldd	r25, Z+1	; 0x01
    3780:	28 17       	cp	r18, r24
    3782:	39 07       	cpc	r19, r25
    3784:	90 f4       	brcc	.+36     	; 0x37aa <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3786:	eb 81       	ldd	r30, Y+3	; 0x03
    3788:	fc 81       	ldd	r31, Y+4	; 0x04
    378a:	24 81       	ldd	r18, Z+4	; 0x04
    378c:	35 81       	ldd	r19, Z+5	; 0x05
    378e:	eb 81       	ldd	r30, Y+3	; 0x03
    3790:	fc 81       	ldd	r31, Y+4	; 0x04
    3792:	84 8d       	ldd	r24, Z+28	; 0x1c
    3794:	88 2f       	mov	r24, r24
    3796:	90 e0       	ldi	r25, 0x00	; 0
    3798:	90 95       	com	r25
    379a:	81 95       	neg	r24
    379c:	9f 4f       	sbci	r25, 0xFF	; 255
    379e:	82 0f       	add	r24, r18
    37a0:	93 1f       	adc	r25, r19
    37a2:	eb 81       	ldd	r30, Y+3	; 0x03
    37a4:	fc 81       	ldd	r31, Y+4	; 0x04
    37a6:	97 83       	std	Z+7, r25	; 0x07
    37a8:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    37aa:	8f 81       	ldd	r24, Y+7	; 0x07
    37ac:	82 30       	cpi	r24, 0x02	; 2
    37ae:	31 f4       	brne	.+12     	; 0x37bc <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    37b0:	89 81       	ldd	r24, Y+1	; 0x01
    37b2:	88 23       	and	r24, r24
    37b4:	19 f0       	breq	.+6      	; 0x37bc <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    37b6:	89 81       	ldd	r24, Y+1	; 0x01
    37b8:	81 50       	subi	r24, 0x01	; 1
    37ba:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    37bc:	89 81       	ldd	r24, Y+1	; 0x01
    37be:	8f 5f       	subi	r24, 0xFF	; 255
    37c0:	eb 81       	ldd	r30, Y+3	; 0x03
    37c2:	fc 81       	ldd	r31, Y+4	; 0x04
    37c4:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    37c6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    37c8:	27 96       	adiw	r28, 0x07	; 7
    37ca:	0f b6       	in	r0, 0x3f	; 63
    37cc:	f8 94       	cli
    37ce:	de bf       	out	0x3e, r29	; 62
    37d0:	0f be       	out	0x3f, r0	; 63
    37d2:	cd bf       	out	0x3d, r28	; 61
    37d4:	cf 91       	pop	r28
    37d6:	df 91       	pop	r29
    37d8:	08 95       	ret

000037da <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    37da:	df 93       	push	r29
    37dc:	cf 93       	push	r28
    37de:	00 d0       	rcall	.+0      	; 0x37e0 <prvCopyDataFromQueue+0x6>
    37e0:	00 d0       	rcall	.+0      	; 0x37e2 <prvCopyDataFromQueue+0x8>
    37e2:	cd b7       	in	r28, 0x3d	; 61
    37e4:	de b7       	in	r29, 0x3e	; 62
    37e6:	9a 83       	std	Y+2, r25	; 0x02
    37e8:	89 83       	std	Y+1, r24	; 0x01
    37ea:	7c 83       	std	Y+4, r23	; 0x04
    37ec:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    37ee:	e9 81       	ldd	r30, Y+1	; 0x01
    37f0:	fa 81       	ldd	r31, Y+2	; 0x02
    37f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    37f4:	88 23       	and	r24, r24
    37f6:	89 f1       	breq	.+98     	; 0x385a <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    37f8:	e9 81       	ldd	r30, Y+1	; 0x01
    37fa:	fa 81       	ldd	r31, Y+2	; 0x02
    37fc:	26 81       	ldd	r18, Z+6	; 0x06
    37fe:	37 81       	ldd	r19, Z+7	; 0x07
    3800:	e9 81       	ldd	r30, Y+1	; 0x01
    3802:	fa 81       	ldd	r31, Y+2	; 0x02
    3804:	84 8d       	ldd	r24, Z+28	; 0x1c
    3806:	88 2f       	mov	r24, r24
    3808:	90 e0       	ldi	r25, 0x00	; 0
    380a:	82 0f       	add	r24, r18
    380c:	93 1f       	adc	r25, r19
    380e:	e9 81       	ldd	r30, Y+1	; 0x01
    3810:	fa 81       	ldd	r31, Y+2	; 0x02
    3812:	97 83       	std	Z+7, r25	; 0x07
    3814:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3816:	e9 81       	ldd	r30, Y+1	; 0x01
    3818:	fa 81       	ldd	r31, Y+2	; 0x02
    381a:	26 81       	ldd	r18, Z+6	; 0x06
    381c:	37 81       	ldd	r19, Z+7	; 0x07
    381e:	e9 81       	ldd	r30, Y+1	; 0x01
    3820:	fa 81       	ldd	r31, Y+2	; 0x02
    3822:	84 81       	ldd	r24, Z+4	; 0x04
    3824:	95 81       	ldd	r25, Z+5	; 0x05
    3826:	28 17       	cp	r18, r24
    3828:	39 07       	cpc	r19, r25
    382a:	40 f0       	brcs	.+16     	; 0x383c <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    382c:	e9 81       	ldd	r30, Y+1	; 0x01
    382e:	fa 81       	ldd	r31, Y+2	; 0x02
    3830:	80 81       	ld	r24, Z
    3832:	91 81       	ldd	r25, Z+1	; 0x01
    3834:	e9 81       	ldd	r30, Y+1	; 0x01
    3836:	fa 81       	ldd	r31, Y+2	; 0x02
    3838:	97 83       	std	Z+7, r25	; 0x07
    383a:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    383c:	e9 81       	ldd	r30, Y+1	; 0x01
    383e:	fa 81       	ldd	r31, Y+2	; 0x02
    3840:	46 81       	ldd	r20, Z+6	; 0x06
    3842:	57 81       	ldd	r21, Z+7	; 0x07
    3844:	e9 81       	ldd	r30, Y+1	; 0x01
    3846:	fa 81       	ldd	r31, Y+2	; 0x02
    3848:	84 8d       	ldd	r24, Z+28	; 0x1c
    384a:	28 2f       	mov	r18, r24
    384c:	30 e0       	ldi	r19, 0x00	; 0
    384e:	8b 81       	ldd	r24, Y+3	; 0x03
    3850:	9c 81       	ldd	r25, Y+4	; 0x04
    3852:	ba 01       	movw	r22, r20
    3854:	a9 01       	movw	r20, r18
    3856:	0e 94 ff 31 	call	0x63fe	; 0x63fe <memcpy>
	}
}
    385a:	0f 90       	pop	r0
    385c:	0f 90       	pop	r0
    385e:	0f 90       	pop	r0
    3860:	0f 90       	pop	r0
    3862:	cf 91       	pop	r28
    3864:	df 91       	pop	r29
    3866:	08 95       	ret

00003868 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3868:	df 93       	push	r29
    386a:	cf 93       	push	r28
    386c:	00 d0       	rcall	.+0      	; 0x386e <prvUnlockQueue+0x6>
    386e:	00 d0       	rcall	.+0      	; 0x3870 <prvUnlockQueue+0x8>
    3870:	cd b7       	in	r28, 0x3d	; 61
    3872:	de b7       	in	r29, 0x3e	; 62
    3874:	9c 83       	std	Y+4, r25	; 0x04
    3876:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3878:	0f b6       	in	r0, 0x3f	; 63
    387a:	f8 94       	cli
    387c:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    387e:	eb 81       	ldd	r30, Y+3	; 0x03
    3880:	fc 81       	ldd	r31, Y+4	; 0x04
    3882:	86 8d       	ldd	r24, Z+30	; 0x1e
    3884:	8a 83       	std	Y+2, r24	; 0x02
    3886:	11 c0       	rjmp	.+34     	; 0x38aa <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3888:	eb 81       	ldd	r30, Y+3	; 0x03
    388a:	fc 81       	ldd	r31, Y+4	; 0x04
    388c:	81 89       	ldd	r24, Z+17	; 0x11
    388e:	88 23       	and	r24, r24
    3890:	79 f0       	breq	.+30     	; 0x38b0 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3892:	8b 81       	ldd	r24, Y+3	; 0x03
    3894:	9c 81       	ldd	r25, Y+4	; 0x04
    3896:	41 96       	adiw	r24, 0x11	; 17
    3898:	0e 94 24 2b 	call	0x5648	; 0x5648 <xTaskRemoveFromEventList>
    389c:	88 23       	and	r24, r24
    389e:	11 f0       	breq	.+4      	; 0x38a4 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    38a0:	0e 94 90 2c 	call	0x5920	; 0x5920 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    38a4:	8a 81       	ldd	r24, Y+2	; 0x02
    38a6:	81 50       	subi	r24, 0x01	; 1
    38a8:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    38aa:	8a 81       	ldd	r24, Y+2	; 0x02
    38ac:	18 16       	cp	r1, r24
    38ae:	64 f3       	brlt	.-40     	; 0x3888 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    38b0:	eb 81       	ldd	r30, Y+3	; 0x03
    38b2:	fc 81       	ldd	r31, Y+4	; 0x04
    38b4:	8f ef       	ldi	r24, 0xFF	; 255
    38b6:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    38b8:	0f 90       	pop	r0
    38ba:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    38bc:	0f b6       	in	r0, 0x3f	; 63
    38be:	f8 94       	cli
    38c0:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    38c2:	eb 81       	ldd	r30, Y+3	; 0x03
    38c4:	fc 81       	ldd	r31, Y+4	; 0x04
    38c6:	85 8d       	ldd	r24, Z+29	; 0x1d
    38c8:	89 83       	std	Y+1, r24	; 0x01
    38ca:	11 c0       	rjmp	.+34     	; 0x38ee <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    38cc:	eb 81       	ldd	r30, Y+3	; 0x03
    38ce:	fc 81       	ldd	r31, Y+4	; 0x04
    38d0:	80 85       	ldd	r24, Z+8	; 0x08
    38d2:	88 23       	and	r24, r24
    38d4:	79 f0       	breq	.+30     	; 0x38f4 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    38d6:	8b 81       	ldd	r24, Y+3	; 0x03
    38d8:	9c 81       	ldd	r25, Y+4	; 0x04
    38da:	08 96       	adiw	r24, 0x08	; 8
    38dc:	0e 94 24 2b 	call	0x5648	; 0x5648 <xTaskRemoveFromEventList>
    38e0:	88 23       	and	r24, r24
    38e2:	11 f0       	breq	.+4      	; 0x38e8 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    38e4:	0e 94 90 2c 	call	0x5920	; 0x5920 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    38e8:	89 81       	ldd	r24, Y+1	; 0x01
    38ea:	81 50       	subi	r24, 0x01	; 1
    38ec:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    38ee:	89 81       	ldd	r24, Y+1	; 0x01
    38f0:	18 16       	cp	r1, r24
    38f2:	64 f3       	brlt	.-40     	; 0x38cc <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    38f4:	eb 81       	ldd	r30, Y+3	; 0x03
    38f6:	fc 81       	ldd	r31, Y+4	; 0x04
    38f8:	8f ef       	ldi	r24, 0xFF	; 255
    38fa:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    38fc:	0f 90       	pop	r0
    38fe:	0f be       	out	0x3f, r0	; 63
}
    3900:	0f 90       	pop	r0
    3902:	0f 90       	pop	r0
    3904:	0f 90       	pop	r0
    3906:	0f 90       	pop	r0
    3908:	cf 91       	pop	r28
    390a:	df 91       	pop	r29
    390c:	08 95       	ret

0000390e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    390e:	df 93       	push	r29
    3910:	cf 93       	push	r28
    3912:	00 d0       	rcall	.+0      	; 0x3914 <prvIsQueueEmpty+0x6>
    3914:	0f 92       	push	r0
    3916:	cd b7       	in	r28, 0x3d	; 61
    3918:	de b7       	in	r29, 0x3e	; 62
    391a:	9b 83       	std	Y+3, r25	; 0x03
    391c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    391e:	0f b6       	in	r0, 0x3f	; 63
    3920:	f8 94       	cli
    3922:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3924:	ea 81       	ldd	r30, Y+2	; 0x02
    3926:	fb 81       	ldd	r31, Y+3	; 0x03
    3928:	82 8d       	ldd	r24, Z+26	; 0x1a
    392a:	88 23       	and	r24, r24
    392c:	19 f4       	brne	.+6      	; 0x3934 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    392e:	81 e0       	ldi	r24, 0x01	; 1
    3930:	89 83       	std	Y+1, r24	; 0x01
    3932:	01 c0       	rjmp	.+2      	; 0x3936 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    3934:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3936:	0f 90       	pop	r0
    3938:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    393a:	89 81       	ldd	r24, Y+1	; 0x01
}
    393c:	0f 90       	pop	r0
    393e:	0f 90       	pop	r0
    3940:	0f 90       	pop	r0
    3942:	cf 91       	pop	r28
    3944:	df 91       	pop	r29
    3946:	08 95       	ret

00003948 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3948:	df 93       	push	r29
    394a:	cf 93       	push	r28
    394c:	00 d0       	rcall	.+0      	; 0x394e <xQueueIsQueueEmptyFromISR+0x6>
    394e:	00 d0       	rcall	.+0      	; 0x3950 <xQueueIsQueueEmptyFromISR+0x8>
    3950:	0f 92       	push	r0
    3952:	cd b7       	in	r28, 0x3d	; 61
    3954:	de b7       	in	r29, 0x3e	; 62
    3956:	9d 83       	std	Y+5, r25	; 0x05
    3958:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    395a:	8c 81       	ldd	r24, Y+4	; 0x04
    395c:	9d 81       	ldd	r25, Y+5	; 0x05
    395e:	9a 83       	std	Y+2, r25	; 0x02
    3960:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3962:	e9 81       	ldd	r30, Y+1	; 0x01
    3964:	fa 81       	ldd	r31, Y+2	; 0x02
    3966:	82 8d       	ldd	r24, Z+26	; 0x1a
    3968:	88 23       	and	r24, r24
    396a:	19 f4       	brne	.+6      	; 0x3972 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    396c:	81 e0       	ldi	r24, 0x01	; 1
    396e:	8b 83       	std	Y+3, r24	; 0x03
    3970:	01 c0       	rjmp	.+2      	; 0x3974 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    3972:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    3974:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3976:	0f 90       	pop	r0
    3978:	0f 90       	pop	r0
    397a:	0f 90       	pop	r0
    397c:	0f 90       	pop	r0
    397e:	0f 90       	pop	r0
    3980:	cf 91       	pop	r28
    3982:	df 91       	pop	r29
    3984:	08 95       	ret

00003986 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3986:	df 93       	push	r29
    3988:	cf 93       	push	r28
    398a:	00 d0       	rcall	.+0      	; 0x398c <prvIsQueueFull+0x6>
    398c:	0f 92       	push	r0
    398e:	cd b7       	in	r28, 0x3d	; 61
    3990:	de b7       	in	r29, 0x3e	; 62
    3992:	9b 83       	std	Y+3, r25	; 0x03
    3994:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3996:	0f b6       	in	r0, 0x3f	; 63
    3998:	f8 94       	cli
    399a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    399c:	ea 81       	ldd	r30, Y+2	; 0x02
    399e:	fb 81       	ldd	r31, Y+3	; 0x03
    39a0:	92 8d       	ldd	r25, Z+26	; 0x1a
    39a2:	ea 81       	ldd	r30, Y+2	; 0x02
    39a4:	fb 81       	ldd	r31, Y+3	; 0x03
    39a6:	83 8d       	ldd	r24, Z+27	; 0x1b
    39a8:	98 17       	cp	r25, r24
    39aa:	19 f4       	brne	.+6      	; 0x39b2 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    39ac:	81 e0       	ldi	r24, 0x01	; 1
    39ae:	89 83       	std	Y+1, r24	; 0x01
    39b0:	01 c0       	rjmp	.+2      	; 0x39b4 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    39b2:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    39b4:	0f 90       	pop	r0
    39b6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    39b8:	89 81       	ldd	r24, Y+1	; 0x01
}
    39ba:	0f 90       	pop	r0
    39bc:	0f 90       	pop	r0
    39be:	0f 90       	pop	r0
    39c0:	cf 91       	pop	r28
    39c2:	df 91       	pop	r29
    39c4:	08 95       	ret

000039c6 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    39c6:	df 93       	push	r29
    39c8:	cf 93       	push	r28
    39ca:	00 d0       	rcall	.+0      	; 0x39cc <xQueueIsQueueFullFromISR+0x6>
    39cc:	00 d0       	rcall	.+0      	; 0x39ce <xQueueIsQueueFullFromISR+0x8>
    39ce:	0f 92       	push	r0
    39d0:	cd b7       	in	r28, 0x3d	; 61
    39d2:	de b7       	in	r29, 0x3e	; 62
    39d4:	9d 83       	std	Y+5, r25	; 0x05
    39d6:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    39d8:	8c 81       	ldd	r24, Y+4	; 0x04
    39da:	9d 81       	ldd	r25, Y+5	; 0x05
    39dc:	9a 83       	std	Y+2, r25	; 0x02
    39de:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    39e0:	e9 81       	ldd	r30, Y+1	; 0x01
    39e2:	fa 81       	ldd	r31, Y+2	; 0x02
    39e4:	92 8d       	ldd	r25, Z+26	; 0x1a
    39e6:	e9 81       	ldd	r30, Y+1	; 0x01
    39e8:	fa 81       	ldd	r31, Y+2	; 0x02
    39ea:	83 8d       	ldd	r24, Z+27	; 0x1b
    39ec:	98 17       	cp	r25, r24
    39ee:	19 f4       	brne	.+6      	; 0x39f6 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    39f0:	81 e0       	ldi	r24, 0x01	; 1
    39f2:	8b 83       	std	Y+3, r24	; 0x03
    39f4:	01 c0       	rjmp	.+2      	; 0x39f8 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    39f6:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    39f8:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    39fa:	0f 90       	pop	r0
    39fc:	0f 90       	pop	r0
    39fe:	0f 90       	pop	r0
    3a00:	0f 90       	pop	r0
    3a02:	0f 90       	pop	r0
    3a04:	cf 91       	pop	r28
    3a06:	df 91       	pop	r29
    3a08:	08 95       	ret

00003a0a <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    3a0a:	0f 93       	push	r16
    3a0c:	df 93       	push	r29
    3a0e:	cf 93       	push	r28
    3a10:	cd b7       	in	r28, 0x3d	; 61
    3a12:	de b7       	in	r29, 0x3e	; 62
    3a14:	28 97       	sbiw	r28, 0x08	; 8
    3a16:	0f b6       	in	r0, 0x3f	; 63
    3a18:	f8 94       	cli
    3a1a:	de bf       	out	0x3e, r29	; 62
    3a1c:	0f be       	out	0x3f, r0	; 63
    3a1e:	cd bf       	out	0x3d, r28	; 61
    3a20:	9d 83       	std	Y+5, r25	; 0x05
    3a22:	8c 83       	std	Y+4, r24	; 0x04
    3a24:	7f 83       	std	Y+7, r23	; 0x07
    3a26:	6e 83       	std	Y+6, r22	; 0x06
    3a28:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    3a2a:	88 85       	ldd	r24, Y+8	; 0x08
    3a2c:	81 30       	cpi	r24, 0x01	; 1
    3a2e:	19 f4       	brne	.+6      	; 0x3a36 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    3a30:	81 e0       	ldi	r24, 0x01	; 1
    3a32:	89 83       	std	Y+1, r24	; 0x01
    3a34:	01 c0       	rjmp	.+2      	; 0x3a38 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    3a36:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    3a38:	8e 81       	ldd	r24, Y+6	; 0x06
    3a3a:	9f 81       	ldd	r25, Y+7	; 0x07
    3a3c:	00 97       	sbiw	r24, 0x00	; 0
    3a3e:	21 f4       	brne	.+8      	; 0x3a48 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    3a40:	81 e0       	ldi	r24, 0x01	; 1
    3a42:	90 e0       	ldi	r25, 0x00	; 0
    3a44:	9f 83       	std	Y+7, r25	; 0x07
    3a46:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    3a48:	8c 81       	ldd	r24, Y+4	; 0x04
    3a4a:	9d 81       	ldd	r25, Y+5	; 0x05
    3a4c:	01 96       	adiw	r24, 0x01	; 1
    3a4e:	9d 83       	std	Y+5, r25	; 0x05
    3a50:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    3a52:	8c 81       	ldd	r24, Y+4	; 0x04
    3a54:	9d 81       	ldd	r25, Y+5	; 0x05
    3a56:	0f 96       	adiw	r24, 0x0f	; 15
    3a58:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <pvPortMalloc>
    3a5c:	9b 83       	std	Y+3, r25	; 0x03
    3a5e:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    3a60:	8a 81       	ldd	r24, Y+2	; 0x02
    3a62:	9b 81       	ldd	r25, Y+3	; 0x03
    3a64:	00 97       	sbiw	r24, 0x00	; 0
    3a66:	89 f0       	breq	.+34     	; 0x3a8a <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    3a68:	6a 81       	ldd	r22, Y+2	; 0x02
    3a6a:	7b 81       	ldd	r23, Y+3	; 0x03
    3a6c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a6e:	9b 81       	ldd	r25, Y+3	; 0x03
    3a70:	9c 01       	movw	r18, r24
    3a72:	21 5f       	subi	r18, 0xF1	; 241
    3a74:	3f 4f       	sbci	r19, 0xFF	; 255
    3a76:	4c 81       	ldd	r20, Y+4	; 0x04
    3a78:	5d 81       	ldd	r21, Y+5	; 0x05
    3a7a:	ee 81       	ldd	r30, Y+6	; 0x06
    3a7c:	ff 81       	ldd	r31, Y+7	; 0x07
    3a7e:	cb 01       	movw	r24, r22
    3a80:	b9 01       	movw	r22, r18
    3a82:	9f 01       	movw	r18, r30
    3a84:	09 81       	ldd	r16, Y+1	; 0x01
    3a86:	0e 94 5d 24 	call	0x48ba	; 0x48ba <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    3a8a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a8c:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    3a8e:	28 96       	adiw	r28, 0x08	; 8
    3a90:	0f b6       	in	r0, 0x3f	; 63
    3a92:	f8 94       	cli
    3a94:	de bf       	out	0x3e, r29	; 62
    3a96:	0f be       	out	0x3f, r0	; 63
    3a98:	cd bf       	out	0x3d, r28	; 61
    3a9a:	cf 91       	pop	r28
    3a9c:	df 91       	pop	r29
    3a9e:	0f 91       	pop	r16
    3aa0:	08 95       	ret

00003aa2 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    3aa2:	df 93       	push	r29
    3aa4:	cf 93       	push	r28
    3aa6:	00 d0       	rcall	.+0      	; 0x3aa8 <vStreamBufferDelete+0x6>
    3aa8:	00 d0       	rcall	.+0      	; 0x3aaa <vStreamBufferDelete+0x8>
    3aaa:	cd b7       	in	r28, 0x3d	; 61
    3aac:	de b7       	in	r29, 0x3e	; 62
    3aae:	9c 83       	std	Y+4, r25	; 0x04
    3ab0:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    3ab2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ab4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ab6:	9a 83       	std	Y+2, r25	; 0x02
    3ab8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    3aba:	e9 81       	ldd	r30, Y+1	; 0x01
    3abc:	fa 81       	ldd	r31, Y+2	; 0x02
    3abe:	86 85       	ldd	r24, Z+14	; 0x0e
    3ac0:	88 2f       	mov	r24, r24
    3ac2:	90 e0       	ldi	r25, 0x00	; 0
    3ac4:	82 70       	andi	r24, 0x02	; 2
    3ac6:	90 70       	andi	r25, 0x00	; 0
    3ac8:	00 97       	sbiw	r24, 0x00	; 0
    3aca:	29 f4       	brne	.+10     	; 0x3ad6 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    3acc:	89 81       	ldd	r24, Y+1	; 0x01
    3ace:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad0:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <vPortFree>
    3ad4:	08 c0       	rjmp	.+16     	; 0x3ae6 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    3ad6:	89 81       	ldd	r24, Y+1	; 0x01
    3ad8:	9a 81       	ldd	r25, Y+2	; 0x02
    3ada:	60 e0       	ldi	r22, 0x00	; 0
    3adc:	70 e0       	ldi	r23, 0x00	; 0
    3ade:	4f e0       	ldi	r20, 0x0F	; 15
    3ae0:	50 e0       	ldi	r21, 0x00	; 0
    3ae2:	0e 94 08 32 	call	0x6410	; 0x6410 <memset>
	}
}
    3ae6:	0f 90       	pop	r0
    3ae8:	0f 90       	pop	r0
    3aea:	0f 90       	pop	r0
    3aec:	0f 90       	pop	r0
    3aee:	cf 91       	pop	r28
    3af0:	df 91       	pop	r29
    3af2:	08 95       	ret

00003af4 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    3af4:	0f 93       	push	r16
    3af6:	df 93       	push	r29
    3af8:	cf 93       	push	r28
    3afa:	00 d0       	rcall	.+0      	; 0x3afc <xStreamBufferReset+0x8>
    3afc:	00 d0       	rcall	.+0      	; 0x3afe <xStreamBufferReset+0xa>
    3afe:	0f 92       	push	r0
    3b00:	cd b7       	in	r28, 0x3d	; 61
    3b02:	de b7       	in	r29, 0x3e	; 62
    3b04:	9d 83       	std	Y+5, r25	; 0x05
    3b06:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3b08:	8c 81       	ldd	r24, Y+4	; 0x04
    3b0a:	9d 81       	ldd	r25, Y+5	; 0x05
    3b0c:	9b 83       	std	Y+3, r25	; 0x03
    3b0e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    3b10:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    3b12:	0f b6       	in	r0, 0x3f	; 63
    3b14:	f8 94       	cli
    3b16:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    3b18:	ea 81       	ldd	r30, Y+2	; 0x02
    3b1a:	fb 81       	ldd	r31, Y+3	; 0x03
    3b1c:	80 85       	ldd	r24, Z+8	; 0x08
    3b1e:	91 85       	ldd	r25, Z+9	; 0x09
    3b20:	00 97       	sbiw	r24, 0x00	; 0
    3b22:	f1 f4       	brne	.+60     	; 0x3b60 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    3b24:	ea 81       	ldd	r30, Y+2	; 0x02
    3b26:	fb 81       	ldd	r31, Y+3	; 0x03
    3b28:	82 85       	ldd	r24, Z+10	; 0x0a
    3b2a:	93 85       	ldd	r25, Z+11	; 0x0b
    3b2c:	00 97       	sbiw	r24, 0x00	; 0
    3b2e:	c1 f4       	brne	.+48     	; 0x3b60 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    3b30:	ea 81       	ldd	r30, Y+2	; 0x02
    3b32:	fb 81       	ldd	r31, Y+3	; 0x03
    3b34:	24 85       	ldd	r18, Z+12	; 0x0c
    3b36:	35 85       	ldd	r19, Z+13	; 0x0d
    3b38:	ea 81       	ldd	r30, Y+2	; 0x02
    3b3a:	fb 81       	ldd	r31, Y+3	; 0x03
    3b3c:	44 81       	ldd	r20, Z+4	; 0x04
    3b3e:	55 81       	ldd	r21, Z+5	; 0x05
    3b40:	ea 81       	ldd	r30, Y+2	; 0x02
    3b42:	fb 81       	ldd	r31, Y+3	; 0x03
    3b44:	a6 81       	ldd	r26, Z+6	; 0x06
    3b46:	b7 81       	ldd	r27, Z+7	; 0x07
    3b48:	ea 81       	ldd	r30, Y+2	; 0x02
    3b4a:	fb 81       	ldd	r31, Y+3	; 0x03
    3b4c:	e6 85       	ldd	r30, Z+14	; 0x0e
    3b4e:	8a 81       	ldd	r24, Y+2	; 0x02
    3b50:	9b 81       	ldd	r25, Y+3	; 0x03
    3b52:	b9 01       	movw	r22, r18
    3b54:	9d 01       	movw	r18, r26
    3b56:	0e 2f       	mov	r16, r30
    3b58:	0e 94 5d 24 	call	0x48ba	; 0x48ba <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    3b5c:	81 e0       	ldi	r24, 0x01	; 1
    3b5e:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    3b60:	0f 90       	pop	r0
    3b62:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3b64:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b66:	0f 90       	pop	r0
    3b68:	0f 90       	pop	r0
    3b6a:	0f 90       	pop	r0
    3b6c:	0f 90       	pop	r0
    3b6e:	0f 90       	pop	r0
    3b70:	cf 91       	pop	r28
    3b72:	df 91       	pop	r29
    3b74:	0f 91       	pop	r16
    3b76:	08 95       	ret

00003b78 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    3b78:	df 93       	push	r29
    3b7a:	cf 93       	push	r28
    3b7c:	cd b7       	in	r28, 0x3d	; 61
    3b7e:	de b7       	in	r29, 0x3e	; 62
    3b80:	27 97       	sbiw	r28, 0x07	; 7
    3b82:	0f b6       	in	r0, 0x3f	; 63
    3b84:	f8 94       	cli
    3b86:	de bf       	out	0x3e, r29	; 62
    3b88:	0f be       	out	0x3f, r0	; 63
    3b8a:	cd bf       	out	0x3d, r28	; 61
    3b8c:	9d 83       	std	Y+5, r25	; 0x05
    3b8e:	8c 83       	std	Y+4, r24	; 0x04
    3b90:	7f 83       	std	Y+7, r23	; 0x07
    3b92:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3b94:	8c 81       	ldd	r24, Y+4	; 0x04
    3b96:	9d 81       	ldd	r25, Y+5	; 0x05
    3b98:	9b 83       	std	Y+3, r25	; 0x03
    3b9a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    3b9c:	8e 81       	ldd	r24, Y+6	; 0x06
    3b9e:	9f 81       	ldd	r25, Y+7	; 0x07
    3ba0:	00 97       	sbiw	r24, 0x00	; 0
    3ba2:	21 f4       	brne	.+8      	; 0x3bac <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    3ba4:	81 e0       	ldi	r24, 0x01	; 1
    3ba6:	90 e0       	ldi	r25, 0x00	; 0
    3ba8:	9f 83       	std	Y+7, r25	; 0x07
    3baa:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    3bac:	ea 81       	ldd	r30, Y+2	; 0x02
    3bae:	fb 81       	ldd	r31, Y+3	; 0x03
    3bb0:	24 81       	ldd	r18, Z+4	; 0x04
    3bb2:	35 81       	ldd	r19, Z+5	; 0x05
    3bb4:	8e 81       	ldd	r24, Y+6	; 0x06
    3bb6:	9f 81       	ldd	r25, Y+7	; 0x07
    3bb8:	28 17       	cp	r18, r24
    3bba:	39 07       	cpc	r19, r25
    3bbc:	48 f0       	brcs	.+18     	; 0x3bd0 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    3bbe:	ea 81       	ldd	r30, Y+2	; 0x02
    3bc0:	fb 81       	ldd	r31, Y+3	; 0x03
    3bc2:	8e 81       	ldd	r24, Y+6	; 0x06
    3bc4:	9f 81       	ldd	r25, Y+7	; 0x07
    3bc6:	97 83       	std	Z+7, r25	; 0x07
    3bc8:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    3bca:	81 e0       	ldi	r24, 0x01	; 1
    3bcc:	89 83       	std	Y+1, r24	; 0x01
    3bce:	01 c0       	rjmp	.+2      	; 0x3bd2 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    3bd0:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3bd2:	89 81       	ldd	r24, Y+1	; 0x01
}
    3bd4:	27 96       	adiw	r28, 0x07	; 7
    3bd6:	0f b6       	in	r0, 0x3f	; 63
    3bd8:	f8 94       	cli
    3bda:	de bf       	out	0x3e, r29	; 62
    3bdc:	0f be       	out	0x3f, r0	; 63
    3bde:	cd bf       	out	0x3d, r28	; 61
    3be0:	cf 91       	pop	r28
    3be2:	df 91       	pop	r29
    3be4:	08 95       	ret

00003be6 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3be6:	df 93       	push	r29
    3be8:	cf 93       	push	r28
    3bea:	00 d0       	rcall	.+0      	; 0x3bec <xStreamBufferSpacesAvailable+0x6>
    3bec:	00 d0       	rcall	.+0      	; 0x3bee <xStreamBufferSpacesAvailable+0x8>
    3bee:	00 d0       	rcall	.+0      	; 0x3bf0 <xStreamBufferSpacesAvailable+0xa>
    3bf0:	cd b7       	in	r28, 0x3d	; 61
    3bf2:	de b7       	in	r29, 0x3e	; 62
    3bf4:	9e 83       	std	Y+6, r25	; 0x06
    3bf6:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3bf8:	8d 81       	ldd	r24, Y+5	; 0x05
    3bfa:	9e 81       	ldd	r25, Y+6	; 0x06
    3bfc:	9c 83       	std	Y+4, r25	; 0x04
    3bfe:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    3c00:	eb 81       	ldd	r30, Y+3	; 0x03
    3c02:	fc 81       	ldd	r31, Y+4	; 0x04
    3c04:	24 81       	ldd	r18, Z+4	; 0x04
    3c06:	35 81       	ldd	r19, Z+5	; 0x05
    3c08:	eb 81       	ldd	r30, Y+3	; 0x03
    3c0a:	fc 81       	ldd	r31, Y+4	; 0x04
    3c0c:	80 81       	ld	r24, Z
    3c0e:	91 81       	ldd	r25, Z+1	; 0x01
    3c10:	82 0f       	add	r24, r18
    3c12:	93 1f       	adc	r25, r19
    3c14:	9a 83       	std	Y+2, r25	; 0x02
    3c16:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    3c18:	eb 81       	ldd	r30, Y+3	; 0x03
    3c1a:	fc 81       	ldd	r31, Y+4	; 0x04
    3c1c:	22 81       	ldd	r18, Z+2	; 0x02
    3c1e:	33 81       	ldd	r19, Z+3	; 0x03
    3c20:	89 81       	ldd	r24, Y+1	; 0x01
    3c22:	9a 81       	ldd	r25, Y+2	; 0x02
    3c24:	82 1b       	sub	r24, r18
    3c26:	93 0b       	sbc	r25, r19
    3c28:	9a 83       	std	Y+2, r25	; 0x02
    3c2a:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    3c2c:	89 81       	ldd	r24, Y+1	; 0x01
    3c2e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c30:	01 97       	sbiw	r24, 0x01	; 1
    3c32:	9a 83       	std	Y+2, r25	; 0x02
    3c34:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    3c36:	eb 81       	ldd	r30, Y+3	; 0x03
    3c38:	fc 81       	ldd	r31, Y+4	; 0x04
    3c3a:	24 81       	ldd	r18, Z+4	; 0x04
    3c3c:	35 81       	ldd	r19, Z+5	; 0x05
    3c3e:	89 81       	ldd	r24, Y+1	; 0x01
    3c40:	9a 81       	ldd	r25, Y+2	; 0x02
    3c42:	82 17       	cp	r24, r18
    3c44:	93 07       	cpc	r25, r19
    3c46:	50 f0       	brcs	.+20     	; 0x3c5c <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    3c48:	eb 81       	ldd	r30, Y+3	; 0x03
    3c4a:	fc 81       	ldd	r31, Y+4	; 0x04
    3c4c:	24 81       	ldd	r18, Z+4	; 0x04
    3c4e:	35 81       	ldd	r19, Z+5	; 0x05
    3c50:	89 81       	ldd	r24, Y+1	; 0x01
    3c52:	9a 81       	ldd	r25, Y+2	; 0x02
    3c54:	82 1b       	sub	r24, r18
    3c56:	93 0b       	sbc	r25, r19
    3c58:	9a 83       	std	Y+2, r25	; 0x02
    3c5a:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    3c5c:	89 81       	ldd	r24, Y+1	; 0x01
    3c5e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c60:	26 96       	adiw	r28, 0x06	; 6
    3c62:	0f b6       	in	r0, 0x3f	; 63
    3c64:	f8 94       	cli
    3c66:	de bf       	out	0x3e, r29	; 62
    3c68:	0f be       	out	0x3f, r0	; 63
    3c6a:	cd bf       	out	0x3d, r28	; 61
    3c6c:	cf 91       	pop	r28
    3c6e:	df 91       	pop	r29
    3c70:	08 95       	ret

00003c72 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3c72:	df 93       	push	r29
    3c74:	cf 93       	push	r28
    3c76:	00 d0       	rcall	.+0      	; 0x3c78 <xStreamBufferBytesAvailable+0x6>
    3c78:	00 d0       	rcall	.+0      	; 0x3c7a <xStreamBufferBytesAvailable+0x8>
    3c7a:	00 d0       	rcall	.+0      	; 0x3c7c <xStreamBufferBytesAvailable+0xa>
    3c7c:	cd b7       	in	r28, 0x3d	; 61
    3c7e:	de b7       	in	r29, 0x3e	; 62
    3c80:	9e 83       	std	Y+6, r25	; 0x06
    3c82:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3c84:	8d 81       	ldd	r24, Y+5	; 0x05
    3c86:	9e 81       	ldd	r25, Y+6	; 0x06
    3c88:	9c 83       	std	Y+4, r25	; 0x04
    3c8a:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    3c8c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c8e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c90:	0e 94 23 24 	call	0x4846	; 0x4846 <prvBytesInBuffer>
    3c94:	9a 83       	std	Y+2, r25	; 0x02
    3c96:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    3c98:	89 81       	ldd	r24, Y+1	; 0x01
    3c9a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c9c:	26 96       	adiw	r28, 0x06	; 6
    3c9e:	0f b6       	in	r0, 0x3f	; 63
    3ca0:	f8 94       	cli
    3ca2:	de bf       	out	0x3e, r29	; 62
    3ca4:	0f be       	out	0x3f, r0	; 63
    3ca6:	cd bf       	out	0x3d, r28	; 61
    3ca8:	cf 91       	pop	r28
    3caa:	df 91       	pop	r29
    3cac:	08 95       	ret

00003cae <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    3cae:	ef 92       	push	r14
    3cb0:	ff 92       	push	r15
    3cb2:	0f 93       	push	r16
    3cb4:	1f 93       	push	r17
    3cb6:	df 93       	push	r29
    3cb8:	cf 93       	push	r28
    3cba:	cd b7       	in	r28, 0x3d	; 61
    3cbc:	de b7       	in	r29, 0x3e	; 62
    3cbe:	63 97       	sbiw	r28, 0x13	; 19
    3cc0:	0f b6       	in	r0, 0x3f	; 63
    3cc2:	f8 94       	cli
    3cc4:	de bf       	out	0x3e, r29	; 62
    3cc6:	0f be       	out	0x3f, r0	; 63
    3cc8:	cd bf       	out	0x3d, r28	; 61
    3cca:	9d 87       	std	Y+13, r25	; 0x0d
    3ccc:	8c 87       	std	Y+12, r24	; 0x0c
    3cce:	7f 87       	std	Y+15, r23	; 0x0f
    3cd0:	6e 87       	std	Y+14, r22	; 0x0e
    3cd2:	59 8b       	std	Y+17, r21	; 0x11
    3cd4:	48 8b       	std	Y+16, r20	; 0x10
    3cd6:	3b 8b       	std	Y+19, r19	; 0x13
    3cd8:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3cda:	8c 85       	ldd	r24, Y+12	; 0x0c
    3cdc:	9d 85       	ldd	r25, Y+13	; 0x0d
    3cde:	98 87       	std	Y+8, r25	; 0x08
    3ce0:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    3ce2:	1c 82       	std	Y+4, r1	; 0x04
    3ce4:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    3ce6:	88 89       	ldd	r24, Y+16	; 0x10
    3ce8:	99 89       	ldd	r25, Y+17	; 0x11
    3cea:	9a 83       	std	Y+2, r25	; 0x02
    3cec:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3cee:	ef 81       	ldd	r30, Y+7	; 0x07
    3cf0:	f8 85       	ldd	r31, Y+8	; 0x08
    3cf2:	86 85       	ldd	r24, Z+14	; 0x0e
    3cf4:	88 2f       	mov	r24, r24
    3cf6:	90 e0       	ldi	r25, 0x00	; 0
    3cf8:	81 70       	andi	r24, 0x01	; 1
    3cfa:	90 70       	andi	r25, 0x00	; 0
    3cfc:	88 23       	and	r24, r24
    3cfe:	29 f0       	breq	.+10     	; 0x3d0a <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3d00:	89 81       	ldd	r24, Y+1	; 0x01
    3d02:	9a 81       	ldd	r25, Y+2	; 0x02
    3d04:	02 96       	adiw	r24, 0x02	; 2
    3d06:	9a 83       	std	Y+2, r25	; 0x02
    3d08:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3d0a:	8a 89       	ldd	r24, Y+18	; 0x12
    3d0c:	9b 89       	ldd	r25, Y+19	; 0x13
    3d0e:	00 97       	sbiw	r24, 0x00	; 0
    3d10:	09 f4       	brne	.+2      	; 0x3d14 <xStreamBufferSend+0x66>
    3d12:	40 c0       	rjmp	.+128    	; 0x3d94 <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    3d14:	ce 01       	movw	r24, r28
    3d16:	09 96       	adiw	r24, 0x09	; 9
    3d18:	0e 94 ec 2b 	call	0x57d8	; 0x57d8 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    3d1c:	0f b6       	in	r0, 0x3f	; 63
    3d1e:	f8 94       	cli
    3d20:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3d22:	8f 81       	ldd	r24, Y+7	; 0x07
    3d24:	98 85       	ldd	r25, Y+8	; 0x08
    3d26:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <xStreamBufferSpacesAvailable>
    3d2a:	9c 83       	std	Y+4, r25	; 0x04
    3d2c:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    3d2e:	2b 81       	ldd	r18, Y+3	; 0x03
    3d30:	3c 81       	ldd	r19, Y+4	; 0x04
    3d32:	89 81       	ldd	r24, Y+1	; 0x01
    3d34:	9a 81       	ldd	r25, Y+2	; 0x02
    3d36:	28 17       	cp	r18, r24
    3d38:	39 07       	cpc	r19, r25
    3d3a:	50 f5       	brcc	.+84     	; 0x3d90 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    3d3c:	80 e0       	ldi	r24, 0x00	; 0
    3d3e:	90 e0       	ldi	r25, 0x00	; 0
    3d40:	0e 94 fc 30 	call	0x61f8	; 0x61f8 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    3d44:	0e 94 55 2d 	call	0x5aaa	; 0x5aaa <xTaskGetCurrentTaskHandle>
    3d48:	ef 81       	ldd	r30, Y+7	; 0x07
    3d4a:	f8 85       	ldd	r31, Y+8	; 0x08
    3d4c:	93 87       	std	Z+11, r25	; 0x0b
    3d4e:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    3d50:	0f 90       	pop	r0
    3d52:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3d54:	ea 89       	ldd	r30, Y+18	; 0x12
    3d56:	fb 89       	ldd	r31, Y+19	; 0x13
    3d58:	60 e0       	ldi	r22, 0x00	; 0
    3d5a:	70 e0       	ldi	r23, 0x00	; 0
    3d5c:	80 e0       	ldi	r24, 0x00	; 0
    3d5e:	90 e0       	ldi	r25, 0x00	; 0
    3d60:	20 e0       	ldi	r18, 0x00	; 0
    3d62:	30 e0       	ldi	r19, 0x00	; 0
    3d64:	40 e0       	ldi	r20, 0x00	; 0
    3d66:	50 e0       	ldi	r21, 0x00	; 0
    3d68:	00 e0       	ldi	r16, 0x00	; 0
    3d6a:	10 e0       	ldi	r17, 0x00	; 0
    3d6c:	7f 01       	movw	r14, r30
    3d6e:	0e 94 05 2e 	call	0x5c0a	; 0x5c0a <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    3d72:	ef 81       	ldd	r30, Y+7	; 0x07
    3d74:	f8 85       	ldd	r31, Y+8	; 0x08
    3d76:	13 86       	std	Z+11, r1	; 0x0b
    3d78:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    3d7a:	ce 01       	movw	r24, r28
    3d7c:	09 96       	adiw	r24, 0x09	; 9
    3d7e:	9e 01       	movw	r18, r28
    3d80:	2e 5e       	subi	r18, 0xEE	; 238
    3d82:	3f 4f       	sbci	r19, 0xFF	; 255
    3d84:	b9 01       	movw	r22, r18
    3d86:	0e 94 23 2c 	call	0x5846	; 0x5846 <xTaskCheckForTimeOut>
    3d8a:	88 23       	and	r24, r24
    3d8c:	39 f2       	breq	.-114    	; 0x3d1c <xStreamBufferSend+0x6e>
    3d8e:	02 c0       	rjmp	.+4      	; 0x3d94 <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    3d90:	0f 90       	pop	r0
    3d92:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    3d94:	8b 81       	ldd	r24, Y+3	; 0x03
    3d96:	9c 81       	ldd	r25, Y+4	; 0x04
    3d98:	00 97       	sbiw	r24, 0x00	; 0
    3d9a:	31 f4       	brne	.+12     	; 0x3da8 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3d9c:	8f 81       	ldd	r24, Y+7	; 0x07
    3d9e:	98 85       	ldd	r25, Y+8	; 0x08
    3da0:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <xStreamBufferSpacesAvailable>
    3da4:	9c 83       	std	Y+4, r25	; 0x04
    3da6:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3da8:	8f 81       	ldd	r24, Y+7	; 0x07
    3daa:	98 85       	ldd	r25, Y+8	; 0x08
    3dac:	2e 85       	ldd	r18, Y+14	; 0x0e
    3dae:	3f 85       	ldd	r19, Y+15	; 0x0f
    3db0:	48 89       	ldd	r20, Y+16	; 0x10
    3db2:	59 89       	ldd	r21, Y+17	; 0x11
    3db4:	eb 81       	ldd	r30, Y+3	; 0x03
    3db6:	fc 81       	ldd	r31, Y+4	; 0x04
    3db8:	a9 81       	ldd	r26, Y+1	; 0x01
    3dba:	ba 81       	ldd	r27, Y+2	; 0x02
    3dbc:	b9 01       	movw	r22, r18
    3dbe:	9f 01       	movw	r18, r30
    3dc0:	8d 01       	movw	r16, r26
    3dc2:	0e 94 9c 1f 	call	0x3f38	; 0x3f38 <prvWriteMessageToBuffer>
    3dc6:	9e 83       	std	Y+6, r25	; 0x06
    3dc8:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    3dca:	8d 81       	ldd	r24, Y+5	; 0x05
    3dcc:	9e 81       	ldd	r25, Y+6	; 0x06
    3dce:	00 97       	sbiw	r24, 0x00	; 0
    3dd0:	39 f1       	breq	.+78     	; 0x3e20 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3dd2:	8f 81       	ldd	r24, Y+7	; 0x07
    3dd4:	98 85       	ldd	r25, Y+8	; 0x08
    3dd6:	0e 94 23 24 	call	0x4846	; 0x4846 <prvBytesInBuffer>
    3dda:	9c 01       	movw	r18, r24
    3ddc:	ef 81       	ldd	r30, Y+7	; 0x07
    3dde:	f8 85       	ldd	r31, Y+8	; 0x08
    3de0:	86 81       	ldd	r24, Z+6	; 0x06
    3de2:	97 81       	ldd	r25, Z+7	; 0x07
    3de4:	28 17       	cp	r18, r24
    3de6:	39 07       	cpc	r19, r25
    3de8:	d8 f0       	brcs	.+54     	; 0x3e20 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    3dea:	0e 94 84 28 	call	0x5108	; 0x5108 <vTaskSuspendAll>
    3dee:	ef 81       	ldd	r30, Y+7	; 0x07
    3df0:	f8 85       	ldd	r31, Y+8	; 0x08
    3df2:	80 85       	ldd	r24, Z+8	; 0x08
    3df4:	91 85       	ldd	r25, Z+9	; 0x09
    3df6:	00 97       	sbiw	r24, 0x00	; 0
    3df8:	89 f0       	breq	.+34     	; 0x3e1c <xStreamBufferSend+0x16e>
    3dfa:	ef 81       	ldd	r30, Y+7	; 0x07
    3dfc:	f8 85       	ldd	r31, Y+8	; 0x08
    3dfe:	80 85       	ldd	r24, Z+8	; 0x08
    3e00:	91 85       	ldd	r25, Z+9	; 0x09
    3e02:	40 e0       	ldi	r20, 0x00	; 0
    3e04:	50 e0       	ldi	r21, 0x00	; 0
    3e06:	60 e0       	ldi	r22, 0x00	; 0
    3e08:	70 e0       	ldi	r23, 0x00	; 0
    3e0a:	20 e0       	ldi	r18, 0x00	; 0
    3e0c:	00 e0       	ldi	r16, 0x00	; 0
    3e0e:	10 e0       	ldi	r17, 0x00	; 0
    3e10:	0e 94 a1 2e 	call	0x5d42	; 0x5d42 <xTaskGenericNotify>
    3e14:	ef 81       	ldd	r30, Y+7	; 0x07
    3e16:	f8 85       	ldd	r31, Y+8	; 0x08
    3e18:	11 86       	std	Z+9, r1	; 0x09
    3e1a:	10 86       	std	Z+8, r1	; 0x08
    3e1c:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    3e20:	8d 81       	ldd	r24, Y+5	; 0x05
    3e22:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3e24:	63 96       	adiw	r28, 0x13	; 19
    3e26:	0f b6       	in	r0, 0x3f	; 63
    3e28:	f8 94       	cli
    3e2a:	de bf       	out	0x3e, r29	; 62
    3e2c:	0f be       	out	0x3f, r0	; 63
    3e2e:	cd bf       	out	0x3d, r28	; 61
    3e30:	cf 91       	pop	r28
    3e32:	df 91       	pop	r29
    3e34:	1f 91       	pop	r17
    3e36:	0f 91       	pop	r16
    3e38:	ff 90       	pop	r15
    3e3a:	ef 90       	pop	r14
    3e3c:	08 95       	ret

00003e3e <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3e3e:	ef 92       	push	r14
    3e40:	ff 92       	push	r15
    3e42:	0f 93       	push	r16
    3e44:	1f 93       	push	r17
    3e46:	df 93       	push	r29
    3e48:	cf 93       	push	r28
    3e4a:	cd b7       	in	r28, 0x3d	; 61
    3e4c:	de b7       	in	r29, 0x3e	; 62
    3e4e:	61 97       	sbiw	r28, 0x11	; 17
    3e50:	0f b6       	in	r0, 0x3f	; 63
    3e52:	f8 94       	cli
    3e54:	de bf       	out	0x3e, r29	; 62
    3e56:	0f be       	out	0x3f, r0	; 63
    3e58:	cd bf       	out	0x3d, r28	; 61
    3e5a:	9b 87       	std	Y+11, r25	; 0x0b
    3e5c:	8a 87       	std	Y+10, r24	; 0x0a
    3e5e:	7d 87       	std	Y+13, r23	; 0x0d
    3e60:	6c 87       	std	Y+12, r22	; 0x0c
    3e62:	5f 87       	std	Y+15, r21	; 0x0f
    3e64:	4e 87       	std	Y+14, r20	; 0x0e
    3e66:	39 8b       	std	Y+17, r19	; 0x11
    3e68:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3e6a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e6c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e6e:	99 87       	std	Y+9, r25	; 0x09
    3e70:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    3e72:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e74:	9f 85       	ldd	r25, Y+15	; 0x0f
    3e76:	9b 83       	std	Y+3, r25	; 0x03
    3e78:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3e7a:	e8 85       	ldd	r30, Y+8	; 0x08
    3e7c:	f9 85       	ldd	r31, Y+9	; 0x09
    3e7e:	86 85       	ldd	r24, Z+14	; 0x0e
    3e80:	88 2f       	mov	r24, r24
    3e82:	90 e0       	ldi	r25, 0x00	; 0
    3e84:	81 70       	andi	r24, 0x01	; 1
    3e86:	90 70       	andi	r25, 0x00	; 0
    3e88:	88 23       	and	r24, r24
    3e8a:	29 f0       	breq	.+10     	; 0x3e96 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3e8c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e8e:	9b 81       	ldd	r25, Y+3	; 0x03
    3e90:	02 96       	adiw	r24, 0x02	; 2
    3e92:	9b 83       	std	Y+3, r25	; 0x03
    3e94:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3e96:	88 85       	ldd	r24, Y+8	; 0x08
    3e98:	99 85       	ldd	r25, Y+9	; 0x09
    3e9a:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <xStreamBufferSpacesAvailable>
    3e9e:	9d 83       	std	Y+5, r25	; 0x05
    3ea0:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3ea2:	88 85       	ldd	r24, Y+8	; 0x08
    3ea4:	99 85       	ldd	r25, Y+9	; 0x09
    3ea6:	2c 85       	ldd	r18, Y+12	; 0x0c
    3ea8:	3d 85       	ldd	r19, Y+13	; 0x0d
    3eaa:	4e 85       	ldd	r20, Y+14	; 0x0e
    3eac:	5f 85       	ldd	r21, Y+15	; 0x0f
    3eae:	ec 81       	ldd	r30, Y+4	; 0x04
    3eb0:	fd 81       	ldd	r31, Y+5	; 0x05
    3eb2:	aa 81       	ldd	r26, Y+2	; 0x02
    3eb4:	bb 81       	ldd	r27, Y+3	; 0x03
    3eb6:	b9 01       	movw	r22, r18
    3eb8:	9f 01       	movw	r18, r30
    3eba:	8d 01       	movw	r16, r26
    3ebc:	0e 94 9c 1f 	call	0x3f38	; 0x3f38 <prvWriteMessageToBuffer>
    3ec0:	9f 83       	std	Y+7, r25	; 0x07
    3ec2:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    3ec4:	8e 81       	ldd	r24, Y+6	; 0x06
    3ec6:	9f 81       	ldd	r25, Y+7	; 0x07
    3ec8:	00 97       	sbiw	r24, 0x00	; 0
    3eca:	39 f1       	breq	.+78     	; 0x3f1a <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3ecc:	88 85       	ldd	r24, Y+8	; 0x08
    3ece:	99 85       	ldd	r25, Y+9	; 0x09
    3ed0:	0e 94 23 24 	call	0x4846	; 0x4846 <prvBytesInBuffer>
    3ed4:	9c 01       	movw	r18, r24
    3ed6:	e8 85       	ldd	r30, Y+8	; 0x08
    3ed8:	f9 85       	ldd	r31, Y+9	; 0x09
    3eda:	86 81       	ldd	r24, Z+6	; 0x06
    3edc:	97 81       	ldd	r25, Z+7	; 0x07
    3ede:	28 17       	cp	r18, r24
    3ee0:	39 07       	cpc	r19, r25
    3ee2:	d8 f0       	brcs	.+54     	; 0x3f1a <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3ee4:	19 82       	std	Y+1, r1	; 0x01
    3ee6:	e8 85       	ldd	r30, Y+8	; 0x08
    3ee8:	f9 85       	ldd	r31, Y+9	; 0x09
    3eea:	80 85       	ldd	r24, Z+8	; 0x08
    3eec:	91 85       	ldd	r25, Z+9	; 0x09
    3eee:	00 97       	sbiw	r24, 0x00	; 0
    3ef0:	a1 f0       	breq	.+40     	; 0x3f1a <xStreamBufferSendFromISR+0xdc>
    3ef2:	e8 85       	ldd	r30, Y+8	; 0x08
    3ef4:	f9 85       	ldd	r31, Y+9	; 0x09
    3ef6:	80 85       	ldd	r24, Z+8	; 0x08
    3ef8:	91 85       	ldd	r25, Z+9	; 0x09
    3efa:	e8 89       	ldd	r30, Y+16	; 0x10
    3efc:	f9 89       	ldd	r31, Y+17	; 0x11
    3efe:	40 e0       	ldi	r20, 0x00	; 0
    3f00:	50 e0       	ldi	r21, 0x00	; 0
    3f02:	60 e0       	ldi	r22, 0x00	; 0
    3f04:	70 e0       	ldi	r23, 0x00	; 0
    3f06:	20 e0       	ldi	r18, 0x00	; 0
    3f08:	00 e0       	ldi	r16, 0x00	; 0
    3f0a:	10 e0       	ldi	r17, 0x00	; 0
    3f0c:	7f 01       	movw	r14, r30
    3f0e:	0e 94 7e 2f 	call	0x5efc	; 0x5efc <xTaskGenericNotifyFromISR>
    3f12:	e8 85       	ldd	r30, Y+8	; 0x08
    3f14:	f9 85       	ldd	r31, Y+9	; 0x09
    3f16:	11 86       	std	Z+9, r1	; 0x09
    3f18:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    3f1a:	8e 81       	ldd	r24, Y+6	; 0x06
    3f1c:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3f1e:	61 96       	adiw	r28, 0x11	; 17
    3f20:	0f b6       	in	r0, 0x3f	; 63
    3f22:	f8 94       	cli
    3f24:	de bf       	out	0x3e, r29	; 62
    3f26:	0f be       	out	0x3f, r0	; 63
    3f28:	cd bf       	out	0x3d, r28	; 61
    3f2a:	cf 91       	pop	r28
    3f2c:	df 91       	pop	r29
    3f2e:	1f 91       	pop	r17
    3f30:	0f 91       	pop	r16
    3f32:	ff 90       	pop	r15
    3f34:	ef 90       	pop	r14
    3f36:	08 95       	ret

00003f38 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    3f38:	0f 93       	push	r16
    3f3a:	1f 93       	push	r17
    3f3c:	df 93       	push	r29
    3f3e:	cf 93       	push	r28
    3f40:	cd b7       	in	r28, 0x3d	; 61
    3f42:	de b7       	in	r29, 0x3e	; 62
    3f44:	61 97       	sbiw	r28, 0x11	; 17
    3f46:	0f b6       	in	r0, 0x3f	; 63
    3f48:	f8 94       	cli
    3f4a:	de bf       	out	0x3e, r29	; 62
    3f4c:	0f be       	out	0x3f, r0	; 63
    3f4e:	cd bf       	out	0x3d, r28	; 61
    3f50:	9d 83       	std	Y+5, r25	; 0x05
    3f52:	8c 83       	std	Y+4, r24	; 0x04
    3f54:	7f 83       	std	Y+7, r23	; 0x07
    3f56:	6e 83       	std	Y+6, r22	; 0x06
    3f58:	59 87       	std	Y+9, r21	; 0x09
    3f5a:	48 87       	std	Y+8, r20	; 0x08
    3f5c:	3b 87       	std	Y+11, r19	; 0x0b
    3f5e:	2a 87       	std	Y+10, r18	; 0x0a
    3f60:	1d 87       	std	Y+13, r17	; 0x0d
    3f62:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    3f64:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f66:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f68:	00 97       	sbiw	r24, 0x00	; 0
    3f6a:	11 f4       	brne	.+4      	; 0x3f70 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    3f6c:	1b 82       	std	Y+3, r1	; 0x03
    3f6e:	38 c0       	rjmp	.+112    	; 0x3fe0 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    3f70:	ec 81       	ldd	r30, Y+4	; 0x04
    3f72:	fd 81       	ldd	r31, Y+5	; 0x05
    3f74:	86 85       	ldd	r24, Z+14	; 0x0e
    3f76:	88 2f       	mov	r24, r24
    3f78:	90 e0       	ldi	r25, 0x00	; 0
    3f7a:	81 70       	andi	r24, 0x01	; 1
    3f7c:	90 70       	andi	r25, 0x00	; 0
    3f7e:	00 97       	sbiw	r24, 0x00	; 0
    3f80:	d1 f4       	brne	.+52     	; 0x3fb6 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    3f82:	81 e0       	ldi	r24, 0x01	; 1
    3f84:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    3f86:	28 85       	ldd	r18, Y+8	; 0x08
    3f88:	39 85       	ldd	r19, Y+9	; 0x09
    3f8a:	39 8b       	std	Y+17, r19	; 0x11
    3f8c:	28 8b       	std	Y+16, r18	; 0x10
    3f8e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f90:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f92:	9f 87       	std	Y+15, r25	; 0x0f
    3f94:	8e 87       	std	Y+14, r24	; 0x0e
    3f96:	2e 85       	ldd	r18, Y+14	; 0x0e
    3f98:	3f 85       	ldd	r19, Y+15	; 0x0f
    3f9a:	88 89       	ldd	r24, Y+16	; 0x10
    3f9c:	99 89       	ldd	r25, Y+17	; 0x11
    3f9e:	82 17       	cp	r24, r18
    3fa0:	93 07       	cpc	r25, r19
    3fa2:	20 f4       	brcc	.+8      	; 0x3fac <prvWriteMessageToBuffer+0x74>
    3fa4:	28 89       	ldd	r18, Y+16	; 0x10
    3fa6:	39 89       	ldd	r19, Y+17	; 0x11
    3fa8:	3f 87       	std	Y+15, r19	; 0x0f
    3faa:	2e 87       	std	Y+14, r18	; 0x0e
    3fac:	8e 85       	ldd	r24, Y+14	; 0x0e
    3fae:	9f 85       	ldd	r25, Y+15	; 0x0f
    3fb0:	99 87       	std	Y+9, r25	; 0x09
    3fb2:	88 87       	std	Y+8, r24	; 0x08
    3fb4:	15 c0       	rjmp	.+42     	; 0x3fe0 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    3fb6:	2a 85       	ldd	r18, Y+10	; 0x0a
    3fb8:	3b 85       	ldd	r19, Y+11	; 0x0b
    3fba:	8c 85       	ldd	r24, Y+12	; 0x0c
    3fbc:	9d 85       	ldd	r25, Y+13	; 0x0d
    3fbe:	28 17       	cp	r18, r24
    3fc0:	39 07       	cpc	r19, r25
    3fc2:	68 f0       	brcs	.+26     	; 0x3fde <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    3fc4:	81 e0       	ldi	r24, 0x01	; 1
    3fc6:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    3fc8:	9e 01       	movw	r18, r28
    3fca:	28 5f       	subi	r18, 0xF8	; 248
    3fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    3fce:	8c 81       	ldd	r24, Y+4	; 0x04
    3fd0:	9d 81       	ldd	r25, Y+5	; 0x05
    3fd2:	b9 01       	movw	r22, r18
    3fd4:	42 e0       	ldi	r20, 0x02	; 2
    3fd6:	50 e0       	ldi	r21, 0x00	; 0
    3fd8:	0e 94 e9 22 	call	0x45d2	; 0x45d2 <prvWriteBytesToBuffer>
    3fdc:	01 c0       	rjmp	.+2      	; 0x3fe0 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    3fde:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    3fe0:	8b 81       	ldd	r24, Y+3	; 0x03
    3fe2:	88 23       	and	r24, r24
    3fe4:	61 f0       	breq	.+24     	; 0x3ffe <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    3fe6:	2e 81       	ldd	r18, Y+6	; 0x06
    3fe8:	3f 81       	ldd	r19, Y+7	; 0x07
    3fea:	48 85       	ldd	r20, Y+8	; 0x08
    3fec:	59 85       	ldd	r21, Y+9	; 0x09
    3fee:	8c 81       	ldd	r24, Y+4	; 0x04
    3ff0:	9d 81       	ldd	r25, Y+5	; 0x05
    3ff2:	b9 01       	movw	r22, r18
    3ff4:	0e 94 e9 22 	call	0x45d2	; 0x45d2 <prvWriteBytesToBuffer>
    3ff8:	9a 83       	std	Y+2, r25	; 0x02
    3ffa:	89 83       	std	Y+1, r24	; 0x01
    3ffc:	02 c0       	rjmp	.+4      	; 0x4002 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    3ffe:	1a 82       	std	Y+2, r1	; 0x02
    4000:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4002:	89 81       	ldd	r24, Y+1	; 0x01
    4004:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4006:	61 96       	adiw	r28, 0x11	; 17
    4008:	0f b6       	in	r0, 0x3f	; 63
    400a:	f8 94       	cli
    400c:	de bf       	out	0x3e, r29	; 62
    400e:	0f be       	out	0x3f, r0	; 63
    4010:	cd bf       	out	0x3d, r28	; 61
    4012:	cf 91       	pop	r28
    4014:	df 91       	pop	r29
    4016:	1f 91       	pop	r17
    4018:	0f 91       	pop	r16
    401a:	08 95       	ret

0000401c <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    401c:	ef 92       	push	r14
    401e:	ff 92       	push	r15
    4020:	0f 93       	push	r16
    4022:	1f 93       	push	r17
    4024:	df 93       	push	r29
    4026:	cf 93       	push	r28
    4028:	cd b7       	in	r28, 0x3d	; 61
    402a:	de b7       	in	r29, 0x3e	; 62
    402c:	60 97       	sbiw	r28, 0x10	; 16
    402e:	0f b6       	in	r0, 0x3f	; 63
    4030:	f8 94       	cli
    4032:	de bf       	out	0x3e, r29	; 62
    4034:	0f be       	out	0x3f, r0	; 63
    4036:	cd bf       	out	0x3d, r28	; 61
    4038:	9a 87       	std	Y+10, r25	; 0x0a
    403a:	89 87       	std	Y+9, r24	; 0x09
    403c:	7c 87       	std	Y+12, r23	; 0x0c
    403e:	6b 87       	std	Y+11, r22	; 0x0b
    4040:	5e 87       	std	Y+14, r21	; 0x0e
    4042:	4d 87       	std	Y+13, r20	; 0x0d
    4044:	38 8b       	std	Y+16, r19	; 0x10
    4046:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4048:	89 85       	ldd	r24, Y+9	; 0x09
    404a:	9a 85       	ldd	r25, Y+10	; 0x0a
    404c:	98 87       	std	Y+8, r25	; 0x08
    404e:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    4050:	1e 82       	std	Y+6, r1	; 0x06
    4052:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4054:	ef 81       	ldd	r30, Y+7	; 0x07
    4056:	f8 85       	ldd	r31, Y+8	; 0x08
    4058:	86 85       	ldd	r24, Z+14	; 0x0e
    405a:	88 2f       	mov	r24, r24
    405c:	90 e0       	ldi	r25, 0x00	; 0
    405e:	81 70       	andi	r24, 0x01	; 1
    4060:	90 70       	andi	r25, 0x00	; 0
    4062:	88 23       	and	r24, r24
    4064:	29 f0       	breq	.+10     	; 0x4070 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4066:	82 e0       	ldi	r24, 0x02	; 2
    4068:	90 e0       	ldi	r25, 0x00	; 0
    406a:	9a 83       	std	Y+2, r25	; 0x02
    406c:	89 83       	std	Y+1, r24	; 0x01
    406e:	02 c0       	rjmp	.+4      	; 0x4074 <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    4070:	1a 82       	std	Y+2, r1	; 0x02
    4072:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    4074:	8f 85       	ldd	r24, Y+15	; 0x0f
    4076:	98 89       	ldd	r25, Y+16	; 0x10
    4078:	00 97       	sbiw	r24, 0x00	; 0
    407a:	09 f4       	brne	.+2      	; 0x407e <xStreamBufferReceive+0x62>
    407c:	3d c0       	rjmp	.+122    	; 0x40f8 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    407e:	0f b6       	in	r0, 0x3f	; 63
    4080:	f8 94       	cli
    4082:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4084:	8f 81       	ldd	r24, Y+7	; 0x07
    4086:	98 85       	ldd	r25, Y+8	; 0x08
    4088:	0e 94 23 24 	call	0x4846	; 0x4846 <prvBytesInBuffer>
    408c:	9c 83       	std	Y+4, r25	; 0x04
    408e:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    4090:	2b 81       	ldd	r18, Y+3	; 0x03
    4092:	3c 81       	ldd	r19, Y+4	; 0x04
    4094:	89 81       	ldd	r24, Y+1	; 0x01
    4096:	9a 81       	ldd	r25, Y+2	; 0x02
    4098:	82 17       	cp	r24, r18
    409a:	93 07       	cpc	r25, r19
    409c:	50 f0       	brcs	.+20     	; 0x40b2 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    409e:	80 e0       	ldi	r24, 0x00	; 0
    40a0:	90 e0       	ldi	r25, 0x00	; 0
    40a2:	0e 94 fc 30 	call	0x61f8	; 0x61f8 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    40a6:	0e 94 55 2d 	call	0x5aaa	; 0x5aaa <xTaskGetCurrentTaskHandle>
    40aa:	ef 81       	ldd	r30, Y+7	; 0x07
    40ac:	f8 85       	ldd	r31, Y+8	; 0x08
    40ae:	91 87       	std	Z+9, r25	; 0x09
    40b0:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    40b2:	0f 90       	pop	r0
    40b4:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    40b6:	2b 81       	ldd	r18, Y+3	; 0x03
    40b8:	3c 81       	ldd	r19, Y+4	; 0x04
    40ba:	89 81       	ldd	r24, Y+1	; 0x01
    40bc:	9a 81       	ldd	r25, Y+2	; 0x02
    40be:	82 17       	cp	r24, r18
    40c0:	93 07       	cpc	r25, r19
    40c2:	00 f1       	brcs	.+64     	; 0x4104 <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    40c4:	ef 85       	ldd	r30, Y+15	; 0x0f
    40c6:	f8 89       	ldd	r31, Y+16	; 0x10
    40c8:	60 e0       	ldi	r22, 0x00	; 0
    40ca:	70 e0       	ldi	r23, 0x00	; 0
    40cc:	80 e0       	ldi	r24, 0x00	; 0
    40ce:	90 e0       	ldi	r25, 0x00	; 0
    40d0:	20 e0       	ldi	r18, 0x00	; 0
    40d2:	30 e0       	ldi	r19, 0x00	; 0
    40d4:	40 e0       	ldi	r20, 0x00	; 0
    40d6:	50 e0       	ldi	r21, 0x00	; 0
    40d8:	00 e0       	ldi	r16, 0x00	; 0
    40da:	10 e0       	ldi	r17, 0x00	; 0
    40dc:	7f 01       	movw	r14, r30
    40de:	0e 94 05 2e 	call	0x5c0a	; 0x5c0a <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    40e2:	ef 81       	ldd	r30, Y+7	; 0x07
    40e4:	f8 85       	ldd	r31, Y+8	; 0x08
    40e6:	11 86       	std	Z+9, r1	; 0x09
    40e8:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    40ea:	8f 81       	ldd	r24, Y+7	; 0x07
    40ec:	98 85       	ldd	r25, Y+8	; 0x08
    40ee:	0e 94 23 24 	call	0x4846	; 0x4846 <prvBytesInBuffer>
    40f2:	9c 83       	std	Y+4, r25	; 0x04
    40f4:	8b 83       	std	Y+3, r24	; 0x03
    40f6:	06 c0       	rjmp	.+12     	; 0x4104 <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    40f8:	8f 81       	ldd	r24, Y+7	; 0x07
    40fa:	98 85       	ldd	r25, Y+8	; 0x08
    40fc:	0e 94 23 24 	call	0x4846	; 0x4846 <prvBytesInBuffer>
    4100:	9c 83       	std	Y+4, r25	; 0x04
    4102:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    4104:	2b 81       	ldd	r18, Y+3	; 0x03
    4106:	3c 81       	ldd	r19, Y+4	; 0x04
    4108:	89 81       	ldd	r24, Y+1	; 0x01
    410a:	9a 81       	ldd	r25, Y+2	; 0x02
    410c:	82 17       	cp	r24, r18
    410e:	93 07       	cpc	r25, r19
    4110:	80 f5       	brcc	.+96     	; 0x4172 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    4112:	8f 81       	ldd	r24, Y+7	; 0x07
    4114:	98 85       	ldd	r25, Y+8	; 0x08
    4116:	2b 85       	ldd	r18, Y+11	; 0x0b
    4118:	3c 85       	ldd	r19, Y+12	; 0x0c
    411a:	4d 85       	ldd	r20, Y+13	; 0x0d
    411c:	5e 85       	ldd	r21, Y+14	; 0x0e
    411e:	eb 81       	ldd	r30, Y+3	; 0x03
    4120:	fc 81       	ldd	r31, Y+4	; 0x04
    4122:	a9 81       	ldd	r26, Y+1	; 0x01
    4124:	ba 81       	ldd	r27, Y+2	; 0x02
    4126:	b9 01       	movw	r22, r18
    4128:	9f 01       	movw	r18, r30
    412a:	8d 01       	movw	r16, r26
    412c:	0e 94 92 21 	call	0x4324	; 0x4324 <prvReadMessageFromBuffer>
    4130:	9e 83       	std	Y+6, r25	; 0x06
    4132:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    4134:	8d 81       	ldd	r24, Y+5	; 0x05
    4136:	9e 81       	ldd	r25, Y+6	; 0x06
    4138:	00 97       	sbiw	r24, 0x00	; 0
    413a:	d9 f0       	breq	.+54     	; 0x4172 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    413c:	0e 94 84 28 	call	0x5108	; 0x5108 <vTaskSuspendAll>
    4140:	ef 81       	ldd	r30, Y+7	; 0x07
    4142:	f8 85       	ldd	r31, Y+8	; 0x08
    4144:	82 85       	ldd	r24, Z+10	; 0x0a
    4146:	93 85       	ldd	r25, Z+11	; 0x0b
    4148:	00 97       	sbiw	r24, 0x00	; 0
    414a:	89 f0       	breq	.+34     	; 0x416e <xStreamBufferReceive+0x152>
    414c:	ef 81       	ldd	r30, Y+7	; 0x07
    414e:	f8 85       	ldd	r31, Y+8	; 0x08
    4150:	82 85       	ldd	r24, Z+10	; 0x0a
    4152:	93 85       	ldd	r25, Z+11	; 0x0b
    4154:	40 e0       	ldi	r20, 0x00	; 0
    4156:	50 e0       	ldi	r21, 0x00	; 0
    4158:	60 e0       	ldi	r22, 0x00	; 0
    415a:	70 e0       	ldi	r23, 0x00	; 0
    415c:	20 e0       	ldi	r18, 0x00	; 0
    415e:	00 e0       	ldi	r16, 0x00	; 0
    4160:	10 e0       	ldi	r17, 0x00	; 0
    4162:	0e 94 a1 2e 	call	0x5d42	; 0x5d42 <xTaskGenericNotify>
    4166:	ef 81       	ldd	r30, Y+7	; 0x07
    4168:	f8 85       	ldd	r31, Y+8	; 0x08
    416a:	13 86       	std	Z+11, r1	; 0x0b
    416c:	12 86       	std	Z+10, r1	; 0x0a
    416e:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    4172:	8d 81       	ldd	r24, Y+5	; 0x05
    4174:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4176:	60 96       	adiw	r28, 0x10	; 16
    4178:	0f b6       	in	r0, 0x3f	; 63
    417a:	f8 94       	cli
    417c:	de bf       	out	0x3e, r29	; 62
    417e:	0f be       	out	0x3f, r0	; 63
    4180:	cd bf       	out	0x3d, r28	; 61
    4182:	cf 91       	pop	r28
    4184:	df 91       	pop	r29
    4186:	1f 91       	pop	r17
    4188:	0f 91       	pop	r16
    418a:	ff 90       	pop	r15
    418c:	ef 90       	pop	r14
    418e:	08 95       	ret

00004190 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    4190:	df 93       	push	r29
    4192:	cf 93       	push	r28
    4194:	cd b7       	in	r28, 0x3d	; 61
    4196:	de b7       	in	r29, 0x3e	; 62
    4198:	2c 97       	sbiw	r28, 0x0c	; 12
    419a:	0f b6       	in	r0, 0x3f	; 63
    419c:	f8 94       	cli
    419e:	de bf       	out	0x3e, r29	; 62
    41a0:	0f be       	out	0x3f, r0	; 63
    41a2:	cd bf       	out	0x3d, r28	; 61
    41a4:	9c 87       	std	Y+12, r25	; 0x0c
    41a6:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    41a8:	8b 85       	ldd	r24, Y+11	; 0x0b
    41aa:	9c 85       	ldd	r25, Y+12	; 0x0c
    41ac:	98 87       	std	Y+8, r25	; 0x08
    41ae:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    41b0:	ef 81       	ldd	r30, Y+7	; 0x07
    41b2:	f8 85       	ldd	r31, Y+8	; 0x08
    41b4:	86 85       	ldd	r24, Z+14	; 0x0e
    41b6:	88 2f       	mov	r24, r24
    41b8:	90 e0       	ldi	r25, 0x00	; 0
    41ba:	81 70       	andi	r24, 0x01	; 1
    41bc:	90 70       	andi	r25, 0x00	; 0
    41be:	88 23       	and	r24, r24
    41c0:	61 f1       	breq	.+88     	; 0x421a <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    41c2:	8f 81       	ldd	r24, Y+7	; 0x07
    41c4:	98 85       	ldd	r25, Y+8	; 0x08
    41c6:	0e 94 23 24 	call	0x4846	; 0x4846 <prvBytesInBuffer>
    41ca:	9c 83       	std	Y+4, r25	; 0x04
    41cc:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    41ce:	8b 81       	ldd	r24, Y+3	; 0x03
    41d0:	9c 81       	ldd	r25, Y+4	; 0x04
    41d2:	83 30       	cpi	r24, 0x03	; 3
    41d4:	91 05       	cpc	r25, r1
    41d6:	f0 f0       	brcs	.+60     	; 0x4214 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    41d8:	ef 81       	ldd	r30, Y+7	; 0x07
    41da:	f8 85       	ldd	r31, Y+8	; 0x08
    41dc:	80 81       	ld	r24, Z
    41de:	91 81       	ldd	r25, Z+1	; 0x01
    41e0:	9a 83       	std	Y+2, r25	; 0x02
    41e2:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    41e4:	9e 01       	movw	r18, r28
    41e6:	27 5f       	subi	r18, 0xF7	; 247
    41e8:	3f 4f       	sbci	r19, 0xFF	; 255
    41ea:	8f 81       	ldd	r24, Y+7	; 0x07
    41ec:	98 85       	ldd	r25, Y+8	; 0x08
    41ee:	eb 81       	ldd	r30, Y+3	; 0x03
    41f0:	fc 81       	ldd	r31, Y+4	; 0x04
    41f2:	b9 01       	movw	r22, r18
    41f4:	42 e0       	ldi	r20, 0x02	; 2
    41f6:	50 e0       	ldi	r21, 0x00	; 0
    41f8:	9f 01       	movw	r18, r30
    41fa:	0e 94 76 23 	call	0x46ec	; 0x46ec <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    41fe:	89 85       	ldd	r24, Y+9	; 0x09
    4200:	9a 85       	ldd	r25, Y+10	; 0x0a
    4202:	9e 83       	std	Y+6, r25	; 0x06
    4204:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    4206:	ef 81       	ldd	r30, Y+7	; 0x07
    4208:	f8 85       	ldd	r31, Y+8	; 0x08
    420a:	89 81       	ldd	r24, Y+1	; 0x01
    420c:	9a 81       	ldd	r25, Y+2	; 0x02
    420e:	91 83       	std	Z+1, r25	; 0x01
    4210:	80 83       	st	Z, r24
    4212:	05 c0       	rjmp	.+10     	; 0x421e <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    4214:	1e 82       	std	Y+6, r1	; 0x06
    4216:	1d 82       	std	Y+5, r1	; 0x05
    4218:	02 c0       	rjmp	.+4      	; 0x421e <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    421a:	1e 82       	std	Y+6, r1	; 0x06
    421c:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    421e:	8d 81       	ldd	r24, Y+5	; 0x05
    4220:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4222:	2c 96       	adiw	r28, 0x0c	; 12
    4224:	0f b6       	in	r0, 0x3f	; 63
    4226:	f8 94       	cli
    4228:	de bf       	out	0x3e, r29	; 62
    422a:	0f be       	out	0x3f, r0	; 63
    422c:	cd bf       	out	0x3d, r28	; 61
    422e:	cf 91       	pop	r28
    4230:	df 91       	pop	r29
    4232:	08 95       	ret

00004234 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    4234:	ef 92       	push	r14
    4236:	ff 92       	push	r15
    4238:	0f 93       	push	r16
    423a:	1f 93       	push	r17
    423c:	df 93       	push	r29
    423e:	cf 93       	push	r28
    4240:	cd b7       	in	r28, 0x3d	; 61
    4242:	de b7       	in	r29, 0x3e	; 62
    4244:	61 97       	sbiw	r28, 0x11	; 17
    4246:	0f b6       	in	r0, 0x3f	; 63
    4248:	f8 94       	cli
    424a:	de bf       	out	0x3e, r29	; 62
    424c:	0f be       	out	0x3f, r0	; 63
    424e:	cd bf       	out	0x3d, r28	; 61
    4250:	9b 87       	std	Y+11, r25	; 0x0b
    4252:	8a 87       	std	Y+10, r24	; 0x0a
    4254:	7d 87       	std	Y+13, r23	; 0x0d
    4256:	6c 87       	std	Y+12, r22	; 0x0c
    4258:	5f 87       	std	Y+15, r21	; 0x0f
    425a:	4e 87       	std	Y+14, r20	; 0x0e
    425c:	39 8b       	std	Y+17, r19	; 0x11
    425e:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4260:	8a 85       	ldd	r24, Y+10	; 0x0a
    4262:	9b 85       	ldd	r25, Y+11	; 0x0b
    4264:	99 87       	std	Y+9, r25	; 0x09
    4266:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    4268:	1f 82       	std	Y+7, r1	; 0x07
    426a:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    426c:	e8 85       	ldd	r30, Y+8	; 0x08
    426e:	f9 85       	ldd	r31, Y+9	; 0x09
    4270:	86 85       	ldd	r24, Z+14	; 0x0e
    4272:	88 2f       	mov	r24, r24
    4274:	90 e0       	ldi	r25, 0x00	; 0
    4276:	81 70       	andi	r24, 0x01	; 1
    4278:	90 70       	andi	r25, 0x00	; 0
    427a:	88 23       	and	r24, r24
    427c:	29 f0       	breq	.+10     	; 0x4288 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    427e:	82 e0       	ldi	r24, 0x02	; 2
    4280:	90 e0       	ldi	r25, 0x00	; 0
    4282:	9b 83       	std	Y+3, r25	; 0x03
    4284:	8a 83       	std	Y+2, r24	; 0x02
    4286:	02 c0       	rjmp	.+4      	; 0x428c <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    4288:	1b 82       	std	Y+3, r1	; 0x03
    428a:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    428c:	88 85       	ldd	r24, Y+8	; 0x08
    428e:	99 85       	ldd	r25, Y+9	; 0x09
    4290:	0e 94 23 24 	call	0x4846	; 0x4846 <prvBytesInBuffer>
    4294:	9d 83       	std	Y+5, r25	; 0x05
    4296:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    4298:	2c 81       	ldd	r18, Y+4	; 0x04
    429a:	3d 81       	ldd	r19, Y+5	; 0x05
    429c:	8a 81       	ldd	r24, Y+2	; 0x02
    429e:	9b 81       	ldd	r25, Y+3	; 0x03
    42a0:	82 17       	cp	r24, r18
    42a2:	93 07       	cpc	r25, r19
    42a4:	80 f5       	brcc	.+96     	; 0x4306 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    42a6:	88 85       	ldd	r24, Y+8	; 0x08
    42a8:	99 85       	ldd	r25, Y+9	; 0x09
    42aa:	2c 85       	ldd	r18, Y+12	; 0x0c
    42ac:	3d 85       	ldd	r19, Y+13	; 0x0d
    42ae:	4e 85       	ldd	r20, Y+14	; 0x0e
    42b0:	5f 85       	ldd	r21, Y+15	; 0x0f
    42b2:	ec 81       	ldd	r30, Y+4	; 0x04
    42b4:	fd 81       	ldd	r31, Y+5	; 0x05
    42b6:	aa 81       	ldd	r26, Y+2	; 0x02
    42b8:	bb 81       	ldd	r27, Y+3	; 0x03
    42ba:	b9 01       	movw	r22, r18
    42bc:	9f 01       	movw	r18, r30
    42be:	8d 01       	movw	r16, r26
    42c0:	0e 94 92 21 	call	0x4324	; 0x4324 <prvReadMessageFromBuffer>
    42c4:	9f 83       	std	Y+7, r25	; 0x07
    42c6:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    42c8:	8e 81       	ldd	r24, Y+6	; 0x06
    42ca:	9f 81       	ldd	r25, Y+7	; 0x07
    42cc:	00 97       	sbiw	r24, 0x00	; 0
    42ce:	d9 f0       	breq	.+54     	; 0x4306 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    42d0:	19 82       	std	Y+1, r1	; 0x01
    42d2:	e8 85       	ldd	r30, Y+8	; 0x08
    42d4:	f9 85       	ldd	r31, Y+9	; 0x09
    42d6:	82 85       	ldd	r24, Z+10	; 0x0a
    42d8:	93 85       	ldd	r25, Z+11	; 0x0b
    42da:	00 97       	sbiw	r24, 0x00	; 0
    42dc:	a1 f0       	breq	.+40     	; 0x4306 <xStreamBufferReceiveFromISR+0xd2>
    42de:	e8 85       	ldd	r30, Y+8	; 0x08
    42e0:	f9 85       	ldd	r31, Y+9	; 0x09
    42e2:	82 85       	ldd	r24, Z+10	; 0x0a
    42e4:	93 85       	ldd	r25, Z+11	; 0x0b
    42e6:	e8 89       	ldd	r30, Y+16	; 0x10
    42e8:	f9 89       	ldd	r31, Y+17	; 0x11
    42ea:	40 e0       	ldi	r20, 0x00	; 0
    42ec:	50 e0       	ldi	r21, 0x00	; 0
    42ee:	60 e0       	ldi	r22, 0x00	; 0
    42f0:	70 e0       	ldi	r23, 0x00	; 0
    42f2:	20 e0       	ldi	r18, 0x00	; 0
    42f4:	00 e0       	ldi	r16, 0x00	; 0
    42f6:	10 e0       	ldi	r17, 0x00	; 0
    42f8:	7f 01       	movw	r14, r30
    42fa:	0e 94 7e 2f 	call	0x5efc	; 0x5efc <xTaskGenericNotifyFromISR>
    42fe:	e8 85       	ldd	r30, Y+8	; 0x08
    4300:	f9 85       	ldd	r31, Y+9	; 0x09
    4302:	13 86       	std	Z+11, r1	; 0x0b
    4304:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    4306:	8e 81       	ldd	r24, Y+6	; 0x06
    4308:	9f 81       	ldd	r25, Y+7	; 0x07
}
    430a:	61 96       	adiw	r28, 0x11	; 17
    430c:	0f b6       	in	r0, 0x3f	; 63
    430e:	f8 94       	cli
    4310:	de bf       	out	0x3e, r29	; 62
    4312:	0f be       	out	0x3f, r0	; 63
    4314:	cd bf       	out	0x3d, r28	; 61
    4316:	cf 91       	pop	r28
    4318:	df 91       	pop	r29
    431a:	1f 91       	pop	r17
    431c:	0f 91       	pop	r16
    431e:	ff 90       	pop	r15
    4320:	ef 90       	pop	r14
    4322:	08 95       	ret

00004324 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    4324:	0f 93       	push	r16
    4326:	1f 93       	push	r17
    4328:	df 93       	push	r29
    432a:	cf 93       	push	r28
    432c:	cd b7       	in	r28, 0x3d	; 61
    432e:	de b7       	in	r29, 0x3e	; 62
    4330:	62 97       	sbiw	r28, 0x12	; 18
    4332:	0f b6       	in	r0, 0x3f	; 63
    4334:	f8 94       	cli
    4336:	de bf       	out	0x3e, r29	; 62
    4338:	0f be       	out	0x3f, r0	; 63
    433a:	cd bf       	out	0x3d, r28	; 61
    433c:	9a 87       	std	Y+10, r25	; 0x0a
    433e:	89 87       	std	Y+9, r24	; 0x09
    4340:	7c 87       	std	Y+12, r23	; 0x0c
    4342:	6b 87       	std	Y+11, r22	; 0x0b
    4344:	5e 87       	std	Y+14, r21	; 0x0e
    4346:	4d 87       	std	Y+13, r20	; 0x0d
    4348:	38 8b       	std	Y+16, r19	; 0x10
    434a:	2f 87       	std	Y+15, r18	; 0x0f
    434c:	1a 8b       	std	Y+18, r17	; 0x12
    434e:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    4350:	89 89       	ldd	r24, Y+17	; 0x11
    4352:	9a 89       	ldd	r25, Y+18	; 0x12
    4354:	00 97       	sbiw	r24, 0x00	; 0
    4356:	91 f1       	breq	.+100    	; 0x43bc <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    4358:	e9 85       	ldd	r30, Y+9	; 0x09
    435a:	fa 85       	ldd	r31, Y+10	; 0x0a
    435c:	80 81       	ld	r24, Z
    435e:	91 81       	ldd	r25, Z+1	; 0x01
    4360:	9e 83       	std	Y+6, r25	; 0x06
    4362:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    4364:	ae 01       	movw	r20, r28
    4366:	49 5f       	subi	r20, 0xF9	; 249
    4368:	5f 4f       	sbci	r21, 0xFF	; 255
    436a:	89 85       	ldd	r24, Y+9	; 0x09
    436c:	9a 85       	ldd	r25, Y+10	; 0x0a
    436e:	29 89       	ldd	r18, Y+17	; 0x11
    4370:	3a 89       	ldd	r19, Y+18	; 0x12
    4372:	ef 85       	ldd	r30, Y+15	; 0x0f
    4374:	f8 89       	ldd	r31, Y+16	; 0x10
    4376:	ba 01       	movw	r22, r20
    4378:	a9 01       	movw	r20, r18
    437a:	9f 01       	movw	r18, r30
    437c:	0e 94 76 23 	call	0x46ec	; 0x46ec <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    4380:	8f 81       	ldd	r24, Y+7	; 0x07
    4382:	98 85       	ldd	r25, Y+8	; 0x08
    4384:	9a 83       	std	Y+2, r25	; 0x02
    4386:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    4388:	2f 85       	ldd	r18, Y+15	; 0x0f
    438a:	38 89       	ldd	r19, Y+16	; 0x10
    438c:	89 89       	ldd	r24, Y+17	; 0x11
    438e:	9a 89       	ldd	r25, Y+18	; 0x12
    4390:	a9 01       	movw	r20, r18
    4392:	48 1b       	sub	r20, r24
    4394:	59 0b       	sbc	r21, r25
    4396:	ca 01       	movw	r24, r20
    4398:	98 8b       	std	Y+16, r25	; 0x10
    439a:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    439c:	29 81       	ldd	r18, Y+1	; 0x01
    439e:	3a 81       	ldd	r19, Y+2	; 0x02
    43a0:	8d 85       	ldd	r24, Y+13	; 0x0d
    43a2:	9e 85       	ldd	r25, Y+14	; 0x0e
    43a4:	82 17       	cp	r24, r18
    43a6:	93 07       	cpc	r25, r19
    43a8:	68 f4       	brcc	.+26     	; 0x43c4 <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    43aa:	e9 85       	ldd	r30, Y+9	; 0x09
    43ac:	fa 85       	ldd	r31, Y+10	; 0x0a
    43ae:	8d 81       	ldd	r24, Y+5	; 0x05
    43b0:	9e 81       	ldd	r25, Y+6	; 0x06
    43b2:	91 83       	std	Z+1, r25	; 0x01
    43b4:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    43b6:	1a 82       	std	Y+2, r1	; 0x02
    43b8:	19 82       	std	Y+1, r1	; 0x01
    43ba:	04 c0       	rjmp	.+8      	; 0x43c4 <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    43bc:	8d 85       	ldd	r24, Y+13	; 0x0d
    43be:	9e 85       	ldd	r25, Y+14	; 0x0e
    43c0:	9a 83       	std	Y+2, r25	; 0x02
    43c2:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    43c4:	4b 85       	ldd	r20, Y+11	; 0x0b
    43c6:	5c 85       	ldd	r21, Y+12	; 0x0c
    43c8:	89 85       	ldd	r24, Y+9	; 0x09
    43ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    43cc:	29 81       	ldd	r18, Y+1	; 0x01
    43ce:	3a 81       	ldd	r19, Y+2	; 0x02
    43d0:	ef 85       	ldd	r30, Y+15	; 0x0f
    43d2:	f8 89       	ldd	r31, Y+16	; 0x10
    43d4:	ba 01       	movw	r22, r20
    43d6:	a9 01       	movw	r20, r18
    43d8:	9f 01       	movw	r18, r30
    43da:	0e 94 76 23 	call	0x46ec	; 0x46ec <prvReadBytesFromBuffer>
    43de:	9c 83       	std	Y+4, r25	; 0x04
    43e0:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    43e2:	8b 81       	ldd	r24, Y+3	; 0x03
    43e4:	9c 81       	ldd	r25, Y+4	; 0x04
}
    43e6:	62 96       	adiw	r28, 0x12	; 18
    43e8:	0f b6       	in	r0, 0x3f	; 63
    43ea:	f8 94       	cli
    43ec:	de bf       	out	0x3e, r29	; 62
    43ee:	0f be       	out	0x3f, r0	; 63
    43f0:	cd bf       	out	0x3d, r28	; 61
    43f2:	cf 91       	pop	r28
    43f4:	df 91       	pop	r29
    43f6:	1f 91       	pop	r17
    43f8:	0f 91       	pop	r16
    43fa:	08 95       	ret

000043fc <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    43fc:	df 93       	push	r29
    43fe:	cf 93       	push	r28
    4400:	cd b7       	in	r28, 0x3d	; 61
    4402:	de b7       	in	r29, 0x3e	; 62
    4404:	27 97       	sbiw	r28, 0x07	; 7
    4406:	0f b6       	in	r0, 0x3f	; 63
    4408:	f8 94       	cli
    440a:	de bf       	out	0x3e, r29	; 62
    440c:	0f be       	out	0x3f, r0	; 63
    440e:	cd bf       	out	0x3d, r28	; 61
    4410:	9f 83       	std	Y+7, r25	; 0x07
    4412:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4414:	8e 81       	ldd	r24, Y+6	; 0x06
    4416:	9f 81       	ldd	r25, Y+7	; 0x07
    4418:	9d 83       	std	Y+5, r25	; 0x05
    441a:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    441c:	ec 81       	ldd	r30, Y+4	; 0x04
    441e:	fd 81       	ldd	r31, Y+5	; 0x05
    4420:	80 81       	ld	r24, Z
    4422:	91 81       	ldd	r25, Z+1	; 0x01
    4424:	9a 83       	std	Y+2, r25	; 0x02
    4426:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    4428:	ec 81       	ldd	r30, Y+4	; 0x04
    442a:	fd 81       	ldd	r31, Y+5	; 0x05
    442c:	22 81       	ldd	r18, Z+2	; 0x02
    442e:	33 81       	ldd	r19, Z+3	; 0x03
    4430:	89 81       	ldd	r24, Y+1	; 0x01
    4432:	9a 81       	ldd	r25, Y+2	; 0x02
    4434:	28 17       	cp	r18, r24
    4436:	39 07       	cpc	r19, r25
    4438:	19 f4       	brne	.+6      	; 0x4440 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    443a:	81 e0       	ldi	r24, 0x01	; 1
    443c:	8b 83       	std	Y+3, r24	; 0x03
    443e:	01 c0       	rjmp	.+2      	; 0x4442 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    4440:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    4442:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4444:	27 96       	adiw	r28, 0x07	; 7
    4446:	0f b6       	in	r0, 0x3f	; 63
    4448:	f8 94       	cli
    444a:	de bf       	out	0x3e, r29	; 62
    444c:	0f be       	out	0x3f, r0	; 63
    444e:	cd bf       	out	0x3d, r28	; 61
    4450:	cf 91       	pop	r28
    4452:	df 91       	pop	r29
    4454:	08 95       	ret

00004456 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    4456:	df 93       	push	r29
    4458:	cf 93       	push	r28
    445a:	cd b7       	in	r28, 0x3d	; 61
    445c:	de b7       	in	r29, 0x3e	; 62
    445e:	27 97       	sbiw	r28, 0x07	; 7
    4460:	0f b6       	in	r0, 0x3f	; 63
    4462:	f8 94       	cli
    4464:	de bf       	out	0x3e, r29	; 62
    4466:	0f be       	out	0x3f, r0	; 63
    4468:	cd bf       	out	0x3d, r28	; 61
    446a:	9f 83       	std	Y+7, r25	; 0x07
    446c:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    446e:	8e 81       	ldd	r24, Y+6	; 0x06
    4470:	9f 81       	ldd	r25, Y+7	; 0x07
    4472:	9a 83       	std	Y+2, r25	; 0x02
    4474:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4476:	e9 81       	ldd	r30, Y+1	; 0x01
    4478:	fa 81       	ldd	r31, Y+2	; 0x02
    447a:	86 85       	ldd	r24, Z+14	; 0x0e
    447c:	88 2f       	mov	r24, r24
    447e:	90 e0       	ldi	r25, 0x00	; 0
    4480:	81 70       	andi	r24, 0x01	; 1
    4482:	90 70       	andi	r25, 0x00	; 0
    4484:	88 23       	and	r24, r24
    4486:	29 f0       	breq	.+10     	; 0x4492 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4488:	82 e0       	ldi	r24, 0x02	; 2
    448a:	90 e0       	ldi	r25, 0x00	; 0
    448c:	9c 83       	std	Y+4, r25	; 0x04
    448e:	8b 83       	std	Y+3, r24	; 0x03
    4490:	02 c0       	rjmp	.+4      	; 0x4496 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    4492:	1c 82       	std	Y+4, r1	; 0x04
    4494:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    4496:	8e 81       	ldd	r24, Y+6	; 0x06
    4498:	9f 81       	ldd	r25, Y+7	; 0x07
    449a:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <xStreamBufferSpacesAvailable>
    449e:	9c 01       	movw	r18, r24
    44a0:	8b 81       	ldd	r24, Y+3	; 0x03
    44a2:	9c 81       	ldd	r25, Y+4	; 0x04
    44a4:	82 17       	cp	r24, r18
    44a6:	93 07       	cpc	r25, r19
    44a8:	18 f0       	brcs	.+6      	; 0x44b0 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    44aa:	81 e0       	ldi	r24, 0x01	; 1
    44ac:	8d 83       	std	Y+5, r24	; 0x05
    44ae:	01 c0       	rjmp	.+2      	; 0x44b2 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    44b0:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    44b2:	8d 81       	ldd	r24, Y+5	; 0x05
}
    44b4:	27 96       	adiw	r28, 0x07	; 7
    44b6:	0f b6       	in	r0, 0x3f	; 63
    44b8:	f8 94       	cli
    44ba:	de bf       	out	0x3e, r29	; 62
    44bc:	0f be       	out	0x3f, r0	; 63
    44be:	cd bf       	out	0x3d, r28	; 61
    44c0:	cf 91       	pop	r28
    44c2:	df 91       	pop	r29
    44c4:	08 95       	ret

000044c6 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    44c6:	ef 92       	push	r14
    44c8:	ff 92       	push	r15
    44ca:	0f 93       	push	r16
    44cc:	1f 93       	push	r17
    44ce:	df 93       	push	r29
    44d0:	cf 93       	push	r28
    44d2:	cd b7       	in	r28, 0x3d	; 61
    44d4:	de b7       	in	r29, 0x3e	; 62
    44d6:	28 97       	sbiw	r28, 0x08	; 8
    44d8:	0f b6       	in	r0, 0x3f	; 63
    44da:	f8 94       	cli
    44dc:	de bf       	out	0x3e, r29	; 62
    44de:	0f be       	out	0x3f, r0	; 63
    44e0:	cd bf       	out	0x3d, r28	; 61
    44e2:	9e 83       	std	Y+6, r25	; 0x06
    44e4:	8d 83       	std	Y+5, r24	; 0x05
    44e6:	78 87       	std	Y+8, r23	; 0x08
    44e8:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    44ea:	8d 81       	ldd	r24, Y+5	; 0x05
    44ec:	9e 81       	ldd	r25, Y+6	; 0x06
    44ee:	9c 83       	std	Y+4, r25	; 0x04
    44f0:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    44f2:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    44f4:	eb 81       	ldd	r30, Y+3	; 0x03
    44f6:	fc 81       	ldd	r31, Y+4	; 0x04
    44f8:	80 85       	ldd	r24, Z+8	; 0x08
    44fa:	91 85       	ldd	r25, Z+9	; 0x09
    44fc:	00 97       	sbiw	r24, 0x00	; 0
    44fe:	b9 f0       	breq	.+46     	; 0x452e <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    4500:	eb 81       	ldd	r30, Y+3	; 0x03
    4502:	fc 81       	ldd	r31, Y+4	; 0x04
    4504:	80 85       	ldd	r24, Z+8	; 0x08
    4506:	91 85       	ldd	r25, Z+9	; 0x09
    4508:	ef 81       	ldd	r30, Y+7	; 0x07
    450a:	f8 85       	ldd	r31, Y+8	; 0x08
    450c:	40 e0       	ldi	r20, 0x00	; 0
    450e:	50 e0       	ldi	r21, 0x00	; 0
    4510:	60 e0       	ldi	r22, 0x00	; 0
    4512:	70 e0       	ldi	r23, 0x00	; 0
    4514:	20 e0       	ldi	r18, 0x00	; 0
    4516:	00 e0       	ldi	r16, 0x00	; 0
    4518:	10 e0       	ldi	r17, 0x00	; 0
    451a:	7f 01       	movw	r14, r30
    451c:	0e 94 7e 2f 	call	0x5efc	; 0x5efc <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    4520:	eb 81       	ldd	r30, Y+3	; 0x03
    4522:	fc 81       	ldd	r31, Y+4	; 0x04
    4524:	11 86       	std	Z+9, r1	; 0x09
    4526:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    4528:	81 e0       	ldi	r24, 0x01	; 1
    452a:	8a 83       	std	Y+2, r24	; 0x02
    452c:	01 c0       	rjmp	.+2      	; 0x4530 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    452e:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4530:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4532:	28 96       	adiw	r28, 0x08	; 8
    4534:	0f b6       	in	r0, 0x3f	; 63
    4536:	f8 94       	cli
    4538:	de bf       	out	0x3e, r29	; 62
    453a:	0f be       	out	0x3f, r0	; 63
    453c:	cd bf       	out	0x3d, r28	; 61
    453e:	cf 91       	pop	r28
    4540:	df 91       	pop	r29
    4542:	1f 91       	pop	r17
    4544:	0f 91       	pop	r16
    4546:	ff 90       	pop	r15
    4548:	ef 90       	pop	r14
    454a:	08 95       	ret

0000454c <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    454c:	ef 92       	push	r14
    454e:	ff 92       	push	r15
    4550:	0f 93       	push	r16
    4552:	1f 93       	push	r17
    4554:	df 93       	push	r29
    4556:	cf 93       	push	r28
    4558:	cd b7       	in	r28, 0x3d	; 61
    455a:	de b7       	in	r29, 0x3e	; 62
    455c:	28 97       	sbiw	r28, 0x08	; 8
    455e:	0f b6       	in	r0, 0x3f	; 63
    4560:	f8 94       	cli
    4562:	de bf       	out	0x3e, r29	; 62
    4564:	0f be       	out	0x3f, r0	; 63
    4566:	cd bf       	out	0x3d, r28	; 61
    4568:	9e 83       	std	Y+6, r25	; 0x06
    456a:	8d 83       	std	Y+5, r24	; 0x05
    456c:	78 87       	std	Y+8, r23	; 0x08
    456e:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4570:	8d 81       	ldd	r24, Y+5	; 0x05
    4572:	9e 81       	ldd	r25, Y+6	; 0x06
    4574:	9c 83       	std	Y+4, r25	; 0x04
    4576:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    4578:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    457a:	eb 81       	ldd	r30, Y+3	; 0x03
    457c:	fc 81       	ldd	r31, Y+4	; 0x04
    457e:	82 85       	ldd	r24, Z+10	; 0x0a
    4580:	93 85       	ldd	r25, Z+11	; 0x0b
    4582:	00 97       	sbiw	r24, 0x00	; 0
    4584:	b9 f0       	breq	.+46     	; 0x45b4 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    4586:	eb 81       	ldd	r30, Y+3	; 0x03
    4588:	fc 81       	ldd	r31, Y+4	; 0x04
    458a:	82 85       	ldd	r24, Z+10	; 0x0a
    458c:	93 85       	ldd	r25, Z+11	; 0x0b
    458e:	ef 81       	ldd	r30, Y+7	; 0x07
    4590:	f8 85       	ldd	r31, Y+8	; 0x08
    4592:	40 e0       	ldi	r20, 0x00	; 0
    4594:	50 e0       	ldi	r21, 0x00	; 0
    4596:	60 e0       	ldi	r22, 0x00	; 0
    4598:	70 e0       	ldi	r23, 0x00	; 0
    459a:	20 e0       	ldi	r18, 0x00	; 0
    459c:	00 e0       	ldi	r16, 0x00	; 0
    459e:	10 e0       	ldi	r17, 0x00	; 0
    45a0:	7f 01       	movw	r14, r30
    45a2:	0e 94 7e 2f 	call	0x5efc	; 0x5efc <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    45a6:	eb 81       	ldd	r30, Y+3	; 0x03
    45a8:	fc 81       	ldd	r31, Y+4	; 0x04
    45aa:	13 86       	std	Z+11, r1	; 0x0b
    45ac:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    45ae:	81 e0       	ldi	r24, 0x01	; 1
    45b0:	8a 83       	std	Y+2, r24	; 0x02
    45b2:	01 c0       	rjmp	.+2      	; 0x45b6 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    45b4:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    45b6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    45b8:	28 96       	adiw	r28, 0x08	; 8
    45ba:	0f b6       	in	r0, 0x3f	; 63
    45bc:	f8 94       	cli
    45be:	de bf       	out	0x3e, r29	; 62
    45c0:	0f be       	out	0x3f, r0	; 63
    45c2:	cd bf       	out	0x3d, r28	; 61
    45c4:	cf 91       	pop	r28
    45c6:	df 91       	pop	r29
    45c8:	1f 91       	pop	r17
    45ca:	0f 91       	pop	r16
    45cc:	ff 90       	pop	r15
    45ce:	ef 90       	pop	r14
    45d0:	08 95       	ret

000045d2 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    45d2:	df 93       	push	r29
    45d4:	cf 93       	push	r28
    45d6:	cd b7       	in	r28, 0x3d	; 61
    45d8:	de b7       	in	r29, 0x3e	; 62
    45da:	2e 97       	sbiw	r28, 0x0e	; 14
    45dc:	0f b6       	in	r0, 0x3f	; 63
    45de:	f8 94       	cli
    45e0:	de bf       	out	0x3e, r29	; 62
    45e2:	0f be       	out	0x3f, r0	; 63
    45e4:	cd bf       	out	0x3d, r28	; 61
    45e6:	9e 83       	std	Y+6, r25	; 0x06
    45e8:	8d 83       	std	Y+5, r24	; 0x05
    45ea:	78 87       	std	Y+8, r23	; 0x08
    45ec:	6f 83       	std	Y+7, r22	; 0x07
    45ee:	5a 87       	std	Y+10, r21	; 0x0a
    45f0:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    45f2:	ed 81       	ldd	r30, Y+5	; 0x05
    45f4:	fe 81       	ldd	r31, Y+6	; 0x06
    45f6:	82 81       	ldd	r24, Z+2	; 0x02
    45f8:	93 81       	ldd	r25, Z+3	; 0x03
    45fa:	9c 83       	std	Y+4, r25	; 0x04
    45fc:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    45fe:	ed 81       	ldd	r30, Y+5	; 0x05
    4600:	fe 81       	ldd	r31, Y+6	; 0x06
    4602:	24 81       	ldd	r18, Z+4	; 0x04
    4604:	35 81       	ldd	r19, Z+5	; 0x05
    4606:	8b 81       	ldd	r24, Y+3	; 0x03
    4608:	9c 81       	ldd	r25, Y+4	; 0x04
    460a:	a9 01       	movw	r20, r18
    460c:	48 1b       	sub	r20, r24
    460e:	59 0b       	sbc	r21, r25
    4610:	ca 01       	movw	r24, r20
    4612:	29 85       	ldd	r18, Y+9	; 0x09
    4614:	3a 85       	ldd	r19, Y+10	; 0x0a
    4616:	3e 87       	std	Y+14, r19	; 0x0e
    4618:	2d 87       	std	Y+13, r18	; 0x0d
    461a:	9c 87       	std	Y+12, r25	; 0x0c
    461c:	8b 87       	std	Y+11, r24	; 0x0b
    461e:	4b 85       	ldd	r20, Y+11	; 0x0b
    4620:	5c 85       	ldd	r21, Y+12	; 0x0c
    4622:	8d 85       	ldd	r24, Y+13	; 0x0d
    4624:	9e 85       	ldd	r25, Y+14	; 0x0e
    4626:	84 17       	cp	r24, r20
    4628:	95 07       	cpc	r25, r21
    462a:	20 f4       	brcc	.+8      	; 0x4634 <prvWriteBytesToBuffer+0x62>
    462c:	2d 85       	ldd	r18, Y+13	; 0x0d
    462e:	3e 85       	ldd	r19, Y+14	; 0x0e
    4630:	3c 87       	std	Y+12, r19	; 0x0c
    4632:	2b 87       	std	Y+11, r18	; 0x0b
    4634:	4b 85       	ldd	r20, Y+11	; 0x0b
    4636:	5c 85       	ldd	r21, Y+12	; 0x0c
    4638:	5a 83       	std	Y+2, r21	; 0x02
    463a:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    463c:	ed 81       	ldd	r30, Y+5	; 0x05
    463e:	fe 81       	ldd	r31, Y+6	; 0x06
    4640:	24 85       	ldd	r18, Z+12	; 0x0c
    4642:	35 85       	ldd	r19, Z+13	; 0x0d
    4644:	8b 81       	ldd	r24, Y+3	; 0x03
    4646:	9c 81       	ldd	r25, Y+4	; 0x04
    4648:	82 0f       	add	r24, r18
    464a:	93 1f       	adc	r25, r19
    464c:	2f 81       	ldd	r18, Y+7	; 0x07
    464e:	38 85       	ldd	r19, Y+8	; 0x08
    4650:	49 81       	ldd	r20, Y+1	; 0x01
    4652:	5a 81       	ldd	r21, Y+2	; 0x02
    4654:	b9 01       	movw	r22, r18
    4656:	0e 94 ff 31 	call	0x63fe	; 0x63fe <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    465a:	29 85       	ldd	r18, Y+9	; 0x09
    465c:	3a 85       	ldd	r19, Y+10	; 0x0a
    465e:	89 81       	ldd	r24, Y+1	; 0x01
    4660:	9a 81       	ldd	r25, Y+2	; 0x02
    4662:	82 17       	cp	r24, r18
    4664:	93 07       	cpc	r25, r19
    4666:	b0 f4       	brcc	.+44     	; 0x4694 <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4668:	ed 81       	ldd	r30, Y+5	; 0x05
    466a:	fe 81       	ldd	r31, Y+6	; 0x06
    466c:	64 85       	ldd	r22, Z+12	; 0x0c
    466e:	75 85       	ldd	r23, Z+13	; 0x0d
    4670:	2f 81       	ldd	r18, Y+7	; 0x07
    4672:	38 85       	ldd	r19, Y+8	; 0x08
    4674:	89 81       	ldd	r24, Y+1	; 0x01
    4676:	9a 81       	ldd	r25, Y+2	; 0x02
    4678:	a9 01       	movw	r20, r18
    467a:	48 0f       	add	r20, r24
    467c:	59 1f       	adc	r21, r25
    467e:	29 85       	ldd	r18, Y+9	; 0x09
    4680:	3a 85       	ldd	r19, Y+10	; 0x0a
    4682:	89 81       	ldd	r24, Y+1	; 0x01
    4684:	9a 81       	ldd	r25, Y+2	; 0x02
    4686:	28 1b       	sub	r18, r24
    4688:	39 0b       	sbc	r19, r25
    468a:	cb 01       	movw	r24, r22
    468c:	ba 01       	movw	r22, r20
    468e:	a9 01       	movw	r20, r18
    4690:	0e 94 ff 31 	call	0x63fe	; 0x63fe <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    4694:	2b 81       	ldd	r18, Y+3	; 0x03
    4696:	3c 81       	ldd	r19, Y+4	; 0x04
    4698:	89 85       	ldd	r24, Y+9	; 0x09
    469a:	9a 85       	ldd	r25, Y+10	; 0x0a
    469c:	82 0f       	add	r24, r18
    469e:	93 1f       	adc	r25, r19
    46a0:	9c 83       	std	Y+4, r25	; 0x04
    46a2:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    46a4:	ed 81       	ldd	r30, Y+5	; 0x05
    46a6:	fe 81       	ldd	r31, Y+6	; 0x06
    46a8:	24 81       	ldd	r18, Z+4	; 0x04
    46aa:	35 81       	ldd	r19, Z+5	; 0x05
    46ac:	8b 81       	ldd	r24, Y+3	; 0x03
    46ae:	9c 81       	ldd	r25, Y+4	; 0x04
    46b0:	82 17       	cp	r24, r18
    46b2:	93 07       	cpc	r25, r19
    46b4:	50 f0       	brcs	.+20     	; 0x46ca <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    46b6:	ed 81       	ldd	r30, Y+5	; 0x05
    46b8:	fe 81       	ldd	r31, Y+6	; 0x06
    46ba:	24 81       	ldd	r18, Z+4	; 0x04
    46bc:	35 81       	ldd	r19, Z+5	; 0x05
    46be:	8b 81       	ldd	r24, Y+3	; 0x03
    46c0:	9c 81       	ldd	r25, Y+4	; 0x04
    46c2:	82 1b       	sub	r24, r18
    46c4:	93 0b       	sbc	r25, r19
    46c6:	9c 83       	std	Y+4, r25	; 0x04
    46c8:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    46ca:	ed 81       	ldd	r30, Y+5	; 0x05
    46cc:	fe 81       	ldd	r31, Y+6	; 0x06
    46ce:	8b 81       	ldd	r24, Y+3	; 0x03
    46d0:	9c 81       	ldd	r25, Y+4	; 0x04
    46d2:	93 83       	std	Z+3, r25	; 0x03
    46d4:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    46d6:	89 85       	ldd	r24, Y+9	; 0x09
    46d8:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    46da:	2e 96       	adiw	r28, 0x0e	; 14
    46dc:	0f b6       	in	r0, 0x3f	; 63
    46de:	f8 94       	cli
    46e0:	de bf       	out	0x3e, r29	; 62
    46e2:	0f be       	out	0x3f, r0	; 63
    46e4:	cd bf       	out	0x3d, r28	; 61
    46e6:	cf 91       	pop	r28
    46e8:	df 91       	pop	r29
    46ea:	08 95       	ret

000046ec <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    46ec:	df 93       	push	r29
    46ee:	cf 93       	push	r28
    46f0:	cd b7       	in	r28, 0x3d	; 61
    46f2:	de b7       	in	r29, 0x3e	; 62
    46f4:	66 97       	sbiw	r28, 0x16	; 22
    46f6:	0f b6       	in	r0, 0x3f	; 63
    46f8:	f8 94       	cli
    46fa:	de bf       	out	0x3e, r29	; 62
    46fc:	0f be       	out	0x3f, r0	; 63
    46fe:	cd bf       	out	0x3d, r28	; 61
    4700:	98 87       	std	Y+8, r25	; 0x08
    4702:	8f 83       	std	Y+7, r24	; 0x07
    4704:	7a 87       	std	Y+10, r23	; 0x0a
    4706:	69 87       	std	Y+9, r22	; 0x09
    4708:	5c 87       	std	Y+12, r21	; 0x0c
    470a:	4b 87       	std	Y+11, r20	; 0x0b
    470c:	3e 87       	std	Y+14, r19	; 0x0e
    470e:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    4710:	2d 85       	ldd	r18, Y+13	; 0x0d
    4712:	3e 85       	ldd	r19, Y+14	; 0x0e
    4714:	3a 8b       	std	Y+18, r19	; 0x12
    4716:	29 8b       	std	Y+17, r18	; 0x11
    4718:	4b 85       	ldd	r20, Y+11	; 0x0b
    471a:	5c 85       	ldd	r21, Y+12	; 0x0c
    471c:	58 8b       	std	Y+16, r21	; 0x10
    471e:	4f 87       	std	Y+15, r20	; 0x0f
    4720:	8f 85       	ldd	r24, Y+15	; 0x0f
    4722:	98 89       	ldd	r25, Y+16	; 0x10
    4724:	29 89       	ldd	r18, Y+17	; 0x11
    4726:	3a 89       	ldd	r19, Y+18	; 0x12
    4728:	28 17       	cp	r18, r24
    472a:	39 07       	cpc	r19, r25
    472c:	20 f4       	brcc	.+8      	; 0x4736 <prvReadBytesFromBuffer+0x4a>
    472e:	49 89       	ldd	r20, Y+17	; 0x11
    4730:	5a 89       	ldd	r21, Y+18	; 0x12
    4732:	58 8b       	std	Y+16, r21	; 0x10
    4734:	4f 87       	std	Y+15, r20	; 0x0f
    4736:	8f 85       	ldd	r24, Y+15	; 0x0f
    4738:	98 89       	ldd	r25, Y+16	; 0x10
    473a:	9e 83       	std	Y+6, r25	; 0x06
    473c:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    473e:	8d 81       	ldd	r24, Y+5	; 0x05
    4740:	9e 81       	ldd	r25, Y+6	; 0x06
    4742:	00 97       	sbiw	r24, 0x00	; 0
    4744:	09 f4       	brne	.+2      	; 0x4748 <prvReadBytesFromBuffer+0x5c>
    4746:	74 c0       	rjmp	.+232    	; 0x4830 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    4748:	ef 81       	ldd	r30, Y+7	; 0x07
    474a:	f8 85       	ldd	r31, Y+8	; 0x08
    474c:	80 81       	ld	r24, Z
    474e:	91 81       	ldd	r25, Z+1	; 0x01
    4750:	9a 83       	std	Y+2, r25	; 0x02
    4752:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    4754:	ef 81       	ldd	r30, Y+7	; 0x07
    4756:	f8 85       	ldd	r31, Y+8	; 0x08
    4758:	24 81       	ldd	r18, Z+4	; 0x04
    475a:	35 81       	ldd	r19, Z+5	; 0x05
    475c:	89 81       	ldd	r24, Y+1	; 0x01
    475e:	9a 81       	ldd	r25, Y+2	; 0x02
    4760:	a9 01       	movw	r20, r18
    4762:	48 1b       	sub	r20, r24
    4764:	59 0b       	sbc	r21, r25
    4766:	ca 01       	movw	r24, r20
    4768:	2d 81       	ldd	r18, Y+5	; 0x05
    476a:	3e 81       	ldd	r19, Y+6	; 0x06
    476c:	3e 8b       	std	Y+22, r19	; 0x16
    476e:	2d 8b       	std	Y+21, r18	; 0x15
    4770:	9c 8b       	std	Y+20, r25	; 0x14
    4772:	8b 8b       	std	Y+19, r24	; 0x13
    4774:	4b 89       	ldd	r20, Y+19	; 0x13
    4776:	5c 89       	ldd	r21, Y+20	; 0x14
    4778:	8d 89       	ldd	r24, Y+21	; 0x15
    477a:	9e 89       	ldd	r25, Y+22	; 0x16
    477c:	84 17       	cp	r24, r20
    477e:	95 07       	cpc	r25, r21
    4780:	20 f4       	brcc	.+8      	; 0x478a <prvReadBytesFromBuffer+0x9e>
    4782:	2d 89       	ldd	r18, Y+21	; 0x15
    4784:	3e 89       	ldd	r19, Y+22	; 0x16
    4786:	3c 8b       	std	Y+20, r19	; 0x14
    4788:	2b 8b       	std	Y+19, r18	; 0x13
    478a:	4b 89       	ldd	r20, Y+19	; 0x13
    478c:	5c 89       	ldd	r21, Y+20	; 0x14
    478e:	5c 83       	std	Y+4, r21	; 0x04
    4790:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4792:	ef 81       	ldd	r30, Y+7	; 0x07
    4794:	f8 85       	ldd	r31, Y+8	; 0x08
    4796:	24 85       	ldd	r18, Z+12	; 0x0c
    4798:	35 85       	ldd	r19, Z+13	; 0x0d
    479a:	89 81       	ldd	r24, Y+1	; 0x01
    479c:	9a 81       	ldd	r25, Y+2	; 0x02
    479e:	a9 01       	movw	r20, r18
    47a0:	48 0f       	add	r20, r24
    47a2:	59 1f       	adc	r21, r25
    47a4:	89 85       	ldd	r24, Y+9	; 0x09
    47a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    47a8:	2b 81       	ldd	r18, Y+3	; 0x03
    47aa:	3c 81       	ldd	r19, Y+4	; 0x04
    47ac:	ba 01       	movw	r22, r20
    47ae:	a9 01       	movw	r20, r18
    47b0:	0e 94 ff 31 	call	0x63fe	; 0x63fe <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    47b4:	2d 81       	ldd	r18, Y+5	; 0x05
    47b6:	3e 81       	ldd	r19, Y+6	; 0x06
    47b8:	8b 81       	ldd	r24, Y+3	; 0x03
    47ba:	9c 81       	ldd	r25, Y+4	; 0x04
    47bc:	82 17       	cp	r24, r18
    47be:	93 07       	cpc	r25, r19
    47c0:	b0 f4       	brcc	.+44     	; 0x47ee <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    47c2:	29 85       	ldd	r18, Y+9	; 0x09
    47c4:	3a 85       	ldd	r19, Y+10	; 0x0a
    47c6:	8b 81       	ldd	r24, Y+3	; 0x03
    47c8:	9c 81       	ldd	r25, Y+4	; 0x04
    47ca:	b9 01       	movw	r22, r18
    47cc:	68 0f       	add	r22, r24
    47ce:	79 1f       	adc	r23, r25
    47d0:	ef 81       	ldd	r30, Y+7	; 0x07
    47d2:	f8 85       	ldd	r31, Y+8	; 0x08
    47d4:	44 85       	ldd	r20, Z+12	; 0x0c
    47d6:	55 85       	ldd	r21, Z+13	; 0x0d
    47d8:	2d 81       	ldd	r18, Y+5	; 0x05
    47da:	3e 81       	ldd	r19, Y+6	; 0x06
    47dc:	8b 81       	ldd	r24, Y+3	; 0x03
    47de:	9c 81       	ldd	r25, Y+4	; 0x04
    47e0:	28 1b       	sub	r18, r24
    47e2:	39 0b       	sbc	r19, r25
    47e4:	cb 01       	movw	r24, r22
    47e6:	ba 01       	movw	r22, r20
    47e8:	a9 01       	movw	r20, r18
    47ea:	0e 94 ff 31 	call	0x63fe	; 0x63fe <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    47ee:	29 81       	ldd	r18, Y+1	; 0x01
    47f0:	3a 81       	ldd	r19, Y+2	; 0x02
    47f2:	8d 81       	ldd	r24, Y+5	; 0x05
    47f4:	9e 81       	ldd	r25, Y+6	; 0x06
    47f6:	82 0f       	add	r24, r18
    47f8:	93 1f       	adc	r25, r19
    47fa:	9a 83       	std	Y+2, r25	; 0x02
    47fc:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    47fe:	ef 81       	ldd	r30, Y+7	; 0x07
    4800:	f8 85       	ldd	r31, Y+8	; 0x08
    4802:	24 81       	ldd	r18, Z+4	; 0x04
    4804:	35 81       	ldd	r19, Z+5	; 0x05
    4806:	89 81       	ldd	r24, Y+1	; 0x01
    4808:	9a 81       	ldd	r25, Y+2	; 0x02
    480a:	82 17       	cp	r24, r18
    480c:	93 07       	cpc	r25, r19
    480e:	50 f0       	brcs	.+20     	; 0x4824 <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    4810:	ef 81       	ldd	r30, Y+7	; 0x07
    4812:	f8 85       	ldd	r31, Y+8	; 0x08
    4814:	24 81       	ldd	r18, Z+4	; 0x04
    4816:	35 81       	ldd	r19, Z+5	; 0x05
    4818:	89 81       	ldd	r24, Y+1	; 0x01
    481a:	9a 81       	ldd	r25, Y+2	; 0x02
    481c:	82 1b       	sub	r24, r18
    481e:	93 0b       	sbc	r25, r19
    4820:	9a 83       	std	Y+2, r25	; 0x02
    4822:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    4824:	ef 81       	ldd	r30, Y+7	; 0x07
    4826:	f8 85       	ldd	r31, Y+8	; 0x08
    4828:	89 81       	ldd	r24, Y+1	; 0x01
    482a:	9a 81       	ldd	r25, Y+2	; 0x02
    482c:	91 83       	std	Z+1, r25	; 0x01
    482e:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    4830:	8d 81       	ldd	r24, Y+5	; 0x05
    4832:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4834:	66 96       	adiw	r28, 0x16	; 22
    4836:	0f b6       	in	r0, 0x3f	; 63
    4838:	f8 94       	cli
    483a:	de bf       	out	0x3e, r29	; 62
    483c:	0f be       	out	0x3f, r0	; 63
    483e:	cd bf       	out	0x3d, r28	; 61
    4840:	cf 91       	pop	r28
    4842:	df 91       	pop	r29
    4844:	08 95       	ret

00004846 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    4846:	df 93       	push	r29
    4848:	cf 93       	push	r28
    484a:	00 d0       	rcall	.+0      	; 0x484c <prvBytesInBuffer+0x6>
    484c:	00 d0       	rcall	.+0      	; 0x484e <prvBytesInBuffer+0x8>
    484e:	cd b7       	in	r28, 0x3d	; 61
    4850:	de b7       	in	r29, 0x3e	; 62
    4852:	9c 83       	std	Y+4, r25	; 0x04
    4854:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    4856:	eb 81       	ldd	r30, Y+3	; 0x03
    4858:	fc 81       	ldd	r31, Y+4	; 0x04
    485a:	24 81       	ldd	r18, Z+4	; 0x04
    485c:	35 81       	ldd	r19, Z+5	; 0x05
    485e:	eb 81       	ldd	r30, Y+3	; 0x03
    4860:	fc 81       	ldd	r31, Y+4	; 0x04
    4862:	82 81       	ldd	r24, Z+2	; 0x02
    4864:	93 81       	ldd	r25, Z+3	; 0x03
    4866:	82 0f       	add	r24, r18
    4868:	93 1f       	adc	r25, r19
    486a:	9a 83       	std	Y+2, r25	; 0x02
    486c:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    486e:	eb 81       	ldd	r30, Y+3	; 0x03
    4870:	fc 81       	ldd	r31, Y+4	; 0x04
    4872:	20 81       	ld	r18, Z
    4874:	31 81       	ldd	r19, Z+1	; 0x01
    4876:	89 81       	ldd	r24, Y+1	; 0x01
    4878:	9a 81       	ldd	r25, Y+2	; 0x02
    487a:	82 1b       	sub	r24, r18
    487c:	93 0b       	sbc	r25, r19
    487e:	9a 83       	std	Y+2, r25	; 0x02
    4880:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    4882:	eb 81       	ldd	r30, Y+3	; 0x03
    4884:	fc 81       	ldd	r31, Y+4	; 0x04
    4886:	24 81       	ldd	r18, Z+4	; 0x04
    4888:	35 81       	ldd	r19, Z+5	; 0x05
    488a:	89 81       	ldd	r24, Y+1	; 0x01
    488c:	9a 81       	ldd	r25, Y+2	; 0x02
    488e:	82 17       	cp	r24, r18
    4890:	93 07       	cpc	r25, r19
    4892:	50 f0       	brcs	.+20     	; 0x48a8 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    4894:	eb 81       	ldd	r30, Y+3	; 0x03
    4896:	fc 81       	ldd	r31, Y+4	; 0x04
    4898:	24 81       	ldd	r18, Z+4	; 0x04
    489a:	35 81       	ldd	r19, Z+5	; 0x05
    489c:	89 81       	ldd	r24, Y+1	; 0x01
    489e:	9a 81       	ldd	r25, Y+2	; 0x02
    48a0:	82 1b       	sub	r24, r18
    48a2:	93 0b       	sbc	r25, r19
    48a4:	9a 83       	std	Y+2, r25	; 0x02
    48a6:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    48a8:	89 81       	ldd	r24, Y+1	; 0x01
    48aa:	9a 81       	ldd	r25, Y+2	; 0x02
}
    48ac:	0f 90       	pop	r0
    48ae:	0f 90       	pop	r0
    48b0:	0f 90       	pop	r0
    48b2:	0f 90       	pop	r0
    48b4:	cf 91       	pop	r28
    48b6:	df 91       	pop	r29
    48b8:	08 95       	ret

000048ba <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    48ba:	0f 93       	push	r16
    48bc:	df 93       	push	r29
    48be:	cf 93       	push	r28
    48c0:	cd b7       	in	r28, 0x3d	; 61
    48c2:	de b7       	in	r29, 0x3e	; 62
    48c4:	29 97       	sbiw	r28, 0x09	; 9
    48c6:	0f b6       	in	r0, 0x3f	; 63
    48c8:	f8 94       	cli
    48ca:	de bf       	out	0x3e, r29	; 62
    48cc:	0f be       	out	0x3f, r0	; 63
    48ce:	cd bf       	out	0x3d, r28	; 61
    48d0:	9a 83       	std	Y+2, r25	; 0x02
    48d2:	89 83       	std	Y+1, r24	; 0x01
    48d4:	7c 83       	std	Y+4, r23	; 0x04
    48d6:	6b 83       	std	Y+3, r22	; 0x03
    48d8:	5e 83       	std	Y+6, r21	; 0x06
    48da:	4d 83       	std	Y+5, r20	; 0x05
    48dc:	38 87       	std	Y+8, r19	; 0x08
    48de:	2f 83       	std	Y+7, r18	; 0x07
    48e0:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    48e2:	89 81       	ldd	r24, Y+1	; 0x01
    48e4:	9a 81       	ldd	r25, Y+2	; 0x02
    48e6:	60 e0       	ldi	r22, 0x00	; 0
    48e8:	70 e0       	ldi	r23, 0x00	; 0
    48ea:	4f e0       	ldi	r20, 0x0F	; 15
    48ec:	50 e0       	ldi	r21, 0x00	; 0
    48ee:	0e 94 08 32 	call	0x6410	; 0x6410 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    48f2:	e9 81       	ldd	r30, Y+1	; 0x01
    48f4:	fa 81       	ldd	r31, Y+2	; 0x02
    48f6:	8b 81       	ldd	r24, Y+3	; 0x03
    48f8:	9c 81       	ldd	r25, Y+4	; 0x04
    48fa:	95 87       	std	Z+13, r25	; 0x0d
    48fc:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    48fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4900:	fa 81       	ldd	r31, Y+2	; 0x02
    4902:	8d 81       	ldd	r24, Y+5	; 0x05
    4904:	9e 81       	ldd	r25, Y+6	; 0x06
    4906:	95 83       	std	Z+5, r25	; 0x05
    4908:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    490a:	e9 81       	ldd	r30, Y+1	; 0x01
    490c:	fa 81       	ldd	r31, Y+2	; 0x02
    490e:	8f 81       	ldd	r24, Y+7	; 0x07
    4910:	98 85       	ldd	r25, Y+8	; 0x08
    4912:	97 83       	std	Z+7, r25	; 0x07
    4914:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    4916:	e9 81       	ldd	r30, Y+1	; 0x01
    4918:	fa 81       	ldd	r31, Y+2	; 0x02
    491a:	89 85       	ldd	r24, Y+9	; 0x09
    491c:	86 87       	std	Z+14, r24	; 0x0e
}
    491e:	29 96       	adiw	r28, 0x09	; 9
    4920:	0f b6       	in	r0, 0x3f	; 63
    4922:	f8 94       	cli
    4924:	de bf       	out	0x3e, r29	; 62
    4926:	0f be       	out	0x3f, r0	; 63
    4928:	cd bf       	out	0x3d, r28	; 61
    492a:	cf 91       	pop	r28
    492c:	df 91       	pop	r29
    492e:	0f 91       	pop	r16
    4930:	08 95       	ret

00004932 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    4932:	8f 92       	push	r8
    4934:	9f 92       	push	r9
    4936:	af 92       	push	r10
    4938:	bf 92       	push	r11
    493a:	cf 92       	push	r12
    493c:	df 92       	push	r13
    493e:	ef 92       	push	r14
    4940:	ff 92       	push	r15
    4942:	0f 93       	push	r16
    4944:	1f 93       	push	r17
    4946:	df 93       	push	r29
    4948:	cf 93       	push	r28
    494a:	cd b7       	in	r28, 0x3d	; 61
    494c:	de b7       	in	r29, 0x3e	; 62
    494e:	60 97       	sbiw	r28, 0x10	; 16
    4950:	0f b6       	in	r0, 0x3f	; 63
    4952:	f8 94       	cli
    4954:	de bf       	out	0x3e, r29	; 62
    4956:	0f be       	out	0x3f, r0	; 63
    4958:	cd bf       	out	0x3d, r28	; 61
    495a:	9f 83       	std	Y+7, r25	; 0x07
    495c:	8e 83       	std	Y+6, r24	; 0x06
    495e:	79 87       	std	Y+9, r23	; 0x09
    4960:	68 87       	std	Y+8, r22	; 0x08
    4962:	5b 87       	std	Y+11, r21	; 0x0b
    4964:	4a 87       	std	Y+10, r20	; 0x0a
    4966:	3d 87       	std	Y+13, r19	; 0x0d
    4968:	2c 87       	std	Y+12, r18	; 0x0c
    496a:	0e 87       	std	Y+14, r16	; 0x0e
    496c:	f8 8a       	std	Y+16, r15	; 0x10
    496e:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    4970:	8a 85       	ldd	r24, Y+10	; 0x0a
    4972:	9b 85       	ldd	r25, Y+11	; 0x0b
    4974:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <pvPortMalloc>
    4978:	9a 83       	std	Y+2, r25	; 0x02
    497a:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    497c:	89 81       	ldd	r24, Y+1	; 0x01
    497e:	9a 81       	ldd	r25, Y+2	; 0x02
    4980:	00 97       	sbiw	r24, 0x00	; 0
    4982:	b1 f0       	breq	.+44     	; 0x49b0 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    4984:	82 e3       	ldi	r24, 0x32	; 50
    4986:	90 e0       	ldi	r25, 0x00	; 0
    4988:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <pvPortMalloc>
    498c:	9d 83       	std	Y+5, r25	; 0x05
    498e:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    4990:	8c 81       	ldd	r24, Y+4	; 0x04
    4992:	9d 81       	ldd	r25, Y+5	; 0x05
    4994:	00 97       	sbiw	r24, 0x00	; 0
    4996:	39 f0       	breq	.+14     	; 0x49a6 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    4998:	ec 81       	ldd	r30, Y+4	; 0x04
    499a:	fd 81       	ldd	r31, Y+5	; 0x05
    499c:	89 81       	ldd	r24, Y+1	; 0x01
    499e:	9a 81       	ldd	r25, Y+2	; 0x02
    49a0:	90 8f       	std	Z+24, r25	; 0x18
    49a2:	87 8b       	std	Z+23, r24	; 0x17
    49a4:	07 c0       	rjmp	.+14     	; 0x49b4 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    49a6:	89 81       	ldd	r24, Y+1	; 0x01
    49a8:	9a 81       	ldd	r25, Y+2	; 0x02
    49aa:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <vPortFree>
    49ae:	02 c0       	rjmp	.+4      	; 0x49b4 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    49b0:	1d 82       	std	Y+5, r1	; 0x05
    49b2:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    49b4:	8c 81       	ldd	r24, Y+4	; 0x04
    49b6:	9d 81       	ldd	r25, Y+5	; 0x05
    49b8:	00 97       	sbiw	r24, 0x00	; 0
    49ba:	e9 f0       	breq	.+58     	; 0x49f6 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    49bc:	8a 85       	ldd	r24, Y+10	; 0x0a
    49be:	9b 85       	ldd	r25, Y+11	; 0x0b
    49c0:	9c 01       	movw	r18, r24
    49c2:	40 e0       	ldi	r20, 0x00	; 0
    49c4:	50 e0       	ldi	r21, 0x00	; 0
    49c6:	8e 81       	ldd	r24, Y+6	; 0x06
    49c8:	9f 81       	ldd	r25, Y+7	; 0x07
    49ca:	68 85       	ldd	r22, Y+8	; 0x08
    49cc:	79 85       	ldd	r23, Y+9	; 0x09
    49ce:	ec 85       	ldd	r30, Y+12	; 0x0c
    49d0:	fd 85       	ldd	r31, Y+13	; 0x0d
    49d2:	af 85       	ldd	r26, Y+15	; 0x0f
    49d4:	b8 89       	ldd	r27, Y+16	; 0x10
    49d6:	ac 80       	ldd	r10, Y+4	; 0x04
    49d8:	bd 80       	ldd	r11, Y+5	; 0x05
    49da:	8f 01       	movw	r16, r30
    49dc:	ee 84       	ldd	r14, Y+14	; 0x0e
    49de:	6d 01       	movw	r12, r26
    49e0:	88 24       	eor	r8, r8
    49e2:	99 24       	eor	r9, r9
    49e4:	0e 94 11 25 	call	0x4a22	; 0x4a22 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    49e8:	8c 81       	ldd	r24, Y+4	; 0x04
    49ea:	9d 81       	ldd	r25, Y+5	; 0x05
    49ec:	0e 94 cd 25 	call	0x4b9a	; 0x4b9a <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    49f0:	81 e0       	ldi	r24, 0x01	; 1
    49f2:	8b 83       	std	Y+3, r24	; 0x03
    49f4:	02 c0       	rjmp	.+4      	; 0x49fa <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    49f6:	8f ef       	ldi	r24, 0xFF	; 255
    49f8:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    49fa:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    49fc:	60 96       	adiw	r28, 0x10	; 16
    49fe:	0f b6       	in	r0, 0x3f	; 63
    4a00:	f8 94       	cli
    4a02:	de bf       	out	0x3e, r29	; 62
    4a04:	0f be       	out	0x3f, r0	; 63
    4a06:	cd bf       	out	0x3d, r28	; 61
    4a08:	cf 91       	pop	r28
    4a0a:	df 91       	pop	r29
    4a0c:	1f 91       	pop	r17
    4a0e:	0f 91       	pop	r16
    4a10:	ff 90       	pop	r15
    4a12:	ef 90       	pop	r14
    4a14:	df 90       	pop	r13
    4a16:	cf 90       	pop	r12
    4a18:	bf 90       	pop	r11
    4a1a:	af 90       	pop	r10
    4a1c:	9f 90       	pop	r9
    4a1e:	8f 90       	pop	r8
    4a20:	08 95       	ret

00004a22 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    4a22:	8f 92       	push	r8
    4a24:	9f 92       	push	r9
    4a26:	af 92       	push	r10
    4a28:	bf 92       	push	r11
    4a2a:	cf 92       	push	r12
    4a2c:	df 92       	push	r13
    4a2e:	ef 92       	push	r14
    4a30:	0f 93       	push	r16
    4a32:	1f 93       	push	r17
    4a34:	df 93       	push	r29
    4a36:	cf 93       	push	r28
    4a38:	cd b7       	in	r28, 0x3d	; 61
    4a3a:	de b7       	in	r29, 0x3e	; 62
    4a3c:	64 97       	sbiw	r28, 0x14	; 20
    4a3e:	0f b6       	in	r0, 0x3f	; 63
    4a40:	f8 94       	cli
    4a42:	de bf       	out	0x3e, r29	; 62
    4a44:	0f be       	out	0x3f, r0	; 63
    4a46:	cd bf       	out	0x3d, r28	; 61
    4a48:	9d 83       	std	Y+5, r25	; 0x05
    4a4a:	8c 83       	std	Y+4, r24	; 0x04
    4a4c:	7f 83       	std	Y+7, r23	; 0x07
    4a4e:	6e 83       	std	Y+6, r22	; 0x06
    4a50:	28 87       	std	Y+8, r18	; 0x08
    4a52:	39 87       	std	Y+9, r19	; 0x09
    4a54:	4a 87       	std	Y+10, r20	; 0x0a
    4a56:	5b 87       	std	Y+11, r21	; 0x0b
    4a58:	1d 87       	std	Y+13, r17	; 0x0d
    4a5a:	0c 87       	std	Y+12, r16	; 0x0c
    4a5c:	ee 86       	std	Y+14, r14	; 0x0e
    4a5e:	d8 8a       	std	Y+16, r13	; 0x10
    4a60:	cf 86       	std	Y+15, r12	; 0x0f
    4a62:	ba 8a       	std	Y+18, r11	; 0x12
    4a64:	a9 8a       	std	Y+17, r10	; 0x11
    4a66:	9c 8a       	std	Y+20, r9	; 0x14
    4a68:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    4a6a:	e9 89       	ldd	r30, Y+17	; 0x11
    4a6c:	fa 89       	ldd	r31, Y+18	; 0x12
    4a6e:	27 89       	ldd	r18, Z+23	; 0x17
    4a70:	30 8d       	ldd	r19, Z+24	; 0x18
    4a72:	88 85       	ldd	r24, Y+8	; 0x08
    4a74:	99 85       	ldd	r25, Y+9	; 0x09
    4a76:	01 97       	sbiw	r24, 0x01	; 1
    4a78:	82 0f       	add	r24, r18
    4a7a:	93 1f       	adc	r25, r19
    4a7c:	9b 83       	std	Y+3, r25	; 0x03
    4a7e:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    4a80:	8e 81       	ldd	r24, Y+6	; 0x06
    4a82:	9f 81       	ldd	r25, Y+7	; 0x07
    4a84:	00 97       	sbiw	r24, 0x00	; 0
    4a86:	51 f1       	breq	.+84     	; 0x4adc <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4a88:	19 82       	std	Y+1, r1	; 0x01
    4a8a:	21 c0       	rjmp	.+66     	; 0x4ace <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    4a8c:	89 81       	ldd	r24, Y+1	; 0x01
    4a8e:	48 2f       	mov	r20, r24
    4a90:	50 e0       	ldi	r21, 0x00	; 0
    4a92:	89 81       	ldd	r24, Y+1	; 0x01
    4a94:	28 2f       	mov	r18, r24
    4a96:	30 e0       	ldi	r19, 0x00	; 0
    4a98:	8e 81       	ldd	r24, Y+6	; 0x06
    4a9a:	9f 81       	ldd	r25, Y+7	; 0x07
    4a9c:	fc 01       	movw	r30, r24
    4a9e:	e2 0f       	add	r30, r18
    4aa0:	f3 1f       	adc	r31, r19
    4aa2:	20 81       	ld	r18, Z
    4aa4:	89 89       	ldd	r24, Y+17	; 0x11
    4aa6:	9a 89       	ldd	r25, Y+18	; 0x12
    4aa8:	84 0f       	add	r24, r20
    4aaa:	95 1f       	adc	r25, r21
    4aac:	fc 01       	movw	r30, r24
    4aae:	79 96       	adiw	r30, 0x19	; 25
    4ab0:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    4ab2:	89 81       	ldd	r24, Y+1	; 0x01
    4ab4:	28 2f       	mov	r18, r24
    4ab6:	30 e0       	ldi	r19, 0x00	; 0
    4ab8:	8e 81       	ldd	r24, Y+6	; 0x06
    4aba:	9f 81       	ldd	r25, Y+7	; 0x07
    4abc:	fc 01       	movw	r30, r24
    4abe:	e2 0f       	add	r30, r18
    4ac0:	f3 1f       	adc	r31, r19
    4ac2:	80 81       	ld	r24, Z
    4ac4:	88 23       	and	r24, r24
    4ac6:	31 f0       	breq	.+12     	; 0x4ad4 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4ac8:	89 81       	ldd	r24, Y+1	; 0x01
    4aca:	8f 5f       	subi	r24, 0xFF	; 255
    4acc:	89 83       	std	Y+1, r24	; 0x01
    4ace:	89 81       	ldd	r24, Y+1	; 0x01
    4ad0:	84 31       	cpi	r24, 0x14	; 20
    4ad2:	e0 f2       	brcs	.-72     	; 0x4a8c <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4ad4:	e9 89       	ldd	r30, Y+17	; 0x11
    4ad6:	fa 89       	ldd	r31, Y+18	; 0x12
    4ad8:	14 a6       	std	Z+44, r1	; 0x2c
    4ada:	03 c0       	rjmp	.+6      	; 0x4ae2 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    4adc:	e9 89       	ldd	r30, Y+17	; 0x11
    4ade:	fa 89       	ldd	r31, Y+18	; 0x12
    4ae0:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4ae2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ae4:	85 30       	cpi	r24, 0x05	; 5
    4ae6:	10 f0       	brcs	.+4      	; 0x4aec <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    4ae8:	84 e0       	ldi	r24, 0x04	; 4
    4aea:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    4aec:	e9 89       	ldd	r30, Y+17	; 0x11
    4aee:	fa 89       	ldd	r31, Y+18	; 0x12
    4af0:	8e 85       	ldd	r24, Y+14	; 0x0e
    4af2:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    4af4:	89 89       	ldd	r24, Y+17	; 0x11
    4af6:	9a 89       	ldd	r25, Y+18	; 0x12
    4af8:	02 96       	adiw	r24, 0x02	; 2
    4afa:	0e 94 e6 11 	call	0x23cc	; 0x23cc <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4afe:	89 89       	ldd	r24, Y+17	; 0x11
    4b00:	9a 89       	ldd	r25, Y+18	; 0x12
    4b02:	0c 96       	adiw	r24, 0x0c	; 12
    4b04:	0e 94 e6 11 	call	0x23cc	; 0x23cc <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    4b08:	e9 89       	ldd	r30, Y+17	; 0x11
    4b0a:	fa 89       	ldd	r31, Y+18	; 0x12
    4b0c:	89 89       	ldd	r24, Y+17	; 0x11
    4b0e:	9a 89       	ldd	r25, Y+18	; 0x12
    4b10:	91 87       	std	Z+9, r25	; 0x09
    4b12:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4b14:	8e 85       	ldd	r24, Y+14	; 0x0e
    4b16:	28 2f       	mov	r18, r24
    4b18:	30 e0       	ldi	r19, 0x00	; 0
    4b1a:	85 e0       	ldi	r24, 0x05	; 5
    4b1c:	90 e0       	ldi	r25, 0x00	; 0
    4b1e:	82 1b       	sub	r24, r18
    4b20:	93 0b       	sbc	r25, r19
    4b22:	e9 89       	ldd	r30, Y+17	; 0x11
    4b24:	fa 89       	ldd	r31, Y+18	; 0x12
    4b26:	95 87       	std	Z+13, r25	; 0x0d
    4b28:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4b2a:	e9 89       	ldd	r30, Y+17	; 0x11
    4b2c:	fa 89       	ldd	r31, Y+18	; 0x12
    4b2e:	89 89       	ldd	r24, Y+17	; 0x11
    4b30:	9a 89       	ldd	r25, Y+18	; 0x12
    4b32:	93 8b       	std	Z+19, r25	; 0x13
    4b34:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    4b36:	e9 89       	ldd	r30, Y+17	; 0x11
    4b38:	fa 89       	ldd	r31, Y+18	; 0x12
    4b3a:	15 a6       	std	Z+45, r1	; 0x2d
    4b3c:	16 a6       	std	Z+46, r1	; 0x2e
    4b3e:	17 a6       	std	Z+47, r1	; 0x2f
    4b40:	10 aa       	std	Z+48, r1	; 0x30
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4b42:	e9 89       	ldd	r30, Y+17	; 0x11
    4b44:	fa 89       	ldd	r31, Y+18	; 0x12
    4b46:	11 aa       	std	Z+49, r1	; 0x31
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4b48:	8a 81       	ldd	r24, Y+2	; 0x02
    4b4a:	9b 81       	ldd	r25, Y+3	; 0x03
    4b4c:	2c 81       	ldd	r18, Y+4	; 0x04
    4b4e:	3d 81       	ldd	r19, Y+5	; 0x05
    4b50:	4c 85       	ldd	r20, Y+12	; 0x0c
    4b52:	5d 85       	ldd	r21, Y+13	; 0x0d
    4b54:	b9 01       	movw	r22, r18
    4b56:	0e 94 0f 13 	call	0x261e	; 0x261e <pxPortInitialiseStack>
    4b5a:	e9 89       	ldd	r30, Y+17	; 0x11
    4b5c:	fa 89       	ldd	r31, Y+18	; 0x12
    4b5e:	91 83       	std	Z+1, r25	; 0x01
    4b60:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    4b62:	8f 85       	ldd	r24, Y+15	; 0x0f
    4b64:	98 89       	ldd	r25, Y+16	; 0x10
    4b66:	00 97       	sbiw	r24, 0x00	; 0
    4b68:	31 f0       	breq	.+12     	; 0x4b76 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4b6a:	ef 85       	ldd	r30, Y+15	; 0x0f
    4b6c:	f8 89       	ldd	r31, Y+16	; 0x10
    4b6e:	89 89       	ldd	r24, Y+17	; 0x11
    4b70:	9a 89       	ldd	r25, Y+18	; 0x12
    4b72:	91 83       	std	Z+1, r25	; 0x01
    4b74:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4b76:	64 96       	adiw	r28, 0x14	; 20
    4b78:	0f b6       	in	r0, 0x3f	; 63
    4b7a:	f8 94       	cli
    4b7c:	de bf       	out	0x3e, r29	; 62
    4b7e:	0f be       	out	0x3f, r0	; 63
    4b80:	cd bf       	out	0x3d, r28	; 61
    4b82:	cf 91       	pop	r28
    4b84:	df 91       	pop	r29
    4b86:	1f 91       	pop	r17
    4b88:	0f 91       	pop	r16
    4b8a:	ef 90       	pop	r14
    4b8c:	df 90       	pop	r13
    4b8e:	cf 90       	pop	r12
    4b90:	bf 90       	pop	r11
    4b92:	af 90       	pop	r10
    4b94:	9f 90       	pop	r9
    4b96:	8f 90       	pop	r8
    4b98:	08 95       	ret

00004b9a <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    4b9a:	df 93       	push	r29
    4b9c:	cf 93       	push	r28
    4b9e:	00 d0       	rcall	.+0      	; 0x4ba0 <prvAddNewTaskToReadyList+0x6>
    4ba0:	cd b7       	in	r28, 0x3d	; 61
    4ba2:	de b7       	in	r29, 0x3e	; 62
    4ba4:	9a 83       	std	Y+2, r25	; 0x02
    4ba6:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4ba8:	0f b6       	in	r0, 0x3f	; 63
    4baa:	f8 94       	cli
    4bac:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    4bae:	80 91 ab 06 	lds	r24, 0x06AB
    4bb2:	8f 5f       	subi	r24, 0xFF	; 255
    4bb4:	80 93 ab 06 	sts	0x06AB, r24
		if( pxCurrentTCB == NULL )
    4bb8:	80 91 a8 06 	lds	r24, 0x06A8
    4bbc:	90 91 a9 06 	lds	r25, 0x06A9
    4bc0:	00 97       	sbiw	r24, 0x00	; 0
    4bc2:	69 f4       	brne	.+26     	; 0x4bde <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4bc4:	89 81       	ldd	r24, Y+1	; 0x01
    4bc6:	9a 81       	ldd	r25, Y+2	; 0x02
    4bc8:	90 93 a9 06 	sts	0x06A9, r25
    4bcc:	80 93 a8 06 	sts	0x06A8, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4bd0:	80 91 ab 06 	lds	r24, 0x06AB
    4bd4:	81 30       	cpi	r24, 0x01	; 1
    4bd6:	b9 f4       	brne	.+46     	; 0x4c06 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    4bd8:	0e 94 a4 2c 	call	0x5948	; 0x5948 <prvInitialiseTaskLists>
    4bdc:	14 c0       	rjmp	.+40     	; 0x4c06 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    4bde:	80 91 af 06 	lds	r24, 0x06AF
    4be2:	88 23       	and	r24, r24
    4be4:	81 f4       	brne	.+32     	; 0x4c06 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4be6:	e0 91 a8 06 	lds	r30, 0x06A8
    4bea:	f0 91 a9 06 	lds	r31, 0x06A9
    4bee:	96 89       	ldd	r25, Z+22	; 0x16
    4bf0:	e9 81       	ldd	r30, Y+1	; 0x01
    4bf2:	fa 81       	ldd	r31, Y+2	; 0x02
    4bf4:	86 89       	ldd	r24, Z+22	; 0x16
    4bf6:	89 17       	cp	r24, r25
    4bf8:	30 f0       	brcs	.+12     	; 0x4c06 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    4bfa:	89 81       	ldd	r24, Y+1	; 0x01
    4bfc:	9a 81       	ldd	r25, Y+2	; 0x02
    4bfe:	90 93 a9 06 	sts	0x06A9, r25
    4c02:	80 93 a8 06 	sts	0x06A8, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4c06:	80 91 b3 06 	lds	r24, 0x06B3
    4c0a:	8f 5f       	subi	r24, 0xFF	; 255
    4c0c:	80 93 b3 06 	sts	0x06B3, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    4c10:	e9 81       	ldd	r30, Y+1	; 0x01
    4c12:	fa 81       	ldd	r31, Y+2	; 0x02
    4c14:	96 89       	ldd	r25, Z+22	; 0x16
    4c16:	80 91 ae 06 	lds	r24, 0x06AE
    4c1a:	89 17       	cp	r24, r25
    4c1c:	28 f4       	brcc	.+10     	; 0x4c28 <prvAddNewTaskToReadyList+0x8e>
    4c1e:	e9 81       	ldd	r30, Y+1	; 0x01
    4c20:	fa 81       	ldd	r31, Y+2	; 0x02
    4c22:	86 89       	ldd	r24, Z+22	; 0x16
    4c24:	80 93 ae 06 	sts	0x06AE, r24
    4c28:	e9 81       	ldd	r30, Y+1	; 0x01
    4c2a:	fa 81       	ldd	r31, Y+2	; 0x02
    4c2c:	86 89       	ldd	r24, Z+22	; 0x16
    4c2e:	28 2f       	mov	r18, r24
    4c30:	30 e0       	ldi	r19, 0x00	; 0
    4c32:	c9 01       	movw	r24, r18
    4c34:	88 0f       	add	r24, r24
    4c36:	99 1f       	adc	r25, r25
    4c38:	88 0f       	add	r24, r24
    4c3a:	99 1f       	adc	r25, r25
    4c3c:	88 0f       	add	r24, r24
    4c3e:	99 1f       	adc	r25, r25
    4c40:	82 0f       	add	r24, r18
    4c42:	93 1f       	adc	r25, r19
    4c44:	ac 01       	movw	r20, r24
    4c46:	47 54       	subi	r20, 0x47	; 71
    4c48:	59 4f       	sbci	r21, 0xF9	; 249
    4c4a:	89 81       	ldd	r24, Y+1	; 0x01
    4c4c:	9a 81       	ldd	r25, Y+2	; 0x02
    4c4e:	9c 01       	movw	r18, r24
    4c50:	2e 5f       	subi	r18, 0xFE	; 254
    4c52:	3f 4f       	sbci	r19, 0xFF	; 255
    4c54:	ca 01       	movw	r24, r20
    4c56:	b9 01       	movw	r22, r18
    4c58:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    4c5c:	0f 90       	pop	r0
    4c5e:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    4c60:	80 91 af 06 	lds	r24, 0x06AF
    4c64:	88 23       	and	r24, r24
    4c66:	61 f0       	breq	.+24     	; 0x4c80 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    4c68:	e0 91 a8 06 	lds	r30, 0x06A8
    4c6c:	f0 91 a9 06 	lds	r31, 0x06A9
    4c70:	96 89       	ldd	r25, Z+22	; 0x16
    4c72:	e9 81       	ldd	r30, Y+1	; 0x01
    4c74:	fa 81       	ldd	r31, Y+2	; 0x02
    4c76:	86 89       	ldd	r24, Z+22	; 0x16
    4c78:	98 17       	cp	r25, r24
    4c7a:	10 f4       	brcc	.+4      	; 0x4c80 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    4c7c:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4c80:	0f 90       	pop	r0
    4c82:	0f 90       	pop	r0
    4c84:	cf 91       	pop	r28
    4c86:	df 91       	pop	r29
    4c88:	08 95       	ret

00004c8a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4c8a:	df 93       	push	r29
    4c8c:	cf 93       	push	r28
    4c8e:	00 d0       	rcall	.+0      	; 0x4c90 <vTaskDelete+0x6>
    4c90:	00 d0       	rcall	.+0      	; 0x4c92 <vTaskDelete+0x8>
    4c92:	00 d0       	rcall	.+0      	; 0x4c94 <vTaskDelete+0xa>
    4c94:	cd b7       	in	r28, 0x3d	; 61
    4c96:	de b7       	in	r29, 0x3e	; 62
    4c98:	9c 83       	std	Y+4, r25	; 0x04
    4c9a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4c9c:	0f b6       	in	r0, 0x3f	; 63
    4c9e:	f8 94       	cli
    4ca0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4ca2:	8b 81       	ldd	r24, Y+3	; 0x03
    4ca4:	9c 81       	ldd	r25, Y+4	; 0x04
    4ca6:	00 97       	sbiw	r24, 0x00	; 0
    4ca8:	39 f4       	brne	.+14     	; 0x4cb8 <vTaskDelete+0x2e>
    4caa:	80 91 a8 06 	lds	r24, 0x06A8
    4cae:	90 91 a9 06 	lds	r25, 0x06A9
    4cb2:	9e 83       	std	Y+6, r25	; 0x06
    4cb4:	8d 83       	std	Y+5, r24	; 0x05
    4cb6:	04 c0       	rjmp	.+8      	; 0x4cc0 <vTaskDelete+0x36>
    4cb8:	8b 81       	ldd	r24, Y+3	; 0x03
    4cba:	9c 81       	ldd	r25, Y+4	; 0x04
    4cbc:	9e 83       	std	Y+6, r25	; 0x06
    4cbe:	8d 83       	std	Y+5, r24	; 0x05
    4cc0:	8d 81       	ldd	r24, Y+5	; 0x05
    4cc2:	9e 81       	ldd	r25, Y+6	; 0x06
    4cc4:	9a 83       	std	Y+2, r25	; 0x02
    4cc6:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4cc8:	89 81       	ldd	r24, Y+1	; 0x01
    4cca:	9a 81       	ldd	r25, Y+2	; 0x02
    4ccc:	02 96       	adiw	r24, 0x02	; 2
    4cce:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4cd2:	e9 81       	ldd	r30, Y+1	; 0x01
    4cd4:	fa 81       	ldd	r31, Y+2	; 0x02
    4cd6:	84 89       	ldd	r24, Z+20	; 0x14
    4cd8:	95 89       	ldd	r25, Z+21	; 0x15
    4cda:	00 97       	sbiw	r24, 0x00	; 0
    4cdc:	29 f0       	breq	.+10     	; 0x4ce8 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4cde:	89 81       	ldd	r24, Y+1	; 0x01
    4ce0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ce2:	0c 96       	adiw	r24, 0x0c	; 12
    4ce4:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    4ce8:	80 91 b3 06 	lds	r24, 0x06B3
    4cec:	8f 5f       	subi	r24, 0xFF	; 255
    4cee:	80 93 b3 06 	sts	0x06B3, r24

			if( pxTCB == pxCurrentTCB )
    4cf2:	20 91 a8 06 	lds	r18, 0x06A8
    4cf6:	30 91 a9 06 	lds	r19, 0x06A9
    4cfa:	89 81       	ldd	r24, Y+1	; 0x01
    4cfc:	9a 81       	ldd	r25, Y+2	; 0x02
    4cfe:	82 17       	cp	r24, r18
    4d00:	93 07       	cpc	r25, r19
    4d02:	81 f4       	brne	.+32     	; 0x4d24 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4d04:	89 81       	ldd	r24, Y+1	; 0x01
    4d06:	9a 81       	ldd	r25, Y+2	; 0x02
    4d08:	9c 01       	movw	r18, r24
    4d0a:	2e 5f       	subi	r18, 0xFE	; 254
    4d0c:	3f 4f       	sbci	r19, 0xFF	; 255
    4d0e:	85 e0       	ldi	r24, 0x05	; 5
    4d10:	97 e0       	ldi	r25, 0x07	; 7
    4d12:	b9 01       	movw	r22, r18
    4d14:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    4d18:	80 91 aa 06 	lds	r24, 0x06AA
    4d1c:	8f 5f       	subi	r24, 0xFF	; 255
    4d1e:	80 93 aa 06 	sts	0x06AA, r24
    4d22:	0b c0       	rjmp	.+22     	; 0x4d3a <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    4d24:	80 91 ab 06 	lds	r24, 0x06AB
    4d28:	81 50       	subi	r24, 0x01	; 1
    4d2a:	80 93 ab 06 	sts	0x06AB, r24
				prvDeleteTCB( pxTCB );
    4d2e:	89 81       	ldd	r24, Y+1	; 0x01
    4d30:	9a 81       	ldd	r25, Y+2	; 0x02
    4d32:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    4d36:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4d3a:	0f 90       	pop	r0
    4d3c:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4d3e:	80 91 af 06 	lds	r24, 0x06AF
    4d42:	88 23       	and	r24, r24
    4d44:	59 f0       	breq	.+22     	; 0x4d5c <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    4d46:	20 91 a8 06 	lds	r18, 0x06A8
    4d4a:	30 91 a9 06 	lds	r19, 0x06A9
    4d4e:	89 81       	ldd	r24, Y+1	; 0x01
    4d50:	9a 81       	ldd	r25, Y+2	; 0x02
    4d52:	82 17       	cp	r24, r18
    4d54:	93 07       	cpc	r25, r19
    4d56:	11 f4       	brne	.+4      	; 0x4d5c <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    4d58:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    4d5c:	26 96       	adiw	r28, 0x06	; 6
    4d5e:	0f b6       	in	r0, 0x3f	; 63
    4d60:	f8 94       	cli
    4d62:	de bf       	out	0x3e, r29	; 62
    4d64:	0f be       	out	0x3f, r0	; 63
    4d66:	cd bf       	out	0x3d, r28	; 61
    4d68:	cf 91       	pop	r28
    4d6a:	df 91       	pop	r29
    4d6c:	08 95       	ret

00004d6e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    4d6e:	df 93       	push	r29
    4d70:	cf 93       	push	r28
    4d72:	00 d0       	rcall	.+0      	; 0x4d74 <vTaskDelay+0x6>
    4d74:	0f 92       	push	r0
    4d76:	cd b7       	in	r28, 0x3d	; 61
    4d78:	de b7       	in	r29, 0x3e	; 62
    4d7a:	9b 83       	std	Y+3, r25	; 0x03
    4d7c:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    4d7e:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    4d80:	8a 81       	ldd	r24, Y+2	; 0x02
    4d82:	9b 81       	ldd	r25, Y+3	; 0x03
    4d84:	00 97       	sbiw	r24, 0x00	; 0
    4d86:	51 f0       	breq	.+20     	; 0x4d9c <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    4d88:	0e 94 84 28 	call	0x5108	; 0x5108 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4d8c:	8a 81       	ldd	r24, Y+2	; 0x02
    4d8e:	9b 81       	ldd	r25, Y+3	; 0x03
    4d90:	60 e0       	ldi	r22, 0x00	; 0
    4d92:	0e 94 36 31 	call	0x626c	; 0x626c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4d96:	0e 94 90 28 	call	0x5120	; 0x5120 <xTaskResumeAll>
    4d9a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4d9c:	89 81       	ldd	r24, Y+1	; 0x01
    4d9e:	88 23       	and	r24, r24
    4da0:	11 f4       	brne	.+4      	; 0x4da6 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    4da2:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4da6:	0f 90       	pop	r0
    4da8:	0f 90       	pop	r0
    4daa:	0f 90       	pop	r0
    4dac:	cf 91       	pop	r28
    4dae:	df 91       	pop	r29
    4db0:	08 95       	ret

00004db2 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    4db2:	df 93       	push	r29
    4db4:	cf 93       	push	r28
    4db6:	00 d0       	rcall	.+0      	; 0x4db8 <vTaskSuspend+0x6>
    4db8:	00 d0       	rcall	.+0      	; 0x4dba <vTaskSuspend+0x8>
    4dba:	00 d0       	rcall	.+0      	; 0x4dbc <vTaskSuspend+0xa>
    4dbc:	cd b7       	in	r28, 0x3d	; 61
    4dbe:	de b7       	in	r29, 0x3e	; 62
    4dc0:	9c 83       	std	Y+4, r25	; 0x04
    4dc2:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4dc4:	0f b6       	in	r0, 0x3f	; 63
    4dc6:	f8 94       	cli
    4dc8:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    4dca:	8b 81       	ldd	r24, Y+3	; 0x03
    4dcc:	9c 81       	ldd	r25, Y+4	; 0x04
    4dce:	00 97       	sbiw	r24, 0x00	; 0
    4dd0:	39 f4       	brne	.+14     	; 0x4de0 <vTaskSuspend+0x2e>
    4dd2:	80 91 a8 06 	lds	r24, 0x06A8
    4dd6:	90 91 a9 06 	lds	r25, 0x06A9
    4dda:	9e 83       	std	Y+6, r25	; 0x06
    4ddc:	8d 83       	std	Y+5, r24	; 0x05
    4dde:	04 c0       	rjmp	.+8      	; 0x4de8 <vTaskSuspend+0x36>
    4de0:	8b 81       	ldd	r24, Y+3	; 0x03
    4de2:	9c 81       	ldd	r25, Y+4	; 0x04
    4de4:	9e 83       	std	Y+6, r25	; 0x06
    4de6:	8d 83       	std	Y+5, r24	; 0x05
    4de8:	8d 81       	ldd	r24, Y+5	; 0x05
    4dea:	9e 81       	ldd	r25, Y+6	; 0x06
    4dec:	9a 83       	std	Y+2, r25	; 0x02
    4dee:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4df0:	89 81       	ldd	r24, Y+1	; 0x01
    4df2:	9a 81       	ldd	r25, Y+2	; 0x02
    4df4:	02 96       	adiw	r24, 0x02	; 2
    4df6:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4dfa:	e9 81       	ldd	r30, Y+1	; 0x01
    4dfc:	fa 81       	ldd	r31, Y+2	; 0x02
    4dfe:	84 89       	ldd	r24, Z+20	; 0x14
    4e00:	95 89       	ldd	r25, Z+21	; 0x15
    4e02:	00 97       	sbiw	r24, 0x00	; 0
    4e04:	29 f0       	breq	.+10     	; 0x4e10 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4e06:	89 81       	ldd	r24, Y+1	; 0x01
    4e08:	9a 81       	ldd	r25, Y+2	; 0x02
    4e0a:	0c 96       	adiw	r24, 0x0c	; 12
    4e0c:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    4e10:	89 81       	ldd	r24, Y+1	; 0x01
    4e12:	9a 81       	ldd	r25, Y+2	; 0x02
    4e14:	9c 01       	movw	r18, r24
    4e16:	2e 5f       	subi	r18, 0xFE	; 254
    4e18:	3f 4f       	sbci	r19, 0xFF	; 255
    4e1a:	8e e0       	ldi	r24, 0x0E	; 14
    4e1c:	97 e0       	ldi	r25, 0x07	; 7
    4e1e:	b9 01       	movw	r22, r18
    4e20:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    4e24:	e9 81       	ldd	r30, Y+1	; 0x01
    4e26:	fa 81       	ldd	r31, Y+2	; 0x02
    4e28:	81 a9       	ldd	r24, Z+49	; 0x31
    4e2a:	81 30       	cpi	r24, 0x01	; 1
    4e2c:	19 f4       	brne	.+6      	; 0x4e34 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    4e30:	fa 81       	ldd	r31, Y+2	; 0x02
    4e32:	11 aa       	std	Z+49, r1	; 0x31
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    4e34:	0f 90       	pop	r0
    4e36:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    4e38:	80 91 af 06 	lds	r24, 0x06AF
    4e3c:	88 23       	and	r24, r24
    4e3e:	39 f0       	breq	.+14     	; 0x4e4e <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    4e40:	0f b6       	in	r0, 0x3f	; 63
    4e42:	f8 94       	cli
    4e44:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    4e46:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    4e4a:	0f 90       	pop	r0
    4e4c:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    4e4e:	20 91 a8 06 	lds	r18, 0x06A8
    4e52:	30 91 a9 06 	lds	r19, 0x06A9
    4e56:	89 81       	ldd	r24, Y+1	; 0x01
    4e58:	9a 81       	ldd	r25, Y+2	; 0x02
    4e5a:	82 17       	cp	r24, r18
    4e5c:	93 07       	cpc	r25, r19
    4e5e:	a1 f4       	brne	.+40     	; 0x4e88 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    4e60:	80 91 af 06 	lds	r24, 0x06AF
    4e64:	88 23       	and	r24, r24
    4e66:	19 f0       	breq	.+6      	; 0x4e6e <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    4e68:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
    4e6c:	0d c0       	rjmp	.+26     	; 0x4e88 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    4e6e:	90 91 0e 07 	lds	r25, 0x070E
    4e72:	80 91 ab 06 	lds	r24, 0x06AB
    4e76:	98 17       	cp	r25, r24
    4e78:	29 f4       	brne	.+10     	; 0x4e84 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    4e7a:	10 92 a9 06 	sts	0x06A9, r1
    4e7e:	10 92 a8 06 	sts	0x06A8, r1
    4e82:	02 c0       	rjmp	.+4      	; 0x4e88 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    4e84:	0e 94 65 2a 	call	0x54ca	; 0x54ca <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4e88:	26 96       	adiw	r28, 0x06	; 6
    4e8a:	0f b6       	in	r0, 0x3f	; 63
    4e8c:	f8 94       	cli
    4e8e:	de bf       	out	0x3e, r29	; 62
    4e90:	0f be       	out	0x3f, r0	; 63
    4e92:	cd bf       	out	0x3d, r28	; 61
    4e94:	cf 91       	pop	r28
    4e96:	df 91       	pop	r29
    4e98:	08 95       	ret

00004e9a <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    4e9a:	df 93       	push	r29
    4e9c:	cf 93       	push	r28
    4e9e:	00 d0       	rcall	.+0      	; 0x4ea0 <prvTaskIsTaskSuspended+0x6>
    4ea0:	00 d0       	rcall	.+0      	; 0x4ea2 <prvTaskIsTaskSuspended+0x8>
    4ea2:	0f 92       	push	r0
    4ea4:	cd b7       	in	r28, 0x3d	; 61
    4ea6:	de b7       	in	r29, 0x3e	; 62
    4ea8:	9d 83       	std	Y+5, r25	; 0x05
    4eaa:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    4eac:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    4eae:	8c 81       	ldd	r24, Y+4	; 0x04
    4eb0:	9d 81       	ldd	r25, Y+5	; 0x05
    4eb2:	9a 83       	std	Y+2, r25	; 0x02
    4eb4:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    4eb6:	e9 81       	ldd	r30, Y+1	; 0x01
    4eb8:	fa 81       	ldd	r31, Y+2	; 0x02
    4eba:	82 85       	ldd	r24, Z+10	; 0x0a
    4ebc:	93 85       	ldd	r25, Z+11	; 0x0b
    4ebe:	27 e0       	ldi	r18, 0x07	; 7
    4ec0:	8e 30       	cpi	r24, 0x0E	; 14
    4ec2:	92 07       	cpc	r25, r18
    4ec4:	81 f4       	brne	.+32     	; 0x4ee6 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    4ec6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ec8:	fa 81       	ldd	r31, Y+2	; 0x02
    4eca:	84 89       	ldd	r24, Z+20	; 0x14
    4ecc:	95 89       	ldd	r25, Z+21	; 0x15
    4ece:	26 e0       	ldi	r18, 0x06	; 6
    4ed0:	8c 3f       	cpi	r24, 0xFC	; 252
    4ed2:	92 07       	cpc	r25, r18
    4ed4:	41 f0       	breq	.+16     	; 0x4ee6 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    4ed6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ed8:	fa 81       	ldd	r31, Y+2	; 0x02
    4eda:	84 89       	ldd	r24, Z+20	; 0x14
    4edc:	95 89       	ldd	r25, Z+21	; 0x15
    4ede:	00 97       	sbiw	r24, 0x00	; 0
    4ee0:	11 f4       	brne	.+4      	; 0x4ee6 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    4ee2:	81 e0       	ldi	r24, 0x01	; 1
    4ee4:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4ee6:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    4ee8:	0f 90       	pop	r0
    4eea:	0f 90       	pop	r0
    4eec:	0f 90       	pop	r0
    4eee:	0f 90       	pop	r0
    4ef0:	0f 90       	pop	r0
    4ef2:	cf 91       	pop	r28
    4ef4:	df 91       	pop	r29
    4ef6:	08 95       	ret

00004ef8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    4ef8:	df 93       	push	r29
    4efa:	cf 93       	push	r28
    4efc:	00 d0       	rcall	.+0      	; 0x4efe <vTaskResume+0x6>
    4efe:	00 d0       	rcall	.+0      	; 0x4f00 <vTaskResume+0x8>
    4f00:	cd b7       	in	r28, 0x3d	; 61
    4f02:	de b7       	in	r29, 0x3e	; 62
    4f04:	9c 83       	std	Y+4, r25	; 0x04
    4f06:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    4f08:	8b 81       	ldd	r24, Y+3	; 0x03
    4f0a:	9c 81       	ldd	r25, Y+4	; 0x04
    4f0c:	9a 83       	std	Y+2, r25	; 0x02
    4f0e:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    4f10:	20 91 a8 06 	lds	r18, 0x06A8
    4f14:	30 91 a9 06 	lds	r19, 0x06A9
    4f18:	89 81       	ldd	r24, Y+1	; 0x01
    4f1a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f1c:	82 17       	cp	r24, r18
    4f1e:	93 07       	cpc	r25, r19
    4f20:	09 f4       	brne	.+2      	; 0x4f24 <vTaskResume+0x2c>
    4f22:	47 c0       	rjmp	.+142    	; 0x4fb2 <vTaskResume+0xba>
    4f24:	89 81       	ldd	r24, Y+1	; 0x01
    4f26:	9a 81       	ldd	r25, Y+2	; 0x02
    4f28:	00 97       	sbiw	r24, 0x00	; 0
    4f2a:	09 f4       	brne	.+2      	; 0x4f2e <vTaskResume+0x36>
    4f2c:	42 c0       	rjmp	.+132    	; 0x4fb2 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    4f2e:	0f b6       	in	r0, 0x3f	; 63
    4f30:	f8 94       	cli
    4f32:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4f34:	89 81       	ldd	r24, Y+1	; 0x01
    4f36:	9a 81       	ldd	r25, Y+2	; 0x02
    4f38:	0e 94 4d 27 	call	0x4e9a	; 0x4e9a <prvTaskIsTaskSuspended>
    4f3c:	88 23       	and	r24, r24
    4f3e:	b9 f1       	breq	.+110    	; 0x4fae <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    4f40:	89 81       	ldd	r24, Y+1	; 0x01
    4f42:	9a 81       	ldd	r25, Y+2	; 0x02
    4f44:	02 96       	adiw	r24, 0x02	; 2
    4f46:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4f4a:	e9 81       	ldd	r30, Y+1	; 0x01
    4f4c:	fa 81       	ldd	r31, Y+2	; 0x02
    4f4e:	96 89       	ldd	r25, Z+22	; 0x16
    4f50:	80 91 ae 06 	lds	r24, 0x06AE
    4f54:	89 17       	cp	r24, r25
    4f56:	28 f4       	brcc	.+10     	; 0x4f62 <vTaskResume+0x6a>
    4f58:	e9 81       	ldd	r30, Y+1	; 0x01
    4f5a:	fa 81       	ldd	r31, Y+2	; 0x02
    4f5c:	86 89       	ldd	r24, Z+22	; 0x16
    4f5e:	80 93 ae 06 	sts	0x06AE, r24
    4f62:	e9 81       	ldd	r30, Y+1	; 0x01
    4f64:	fa 81       	ldd	r31, Y+2	; 0x02
    4f66:	86 89       	ldd	r24, Z+22	; 0x16
    4f68:	28 2f       	mov	r18, r24
    4f6a:	30 e0       	ldi	r19, 0x00	; 0
    4f6c:	c9 01       	movw	r24, r18
    4f6e:	88 0f       	add	r24, r24
    4f70:	99 1f       	adc	r25, r25
    4f72:	88 0f       	add	r24, r24
    4f74:	99 1f       	adc	r25, r25
    4f76:	88 0f       	add	r24, r24
    4f78:	99 1f       	adc	r25, r25
    4f7a:	82 0f       	add	r24, r18
    4f7c:	93 1f       	adc	r25, r19
    4f7e:	ac 01       	movw	r20, r24
    4f80:	47 54       	subi	r20, 0x47	; 71
    4f82:	59 4f       	sbci	r21, 0xF9	; 249
    4f84:	89 81       	ldd	r24, Y+1	; 0x01
    4f86:	9a 81       	ldd	r25, Y+2	; 0x02
    4f88:	9c 01       	movw	r18, r24
    4f8a:	2e 5f       	subi	r18, 0xFE	; 254
    4f8c:	3f 4f       	sbci	r19, 0xFF	; 255
    4f8e:	ca 01       	movw	r24, r20
    4f90:	b9 01       	movw	r22, r18
    4f92:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4f96:	e9 81       	ldd	r30, Y+1	; 0x01
    4f98:	fa 81       	ldd	r31, Y+2	; 0x02
    4f9a:	96 89       	ldd	r25, Z+22	; 0x16
    4f9c:	e0 91 a8 06 	lds	r30, 0x06A8
    4fa0:	f0 91 a9 06 	lds	r31, 0x06A9
    4fa4:	86 89       	ldd	r24, Z+22	; 0x16
    4fa6:	98 17       	cp	r25, r24
    4fa8:	10 f0       	brcs	.+4      	; 0x4fae <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    4faa:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    4fae:	0f 90       	pop	r0
    4fb0:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4fb2:	0f 90       	pop	r0
    4fb4:	0f 90       	pop	r0
    4fb6:	0f 90       	pop	r0
    4fb8:	0f 90       	pop	r0
    4fba:	cf 91       	pop	r28
    4fbc:	df 91       	pop	r29
    4fbe:	08 95       	ret

00004fc0 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    4fc0:	df 93       	push	r29
    4fc2:	cf 93       	push	r28
    4fc4:	00 d0       	rcall	.+0      	; 0x4fc6 <xTaskResumeFromISR+0x6>
    4fc6:	00 d0       	rcall	.+0      	; 0x4fc8 <xTaskResumeFromISR+0x8>
    4fc8:	00 d0       	rcall	.+0      	; 0x4fca <xTaskResumeFromISR+0xa>
    4fca:	cd b7       	in	r28, 0x3d	; 61
    4fcc:	de b7       	in	r29, 0x3e	; 62
    4fce:	9e 83       	std	Y+6, r25	; 0x06
    4fd0:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    4fd2:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    4fd4:	8d 81       	ldd	r24, Y+5	; 0x05
    4fd6:	9e 81       	ldd	r25, Y+6	; 0x06
    4fd8:	9b 83       	std	Y+3, r25	; 0x03
    4fda:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4fdc:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4fde:	8a 81       	ldd	r24, Y+2	; 0x02
    4fe0:	9b 81       	ldd	r25, Y+3	; 0x03
    4fe2:	0e 94 4d 27 	call	0x4e9a	; 0x4e9a <prvTaskIsTaskSuspended>
    4fe6:	88 23       	and	r24, r24
    4fe8:	09 f4       	brne	.+2      	; 0x4fec <xTaskResumeFromISR+0x2c>
    4fea:	46 c0       	rjmp	.+140    	; 0x5078 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4fec:	80 91 b8 06 	lds	r24, 0x06B8
    4ff0:	88 23       	and	r24, r24
    4ff2:	c1 f5       	brne	.+112    	; 0x5064 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4ff4:	ea 81       	ldd	r30, Y+2	; 0x02
    4ff6:	fb 81       	ldd	r31, Y+3	; 0x03
    4ff8:	96 89       	ldd	r25, Z+22	; 0x16
    4ffa:	e0 91 a8 06 	lds	r30, 0x06A8
    4ffe:	f0 91 a9 06 	lds	r31, 0x06A9
    5002:	86 89       	ldd	r24, Z+22	; 0x16
    5004:	98 17       	cp	r25, r24
    5006:	10 f0       	brcs	.+4      	; 0x500c <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    5008:	81 e0       	ldi	r24, 0x01	; 1
    500a:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    500c:	8a 81       	ldd	r24, Y+2	; 0x02
    500e:	9b 81       	ldd	r25, Y+3	; 0x03
    5010:	02 96       	adiw	r24, 0x02	; 2
    5012:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5016:	ea 81       	ldd	r30, Y+2	; 0x02
    5018:	fb 81       	ldd	r31, Y+3	; 0x03
    501a:	96 89       	ldd	r25, Z+22	; 0x16
    501c:	80 91 ae 06 	lds	r24, 0x06AE
    5020:	89 17       	cp	r24, r25
    5022:	28 f4       	brcc	.+10     	; 0x502e <xTaskResumeFromISR+0x6e>
    5024:	ea 81       	ldd	r30, Y+2	; 0x02
    5026:	fb 81       	ldd	r31, Y+3	; 0x03
    5028:	86 89       	ldd	r24, Z+22	; 0x16
    502a:	80 93 ae 06 	sts	0x06AE, r24
    502e:	ea 81       	ldd	r30, Y+2	; 0x02
    5030:	fb 81       	ldd	r31, Y+3	; 0x03
    5032:	86 89       	ldd	r24, Z+22	; 0x16
    5034:	28 2f       	mov	r18, r24
    5036:	30 e0       	ldi	r19, 0x00	; 0
    5038:	c9 01       	movw	r24, r18
    503a:	88 0f       	add	r24, r24
    503c:	99 1f       	adc	r25, r25
    503e:	88 0f       	add	r24, r24
    5040:	99 1f       	adc	r25, r25
    5042:	88 0f       	add	r24, r24
    5044:	99 1f       	adc	r25, r25
    5046:	82 0f       	add	r24, r18
    5048:	93 1f       	adc	r25, r19
    504a:	ac 01       	movw	r20, r24
    504c:	47 54       	subi	r20, 0x47	; 71
    504e:	59 4f       	sbci	r21, 0xF9	; 249
    5050:	8a 81       	ldd	r24, Y+2	; 0x02
    5052:	9b 81       	ldd	r25, Y+3	; 0x03
    5054:	9c 01       	movw	r18, r24
    5056:	2e 5f       	subi	r18, 0xFE	; 254
    5058:	3f 4f       	sbci	r19, 0xFF	; 255
    505a:	ca 01       	movw	r24, r20
    505c:	b9 01       	movw	r22, r18
    505e:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>
    5062:	0a c0       	rjmp	.+20     	; 0x5078 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5064:	8a 81       	ldd	r24, Y+2	; 0x02
    5066:	9b 81       	ldd	r25, Y+3	; 0x03
    5068:	9c 01       	movw	r18, r24
    506a:	24 5f       	subi	r18, 0xF4	; 244
    506c:	3f 4f       	sbci	r19, 0xFF	; 255
    506e:	8c ef       	ldi	r24, 0xFC	; 252
    5070:	96 e0       	ldi	r25, 0x06	; 6
    5072:	b9 01       	movw	r22, r18
    5074:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    5078:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    507a:	26 96       	adiw	r28, 0x06	; 6
    507c:	0f b6       	in	r0, 0x3f	; 63
    507e:	f8 94       	cli
    5080:	de bf       	out	0x3e, r29	; 62
    5082:	0f be       	out	0x3f, r0	; 63
    5084:	cd bf       	out	0x3d, r28	; 61
    5086:	cf 91       	pop	r28
    5088:	df 91       	pop	r29
    508a:	08 95       	ret

0000508c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    508c:	ef 92       	push	r14
    508e:	ff 92       	push	r15
    5090:	0f 93       	push	r16
    5092:	df 93       	push	r29
    5094:	cf 93       	push	r28
    5096:	0f 92       	push	r0
    5098:	cd b7       	in	r28, 0x3d	; 61
    509a:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    509c:	8a e9       	ldi	r24, 0x9A	; 154
    509e:	9c e2       	ldi	r25, 0x2C	; 44
    50a0:	27 ea       	ldi	r18, 0xA7	; 167
    50a2:	30 e0       	ldi	r19, 0x00	; 0
    50a4:	e6 eb       	ldi	r30, 0xB6	; 182
    50a6:	f6 e0       	ldi	r31, 0x06	; 6
    50a8:	b9 01       	movw	r22, r18
    50aa:	46 e9       	ldi	r20, 0x96	; 150
    50ac:	50 e0       	ldi	r21, 0x00	; 0
    50ae:	20 e0       	ldi	r18, 0x00	; 0
    50b0:	30 e0       	ldi	r19, 0x00	; 0
    50b2:	00 e0       	ldi	r16, 0x00	; 0
    50b4:	7f 01       	movw	r14, r30
    50b6:	0e 94 99 24 	call	0x4932	; 0x4932 <xTaskCreate>
    50ba:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    50bc:	89 81       	ldd	r24, Y+1	; 0x01
    50be:	81 30       	cpi	r24, 0x01	; 1
    50c0:	81 f4       	brne	.+32     	; 0x50e2 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    50c2:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    50c4:	8f ef       	ldi	r24, 0xFF	; 255
    50c6:	9f ef       	ldi	r25, 0xFF	; 255
    50c8:	90 93 b5 06 	sts	0x06B5, r25
    50cc:	80 93 b4 06 	sts	0x06B4, r24
		xSchedulerRunning = pdTRUE;
    50d0:	81 e0       	ldi	r24, 0x01	; 1
    50d2:	80 93 af 06 	sts	0x06AF, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    50d6:	10 92 ad 06 	sts	0x06AD, r1
    50da:	10 92 ac 06 	sts	0x06AC, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    50de:	0e 94 92 14 	call	0x2924	; 0x2924 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    50e2:	0f 90       	pop	r0
    50e4:	cf 91       	pop	r28
    50e6:	df 91       	pop	r29
    50e8:	0f 91       	pop	r16
    50ea:	ff 90       	pop	r15
    50ec:	ef 90       	pop	r14
    50ee:	08 95       	ret

000050f0 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    50f0:	df 93       	push	r29
    50f2:	cf 93       	push	r28
    50f4:	cd b7       	in	r28, 0x3d	; 61
    50f6:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    50f8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    50fa:	10 92 af 06 	sts	0x06AF, r1
	vPortEndScheduler();
    50fe:	0e 94 c7 14 	call	0x298e	; 0x298e <vPortEndScheduler>
}
    5102:	cf 91       	pop	r28
    5104:	df 91       	pop	r29
    5106:	08 95       	ret

00005108 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    5108:	df 93       	push	r29
    510a:	cf 93       	push	r28
    510c:	cd b7       	in	r28, 0x3d	; 61
    510e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    5110:	80 91 b8 06 	lds	r24, 0x06B8
    5114:	8f 5f       	subi	r24, 0xFF	; 255
    5116:	80 93 b8 06 	sts	0x06B8, r24
}
    511a:	cf 91       	pop	r28
    511c:	df 91       	pop	r29
    511e:	08 95       	ret

00005120 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    5120:	df 93       	push	r29
    5122:	cf 93       	push	r28
    5124:	00 d0       	rcall	.+0      	; 0x5126 <xTaskResumeAll+0x6>
    5126:	00 d0       	rcall	.+0      	; 0x5128 <xTaskResumeAll+0x8>
    5128:	cd b7       	in	r28, 0x3d	; 61
    512a:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    512c:	1c 82       	std	Y+4, r1	; 0x04
    512e:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    5130:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    5132:	0f b6       	in	r0, 0x3f	; 63
    5134:	f8 94       	cli
    5136:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    5138:	80 91 b8 06 	lds	r24, 0x06B8
    513c:	81 50       	subi	r24, 0x01	; 1
    513e:	80 93 b8 06 	sts	0x06B8, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5142:	80 91 b8 06 	lds	r24, 0x06B8
    5146:	88 23       	and	r24, r24
    5148:	09 f0       	breq	.+2      	; 0x514c <xTaskResumeAll+0x2c>
    514a:	73 c0       	rjmp	.+230    	; 0x5232 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    514c:	80 91 ab 06 	lds	r24, 0x06AB
    5150:	88 23       	and	r24, r24
    5152:	09 f4       	brne	.+2      	; 0x5156 <xTaskResumeAll+0x36>
    5154:	6e c0       	rjmp	.+220    	; 0x5232 <xTaskResumeAll+0x112>
    5156:	45 c0       	rjmp	.+138    	; 0x51e2 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5158:	e0 91 01 07 	lds	r30, 0x0701
    515c:	f0 91 02 07 	lds	r31, 0x0702
    5160:	86 81       	ldd	r24, Z+6	; 0x06
    5162:	97 81       	ldd	r25, Z+7	; 0x07
    5164:	9c 83       	std	Y+4, r25	; 0x04
    5166:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5168:	8b 81       	ldd	r24, Y+3	; 0x03
    516a:	9c 81       	ldd	r25, Y+4	; 0x04
    516c:	0c 96       	adiw	r24, 0x0c	; 12
    516e:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5172:	8b 81       	ldd	r24, Y+3	; 0x03
    5174:	9c 81       	ldd	r25, Y+4	; 0x04
    5176:	02 96       	adiw	r24, 0x02	; 2
    5178:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    517c:	eb 81       	ldd	r30, Y+3	; 0x03
    517e:	fc 81       	ldd	r31, Y+4	; 0x04
    5180:	96 89       	ldd	r25, Z+22	; 0x16
    5182:	80 91 ae 06 	lds	r24, 0x06AE
    5186:	89 17       	cp	r24, r25
    5188:	28 f4       	brcc	.+10     	; 0x5194 <xTaskResumeAll+0x74>
    518a:	eb 81       	ldd	r30, Y+3	; 0x03
    518c:	fc 81       	ldd	r31, Y+4	; 0x04
    518e:	86 89       	ldd	r24, Z+22	; 0x16
    5190:	80 93 ae 06 	sts	0x06AE, r24
    5194:	eb 81       	ldd	r30, Y+3	; 0x03
    5196:	fc 81       	ldd	r31, Y+4	; 0x04
    5198:	86 89       	ldd	r24, Z+22	; 0x16
    519a:	28 2f       	mov	r18, r24
    519c:	30 e0       	ldi	r19, 0x00	; 0
    519e:	c9 01       	movw	r24, r18
    51a0:	88 0f       	add	r24, r24
    51a2:	99 1f       	adc	r25, r25
    51a4:	88 0f       	add	r24, r24
    51a6:	99 1f       	adc	r25, r25
    51a8:	88 0f       	add	r24, r24
    51aa:	99 1f       	adc	r25, r25
    51ac:	82 0f       	add	r24, r18
    51ae:	93 1f       	adc	r25, r19
    51b0:	ac 01       	movw	r20, r24
    51b2:	47 54       	subi	r20, 0x47	; 71
    51b4:	59 4f       	sbci	r21, 0xF9	; 249
    51b6:	8b 81       	ldd	r24, Y+3	; 0x03
    51b8:	9c 81       	ldd	r25, Y+4	; 0x04
    51ba:	9c 01       	movw	r18, r24
    51bc:	2e 5f       	subi	r18, 0xFE	; 254
    51be:	3f 4f       	sbci	r19, 0xFF	; 255
    51c0:	ca 01       	movw	r24, r20
    51c2:	b9 01       	movw	r22, r18
    51c4:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    51c8:	eb 81       	ldd	r30, Y+3	; 0x03
    51ca:	fc 81       	ldd	r31, Y+4	; 0x04
    51cc:	96 89       	ldd	r25, Z+22	; 0x16
    51ce:	e0 91 a8 06 	lds	r30, 0x06A8
    51d2:	f0 91 a9 06 	lds	r31, 0x06A9
    51d6:	86 89       	ldd	r24, Z+22	; 0x16
    51d8:	98 17       	cp	r25, r24
    51da:	18 f0       	brcs	.+6      	; 0x51e2 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    51dc:	81 e0       	ldi	r24, 0x01	; 1
    51de:	80 93 b1 06 	sts	0x06B1, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    51e2:	80 91 fc 06 	lds	r24, 0x06FC
    51e6:	88 23       	and	r24, r24
    51e8:	09 f0       	breq	.+2      	; 0x51ec <xTaskResumeAll+0xcc>
    51ea:	b6 cf       	rjmp	.-148    	; 0x5158 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    51ec:	8b 81       	ldd	r24, Y+3	; 0x03
    51ee:	9c 81       	ldd	r25, Y+4	; 0x04
    51f0:	00 97       	sbiw	r24, 0x00	; 0
    51f2:	11 f0       	breq	.+4      	; 0x51f8 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    51f4:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    51f8:	80 91 b0 06 	lds	r24, 0x06B0
    51fc:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    51fe:	89 81       	ldd	r24, Y+1	; 0x01
    5200:	88 23       	and	r24, r24
    5202:	79 f0       	breq	.+30     	; 0x5222 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    5204:	0e 94 80 29 	call	0x5300	; 0x5300 <xTaskIncrementTick>
    5208:	88 23       	and	r24, r24
    520a:	19 f0       	breq	.+6      	; 0x5212 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    520c:	81 e0       	ldi	r24, 0x01	; 1
    520e:	80 93 b1 06 	sts	0x06B1, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    5212:	89 81       	ldd	r24, Y+1	; 0x01
    5214:	81 50       	subi	r24, 0x01	; 1
    5216:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    5218:	89 81       	ldd	r24, Y+1	; 0x01
    521a:	88 23       	and	r24, r24
    521c:	99 f7       	brne	.-26     	; 0x5204 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    521e:	10 92 b0 06 	sts	0x06B0, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    5222:	80 91 b1 06 	lds	r24, 0x06B1
    5226:	88 23       	and	r24, r24
    5228:	21 f0       	breq	.+8      	; 0x5232 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    522a:	81 e0       	ldi	r24, 0x01	; 1
    522c:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    522e:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    5232:	0f 90       	pop	r0
    5234:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    5236:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5238:	0f 90       	pop	r0
    523a:	0f 90       	pop	r0
    523c:	0f 90       	pop	r0
    523e:	0f 90       	pop	r0
    5240:	cf 91       	pop	r28
    5242:	df 91       	pop	r29
    5244:	08 95       	ret

00005246 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    5246:	df 93       	push	r29
    5248:	cf 93       	push	r28
    524a:	00 d0       	rcall	.+0      	; 0x524c <xTaskGetTickCount+0x6>
    524c:	cd b7       	in	r28, 0x3d	; 61
    524e:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    5250:	0f b6       	in	r0, 0x3f	; 63
    5252:	f8 94       	cli
    5254:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    5256:	80 91 ac 06 	lds	r24, 0x06AC
    525a:	90 91 ad 06 	lds	r25, 0x06AD
    525e:	9a 83       	std	Y+2, r25	; 0x02
    5260:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    5262:	0f 90       	pop	r0
    5264:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    5266:	89 81       	ldd	r24, Y+1	; 0x01
    5268:	9a 81       	ldd	r25, Y+2	; 0x02
}
    526a:	0f 90       	pop	r0
    526c:	0f 90       	pop	r0
    526e:	cf 91       	pop	r28
    5270:	df 91       	pop	r29
    5272:	08 95       	ret

00005274 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    5274:	df 93       	push	r29
    5276:	cf 93       	push	r28
    5278:	00 d0       	rcall	.+0      	; 0x527a <xTaskGetTickCountFromISR+0x6>
    527a:	0f 92       	push	r0
    527c:	cd b7       	in	r28, 0x3d	; 61
    527e:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    5280:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    5282:	80 91 ac 06 	lds	r24, 0x06AC
    5286:	90 91 ad 06 	lds	r25, 0x06AD
    528a:	9b 83       	std	Y+3, r25	; 0x03
    528c:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    528e:	8a 81       	ldd	r24, Y+2	; 0x02
    5290:	9b 81       	ldd	r25, Y+3	; 0x03
}
    5292:	0f 90       	pop	r0
    5294:	0f 90       	pop	r0
    5296:	0f 90       	pop	r0
    5298:	cf 91       	pop	r28
    529a:	df 91       	pop	r29
    529c:	08 95       	ret

0000529e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    529e:	df 93       	push	r29
    52a0:	cf 93       	push	r28
    52a2:	cd b7       	in	r28, 0x3d	; 61
    52a4:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    52a6:	80 91 ab 06 	lds	r24, 0x06AB
}
    52aa:	cf 91       	pop	r28
    52ac:	df 91       	pop	r29
    52ae:	08 95       	ret

000052b0 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    52b0:	df 93       	push	r29
    52b2:	cf 93       	push	r28
    52b4:	00 d0       	rcall	.+0      	; 0x52b6 <pcTaskGetName+0x6>
    52b6:	00 d0       	rcall	.+0      	; 0x52b8 <pcTaskGetName+0x8>
    52b8:	00 d0       	rcall	.+0      	; 0x52ba <pcTaskGetName+0xa>
    52ba:	cd b7       	in	r28, 0x3d	; 61
    52bc:	de b7       	in	r29, 0x3e	; 62
    52be:	9c 83       	std	Y+4, r25	; 0x04
    52c0:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    52c2:	8b 81       	ldd	r24, Y+3	; 0x03
    52c4:	9c 81       	ldd	r25, Y+4	; 0x04
    52c6:	00 97       	sbiw	r24, 0x00	; 0
    52c8:	39 f4       	brne	.+14     	; 0x52d8 <pcTaskGetName+0x28>
    52ca:	80 91 a8 06 	lds	r24, 0x06A8
    52ce:	90 91 a9 06 	lds	r25, 0x06A9
    52d2:	9e 83       	std	Y+6, r25	; 0x06
    52d4:	8d 83       	std	Y+5, r24	; 0x05
    52d6:	04 c0       	rjmp	.+8      	; 0x52e0 <pcTaskGetName+0x30>
    52d8:	8b 81       	ldd	r24, Y+3	; 0x03
    52da:	9c 81       	ldd	r25, Y+4	; 0x04
    52dc:	9e 83       	std	Y+6, r25	; 0x06
    52de:	8d 83       	std	Y+5, r24	; 0x05
    52e0:	8d 81       	ldd	r24, Y+5	; 0x05
    52e2:	9e 81       	ldd	r25, Y+6	; 0x06
    52e4:	9a 83       	std	Y+2, r25	; 0x02
    52e6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    52e8:	89 81       	ldd	r24, Y+1	; 0x01
    52ea:	9a 81       	ldd	r25, Y+2	; 0x02
    52ec:	49 96       	adiw	r24, 0x19	; 25
}
    52ee:	26 96       	adiw	r28, 0x06	; 6
    52f0:	0f b6       	in	r0, 0x3f	; 63
    52f2:	f8 94       	cli
    52f4:	de bf       	out	0x3e, r29	; 62
    52f6:	0f be       	out	0x3f, r0	; 63
    52f8:	cd bf       	out	0x3d, r28	; 61
    52fa:	cf 91       	pop	r28
    52fc:	df 91       	pop	r29
    52fe:	08 95       	ret

00005300 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    5300:	df 93       	push	r29
    5302:	cf 93       	push	r28
    5304:	cd b7       	in	r28, 0x3d	; 61
    5306:	de b7       	in	r29, 0x3e	; 62
    5308:	29 97       	sbiw	r28, 0x09	; 9
    530a:	0f b6       	in	r0, 0x3f	; 63
    530c:	f8 94       	cli
    530e:	de bf       	out	0x3e, r29	; 62
    5310:	0f be       	out	0x3f, r0	; 63
    5312:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    5314:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5316:	80 91 b8 06 	lds	r24, 0x06B8
    531a:	88 23       	and	r24, r24
    531c:	09 f0       	breq	.+2      	; 0x5320 <xTaskIncrementTick+0x20>
    531e:	c0 c0       	rjmp	.+384    	; 0x54a0 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    5320:	80 91 ac 06 	lds	r24, 0x06AC
    5324:	90 91 ad 06 	lds	r25, 0x06AD
    5328:	01 96       	adiw	r24, 0x01	; 1
    532a:	9c 83       	std	Y+4, r25	; 0x04
    532c:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    532e:	8b 81       	ldd	r24, Y+3	; 0x03
    5330:	9c 81       	ldd	r25, Y+4	; 0x04
    5332:	90 93 ad 06 	sts	0x06AD, r25
    5336:	80 93 ac 06 	sts	0x06AC, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    533a:	8b 81       	ldd	r24, Y+3	; 0x03
    533c:	9c 81       	ldd	r25, Y+4	; 0x04
    533e:	00 97       	sbiw	r24, 0x00	; 0
    5340:	d9 f4       	brne	.+54     	; 0x5378 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    5342:	80 91 f8 06 	lds	r24, 0x06F8
    5346:	90 91 f9 06 	lds	r25, 0x06F9
    534a:	9a 83       	std	Y+2, r25	; 0x02
    534c:	89 83       	std	Y+1, r24	; 0x01
    534e:	80 91 fa 06 	lds	r24, 0x06FA
    5352:	90 91 fb 06 	lds	r25, 0x06FB
    5356:	90 93 f9 06 	sts	0x06F9, r25
    535a:	80 93 f8 06 	sts	0x06F8, r24
    535e:	89 81       	ldd	r24, Y+1	; 0x01
    5360:	9a 81       	ldd	r25, Y+2	; 0x02
    5362:	90 93 fb 06 	sts	0x06FB, r25
    5366:	80 93 fa 06 	sts	0x06FA, r24
    536a:	80 91 b2 06 	lds	r24, 0x06B2
    536e:	8f 5f       	subi	r24, 0xFF	; 255
    5370:	80 93 b2 06 	sts	0x06B2, r24
    5374:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    5378:	20 91 b4 06 	lds	r18, 0x06B4
    537c:	30 91 b5 06 	lds	r19, 0x06B5
    5380:	8b 81       	ldd	r24, Y+3	; 0x03
    5382:	9c 81       	ldd	r25, Y+4	; 0x04
    5384:	82 17       	cp	r24, r18
    5386:	93 07       	cpc	r25, r19
    5388:	08 f4       	brcc	.+2      	; 0x538c <xTaskIncrementTick+0x8c>
    538a:	71 c0       	rjmp	.+226    	; 0x546e <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    538c:	e0 91 f8 06 	lds	r30, 0x06F8
    5390:	f0 91 f9 06 	lds	r31, 0x06F9
    5394:	80 81       	ld	r24, Z
    5396:	88 23       	and	r24, r24
    5398:	39 f4       	brne	.+14     	; 0x53a8 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    539a:	8f ef       	ldi	r24, 0xFF	; 255
    539c:	9f ef       	ldi	r25, 0xFF	; 255
    539e:	90 93 b5 06 	sts	0x06B5, r25
    53a2:	80 93 b4 06 	sts	0x06B4, r24
    53a6:	63 c0       	rjmp	.+198    	; 0x546e <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    53a8:	e0 91 f8 06 	lds	r30, 0x06F8
    53ac:	f0 91 f9 06 	lds	r31, 0x06F9
    53b0:	05 80       	ldd	r0, Z+5	; 0x05
    53b2:	f6 81       	ldd	r31, Z+6	; 0x06
    53b4:	e0 2d       	mov	r30, r0
    53b6:	86 81       	ldd	r24, Z+6	; 0x06
    53b8:	97 81       	ldd	r25, Z+7	; 0x07
    53ba:	99 87       	std	Y+9, r25	; 0x09
    53bc:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    53be:	e8 85       	ldd	r30, Y+8	; 0x08
    53c0:	f9 85       	ldd	r31, Y+9	; 0x09
    53c2:	82 81       	ldd	r24, Z+2	; 0x02
    53c4:	93 81       	ldd	r25, Z+3	; 0x03
    53c6:	9f 83       	std	Y+7, r25	; 0x07
    53c8:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    53ca:	2b 81       	ldd	r18, Y+3	; 0x03
    53cc:	3c 81       	ldd	r19, Y+4	; 0x04
    53ce:	8e 81       	ldd	r24, Y+6	; 0x06
    53d0:	9f 81       	ldd	r25, Y+7	; 0x07
    53d2:	28 17       	cp	r18, r24
    53d4:	39 07       	cpc	r19, r25
    53d6:	38 f4       	brcc	.+14     	; 0x53e6 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    53d8:	8e 81       	ldd	r24, Y+6	; 0x06
    53da:	9f 81       	ldd	r25, Y+7	; 0x07
    53dc:	90 93 b5 06 	sts	0x06B5, r25
    53e0:	80 93 b4 06 	sts	0x06B4, r24
    53e4:	44 c0       	rjmp	.+136    	; 0x546e <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    53e6:	88 85       	ldd	r24, Y+8	; 0x08
    53e8:	99 85       	ldd	r25, Y+9	; 0x09
    53ea:	02 96       	adiw	r24, 0x02	; 2
    53ec:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    53f0:	e8 85       	ldd	r30, Y+8	; 0x08
    53f2:	f9 85       	ldd	r31, Y+9	; 0x09
    53f4:	84 89       	ldd	r24, Z+20	; 0x14
    53f6:	95 89       	ldd	r25, Z+21	; 0x15
    53f8:	00 97       	sbiw	r24, 0x00	; 0
    53fa:	29 f0       	breq	.+10     	; 0x5406 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    53fc:	88 85       	ldd	r24, Y+8	; 0x08
    53fe:	99 85       	ldd	r25, Y+9	; 0x09
    5400:	0c 96       	adiw	r24, 0x0c	; 12
    5402:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    5406:	e8 85       	ldd	r30, Y+8	; 0x08
    5408:	f9 85       	ldd	r31, Y+9	; 0x09
    540a:	96 89       	ldd	r25, Z+22	; 0x16
    540c:	80 91 ae 06 	lds	r24, 0x06AE
    5410:	89 17       	cp	r24, r25
    5412:	28 f4       	brcc	.+10     	; 0x541e <xTaskIncrementTick+0x11e>
    5414:	e8 85       	ldd	r30, Y+8	; 0x08
    5416:	f9 85       	ldd	r31, Y+9	; 0x09
    5418:	86 89       	ldd	r24, Z+22	; 0x16
    541a:	80 93 ae 06 	sts	0x06AE, r24
    541e:	e8 85       	ldd	r30, Y+8	; 0x08
    5420:	f9 85       	ldd	r31, Y+9	; 0x09
    5422:	86 89       	ldd	r24, Z+22	; 0x16
    5424:	28 2f       	mov	r18, r24
    5426:	30 e0       	ldi	r19, 0x00	; 0
    5428:	c9 01       	movw	r24, r18
    542a:	88 0f       	add	r24, r24
    542c:	99 1f       	adc	r25, r25
    542e:	88 0f       	add	r24, r24
    5430:	99 1f       	adc	r25, r25
    5432:	88 0f       	add	r24, r24
    5434:	99 1f       	adc	r25, r25
    5436:	82 0f       	add	r24, r18
    5438:	93 1f       	adc	r25, r19
    543a:	ac 01       	movw	r20, r24
    543c:	47 54       	subi	r20, 0x47	; 71
    543e:	59 4f       	sbci	r21, 0xF9	; 249
    5440:	88 85       	ldd	r24, Y+8	; 0x08
    5442:	99 85       	ldd	r25, Y+9	; 0x09
    5444:	9c 01       	movw	r18, r24
    5446:	2e 5f       	subi	r18, 0xFE	; 254
    5448:	3f 4f       	sbci	r19, 0xFF	; 255
    544a:	ca 01       	movw	r24, r20
    544c:	b9 01       	movw	r22, r18
    544e:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5452:	e8 85       	ldd	r30, Y+8	; 0x08
    5454:	f9 85       	ldd	r31, Y+9	; 0x09
    5456:	96 89       	ldd	r25, Z+22	; 0x16
    5458:	e0 91 a8 06 	lds	r30, 0x06A8
    545c:	f0 91 a9 06 	lds	r31, 0x06A9
    5460:	86 89       	ldd	r24, Z+22	; 0x16
    5462:	98 17       	cp	r25, r24
    5464:	08 f4       	brcc	.+2      	; 0x5468 <xTaskIncrementTick+0x168>
    5466:	92 cf       	rjmp	.-220    	; 0x538c <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    5468:	81 e0       	ldi	r24, 0x01	; 1
    546a:	8d 83       	std	Y+5, r24	; 0x05
    546c:	8f cf       	rjmp	.-226    	; 0x538c <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    546e:	e0 91 a8 06 	lds	r30, 0x06A8
    5472:	f0 91 a9 06 	lds	r31, 0x06A9
    5476:	86 89       	ldd	r24, Z+22	; 0x16
    5478:	28 2f       	mov	r18, r24
    547a:	30 e0       	ldi	r19, 0x00	; 0
    547c:	c9 01       	movw	r24, r18
    547e:	88 0f       	add	r24, r24
    5480:	99 1f       	adc	r25, r25
    5482:	88 0f       	add	r24, r24
    5484:	99 1f       	adc	r25, r25
    5486:	88 0f       	add	r24, r24
    5488:	99 1f       	adc	r25, r25
    548a:	82 0f       	add	r24, r18
    548c:	93 1f       	adc	r25, r19
    548e:	fc 01       	movw	r30, r24
    5490:	e7 54       	subi	r30, 0x47	; 71
    5492:	f9 4f       	sbci	r31, 0xF9	; 249
    5494:	80 81       	ld	r24, Z
    5496:	82 30       	cpi	r24, 0x02	; 2
    5498:	40 f0       	brcs	.+16     	; 0x54aa <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    549a:	81 e0       	ldi	r24, 0x01	; 1
    549c:	8d 83       	std	Y+5, r24	; 0x05
    549e:	05 c0       	rjmp	.+10     	; 0x54aa <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    54a0:	80 91 b0 06 	lds	r24, 0x06B0
    54a4:	8f 5f       	subi	r24, 0xFF	; 255
    54a6:	80 93 b0 06 	sts	0x06B0, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    54aa:	80 91 b1 06 	lds	r24, 0x06B1
    54ae:	88 23       	and	r24, r24
    54b0:	11 f0       	breq	.+4      	; 0x54b6 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    54b2:	81 e0       	ldi	r24, 0x01	; 1
    54b4:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    54b6:	8d 81       	ldd	r24, Y+5	; 0x05
}
    54b8:	29 96       	adiw	r28, 0x09	; 9
    54ba:	0f b6       	in	r0, 0x3f	; 63
    54bc:	f8 94       	cli
    54be:	de bf       	out	0x3e, r29	; 62
    54c0:	0f be       	out	0x3f, r0	; 63
    54c2:	cd bf       	out	0x3d, r28	; 61
    54c4:	cf 91       	pop	r28
    54c6:	df 91       	pop	r29
    54c8:	08 95       	ret

000054ca <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    54ca:	df 93       	push	r29
    54cc:	cf 93       	push	r28
    54ce:	00 d0       	rcall	.+0      	; 0x54d0 <vTaskSwitchContext+0x6>
    54d0:	0f 92       	push	r0
    54d2:	cd b7       	in	r28, 0x3d	; 61
    54d4:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    54d6:	80 91 b8 06 	lds	r24, 0x06B8
    54da:	88 23       	and	r24, r24
    54dc:	21 f0       	breq	.+8      	; 0x54e6 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    54de:	81 e0       	ldi	r24, 0x01	; 1
    54e0:	80 93 b1 06 	sts	0x06B1, r24
    54e4:	59 c0       	rjmp	.+178    	; 0x5598 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    54e6:	10 92 b1 06 	sts	0x06B1, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    54ea:	80 91 ae 06 	lds	r24, 0x06AE
    54ee:	8b 83       	std	Y+3, r24	; 0x03
    54f0:	03 c0       	rjmp	.+6      	; 0x54f8 <vTaskSwitchContext+0x2e>
    54f2:	8b 81       	ldd	r24, Y+3	; 0x03
    54f4:	81 50       	subi	r24, 0x01	; 1
    54f6:	8b 83       	std	Y+3, r24	; 0x03
    54f8:	8b 81       	ldd	r24, Y+3	; 0x03
    54fa:	28 2f       	mov	r18, r24
    54fc:	30 e0       	ldi	r19, 0x00	; 0
    54fe:	c9 01       	movw	r24, r18
    5500:	88 0f       	add	r24, r24
    5502:	99 1f       	adc	r25, r25
    5504:	88 0f       	add	r24, r24
    5506:	99 1f       	adc	r25, r25
    5508:	88 0f       	add	r24, r24
    550a:	99 1f       	adc	r25, r25
    550c:	82 0f       	add	r24, r18
    550e:	93 1f       	adc	r25, r19
    5510:	fc 01       	movw	r30, r24
    5512:	e7 54       	subi	r30, 0x47	; 71
    5514:	f9 4f       	sbci	r31, 0xF9	; 249
    5516:	80 81       	ld	r24, Z
    5518:	88 23       	and	r24, r24
    551a:	59 f3       	breq	.-42     	; 0x54f2 <vTaskSwitchContext+0x28>
    551c:	8b 81       	ldd	r24, Y+3	; 0x03
    551e:	28 2f       	mov	r18, r24
    5520:	30 e0       	ldi	r19, 0x00	; 0
    5522:	c9 01       	movw	r24, r18
    5524:	88 0f       	add	r24, r24
    5526:	99 1f       	adc	r25, r25
    5528:	88 0f       	add	r24, r24
    552a:	99 1f       	adc	r25, r25
    552c:	88 0f       	add	r24, r24
    552e:	99 1f       	adc	r25, r25
    5530:	82 0f       	add	r24, r18
    5532:	93 1f       	adc	r25, r19
    5534:	87 54       	subi	r24, 0x47	; 71
    5536:	99 4f       	sbci	r25, 0xF9	; 249
    5538:	9a 83       	std	Y+2, r25	; 0x02
    553a:	89 83       	std	Y+1, r24	; 0x01
    553c:	e9 81       	ldd	r30, Y+1	; 0x01
    553e:	fa 81       	ldd	r31, Y+2	; 0x02
    5540:	01 80       	ldd	r0, Z+1	; 0x01
    5542:	f2 81       	ldd	r31, Z+2	; 0x02
    5544:	e0 2d       	mov	r30, r0
    5546:	82 81       	ldd	r24, Z+2	; 0x02
    5548:	93 81       	ldd	r25, Z+3	; 0x03
    554a:	e9 81       	ldd	r30, Y+1	; 0x01
    554c:	fa 81       	ldd	r31, Y+2	; 0x02
    554e:	92 83       	std	Z+2, r25	; 0x02
    5550:	81 83       	std	Z+1, r24	; 0x01
    5552:	e9 81       	ldd	r30, Y+1	; 0x01
    5554:	fa 81       	ldd	r31, Y+2	; 0x02
    5556:	21 81       	ldd	r18, Z+1	; 0x01
    5558:	32 81       	ldd	r19, Z+2	; 0x02
    555a:	89 81       	ldd	r24, Y+1	; 0x01
    555c:	9a 81       	ldd	r25, Y+2	; 0x02
    555e:	03 96       	adiw	r24, 0x03	; 3
    5560:	28 17       	cp	r18, r24
    5562:	39 07       	cpc	r19, r25
    5564:	59 f4       	brne	.+22     	; 0x557c <vTaskSwitchContext+0xb2>
    5566:	e9 81       	ldd	r30, Y+1	; 0x01
    5568:	fa 81       	ldd	r31, Y+2	; 0x02
    556a:	01 80       	ldd	r0, Z+1	; 0x01
    556c:	f2 81       	ldd	r31, Z+2	; 0x02
    556e:	e0 2d       	mov	r30, r0
    5570:	82 81       	ldd	r24, Z+2	; 0x02
    5572:	93 81       	ldd	r25, Z+3	; 0x03
    5574:	e9 81       	ldd	r30, Y+1	; 0x01
    5576:	fa 81       	ldd	r31, Y+2	; 0x02
    5578:	92 83       	std	Z+2, r25	; 0x02
    557a:	81 83       	std	Z+1, r24	; 0x01
    557c:	e9 81       	ldd	r30, Y+1	; 0x01
    557e:	fa 81       	ldd	r31, Y+2	; 0x02
    5580:	01 80       	ldd	r0, Z+1	; 0x01
    5582:	f2 81       	ldd	r31, Z+2	; 0x02
    5584:	e0 2d       	mov	r30, r0
    5586:	86 81       	ldd	r24, Z+6	; 0x06
    5588:	97 81       	ldd	r25, Z+7	; 0x07
    558a:	90 93 a9 06 	sts	0x06A9, r25
    558e:	80 93 a8 06 	sts	0x06A8, r24
    5592:	8b 81       	ldd	r24, Y+3	; 0x03
    5594:	80 93 ae 06 	sts	0x06AE, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    5598:	0f 90       	pop	r0
    559a:	0f 90       	pop	r0
    559c:	0f 90       	pop	r0
    559e:	cf 91       	pop	r28
    55a0:	df 91       	pop	r29
    55a2:	08 95       	ret

000055a4 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    55a4:	df 93       	push	r29
    55a6:	cf 93       	push	r28
    55a8:	00 d0       	rcall	.+0      	; 0x55aa <vTaskPlaceOnEventList+0x6>
    55aa:	00 d0       	rcall	.+0      	; 0x55ac <vTaskPlaceOnEventList+0x8>
    55ac:	cd b7       	in	r28, 0x3d	; 61
    55ae:	de b7       	in	r29, 0x3e	; 62
    55b0:	9a 83       	std	Y+2, r25	; 0x02
    55b2:	89 83       	std	Y+1, r24	; 0x01
    55b4:	7c 83       	std	Y+4, r23	; 0x04
    55b6:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    55b8:	80 91 a8 06 	lds	r24, 0x06A8
    55bc:	90 91 a9 06 	lds	r25, 0x06A9
    55c0:	9c 01       	movw	r18, r24
    55c2:	24 5f       	subi	r18, 0xF4	; 244
    55c4:	3f 4f       	sbci	r19, 0xFF	; 255
    55c6:	89 81       	ldd	r24, Y+1	; 0x01
    55c8:	9a 81       	ldd	r25, Y+2	; 0x02
    55ca:	b9 01       	movw	r22, r18
    55cc:	0e 94 3a 12 	call	0x2474	; 0x2474 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    55d0:	8b 81       	ldd	r24, Y+3	; 0x03
    55d2:	9c 81       	ldd	r25, Y+4	; 0x04
    55d4:	61 e0       	ldi	r22, 0x01	; 1
    55d6:	0e 94 36 31 	call	0x626c	; 0x626c <prvAddCurrentTaskToDelayedList>
}
    55da:	0f 90       	pop	r0
    55dc:	0f 90       	pop	r0
    55de:	0f 90       	pop	r0
    55e0:	0f 90       	pop	r0
    55e2:	cf 91       	pop	r28
    55e4:	df 91       	pop	r29
    55e6:	08 95       	ret

000055e8 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    55e8:	df 93       	push	r29
    55ea:	cf 93       	push	r28
    55ec:	00 d0       	rcall	.+0      	; 0x55ee <vTaskPlaceOnUnorderedEventList+0x6>
    55ee:	00 d0       	rcall	.+0      	; 0x55f0 <vTaskPlaceOnUnorderedEventList+0x8>
    55f0:	00 d0       	rcall	.+0      	; 0x55f2 <vTaskPlaceOnUnorderedEventList+0xa>
    55f2:	cd b7       	in	r28, 0x3d	; 61
    55f4:	de b7       	in	r29, 0x3e	; 62
    55f6:	9a 83       	std	Y+2, r25	; 0x02
    55f8:	89 83       	std	Y+1, r24	; 0x01
    55fa:	7c 83       	std	Y+4, r23	; 0x04
    55fc:	6b 83       	std	Y+3, r22	; 0x03
    55fe:	5e 83       	std	Y+6, r21	; 0x06
    5600:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5602:	e0 91 a8 06 	lds	r30, 0x06A8
    5606:	f0 91 a9 06 	lds	r31, 0x06A9
    560a:	8b 81       	ldd	r24, Y+3	; 0x03
    560c:	9c 81       	ldd	r25, Y+4	; 0x04
    560e:	90 68       	ori	r25, 0x80	; 128
    5610:	95 87       	std	Z+13, r25	; 0x0d
    5612:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5614:	80 91 a8 06 	lds	r24, 0x06A8
    5618:	90 91 a9 06 	lds	r25, 0x06A9
    561c:	9c 01       	movw	r18, r24
    561e:	24 5f       	subi	r18, 0xF4	; 244
    5620:	3f 4f       	sbci	r19, 0xFF	; 255
    5622:	89 81       	ldd	r24, Y+1	; 0x01
    5624:	9a 81       	ldd	r25, Y+2	; 0x02
    5626:	b9 01       	movw	r22, r18
    5628:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    562c:	8d 81       	ldd	r24, Y+5	; 0x05
    562e:	9e 81       	ldd	r25, Y+6	; 0x06
    5630:	61 e0       	ldi	r22, 0x01	; 1
    5632:	0e 94 36 31 	call	0x626c	; 0x626c <prvAddCurrentTaskToDelayedList>
}
    5636:	26 96       	adiw	r28, 0x06	; 6
    5638:	0f b6       	in	r0, 0x3f	; 63
    563a:	f8 94       	cli
    563c:	de bf       	out	0x3e, r29	; 62
    563e:	0f be       	out	0x3f, r0	; 63
    5640:	cd bf       	out	0x3d, r28	; 61
    5642:	cf 91       	pop	r28
    5644:	df 91       	pop	r29
    5646:	08 95       	ret

00005648 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    5648:	df 93       	push	r29
    564a:	cf 93       	push	r28
    564c:	00 d0       	rcall	.+0      	; 0x564e <xTaskRemoveFromEventList+0x6>
    564e:	00 d0       	rcall	.+0      	; 0x5650 <xTaskRemoveFromEventList+0x8>
    5650:	0f 92       	push	r0
    5652:	cd b7       	in	r28, 0x3d	; 61
    5654:	de b7       	in	r29, 0x3e	; 62
    5656:	9d 83       	std	Y+5, r25	; 0x05
    5658:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    565a:	ec 81       	ldd	r30, Y+4	; 0x04
    565c:	fd 81       	ldd	r31, Y+5	; 0x05
    565e:	05 80       	ldd	r0, Z+5	; 0x05
    5660:	f6 81       	ldd	r31, Z+6	; 0x06
    5662:	e0 2d       	mov	r30, r0
    5664:	86 81       	ldd	r24, Z+6	; 0x06
    5666:	97 81       	ldd	r25, Z+7	; 0x07
    5668:	9b 83       	std	Y+3, r25	; 0x03
    566a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    566c:	8a 81       	ldd	r24, Y+2	; 0x02
    566e:	9b 81       	ldd	r25, Y+3	; 0x03
    5670:	0c 96       	adiw	r24, 0x0c	; 12
    5672:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5676:	80 91 b8 06 	lds	r24, 0x06B8
    567a:	88 23       	and	r24, r24
    567c:	61 f5       	brne	.+88     	; 0x56d6 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    567e:	8a 81       	ldd	r24, Y+2	; 0x02
    5680:	9b 81       	ldd	r25, Y+3	; 0x03
    5682:	02 96       	adiw	r24, 0x02	; 2
    5684:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    5688:	ea 81       	ldd	r30, Y+2	; 0x02
    568a:	fb 81       	ldd	r31, Y+3	; 0x03
    568c:	96 89       	ldd	r25, Z+22	; 0x16
    568e:	80 91 ae 06 	lds	r24, 0x06AE
    5692:	89 17       	cp	r24, r25
    5694:	28 f4       	brcc	.+10     	; 0x56a0 <xTaskRemoveFromEventList+0x58>
    5696:	ea 81       	ldd	r30, Y+2	; 0x02
    5698:	fb 81       	ldd	r31, Y+3	; 0x03
    569a:	86 89       	ldd	r24, Z+22	; 0x16
    569c:	80 93 ae 06 	sts	0x06AE, r24
    56a0:	ea 81       	ldd	r30, Y+2	; 0x02
    56a2:	fb 81       	ldd	r31, Y+3	; 0x03
    56a4:	86 89       	ldd	r24, Z+22	; 0x16
    56a6:	28 2f       	mov	r18, r24
    56a8:	30 e0       	ldi	r19, 0x00	; 0
    56aa:	c9 01       	movw	r24, r18
    56ac:	88 0f       	add	r24, r24
    56ae:	99 1f       	adc	r25, r25
    56b0:	88 0f       	add	r24, r24
    56b2:	99 1f       	adc	r25, r25
    56b4:	88 0f       	add	r24, r24
    56b6:	99 1f       	adc	r25, r25
    56b8:	82 0f       	add	r24, r18
    56ba:	93 1f       	adc	r25, r19
    56bc:	ac 01       	movw	r20, r24
    56be:	47 54       	subi	r20, 0x47	; 71
    56c0:	59 4f       	sbci	r21, 0xF9	; 249
    56c2:	8a 81       	ldd	r24, Y+2	; 0x02
    56c4:	9b 81       	ldd	r25, Y+3	; 0x03
    56c6:	9c 01       	movw	r18, r24
    56c8:	2e 5f       	subi	r18, 0xFE	; 254
    56ca:	3f 4f       	sbci	r19, 0xFF	; 255
    56cc:	ca 01       	movw	r24, r20
    56ce:	b9 01       	movw	r22, r18
    56d0:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>
    56d4:	0a c0       	rjmp	.+20     	; 0x56ea <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    56d6:	8a 81       	ldd	r24, Y+2	; 0x02
    56d8:	9b 81       	ldd	r25, Y+3	; 0x03
    56da:	9c 01       	movw	r18, r24
    56dc:	24 5f       	subi	r18, 0xF4	; 244
    56de:	3f 4f       	sbci	r19, 0xFF	; 255
    56e0:	8c ef       	ldi	r24, 0xFC	; 252
    56e2:	96 e0       	ldi	r25, 0x06	; 6
    56e4:	b9 01       	movw	r22, r18
    56e6:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    56ea:	ea 81       	ldd	r30, Y+2	; 0x02
    56ec:	fb 81       	ldd	r31, Y+3	; 0x03
    56ee:	96 89       	ldd	r25, Z+22	; 0x16
    56f0:	e0 91 a8 06 	lds	r30, 0x06A8
    56f4:	f0 91 a9 06 	lds	r31, 0x06A9
    56f8:	86 89       	ldd	r24, Z+22	; 0x16
    56fa:	89 17       	cp	r24, r25
    56fc:	30 f4       	brcc	.+12     	; 0x570a <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    56fe:	81 e0       	ldi	r24, 0x01	; 1
    5700:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5702:	81 e0       	ldi	r24, 0x01	; 1
    5704:	80 93 b1 06 	sts	0x06B1, r24
    5708:	01 c0       	rjmp	.+2      	; 0x570c <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    570a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    570c:	89 81       	ldd	r24, Y+1	; 0x01
}
    570e:	0f 90       	pop	r0
    5710:	0f 90       	pop	r0
    5712:	0f 90       	pop	r0
    5714:	0f 90       	pop	r0
    5716:	0f 90       	pop	r0
    5718:	cf 91       	pop	r28
    571a:	df 91       	pop	r29
    571c:	08 95       	ret

0000571e <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    571e:	df 93       	push	r29
    5720:	cf 93       	push	r28
    5722:	00 d0       	rcall	.+0      	; 0x5724 <vTaskRemoveFromUnorderedEventList+0x6>
    5724:	00 d0       	rcall	.+0      	; 0x5726 <vTaskRemoveFromUnorderedEventList+0x8>
    5726:	00 d0       	rcall	.+0      	; 0x5728 <vTaskRemoveFromUnorderedEventList+0xa>
    5728:	cd b7       	in	r28, 0x3d	; 61
    572a:	de b7       	in	r29, 0x3e	; 62
    572c:	9c 83       	std	Y+4, r25	; 0x04
    572e:	8b 83       	std	Y+3, r24	; 0x03
    5730:	7e 83       	std	Y+6, r23	; 0x06
    5732:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5734:	8d 81       	ldd	r24, Y+5	; 0x05
    5736:	9e 81       	ldd	r25, Y+6	; 0x06
    5738:	90 68       	ori	r25, 0x80	; 128
    573a:	eb 81       	ldd	r30, Y+3	; 0x03
    573c:	fc 81       	ldd	r31, Y+4	; 0x04
    573e:	91 83       	std	Z+1, r25	; 0x01
    5740:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5742:	eb 81       	ldd	r30, Y+3	; 0x03
    5744:	fc 81       	ldd	r31, Y+4	; 0x04
    5746:	86 81       	ldd	r24, Z+6	; 0x06
    5748:	97 81       	ldd	r25, Z+7	; 0x07
    574a:	9a 83       	std	Y+2, r25	; 0x02
    574c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    574e:	8b 81       	ldd	r24, Y+3	; 0x03
    5750:	9c 81       	ldd	r25, Y+4	; 0x04
    5752:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    5756:	89 81       	ldd	r24, Y+1	; 0x01
    5758:	9a 81       	ldd	r25, Y+2	; 0x02
    575a:	02 96       	adiw	r24, 0x02	; 2
    575c:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    5760:	e9 81       	ldd	r30, Y+1	; 0x01
    5762:	fa 81       	ldd	r31, Y+2	; 0x02
    5764:	96 89       	ldd	r25, Z+22	; 0x16
    5766:	80 91 ae 06 	lds	r24, 0x06AE
    576a:	89 17       	cp	r24, r25
    576c:	28 f4       	brcc	.+10     	; 0x5778 <vTaskRemoveFromUnorderedEventList+0x5a>
    576e:	e9 81       	ldd	r30, Y+1	; 0x01
    5770:	fa 81       	ldd	r31, Y+2	; 0x02
    5772:	86 89       	ldd	r24, Z+22	; 0x16
    5774:	80 93 ae 06 	sts	0x06AE, r24
    5778:	e9 81       	ldd	r30, Y+1	; 0x01
    577a:	fa 81       	ldd	r31, Y+2	; 0x02
    577c:	86 89       	ldd	r24, Z+22	; 0x16
    577e:	28 2f       	mov	r18, r24
    5780:	30 e0       	ldi	r19, 0x00	; 0
    5782:	c9 01       	movw	r24, r18
    5784:	88 0f       	add	r24, r24
    5786:	99 1f       	adc	r25, r25
    5788:	88 0f       	add	r24, r24
    578a:	99 1f       	adc	r25, r25
    578c:	88 0f       	add	r24, r24
    578e:	99 1f       	adc	r25, r25
    5790:	82 0f       	add	r24, r18
    5792:	93 1f       	adc	r25, r19
    5794:	ac 01       	movw	r20, r24
    5796:	47 54       	subi	r20, 0x47	; 71
    5798:	59 4f       	sbci	r21, 0xF9	; 249
    579a:	89 81       	ldd	r24, Y+1	; 0x01
    579c:	9a 81       	ldd	r25, Y+2	; 0x02
    579e:	9c 01       	movw	r18, r24
    57a0:	2e 5f       	subi	r18, 0xFE	; 254
    57a2:	3f 4f       	sbci	r19, 0xFF	; 255
    57a4:	ca 01       	movw	r24, r20
    57a6:	b9 01       	movw	r22, r18
    57a8:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    57ac:	e9 81       	ldd	r30, Y+1	; 0x01
    57ae:	fa 81       	ldd	r31, Y+2	; 0x02
    57b0:	96 89       	ldd	r25, Z+22	; 0x16
    57b2:	e0 91 a8 06 	lds	r30, 0x06A8
    57b6:	f0 91 a9 06 	lds	r31, 0x06A9
    57ba:	86 89       	ldd	r24, Z+22	; 0x16
    57bc:	89 17       	cp	r24, r25
    57be:	18 f4       	brcc	.+6      	; 0x57c6 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    57c0:	81 e0       	ldi	r24, 0x01	; 1
    57c2:	80 93 b1 06 	sts	0x06B1, r24
	}
}
    57c6:	26 96       	adiw	r28, 0x06	; 6
    57c8:	0f b6       	in	r0, 0x3f	; 63
    57ca:	f8 94       	cli
    57cc:	de bf       	out	0x3e, r29	; 62
    57ce:	0f be       	out	0x3f, r0	; 63
    57d0:	cd bf       	out	0x3d, r28	; 61
    57d2:	cf 91       	pop	r28
    57d4:	df 91       	pop	r29
    57d6:	08 95       	ret

000057d8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    57d8:	df 93       	push	r29
    57da:	cf 93       	push	r28
    57dc:	00 d0       	rcall	.+0      	; 0x57de <vTaskSetTimeOutState+0x6>
    57de:	cd b7       	in	r28, 0x3d	; 61
    57e0:	de b7       	in	r29, 0x3e	; 62
    57e2:	9a 83       	std	Y+2, r25	; 0x02
    57e4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    57e6:	0f b6       	in	r0, 0x3f	; 63
    57e8:	f8 94       	cli
    57ea:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    57ec:	80 91 b2 06 	lds	r24, 0x06B2
    57f0:	e9 81       	ldd	r30, Y+1	; 0x01
    57f2:	fa 81       	ldd	r31, Y+2	; 0x02
    57f4:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    57f6:	80 91 ac 06 	lds	r24, 0x06AC
    57fa:	90 91 ad 06 	lds	r25, 0x06AD
    57fe:	e9 81       	ldd	r30, Y+1	; 0x01
    5800:	fa 81       	ldd	r31, Y+2	; 0x02
    5802:	92 83       	std	Z+2, r25	; 0x02
    5804:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5806:	0f 90       	pop	r0
    5808:	0f be       	out	0x3f, r0	; 63
}
    580a:	0f 90       	pop	r0
    580c:	0f 90       	pop	r0
    580e:	cf 91       	pop	r28
    5810:	df 91       	pop	r29
    5812:	08 95       	ret

00005814 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5814:	df 93       	push	r29
    5816:	cf 93       	push	r28
    5818:	00 d0       	rcall	.+0      	; 0x581a <vTaskInternalSetTimeOutState+0x6>
    581a:	cd b7       	in	r28, 0x3d	; 61
    581c:	de b7       	in	r29, 0x3e	; 62
    581e:	9a 83       	std	Y+2, r25	; 0x02
    5820:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5822:	80 91 b2 06 	lds	r24, 0x06B2
    5826:	e9 81       	ldd	r30, Y+1	; 0x01
    5828:	fa 81       	ldd	r31, Y+2	; 0x02
    582a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    582c:	80 91 ac 06 	lds	r24, 0x06AC
    5830:	90 91 ad 06 	lds	r25, 0x06AD
    5834:	e9 81       	ldd	r30, Y+1	; 0x01
    5836:	fa 81       	ldd	r31, Y+2	; 0x02
    5838:	92 83       	std	Z+2, r25	; 0x02
    583a:	81 83       	std	Z+1, r24	; 0x01
}
    583c:	0f 90       	pop	r0
    583e:	0f 90       	pop	r0
    5840:	cf 91       	pop	r28
    5842:	df 91       	pop	r29
    5844:	08 95       	ret

00005846 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5846:	df 93       	push	r29
    5848:	cf 93       	push	r28
    584a:	cd b7       	in	r28, 0x3d	; 61
    584c:	de b7       	in	r29, 0x3e	; 62
    584e:	29 97       	sbiw	r28, 0x09	; 9
    5850:	0f b6       	in	r0, 0x3f	; 63
    5852:	f8 94       	cli
    5854:	de bf       	out	0x3e, r29	; 62
    5856:	0f be       	out	0x3f, r0	; 63
    5858:	cd bf       	out	0x3d, r28	; 61
    585a:	9f 83       	std	Y+7, r25	; 0x07
    585c:	8e 83       	std	Y+6, r24	; 0x06
    585e:	79 87       	std	Y+9, r23	; 0x09
    5860:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5862:	0f b6       	in	r0, 0x3f	; 63
    5864:	f8 94       	cli
    5866:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5868:	80 91 ac 06 	lds	r24, 0x06AC
    586c:	90 91 ad 06 	lds	r25, 0x06AD
    5870:	9c 83       	std	Y+4, r25	; 0x04
    5872:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    5874:	ee 81       	ldd	r30, Y+6	; 0x06
    5876:	ff 81       	ldd	r31, Y+7	; 0x07
    5878:	21 81       	ldd	r18, Z+1	; 0x01
    587a:	32 81       	ldd	r19, Z+2	; 0x02
    587c:	8b 81       	ldd	r24, Y+3	; 0x03
    587e:	9c 81       	ldd	r25, Y+4	; 0x04
    5880:	82 1b       	sub	r24, r18
    5882:	93 0b       	sbc	r25, r19
    5884:	9a 83       	std	Y+2, r25	; 0x02
    5886:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    5888:	e8 85       	ldd	r30, Y+8	; 0x08
    588a:	f9 85       	ldd	r31, Y+9	; 0x09
    588c:	80 81       	ld	r24, Z
    588e:	91 81       	ldd	r25, Z+1	; 0x01
    5890:	2f ef       	ldi	r18, 0xFF	; 255
    5892:	8f 3f       	cpi	r24, 0xFF	; 255
    5894:	92 07       	cpc	r25, r18
    5896:	11 f4       	brne	.+4      	; 0x589c <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    5898:	1d 82       	std	Y+5, r1	; 0x05
    589a:	36 c0       	rjmp	.+108    	; 0x5908 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    589c:	ee 81       	ldd	r30, Y+6	; 0x06
    589e:	ff 81       	ldd	r31, Y+7	; 0x07
    58a0:	90 81       	ld	r25, Z
    58a2:	80 91 b2 06 	lds	r24, 0x06B2
    58a6:	98 17       	cp	r25, r24
    58a8:	61 f0       	breq	.+24     	; 0x58c2 <xTaskCheckForTimeOut+0x7c>
    58aa:	ee 81       	ldd	r30, Y+6	; 0x06
    58ac:	ff 81       	ldd	r31, Y+7	; 0x07
    58ae:	21 81       	ldd	r18, Z+1	; 0x01
    58b0:	32 81       	ldd	r19, Z+2	; 0x02
    58b2:	8b 81       	ldd	r24, Y+3	; 0x03
    58b4:	9c 81       	ldd	r25, Y+4	; 0x04
    58b6:	82 17       	cp	r24, r18
    58b8:	93 07       	cpc	r25, r19
    58ba:	18 f0       	brcs	.+6      	; 0x58c2 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    58bc:	81 e0       	ldi	r24, 0x01	; 1
    58be:	8d 83       	std	Y+5, r24	; 0x05
    58c0:	23 c0       	rjmp	.+70     	; 0x5908 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    58c2:	e8 85       	ldd	r30, Y+8	; 0x08
    58c4:	f9 85       	ldd	r31, Y+9	; 0x09
    58c6:	20 81       	ld	r18, Z
    58c8:	31 81       	ldd	r19, Z+1	; 0x01
    58ca:	89 81       	ldd	r24, Y+1	; 0x01
    58cc:	9a 81       	ldd	r25, Y+2	; 0x02
    58ce:	82 17       	cp	r24, r18
    58d0:	93 07       	cpc	r25, r19
    58d2:	a0 f4       	brcc	.+40     	; 0x58fc <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    58d4:	e8 85       	ldd	r30, Y+8	; 0x08
    58d6:	f9 85       	ldd	r31, Y+9	; 0x09
    58d8:	20 81       	ld	r18, Z
    58da:	31 81       	ldd	r19, Z+1	; 0x01
    58dc:	89 81       	ldd	r24, Y+1	; 0x01
    58de:	9a 81       	ldd	r25, Y+2	; 0x02
    58e0:	a9 01       	movw	r20, r18
    58e2:	48 1b       	sub	r20, r24
    58e4:	59 0b       	sbc	r21, r25
    58e6:	ca 01       	movw	r24, r20
    58e8:	e8 85       	ldd	r30, Y+8	; 0x08
    58ea:	f9 85       	ldd	r31, Y+9	; 0x09
    58ec:	91 83       	std	Z+1, r25	; 0x01
    58ee:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    58f0:	8e 81       	ldd	r24, Y+6	; 0x06
    58f2:	9f 81       	ldd	r25, Y+7	; 0x07
    58f4:	0e 94 0a 2c 	call	0x5814	; 0x5814 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    58f8:	1d 82       	std	Y+5, r1	; 0x05
    58fa:	06 c0       	rjmp	.+12     	; 0x5908 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    58fc:	e8 85       	ldd	r30, Y+8	; 0x08
    58fe:	f9 85       	ldd	r31, Y+9	; 0x09
    5900:	11 82       	std	Z+1, r1	; 0x01
    5902:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    5904:	81 e0       	ldi	r24, 0x01	; 1
    5906:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    5908:	0f 90       	pop	r0
    590a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    590c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    590e:	29 96       	adiw	r28, 0x09	; 9
    5910:	0f b6       	in	r0, 0x3f	; 63
    5912:	f8 94       	cli
    5914:	de bf       	out	0x3e, r29	; 62
    5916:	0f be       	out	0x3f, r0	; 63
    5918:	cd bf       	out	0x3d, r28	; 61
    591a:	cf 91       	pop	r28
    591c:	df 91       	pop	r29
    591e:	08 95       	ret

00005920 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5920:	df 93       	push	r29
    5922:	cf 93       	push	r28
    5924:	cd b7       	in	r28, 0x3d	; 61
    5926:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    5928:	81 e0       	ldi	r24, 0x01	; 1
    592a:	80 93 b1 06 	sts	0x06B1, r24
}
    592e:	cf 91       	pop	r28
    5930:	df 91       	pop	r29
    5932:	08 95       	ret

00005934 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5934:	df 93       	push	r29
    5936:	cf 93       	push	r28
    5938:	00 d0       	rcall	.+0      	; 0x593a <prvIdleTask+0x6>
    593a:	cd b7       	in	r28, 0x3d	; 61
    593c:	de b7       	in	r29, 0x3e	; 62
    593e:	9a 83       	std	Y+2, r25	; 0x02
    5940:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    5942:	0e 94 e5 2c 	call	0x59ca	; 0x59ca <prvCheckTasksWaitingTermination>
    5946:	fd cf       	rjmp	.-6      	; 0x5942 <prvIdleTask+0xe>

00005948 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5948:	df 93       	push	r29
    594a:	cf 93       	push	r28
    594c:	0f 92       	push	r0
    594e:	cd b7       	in	r28, 0x3d	; 61
    5950:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5952:	19 82       	std	Y+1, r1	; 0x01
    5954:	13 c0       	rjmp	.+38     	; 0x597c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5956:	89 81       	ldd	r24, Y+1	; 0x01
    5958:	28 2f       	mov	r18, r24
    595a:	30 e0       	ldi	r19, 0x00	; 0
    595c:	c9 01       	movw	r24, r18
    595e:	88 0f       	add	r24, r24
    5960:	99 1f       	adc	r25, r25
    5962:	88 0f       	add	r24, r24
    5964:	99 1f       	adc	r25, r25
    5966:	88 0f       	add	r24, r24
    5968:	99 1f       	adc	r25, r25
    596a:	82 0f       	add	r24, r18
    596c:	93 1f       	adc	r25, r19
    596e:	87 54       	subi	r24, 0x47	; 71
    5970:	99 4f       	sbci	r25, 0xF9	; 249
    5972:	0e 94 bc 11 	call	0x2378	; 0x2378 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5976:	89 81       	ldd	r24, Y+1	; 0x01
    5978:	8f 5f       	subi	r24, 0xFF	; 255
    597a:	89 83       	std	Y+1, r24	; 0x01
    597c:	89 81       	ldd	r24, Y+1	; 0x01
    597e:	85 30       	cpi	r24, 0x05	; 5
    5980:	50 f3       	brcs	.-44     	; 0x5956 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5982:	86 ee       	ldi	r24, 0xE6	; 230
    5984:	96 e0       	ldi	r25, 0x06	; 6
    5986:	0e 94 bc 11 	call	0x2378	; 0x2378 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    598a:	8f ee       	ldi	r24, 0xEF	; 239
    598c:	96 e0       	ldi	r25, 0x06	; 6
    598e:	0e 94 bc 11 	call	0x2378	; 0x2378 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    5992:	8c ef       	ldi	r24, 0xFC	; 252
    5994:	96 e0       	ldi	r25, 0x06	; 6
    5996:	0e 94 bc 11 	call	0x2378	; 0x2378 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    599a:	85 e0       	ldi	r24, 0x05	; 5
    599c:	97 e0       	ldi	r25, 0x07	; 7
    599e:	0e 94 bc 11 	call	0x2378	; 0x2378 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    59a2:	8e e0       	ldi	r24, 0x0E	; 14
    59a4:	97 e0       	ldi	r25, 0x07	; 7
    59a6:	0e 94 bc 11 	call	0x2378	; 0x2378 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    59aa:	86 ee       	ldi	r24, 0xE6	; 230
    59ac:	96 e0       	ldi	r25, 0x06	; 6
    59ae:	90 93 f9 06 	sts	0x06F9, r25
    59b2:	80 93 f8 06 	sts	0x06F8, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    59b6:	8f ee       	ldi	r24, 0xEF	; 239
    59b8:	96 e0       	ldi	r25, 0x06	; 6
    59ba:	90 93 fb 06 	sts	0x06FB, r25
    59be:	80 93 fa 06 	sts	0x06FA, r24
}
    59c2:	0f 90       	pop	r0
    59c4:	cf 91       	pop	r28
    59c6:	df 91       	pop	r29
    59c8:	08 95       	ret

000059ca <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    59ca:	df 93       	push	r29
    59cc:	cf 93       	push	r28
    59ce:	00 d0       	rcall	.+0      	; 0x59d0 <prvCheckTasksWaitingTermination+0x6>
    59d0:	cd b7       	in	r28, 0x3d	; 61
    59d2:	de b7       	in	r29, 0x3e	; 62
    59d4:	20 c0       	rjmp	.+64     	; 0x5a16 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    59d6:	0f b6       	in	r0, 0x3f	; 63
    59d8:	f8 94       	cli
    59da:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    59dc:	e0 91 0a 07 	lds	r30, 0x070A
    59e0:	f0 91 0b 07 	lds	r31, 0x070B
    59e4:	86 81       	ldd	r24, Z+6	; 0x06
    59e6:	97 81       	ldd	r25, Z+7	; 0x07
    59e8:	9a 83       	std	Y+2, r25	; 0x02
    59ea:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    59ec:	89 81       	ldd	r24, Y+1	; 0x01
    59ee:	9a 81       	ldd	r25, Y+2	; 0x02
    59f0:	02 96       	adiw	r24, 0x02	; 2
    59f2:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
				--uxCurrentNumberOfTasks;
    59f6:	80 91 ab 06 	lds	r24, 0x06AB
    59fa:	81 50       	subi	r24, 0x01	; 1
    59fc:	80 93 ab 06 	sts	0x06AB, r24
				--uxDeletedTasksWaitingCleanUp;
    5a00:	80 91 aa 06 	lds	r24, 0x06AA
    5a04:	81 50       	subi	r24, 0x01	; 1
    5a06:	80 93 aa 06 	sts	0x06AA, r24
			}
			taskEXIT_CRITICAL();
    5a0a:	0f 90       	pop	r0
    5a0c:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    5a0e:	89 81       	ldd	r24, Y+1	; 0x01
    5a10:	9a 81       	ldd	r25, Y+2	; 0x02
    5a12:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5a16:	80 91 aa 06 	lds	r24, 0x06AA
    5a1a:	88 23       	and	r24, r24
    5a1c:	e1 f6       	brne	.-72     	; 0x59d6 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    5a1e:	0f 90       	pop	r0
    5a20:	0f 90       	pop	r0
    5a22:	cf 91       	pop	r28
    5a24:	df 91       	pop	r29
    5a26:	08 95       	ret

00005a28 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    5a28:	df 93       	push	r29
    5a2a:	cf 93       	push	r28
    5a2c:	00 d0       	rcall	.+0      	; 0x5a2e <prvDeleteTCB+0x6>
    5a2e:	cd b7       	in	r28, 0x3d	; 61
    5a30:	de b7       	in	r29, 0x3e	; 62
    5a32:	9a 83       	std	Y+2, r25	; 0x02
    5a34:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    5a36:	e9 81       	ldd	r30, Y+1	; 0x01
    5a38:	fa 81       	ldd	r31, Y+2	; 0x02
    5a3a:	87 89       	ldd	r24, Z+23	; 0x17
    5a3c:	90 8d       	ldd	r25, Z+24	; 0x18
    5a3e:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <vPortFree>
			vPortFree( pxTCB );
    5a42:	89 81       	ldd	r24, Y+1	; 0x01
    5a44:	9a 81       	ldd	r25, Y+2	; 0x02
    5a46:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    5a4a:	0f 90       	pop	r0
    5a4c:	0f 90       	pop	r0
    5a4e:	cf 91       	pop	r28
    5a50:	df 91       	pop	r29
    5a52:	08 95       	ret

00005a54 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5a54:	df 93       	push	r29
    5a56:	cf 93       	push	r28
    5a58:	00 d0       	rcall	.+0      	; 0x5a5a <prvResetNextTaskUnblockTime+0x6>
    5a5a:	cd b7       	in	r28, 0x3d	; 61
    5a5c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5a5e:	e0 91 f8 06 	lds	r30, 0x06F8
    5a62:	f0 91 f9 06 	lds	r31, 0x06F9
    5a66:	80 81       	ld	r24, Z
    5a68:	88 23       	and	r24, r24
    5a6a:	39 f4       	brne	.+14     	; 0x5a7a <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    5a6c:	8f ef       	ldi	r24, 0xFF	; 255
    5a6e:	9f ef       	ldi	r25, 0xFF	; 255
    5a70:	90 93 b5 06 	sts	0x06B5, r25
    5a74:	80 93 b4 06 	sts	0x06B4, r24
    5a78:	13 c0       	rjmp	.+38     	; 0x5aa0 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5a7a:	e0 91 f8 06 	lds	r30, 0x06F8
    5a7e:	f0 91 f9 06 	lds	r31, 0x06F9
    5a82:	05 80       	ldd	r0, Z+5	; 0x05
    5a84:	f6 81       	ldd	r31, Z+6	; 0x06
    5a86:	e0 2d       	mov	r30, r0
    5a88:	86 81       	ldd	r24, Z+6	; 0x06
    5a8a:	97 81       	ldd	r25, Z+7	; 0x07
    5a8c:	9a 83       	std	Y+2, r25	; 0x02
    5a8e:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    5a90:	e9 81       	ldd	r30, Y+1	; 0x01
    5a92:	fa 81       	ldd	r31, Y+2	; 0x02
    5a94:	82 81       	ldd	r24, Z+2	; 0x02
    5a96:	93 81       	ldd	r25, Z+3	; 0x03
    5a98:	90 93 b5 06 	sts	0x06B5, r25
    5a9c:	80 93 b4 06 	sts	0x06B4, r24
	}
}
    5aa0:	0f 90       	pop	r0
    5aa2:	0f 90       	pop	r0
    5aa4:	cf 91       	pop	r28
    5aa6:	df 91       	pop	r29
    5aa8:	08 95       	ret

00005aaa <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    5aaa:	df 93       	push	r29
    5aac:	cf 93       	push	r28
    5aae:	00 d0       	rcall	.+0      	; 0x5ab0 <xTaskGetCurrentTaskHandle+0x6>
    5ab0:	cd b7       	in	r28, 0x3d	; 61
    5ab2:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    5ab4:	80 91 a8 06 	lds	r24, 0x06A8
    5ab8:	90 91 a9 06 	lds	r25, 0x06A9
    5abc:	9a 83       	std	Y+2, r25	; 0x02
    5abe:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    5ac0:	89 81       	ldd	r24, Y+1	; 0x01
    5ac2:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    5ac4:	0f 90       	pop	r0
    5ac6:	0f 90       	pop	r0
    5ac8:	cf 91       	pop	r28
    5aca:	df 91       	pop	r29
    5acc:	08 95       	ret

00005ace <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    5ace:	df 93       	push	r29
    5ad0:	cf 93       	push	r28
    5ad2:	00 d0       	rcall	.+0      	; 0x5ad4 <uxTaskResetEventItemValue+0x6>
    5ad4:	cd b7       	in	r28, 0x3d	; 61
    5ad6:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5ad8:	e0 91 a8 06 	lds	r30, 0x06A8
    5adc:	f0 91 a9 06 	lds	r31, 0x06A9
    5ae0:	84 85       	ldd	r24, Z+12	; 0x0c
    5ae2:	95 85       	ldd	r25, Z+13	; 0x0d
    5ae4:	9a 83       	std	Y+2, r25	; 0x02
    5ae6:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5ae8:	a0 91 a8 06 	lds	r26, 0x06A8
    5aec:	b0 91 a9 06 	lds	r27, 0x06A9
    5af0:	e0 91 a8 06 	lds	r30, 0x06A8
    5af4:	f0 91 a9 06 	lds	r31, 0x06A9
    5af8:	86 89       	ldd	r24, Z+22	; 0x16
    5afa:	28 2f       	mov	r18, r24
    5afc:	30 e0       	ldi	r19, 0x00	; 0
    5afe:	85 e0       	ldi	r24, 0x05	; 5
    5b00:	90 e0       	ldi	r25, 0x00	; 0
    5b02:	82 1b       	sub	r24, r18
    5b04:	93 0b       	sbc	r25, r19
    5b06:	1d 96       	adiw	r26, 0x0d	; 13
    5b08:	9c 93       	st	X, r25
    5b0a:	8e 93       	st	-X, r24
    5b0c:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    5b0e:	89 81       	ldd	r24, Y+1	; 0x01
    5b10:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5b12:	0f 90       	pop	r0
    5b14:	0f 90       	pop	r0
    5b16:	cf 91       	pop	r28
    5b18:	df 91       	pop	r29
    5b1a:	08 95       	ret

00005b1c <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    5b1c:	df 93       	push	r29
    5b1e:	cf 93       	push	r28
    5b20:	cd b7       	in	r28, 0x3d	; 61
    5b22:	de b7       	in	r29, 0x3e	; 62
    5b24:	27 97       	sbiw	r28, 0x07	; 7
    5b26:	0f b6       	in	r0, 0x3f	; 63
    5b28:	f8 94       	cli
    5b2a:	de bf       	out	0x3e, r29	; 62
    5b2c:	0f be       	out	0x3f, r0	; 63
    5b2e:	cd bf       	out	0x3d, r28	; 61
    5b30:	8d 83       	std	Y+5, r24	; 0x05
    5b32:	7f 83       	std	Y+7, r23	; 0x07
    5b34:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    5b36:	0f b6       	in	r0, 0x3f	; 63
    5b38:	f8 94       	cli
    5b3a:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    5b3c:	e0 91 a8 06 	lds	r30, 0x06A8
    5b40:	f0 91 a9 06 	lds	r31, 0x06A9
    5b44:	85 a5       	ldd	r24, Z+45	; 0x2d
    5b46:	96 a5       	ldd	r25, Z+46	; 0x2e
    5b48:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5b4a:	b0 a9       	ldd	r27, Z+48	; 0x30
    5b4c:	00 97       	sbiw	r24, 0x00	; 0
    5b4e:	a1 05       	cpc	r26, r1
    5b50:	b1 05       	cpc	r27, r1
    5b52:	89 f4       	brne	.+34     	; 0x5b76 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5b54:	e0 91 a8 06 	lds	r30, 0x06A8
    5b58:	f0 91 a9 06 	lds	r31, 0x06A9
    5b5c:	81 e0       	ldi	r24, 0x01	; 1
    5b5e:	81 ab       	std	Z+49, r24	; 0x31

				if( xTicksToWait > ( TickType_t ) 0 )
    5b60:	8e 81       	ldd	r24, Y+6	; 0x06
    5b62:	9f 81       	ldd	r25, Y+7	; 0x07
    5b64:	00 97       	sbiw	r24, 0x00	; 0
    5b66:	39 f0       	breq	.+14     	; 0x5b76 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5b68:	8e 81       	ldd	r24, Y+6	; 0x06
    5b6a:	9f 81       	ldd	r25, Y+7	; 0x07
    5b6c:	61 e0       	ldi	r22, 0x01	; 1
    5b6e:	0e 94 36 31 	call	0x626c	; 0x626c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5b72:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5b76:	0f 90       	pop	r0
    5b78:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5b7a:	0f b6       	in	r0, 0x3f	; 63
    5b7c:	f8 94       	cli
    5b7e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    5b80:	e0 91 a8 06 	lds	r30, 0x06A8
    5b84:	f0 91 a9 06 	lds	r31, 0x06A9
    5b88:	85 a5       	ldd	r24, Z+45	; 0x2d
    5b8a:	96 a5       	ldd	r25, Z+46	; 0x2e
    5b8c:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5b8e:	b0 a9       	ldd	r27, Z+48	; 0x30
    5b90:	89 83       	std	Y+1, r24	; 0x01
    5b92:	9a 83       	std	Y+2, r25	; 0x02
    5b94:	ab 83       	std	Y+3, r26	; 0x03
    5b96:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    5b98:	89 81       	ldd	r24, Y+1	; 0x01
    5b9a:	9a 81       	ldd	r25, Y+2	; 0x02
    5b9c:	ab 81       	ldd	r26, Y+3	; 0x03
    5b9e:	bc 81       	ldd	r27, Y+4	; 0x04
    5ba0:	00 97       	sbiw	r24, 0x00	; 0
    5ba2:	a1 05       	cpc	r26, r1
    5ba4:	b1 05       	cpc	r27, r1
    5ba6:	d9 f0       	breq	.+54     	; 0x5bde <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    5ba8:	8d 81       	ldd	r24, Y+5	; 0x05
    5baa:	88 23       	and	r24, r24
    5bac:	49 f0       	breq	.+18     	; 0x5bc0 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    5bae:	e0 91 a8 06 	lds	r30, 0x06A8
    5bb2:	f0 91 a9 06 	lds	r31, 0x06A9
    5bb6:	15 a6       	std	Z+45, r1	; 0x2d
    5bb8:	16 a6       	std	Z+46, r1	; 0x2e
    5bba:	17 a6       	std	Z+47, r1	; 0x2f
    5bbc:	10 aa       	std	Z+48, r1	; 0x30
    5bbe:	0f c0       	rjmp	.+30     	; 0x5bde <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    5bc0:	e0 91 a8 06 	lds	r30, 0x06A8
    5bc4:	f0 91 a9 06 	lds	r31, 0x06A9
    5bc8:	89 81       	ldd	r24, Y+1	; 0x01
    5bca:	9a 81       	ldd	r25, Y+2	; 0x02
    5bcc:	ab 81       	ldd	r26, Y+3	; 0x03
    5bce:	bc 81       	ldd	r27, Y+4	; 0x04
    5bd0:	01 97       	sbiw	r24, 0x01	; 1
    5bd2:	a1 09       	sbc	r26, r1
    5bd4:	b1 09       	sbc	r27, r1
    5bd6:	85 a7       	std	Z+45, r24	; 0x2d
    5bd8:	96 a7       	std	Z+46, r25	; 0x2e
    5bda:	a7 a7       	std	Z+47, r26	; 0x2f
    5bdc:	b0 ab       	std	Z+48, r27	; 0x30
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5bde:	e0 91 a8 06 	lds	r30, 0x06A8
    5be2:	f0 91 a9 06 	lds	r31, 0x06A9
    5be6:	11 aa       	std	Z+49, r1	; 0x31
		}
		taskEXIT_CRITICAL();
    5be8:	0f 90       	pop	r0
    5bea:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    5bec:	89 81       	ldd	r24, Y+1	; 0x01
    5bee:	9a 81       	ldd	r25, Y+2	; 0x02
    5bf0:	ab 81       	ldd	r26, Y+3	; 0x03
    5bf2:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    5bf4:	bc 01       	movw	r22, r24
    5bf6:	cd 01       	movw	r24, r26
    5bf8:	27 96       	adiw	r28, 0x07	; 7
    5bfa:	0f b6       	in	r0, 0x3f	; 63
    5bfc:	f8 94       	cli
    5bfe:	de bf       	out	0x3e, r29	; 62
    5c00:	0f be       	out	0x3f, r0	; 63
    5c02:	cd bf       	out	0x3d, r28	; 61
    5c04:	cf 91       	pop	r28
    5c06:	df 91       	pop	r29
    5c08:	08 95       	ret

00005c0a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    5c0a:	ef 92       	push	r14
    5c0c:	ff 92       	push	r15
    5c0e:	0f 93       	push	r16
    5c10:	1f 93       	push	r17
    5c12:	df 93       	push	r29
    5c14:	cf 93       	push	r28
    5c16:	cd b7       	in	r28, 0x3d	; 61
    5c18:	de b7       	in	r29, 0x3e	; 62
    5c1a:	2d 97       	sbiw	r28, 0x0d	; 13
    5c1c:	0f b6       	in	r0, 0x3f	; 63
    5c1e:	f8 94       	cli
    5c20:	de bf       	out	0x3e, r29	; 62
    5c22:	0f be       	out	0x3f, r0	; 63
    5c24:	cd bf       	out	0x3d, r28	; 61
    5c26:	6a 83       	std	Y+2, r22	; 0x02
    5c28:	7b 83       	std	Y+3, r23	; 0x03
    5c2a:	8c 83       	std	Y+4, r24	; 0x04
    5c2c:	9d 83       	std	Y+5, r25	; 0x05
    5c2e:	2e 83       	std	Y+6, r18	; 0x06
    5c30:	3f 83       	std	Y+7, r19	; 0x07
    5c32:	48 87       	std	Y+8, r20	; 0x08
    5c34:	59 87       	std	Y+9, r21	; 0x09
    5c36:	1b 87       	std	Y+11, r17	; 0x0b
    5c38:	0a 87       	std	Y+10, r16	; 0x0a
    5c3a:	fd 86       	std	Y+13, r15	; 0x0d
    5c3c:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    5c3e:	0f b6       	in	r0, 0x3f	; 63
    5c40:	f8 94       	cli
    5c42:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5c44:	e0 91 a8 06 	lds	r30, 0x06A8
    5c48:	f0 91 a9 06 	lds	r31, 0x06A9
    5c4c:	81 a9       	ldd	r24, Z+49	; 0x31
    5c4e:	82 30       	cpi	r24, 0x02	; 2
    5c50:	49 f1       	breq	.+82     	; 0x5ca4 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    5c52:	e0 91 a8 06 	lds	r30, 0x06A8
    5c56:	f0 91 a9 06 	lds	r31, 0x06A9
    5c5a:	25 a5       	ldd	r18, Z+45	; 0x2d
    5c5c:	36 a5       	ldd	r19, Z+46	; 0x2e
    5c5e:	47 a5       	ldd	r20, Z+47	; 0x2f
    5c60:	50 a9       	ldd	r21, Z+48	; 0x30
    5c62:	8a 81       	ldd	r24, Y+2	; 0x02
    5c64:	9b 81       	ldd	r25, Y+3	; 0x03
    5c66:	ac 81       	ldd	r26, Y+4	; 0x04
    5c68:	bd 81       	ldd	r27, Y+5	; 0x05
    5c6a:	80 95       	com	r24
    5c6c:	90 95       	com	r25
    5c6e:	a0 95       	com	r26
    5c70:	b0 95       	com	r27
    5c72:	82 23       	and	r24, r18
    5c74:	93 23       	and	r25, r19
    5c76:	a4 23       	and	r26, r20
    5c78:	b5 23       	and	r27, r21
    5c7a:	85 a7       	std	Z+45, r24	; 0x2d
    5c7c:	96 a7       	std	Z+46, r25	; 0x2e
    5c7e:	a7 a7       	std	Z+47, r26	; 0x2f
    5c80:	b0 ab       	std	Z+48, r27	; 0x30

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5c82:	e0 91 a8 06 	lds	r30, 0x06A8
    5c86:	f0 91 a9 06 	lds	r31, 0x06A9
    5c8a:	81 e0       	ldi	r24, 0x01	; 1
    5c8c:	81 ab       	std	Z+49, r24	; 0x31

				if( xTicksToWait > ( TickType_t ) 0 )
    5c8e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5c90:	9d 85       	ldd	r25, Y+13	; 0x0d
    5c92:	00 97       	sbiw	r24, 0x00	; 0
    5c94:	39 f0       	breq	.+14     	; 0x5ca4 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5c96:	8c 85       	ldd	r24, Y+12	; 0x0c
    5c98:	9d 85       	ldd	r25, Y+13	; 0x0d
    5c9a:	61 e0       	ldi	r22, 0x01	; 1
    5c9c:	0e 94 36 31 	call	0x626c	; 0x626c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5ca0:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5ca4:	0f 90       	pop	r0
    5ca6:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5ca8:	0f b6       	in	r0, 0x3f	; 63
    5caa:	f8 94       	cli
    5cac:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    5cae:	8a 85       	ldd	r24, Y+10	; 0x0a
    5cb0:	9b 85       	ldd	r25, Y+11	; 0x0b
    5cb2:	00 97       	sbiw	r24, 0x00	; 0
    5cb4:	71 f0       	breq	.+28     	; 0x5cd2 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    5cb6:	e0 91 a8 06 	lds	r30, 0x06A8
    5cba:	f0 91 a9 06 	lds	r31, 0x06A9
    5cbe:	85 a5       	ldd	r24, Z+45	; 0x2d
    5cc0:	96 a5       	ldd	r25, Z+46	; 0x2e
    5cc2:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5cc4:	b0 a9       	ldd	r27, Z+48	; 0x30
    5cc6:	ea 85       	ldd	r30, Y+10	; 0x0a
    5cc8:	fb 85       	ldd	r31, Y+11	; 0x0b
    5cca:	80 83       	st	Z, r24
    5ccc:	91 83       	std	Z+1, r25	; 0x01
    5cce:	a2 83       	std	Z+2, r26	; 0x02
    5cd0:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5cd2:	e0 91 a8 06 	lds	r30, 0x06A8
    5cd6:	f0 91 a9 06 	lds	r31, 0x06A9
    5cda:	81 a9       	ldd	r24, Z+49	; 0x31
    5cdc:	82 30       	cpi	r24, 0x02	; 2
    5cde:	11 f0       	breq	.+4      	; 0x5ce4 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    5ce0:	19 82       	std	Y+1, r1	; 0x01
    5ce2:	1a c0       	rjmp	.+52     	; 0x5d18 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    5ce4:	e0 91 a8 06 	lds	r30, 0x06A8
    5ce8:	f0 91 a9 06 	lds	r31, 0x06A9
    5cec:	25 a5       	ldd	r18, Z+45	; 0x2d
    5cee:	36 a5       	ldd	r19, Z+46	; 0x2e
    5cf0:	47 a5       	ldd	r20, Z+47	; 0x2f
    5cf2:	50 a9       	ldd	r21, Z+48	; 0x30
    5cf4:	8e 81       	ldd	r24, Y+6	; 0x06
    5cf6:	9f 81       	ldd	r25, Y+7	; 0x07
    5cf8:	a8 85       	ldd	r26, Y+8	; 0x08
    5cfa:	b9 85       	ldd	r27, Y+9	; 0x09
    5cfc:	80 95       	com	r24
    5cfe:	90 95       	com	r25
    5d00:	a0 95       	com	r26
    5d02:	b0 95       	com	r27
    5d04:	82 23       	and	r24, r18
    5d06:	93 23       	and	r25, r19
    5d08:	a4 23       	and	r26, r20
    5d0a:	b5 23       	and	r27, r21
    5d0c:	85 a7       	std	Z+45, r24	; 0x2d
    5d0e:	96 a7       	std	Z+46, r25	; 0x2e
    5d10:	a7 a7       	std	Z+47, r26	; 0x2f
    5d12:	b0 ab       	std	Z+48, r27	; 0x30
				xReturn = pdTRUE;
    5d14:	81 e0       	ldi	r24, 0x01	; 1
    5d16:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5d18:	e0 91 a8 06 	lds	r30, 0x06A8
    5d1c:	f0 91 a9 06 	lds	r31, 0x06A9
    5d20:	11 aa       	std	Z+49, r1	; 0x31
		}
		taskEXIT_CRITICAL();
    5d22:	0f 90       	pop	r0
    5d24:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5d26:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5d28:	2d 96       	adiw	r28, 0x0d	; 13
    5d2a:	0f b6       	in	r0, 0x3f	; 63
    5d2c:	f8 94       	cli
    5d2e:	de bf       	out	0x3e, r29	; 62
    5d30:	0f be       	out	0x3f, r0	; 63
    5d32:	cd bf       	out	0x3d, r28	; 61
    5d34:	cf 91       	pop	r28
    5d36:	df 91       	pop	r29
    5d38:	1f 91       	pop	r17
    5d3a:	0f 91       	pop	r16
    5d3c:	ff 90       	pop	r15
    5d3e:	ef 90       	pop	r14
    5d40:	08 95       	ret

00005d42 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    5d42:	0f 93       	push	r16
    5d44:	1f 93       	push	r17
    5d46:	df 93       	push	r29
    5d48:	cf 93       	push	r28
    5d4a:	cd b7       	in	r28, 0x3d	; 61
    5d4c:	de b7       	in	r29, 0x3e	; 62
    5d4e:	2f 97       	sbiw	r28, 0x0f	; 15
    5d50:	0f b6       	in	r0, 0x3f	; 63
    5d52:	f8 94       	cli
    5d54:	de bf       	out	0x3e, r29	; 62
    5d56:	0f be       	out	0x3f, r0	; 63
    5d58:	cd bf       	out	0x3d, r28	; 61
    5d5a:	9e 83       	std	Y+6, r25	; 0x06
    5d5c:	8d 83       	std	Y+5, r24	; 0x05
    5d5e:	4f 83       	std	Y+7, r20	; 0x07
    5d60:	58 87       	std	Y+8, r21	; 0x08
    5d62:	69 87       	std	Y+9, r22	; 0x09
    5d64:	7a 87       	std	Y+10, r23	; 0x0a
    5d66:	2b 87       	std	Y+11, r18	; 0x0b
    5d68:	1d 87       	std	Y+13, r17	; 0x0d
    5d6a:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    5d6c:	81 e0       	ldi	r24, 0x01	; 1
    5d6e:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    5d70:	8d 81       	ldd	r24, Y+5	; 0x05
    5d72:	9e 81       	ldd	r25, Y+6	; 0x06
    5d74:	9c 83       	std	Y+4, r25	; 0x04
    5d76:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    5d78:	0f b6       	in	r0, 0x3f	; 63
    5d7a:	f8 94       	cli
    5d7c:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    5d7e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5d80:	9d 85       	ldd	r25, Y+13	; 0x0d
    5d82:	00 97       	sbiw	r24, 0x00	; 0
    5d84:	61 f0       	breq	.+24     	; 0x5d9e <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5d86:	eb 81       	ldd	r30, Y+3	; 0x03
    5d88:	fc 81       	ldd	r31, Y+4	; 0x04
    5d8a:	85 a5       	ldd	r24, Z+45	; 0x2d
    5d8c:	96 a5       	ldd	r25, Z+46	; 0x2e
    5d8e:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5d90:	b0 a9       	ldd	r27, Z+48	; 0x30
    5d92:	ec 85       	ldd	r30, Y+12	; 0x0c
    5d94:	fd 85       	ldd	r31, Y+13	; 0x0d
    5d96:	80 83       	st	Z, r24
    5d98:	91 83       	std	Z+1, r25	; 0x01
    5d9a:	a2 83       	std	Z+2, r26	; 0x02
    5d9c:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5d9e:	eb 81       	ldd	r30, Y+3	; 0x03
    5da0:	fc 81       	ldd	r31, Y+4	; 0x04
    5da2:	81 a9       	ldd	r24, Z+49	; 0x31
    5da4:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5da6:	eb 81       	ldd	r30, Y+3	; 0x03
    5da8:	fc 81       	ldd	r31, Y+4	; 0x04
    5daa:	82 e0       	ldi	r24, 0x02	; 2
    5dac:	81 ab       	std	Z+49, r24	; 0x31

			switch( eAction )
    5dae:	8b 85       	ldd	r24, Y+11	; 0x0b
    5db0:	28 2f       	mov	r18, r24
    5db2:	30 e0       	ldi	r19, 0x00	; 0
    5db4:	3f 87       	std	Y+15, r19	; 0x0f
    5db6:	2e 87       	std	Y+14, r18	; 0x0e
    5db8:	8e 85       	ldd	r24, Y+14	; 0x0e
    5dba:	9f 85       	ldd	r25, Y+15	; 0x0f
    5dbc:	82 30       	cpi	r24, 0x02	; 2
    5dbe:	91 05       	cpc	r25, r1
    5dc0:	59 f1       	breq	.+86     	; 0x5e18 <xTaskGenericNotify+0xd6>
    5dc2:	2e 85       	ldd	r18, Y+14	; 0x0e
    5dc4:	3f 85       	ldd	r19, Y+15	; 0x0f
    5dc6:	23 30       	cpi	r18, 0x03	; 3
    5dc8:	31 05       	cpc	r19, r1
    5dca:	34 f4       	brge	.+12     	; 0x5dd8 <xTaskGenericNotify+0x96>
    5dcc:	8e 85       	ldd	r24, Y+14	; 0x0e
    5dce:	9f 85       	ldd	r25, Y+15	; 0x0f
    5dd0:	81 30       	cpi	r24, 0x01	; 1
    5dd2:	91 05       	cpc	r25, r1
    5dd4:	61 f0       	breq	.+24     	; 0x5dee <xTaskGenericNotify+0xac>
    5dd6:	4a c0       	rjmp	.+148    	; 0x5e6c <xTaskGenericNotify+0x12a>
    5dd8:	2e 85       	ldd	r18, Y+14	; 0x0e
    5dda:	3f 85       	ldd	r19, Y+15	; 0x0f
    5ddc:	23 30       	cpi	r18, 0x03	; 3
    5dde:	31 05       	cpc	r19, r1
    5de0:	59 f1       	breq	.+86     	; 0x5e38 <xTaskGenericNotify+0xf6>
    5de2:	8e 85       	ldd	r24, Y+14	; 0x0e
    5de4:	9f 85       	ldd	r25, Y+15	; 0x0f
    5de6:	84 30       	cpi	r24, 0x04	; 4
    5de8:	91 05       	cpc	r25, r1
    5dea:	89 f1       	breq	.+98     	; 0x5e4e <xTaskGenericNotify+0x10c>
    5dec:	3f c0       	rjmp	.+126    	; 0x5e6c <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5dee:	eb 81       	ldd	r30, Y+3	; 0x03
    5df0:	fc 81       	ldd	r31, Y+4	; 0x04
    5df2:	25 a5       	ldd	r18, Z+45	; 0x2d
    5df4:	36 a5       	ldd	r19, Z+46	; 0x2e
    5df6:	47 a5       	ldd	r20, Z+47	; 0x2f
    5df8:	50 a9       	ldd	r21, Z+48	; 0x30
    5dfa:	8f 81       	ldd	r24, Y+7	; 0x07
    5dfc:	98 85       	ldd	r25, Y+8	; 0x08
    5dfe:	a9 85       	ldd	r26, Y+9	; 0x09
    5e00:	ba 85       	ldd	r27, Y+10	; 0x0a
    5e02:	82 2b       	or	r24, r18
    5e04:	93 2b       	or	r25, r19
    5e06:	a4 2b       	or	r26, r20
    5e08:	b5 2b       	or	r27, r21
    5e0a:	eb 81       	ldd	r30, Y+3	; 0x03
    5e0c:	fc 81       	ldd	r31, Y+4	; 0x04
    5e0e:	85 a7       	std	Z+45, r24	; 0x2d
    5e10:	96 a7       	std	Z+46, r25	; 0x2e
    5e12:	a7 a7       	std	Z+47, r26	; 0x2f
    5e14:	b0 ab       	std	Z+48, r27	; 0x30
    5e16:	2a c0       	rjmp	.+84     	; 0x5e6c <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5e18:	eb 81       	ldd	r30, Y+3	; 0x03
    5e1a:	fc 81       	ldd	r31, Y+4	; 0x04
    5e1c:	85 a5       	ldd	r24, Z+45	; 0x2d
    5e1e:	96 a5       	ldd	r25, Z+46	; 0x2e
    5e20:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5e22:	b0 a9       	ldd	r27, Z+48	; 0x30
    5e24:	01 96       	adiw	r24, 0x01	; 1
    5e26:	a1 1d       	adc	r26, r1
    5e28:	b1 1d       	adc	r27, r1
    5e2a:	eb 81       	ldd	r30, Y+3	; 0x03
    5e2c:	fc 81       	ldd	r31, Y+4	; 0x04
    5e2e:	85 a7       	std	Z+45, r24	; 0x2d
    5e30:	96 a7       	std	Z+46, r25	; 0x2e
    5e32:	a7 a7       	std	Z+47, r26	; 0x2f
    5e34:	b0 ab       	std	Z+48, r27	; 0x30
    5e36:	1a c0       	rjmp	.+52     	; 0x5e6c <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5e38:	eb 81       	ldd	r30, Y+3	; 0x03
    5e3a:	fc 81       	ldd	r31, Y+4	; 0x04
    5e3c:	8f 81       	ldd	r24, Y+7	; 0x07
    5e3e:	98 85       	ldd	r25, Y+8	; 0x08
    5e40:	a9 85       	ldd	r26, Y+9	; 0x09
    5e42:	ba 85       	ldd	r27, Y+10	; 0x0a
    5e44:	85 a7       	std	Z+45, r24	; 0x2d
    5e46:	96 a7       	std	Z+46, r25	; 0x2e
    5e48:	a7 a7       	std	Z+47, r26	; 0x2f
    5e4a:	b0 ab       	std	Z+48, r27	; 0x30
    5e4c:	0f c0       	rjmp	.+30     	; 0x5e6c <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5e4e:	89 81       	ldd	r24, Y+1	; 0x01
    5e50:	82 30       	cpi	r24, 0x02	; 2
    5e52:	59 f0       	breq	.+22     	; 0x5e6a <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5e54:	eb 81       	ldd	r30, Y+3	; 0x03
    5e56:	fc 81       	ldd	r31, Y+4	; 0x04
    5e58:	8f 81       	ldd	r24, Y+7	; 0x07
    5e5a:	98 85       	ldd	r25, Y+8	; 0x08
    5e5c:	a9 85       	ldd	r26, Y+9	; 0x09
    5e5e:	ba 85       	ldd	r27, Y+10	; 0x0a
    5e60:	85 a7       	std	Z+45, r24	; 0x2d
    5e62:	96 a7       	std	Z+46, r25	; 0x2e
    5e64:	a7 a7       	std	Z+47, r26	; 0x2f
    5e66:	b0 ab       	std	Z+48, r27	; 0x30
    5e68:	01 c0       	rjmp	.+2      	; 0x5e6c <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5e6a:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5e6c:	89 81       	ldd	r24, Y+1	; 0x01
    5e6e:	81 30       	cpi	r24, 0x01	; 1
    5e70:	b9 f5       	brne	.+110    	; 0x5ee0 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5e72:	8b 81       	ldd	r24, Y+3	; 0x03
    5e74:	9c 81       	ldd	r25, Y+4	; 0x04
    5e76:	02 96       	adiw	r24, 0x02	; 2
    5e78:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    5e7c:	eb 81       	ldd	r30, Y+3	; 0x03
    5e7e:	fc 81       	ldd	r31, Y+4	; 0x04
    5e80:	96 89       	ldd	r25, Z+22	; 0x16
    5e82:	80 91 ae 06 	lds	r24, 0x06AE
    5e86:	89 17       	cp	r24, r25
    5e88:	28 f4       	brcc	.+10     	; 0x5e94 <xTaskGenericNotify+0x152>
    5e8a:	eb 81       	ldd	r30, Y+3	; 0x03
    5e8c:	fc 81       	ldd	r31, Y+4	; 0x04
    5e8e:	86 89       	ldd	r24, Z+22	; 0x16
    5e90:	80 93 ae 06 	sts	0x06AE, r24
    5e94:	eb 81       	ldd	r30, Y+3	; 0x03
    5e96:	fc 81       	ldd	r31, Y+4	; 0x04
    5e98:	86 89       	ldd	r24, Z+22	; 0x16
    5e9a:	28 2f       	mov	r18, r24
    5e9c:	30 e0       	ldi	r19, 0x00	; 0
    5e9e:	c9 01       	movw	r24, r18
    5ea0:	88 0f       	add	r24, r24
    5ea2:	99 1f       	adc	r25, r25
    5ea4:	88 0f       	add	r24, r24
    5ea6:	99 1f       	adc	r25, r25
    5ea8:	88 0f       	add	r24, r24
    5eaa:	99 1f       	adc	r25, r25
    5eac:	82 0f       	add	r24, r18
    5eae:	93 1f       	adc	r25, r19
    5eb0:	ac 01       	movw	r20, r24
    5eb2:	47 54       	subi	r20, 0x47	; 71
    5eb4:	59 4f       	sbci	r21, 0xF9	; 249
    5eb6:	8b 81       	ldd	r24, Y+3	; 0x03
    5eb8:	9c 81       	ldd	r25, Y+4	; 0x04
    5eba:	9c 01       	movw	r18, r24
    5ebc:	2e 5f       	subi	r18, 0xFE	; 254
    5ebe:	3f 4f       	sbci	r19, 0xFF	; 255
    5ec0:	ca 01       	movw	r24, r20
    5ec2:	b9 01       	movw	r22, r18
    5ec4:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5ec8:	eb 81       	ldd	r30, Y+3	; 0x03
    5eca:	fc 81       	ldd	r31, Y+4	; 0x04
    5ecc:	96 89       	ldd	r25, Z+22	; 0x16
    5ece:	e0 91 a8 06 	lds	r30, 0x06A8
    5ed2:	f0 91 a9 06 	lds	r31, 0x06A9
    5ed6:	86 89       	ldd	r24, Z+22	; 0x16
    5ed8:	89 17       	cp	r24, r25
    5eda:	10 f4       	brcc	.+4      	; 0x5ee0 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    5edc:	0e 94 ce 14 	call	0x299c	; 0x299c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5ee0:	0f 90       	pop	r0
    5ee2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5ee4:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    5ee6:	2f 96       	adiw	r28, 0x0f	; 15
    5ee8:	0f b6       	in	r0, 0x3f	; 63
    5eea:	f8 94       	cli
    5eec:	de bf       	out	0x3e, r29	; 62
    5eee:	0f be       	out	0x3f, r0	; 63
    5ef0:	cd bf       	out	0x3d, r28	; 61
    5ef2:	cf 91       	pop	r28
    5ef4:	df 91       	pop	r29
    5ef6:	1f 91       	pop	r17
    5ef8:	0f 91       	pop	r16
    5efa:	08 95       	ret

00005efc <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5efc:	ef 92       	push	r14
    5efe:	ff 92       	push	r15
    5f00:	0f 93       	push	r16
    5f02:	1f 93       	push	r17
    5f04:	df 93       	push	r29
    5f06:	cf 93       	push	r28
    5f08:	cd b7       	in	r28, 0x3d	; 61
    5f0a:	de b7       	in	r29, 0x3e	; 62
    5f0c:	62 97       	sbiw	r28, 0x12	; 18
    5f0e:	0f b6       	in	r0, 0x3f	; 63
    5f10:	f8 94       	cli
    5f12:	de bf       	out	0x3e, r29	; 62
    5f14:	0f be       	out	0x3f, r0	; 63
    5f16:	cd bf       	out	0x3d, r28	; 61
    5f18:	9f 83       	std	Y+7, r25	; 0x07
    5f1a:	8e 83       	std	Y+6, r24	; 0x06
    5f1c:	48 87       	std	Y+8, r20	; 0x08
    5f1e:	59 87       	std	Y+9, r21	; 0x09
    5f20:	6a 87       	std	Y+10, r22	; 0x0a
    5f22:	7b 87       	std	Y+11, r23	; 0x0b
    5f24:	2c 87       	std	Y+12, r18	; 0x0c
    5f26:	1e 87       	std	Y+14, r17	; 0x0e
    5f28:	0d 87       	std	Y+13, r16	; 0x0d
    5f2a:	f8 8a       	std	Y+16, r15	; 0x10
    5f2c:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5f2e:	81 e0       	ldi	r24, 0x01	; 1
    5f30:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5f32:	8e 81       	ldd	r24, Y+6	; 0x06
    5f34:	9f 81       	ldd	r25, Y+7	; 0x07
    5f36:	9d 83       	std	Y+5, r25	; 0x05
    5f38:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5f3a:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    5f3c:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f3e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5f40:	00 97       	sbiw	r24, 0x00	; 0
    5f42:	61 f0       	breq	.+24     	; 0x5f5c <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5f44:	ec 81       	ldd	r30, Y+4	; 0x04
    5f46:	fd 81       	ldd	r31, Y+5	; 0x05
    5f48:	85 a5       	ldd	r24, Z+45	; 0x2d
    5f4a:	96 a5       	ldd	r25, Z+46	; 0x2e
    5f4c:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5f4e:	b0 a9       	ldd	r27, Z+48	; 0x30
    5f50:	ed 85       	ldd	r30, Y+13	; 0x0d
    5f52:	fe 85       	ldd	r31, Y+14	; 0x0e
    5f54:	80 83       	st	Z, r24
    5f56:	91 83       	std	Z+1, r25	; 0x01
    5f58:	a2 83       	std	Z+2, r26	; 0x02
    5f5a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5f5c:	ec 81       	ldd	r30, Y+4	; 0x04
    5f5e:	fd 81       	ldd	r31, Y+5	; 0x05
    5f60:	81 a9       	ldd	r24, Z+49	; 0x31
    5f62:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5f64:	ec 81       	ldd	r30, Y+4	; 0x04
    5f66:	fd 81       	ldd	r31, Y+5	; 0x05
    5f68:	82 e0       	ldi	r24, 0x02	; 2
    5f6a:	81 ab       	std	Z+49, r24	; 0x31

			switch( eAction )
    5f6c:	8c 85       	ldd	r24, Y+12	; 0x0c
    5f6e:	28 2f       	mov	r18, r24
    5f70:	30 e0       	ldi	r19, 0x00	; 0
    5f72:	3a 8b       	std	Y+18, r19	; 0x12
    5f74:	29 8b       	std	Y+17, r18	; 0x11
    5f76:	89 89       	ldd	r24, Y+17	; 0x11
    5f78:	9a 89       	ldd	r25, Y+18	; 0x12
    5f7a:	82 30       	cpi	r24, 0x02	; 2
    5f7c:	91 05       	cpc	r25, r1
    5f7e:	59 f1       	breq	.+86     	; 0x5fd6 <xTaskGenericNotifyFromISR+0xda>
    5f80:	29 89       	ldd	r18, Y+17	; 0x11
    5f82:	3a 89       	ldd	r19, Y+18	; 0x12
    5f84:	23 30       	cpi	r18, 0x03	; 3
    5f86:	31 05       	cpc	r19, r1
    5f88:	34 f4       	brge	.+12     	; 0x5f96 <xTaskGenericNotifyFromISR+0x9a>
    5f8a:	89 89       	ldd	r24, Y+17	; 0x11
    5f8c:	9a 89       	ldd	r25, Y+18	; 0x12
    5f8e:	81 30       	cpi	r24, 0x01	; 1
    5f90:	91 05       	cpc	r25, r1
    5f92:	61 f0       	breq	.+24     	; 0x5fac <xTaskGenericNotifyFromISR+0xb0>
    5f94:	4a c0       	rjmp	.+148    	; 0x602a <xTaskGenericNotifyFromISR+0x12e>
    5f96:	29 89       	ldd	r18, Y+17	; 0x11
    5f98:	3a 89       	ldd	r19, Y+18	; 0x12
    5f9a:	23 30       	cpi	r18, 0x03	; 3
    5f9c:	31 05       	cpc	r19, r1
    5f9e:	59 f1       	breq	.+86     	; 0x5ff6 <xTaskGenericNotifyFromISR+0xfa>
    5fa0:	89 89       	ldd	r24, Y+17	; 0x11
    5fa2:	9a 89       	ldd	r25, Y+18	; 0x12
    5fa4:	84 30       	cpi	r24, 0x04	; 4
    5fa6:	91 05       	cpc	r25, r1
    5fa8:	89 f1       	breq	.+98     	; 0x600c <xTaskGenericNotifyFromISR+0x110>
    5faa:	3f c0       	rjmp	.+126    	; 0x602a <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5fac:	ec 81       	ldd	r30, Y+4	; 0x04
    5fae:	fd 81       	ldd	r31, Y+5	; 0x05
    5fb0:	25 a5       	ldd	r18, Z+45	; 0x2d
    5fb2:	36 a5       	ldd	r19, Z+46	; 0x2e
    5fb4:	47 a5       	ldd	r20, Z+47	; 0x2f
    5fb6:	50 a9       	ldd	r21, Z+48	; 0x30
    5fb8:	88 85       	ldd	r24, Y+8	; 0x08
    5fba:	99 85       	ldd	r25, Y+9	; 0x09
    5fbc:	aa 85       	ldd	r26, Y+10	; 0x0a
    5fbe:	bb 85       	ldd	r27, Y+11	; 0x0b
    5fc0:	82 2b       	or	r24, r18
    5fc2:	93 2b       	or	r25, r19
    5fc4:	a4 2b       	or	r26, r20
    5fc6:	b5 2b       	or	r27, r21
    5fc8:	ec 81       	ldd	r30, Y+4	; 0x04
    5fca:	fd 81       	ldd	r31, Y+5	; 0x05
    5fcc:	85 a7       	std	Z+45, r24	; 0x2d
    5fce:	96 a7       	std	Z+46, r25	; 0x2e
    5fd0:	a7 a7       	std	Z+47, r26	; 0x2f
    5fd2:	b0 ab       	std	Z+48, r27	; 0x30
    5fd4:	2a c0       	rjmp	.+84     	; 0x602a <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5fd6:	ec 81       	ldd	r30, Y+4	; 0x04
    5fd8:	fd 81       	ldd	r31, Y+5	; 0x05
    5fda:	85 a5       	ldd	r24, Z+45	; 0x2d
    5fdc:	96 a5       	ldd	r25, Z+46	; 0x2e
    5fde:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5fe0:	b0 a9       	ldd	r27, Z+48	; 0x30
    5fe2:	01 96       	adiw	r24, 0x01	; 1
    5fe4:	a1 1d       	adc	r26, r1
    5fe6:	b1 1d       	adc	r27, r1
    5fe8:	ec 81       	ldd	r30, Y+4	; 0x04
    5fea:	fd 81       	ldd	r31, Y+5	; 0x05
    5fec:	85 a7       	std	Z+45, r24	; 0x2d
    5fee:	96 a7       	std	Z+46, r25	; 0x2e
    5ff0:	a7 a7       	std	Z+47, r26	; 0x2f
    5ff2:	b0 ab       	std	Z+48, r27	; 0x30
    5ff4:	1a c0       	rjmp	.+52     	; 0x602a <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5ff6:	ec 81       	ldd	r30, Y+4	; 0x04
    5ff8:	fd 81       	ldd	r31, Y+5	; 0x05
    5ffa:	88 85       	ldd	r24, Y+8	; 0x08
    5ffc:	99 85       	ldd	r25, Y+9	; 0x09
    5ffe:	aa 85       	ldd	r26, Y+10	; 0x0a
    6000:	bb 85       	ldd	r27, Y+11	; 0x0b
    6002:	85 a7       	std	Z+45, r24	; 0x2d
    6004:	96 a7       	std	Z+46, r25	; 0x2e
    6006:	a7 a7       	std	Z+47, r26	; 0x2f
    6008:	b0 ab       	std	Z+48, r27	; 0x30
    600a:	0f c0       	rjmp	.+30     	; 0x602a <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    600c:	8b 81       	ldd	r24, Y+3	; 0x03
    600e:	82 30       	cpi	r24, 0x02	; 2
    6010:	59 f0       	breq	.+22     	; 0x6028 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    6012:	ec 81       	ldd	r30, Y+4	; 0x04
    6014:	fd 81       	ldd	r31, Y+5	; 0x05
    6016:	88 85       	ldd	r24, Y+8	; 0x08
    6018:	99 85       	ldd	r25, Y+9	; 0x09
    601a:	aa 85       	ldd	r26, Y+10	; 0x0a
    601c:	bb 85       	ldd	r27, Y+11	; 0x0b
    601e:	85 a7       	std	Z+45, r24	; 0x2d
    6020:	96 a7       	std	Z+46, r25	; 0x2e
    6022:	a7 a7       	std	Z+47, r26	; 0x2f
    6024:	b0 ab       	std	Z+48, r27	; 0x30
    6026:	01 c0       	rjmp	.+2      	; 0x602a <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    6028:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    602a:	8b 81       	ldd	r24, Y+3	; 0x03
    602c:	81 30       	cpi	r24, 0x01	; 1
    602e:	09 f0       	breq	.+2      	; 0x6032 <xTaskGenericNotifyFromISR+0x136>
    6030:	4f c0       	rjmp	.+158    	; 0x60d0 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6032:	80 91 b8 06 	lds	r24, 0x06B8
    6036:	88 23       	and	r24, r24
    6038:	61 f5       	brne	.+88     	; 0x6092 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    603a:	8c 81       	ldd	r24, Y+4	; 0x04
    603c:	9d 81       	ldd	r25, Y+5	; 0x05
    603e:	02 96       	adiw	r24, 0x02	; 2
    6040:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6044:	ec 81       	ldd	r30, Y+4	; 0x04
    6046:	fd 81       	ldd	r31, Y+5	; 0x05
    6048:	96 89       	ldd	r25, Z+22	; 0x16
    604a:	80 91 ae 06 	lds	r24, 0x06AE
    604e:	89 17       	cp	r24, r25
    6050:	28 f4       	brcc	.+10     	; 0x605c <xTaskGenericNotifyFromISR+0x160>
    6052:	ec 81       	ldd	r30, Y+4	; 0x04
    6054:	fd 81       	ldd	r31, Y+5	; 0x05
    6056:	86 89       	ldd	r24, Z+22	; 0x16
    6058:	80 93 ae 06 	sts	0x06AE, r24
    605c:	ec 81       	ldd	r30, Y+4	; 0x04
    605e:	fd 81       	ldd	r31, Y+5	; 0x05
    6060:	86 89       	ldd	r24, Z+22	; 0x16
    6062:	28 2f       	mov	r18, r24
    6064:	30 e0       	ldi	r19, 0x00	; 0
    6066:	c9 01       	movw	r24, r18
    6068:	88 0f       	add	r24, r24
    606a:	99 1f       	adc	r25, r25
    606c:	88 0f       	add	r24, r24
    606e:	99 1f       	adc	r25, r25
    6070:	88 0f       	add	r24, r24
    6072:	99 1f       	adc	r25, r25
    6074:	82 0f       	add	r24, r18
    6076:	93 1f       	adc	r25, r19
    6078:	ac 01       	movw	r20, r24
    607a:	47 54       	subi	r20, 0x47	; 71
    607c:	59 4f       	sbci	r21, 0xF9	; 249
    607e:	8c 81       	ldd	r24, Y+4	; 0x04
    6080:	9d 81       	ldd	r25, Y+5	; 0x05
    6082:	9c 01       	movw	r18, r24
    6084:	2e 5f       	subi	r18, 0xFE	; 254
    6086:	3f 4f       	sbci	r19, 0xFF	; 255
    6088:	ca 01       	movw	r24, r20
    608a:	b9 01       	movw	r22, r18
    608c:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>
    6090:	0a c0       	rjmp	.+20     	; 0x60a6 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    6092:	8c 81       	ldd	r24, Y+4	; 0x04
    6094:	9d 81       	ldd	r25, Y+5	; 0x05
    6096:	9c 01       	movw	r18, r24
    6098:	24 5f       	subi	r18, 0xF4	; 244
    609a:	3f 4f       	sbci	r19, 0xFF	; 255
    609c:	8c ef       	ldi	r24, 0xFC	; 252
    609e:	96 e0       	ldi	r25, 0x06	; 6
    60a0:	b9 01       	movw	r22, r18
    60a2:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    60a6:	ec 81       	ldd	r30, Y+4	; 0x04
    60a8:	fd 81       	ldd	r31, Y+5	; 0x05
    60aa:	96 89       	ldd	r25, Z+22	; 0x16
    60ac:	e0 91 a8 06 	lds	r30, 0x06A8
    60b0:	f0 91 a9 06 	lds	r31, 0x06A9
    60b4:	86 89       	ldd	r24, Z+22	; 0x16
    60b6:	89 17       	cp	r24, r25
    60b8:	58 f4       	brcc	.+22     	; 0x60d0 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    60ba:	8f 85       	ldd	r24, Y+15	; 0x0f
    60bc:	98 89       	ldd	r25, Y+16	; 0x10
    60be:	00 97       	sbiw	r24, 0x00	; 0
    60c0:	21 f0       	breq	.+8      	; 0x60ca <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    60c2:	ef 85       	ldd	r30, Y+15	; 0x0f
    60c4:	f8 89       	ldd	r31, Y+16	; 0x10
    60c6:	81 e0       	ldi	r24, 0x01	; 1
    60c8:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    60ca:	81 e0       	ldi	r24, 0x01	; 1
    60cc:	80 93 b1 06 	sts	0x06B1, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    60d0:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    60d2:	62 96       	adiw	r28, 0x12	; 18
    60d4:	0f b6       	in	r0, 0x3f	; 63
    60d6:	f8 94       	cli
    60d8:	de bf       	out	0x3e, r29	; 62
    60da:	0f be       	out	0x3f, r0	; 63
    60dc:	cd bf       	out	0x3d, r28	; 61
    60de:	cf 91       	pop	r28
    60e0:	df 91       	pop	r29
    60e2:	1f 91       	pop	r17
    60e4:	0f 91       	pop	r16
    60e6:	ff 90       	pop	r15
    60e8:	ef 90       	pop	r14
    60ea:	08 95       	ret

000060ec <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    60ec:	df 93       	push	r29
    60ee:	cf 93       	push	r28
    60f0:	cd b7       	in	r28, 0x3d	; 61
    60f2:	de b7       	in	r29, 0x3e	; 62
    60f4:	28 97       	sbiw	r28, 0x08	; 8
    60f6:	0f b6       	in	r0, 0x3f	; 63
    60f8:	f8 94       	cli
    60fa:	de bf       	out	0x3e, r29	; 62
    60fc:	0f be       	out	0x3f, r0	; 63
    60fe:	cd bf       	out	0x3d, r28	; 61
    6100:	9e 83       	std	Y+6, r25	; 0x06
    6102:	8d 83       	std	Y+5, r24	; 0x05
    6104:	78 87       	std	Y+8, r23	; 0x08
    6106:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    6108:	8d 81       	ldd	r24, Y+5	; 0x05
    610a:	9e 81       	ldd	r25, Y+6	; 0x06
    610c:	9c 83       	std	Y+4, r25	; 0x04
    610e:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    6110:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    6112:	eb 81       	ldd	r30, Y+3	; 0x03
    6114:	fc 81       	ldd	r31, Y+4	; 0x04
    6116:	81 a9       	ldd	r24, Z+49	; 0x31
    6118:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    611a:	eb 81       	ldd	r30, Y+3	; 0x03
    611c:	fc 81       	ldd	r31, Y+4	; 0x04
    611e:	82 e0       	ldi	r24, 0x02	; 2
    6120:	81 ab       	std	Z+49, r24	; 0x31

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    6122:	eb 81       	ldd	r30, Y+3	; 0x03
    6124:	fc 81       	ldd	r31, Y+4	; 0x04
    6126:	85 a5       	ldd	r24, Z+45	; 0x2d
    6128:	96 a5       	ldd	r25, Z+46	; 0x2e
    612a:	a7 a5       	ldd	r26, Z+47	; 0x2f
    612c:	b0 a9       	ldd	r27, Z+48	; 0x30
    612e:	01 96       	adiw	r24, 0x01	; 1
    6130:	a1 1d       	adc	r26, r1
    6132:	b1 1d       	adc	r27, r1
    6134:	eb 81       	ldd	r30, Y+3	; 0x03
    6136:	fc 81       	ldd	r31, Y+4	; 0x04
    6138:	85 a7       	std	Z+45, r24	; 0x2d
    613a:	96 a7       	std	Z+46, r25	; 0x2e
    613c:	a7 a7       	std	Z+47, r26	; 0x2f
    613e:	b0 ab       	std	Z+48, r27	; 0x30

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    6140:	8a 81       	ldd	r24, Y+2	; 0x02
    6142:	81 30       	cpi	r24, 0x01	; 1
    6144:	09 f0       	breq	.+2      	; 0x6148 <vTaskNotifyGiveFromISR+0x5c>
    6146:	4f c0       	rjmp	.+158    	; 0x61e6 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6148:	80 91 b8 06 	lds	r24, 0x06B8
    614c:	88 23       	and	r24, r24
    614e:	61 f5       	brne	.+88     	; 0x61a8 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6150:	8b 81       	ldd	r24, Y+3	; 0x03
    6152:	9c 81       	ldd	r25, Y+4	; 0x04
    6154:	02 96       	adiw	r24, 0x02	; 2
    6156:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    615a:	eb 81       	ldd	r30, Y+3	; 0x03
    615c:	fc 81       	ldd	r31, Y+4	; 0x04
    615e:	96 89       	ldd	r25, Z+22	; 0x16
    6160:	80 91 ae 06 	lds	r24, 0x06AE
    6164:	89 17       	cp	r24, r25
    6166:	28 f4       	brcc	.+10     	; 0x6172 <vTaskNotifyGiveFromISR+0x86>
    6168:	eb 81       	ldd	r30, Y+3	; 0x03
    616a:	fc 81       	ldd	r31, Y+4	; 0x04
    616c:	86 89       	ldd	r24, Z+22	; 0x16
    616e:	80 93 ae 06 	sts	0x06AE, r24
    6172:	eb 81       	ldd	r30, Y+3	; 0x03
    6174:	fc 81       	ldd	r31, Y+4	; 0x04
    6176:	86 89       	ldd	r24, Z+22	; 0x16
    6178:	28 2f       	mov	r18, r24
    617a:	30 e0       	ldi	r19, 0x00	; 0
    617c:	c9 01       	movw	r24, r18
    617e:	88 0f       	add	r24, r24
    6180:	99 1f       	adc	r25, r25
    6182:	88 0f       	add	r24, r24
    6184:	99 1f       	adc	r25, r25
    6186:	88 0f       	add	r24, r24
    6188:	99 1f       	adc	r25, r25
    618a:	82 0f       	add	r24, r18
    618c:	93 1f       	adc	r25, r19
    618e:	ac 01       	movw	r20, r24
    6190:	47 54       	subi	r20, 0x47	; 71
    6192:	59 4f       	sbci	r21, 0xF9	; 249
    6194:	8b 81       	ldd	r24, Y+3	; 0x03
    6196:	9c 81       	ldd	r25, Y+4	; 0x04
    6198:	9c 01       	movw	r18, r24
    619a:	2e 5f       	subi	r18, 0xFE	; 254
    619c:	3f 4f       	sbci	r19, 0xFF	; 255
    619e:	ca 01       	movw	r24, r20
    61a0:	b9 01       	movw	r22, r18
    61a2:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>
    61a6:	0a c0       	rjmp	.+20     	; 0x61bc <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    61a8:	8b 81       	ldd	r24, Y+3	; 0x03
    61aa:	9c 81       	ldd	r25, Y+4	; 0x04
    61ac:	9c 01       	movw	r18, r24
    61ae:	24 5f       	subi	r18, 0xF4	; 244
    61b0:	3f 4f       	sbci	r19, 0xFF	; 255
    61b2:	8c ef       	ldi	r24, 0xFC	; 252
    61b4:	96 e0       	ldi	r25, 0x06	; 6
    61b6:	b9 01       	movw	r22, r18
    61b8:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    61bc:	eb 81       	ldd	r30, Y+3	; 0x03
    61be:	fc 81       	ldd	r31, Y+4	; 0x04
    61c0:	96 89       	ldd	r25, Z+22	; 0x16
    61c2:	e0 91 a8 06 	lds	r30, 0x06A8
    61c6:	f0 91 a9 06 	lds	r31, 0x06A9
    61ca:	86 89       	ldd	r24, Z+22	; 0x16
    61cc:	89 17       	cp	r24, r25
    61ce:	58 f4       	brcc	.+22     	; 0x61e6 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    61d0:	8f 81       	ldd	r24, Y+7	; 0x07
    61d2:	98 85       	ldd	r25, Y+8	; 0x08
    61d4:	00 97       	sbiw	r24, 0x00	; 0
    61d6:	21 f0       	breq	.+8      	; 0x61e0 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    61d8:	ef 81       	ldd	r30, Y+7	; 0x07
    61da:	f8 85       	ldd	r31, Y+8	; 0x08
    61dc:	81 e0       	ldi	r24, 0x01	; 1
    61de:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    61e0:	81 e0       	ldi	r24, 0x01	; 1
    61e2:	80 93 b1 06 	sts	0x06B1, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    61e6:	28 96       	adiw	r28, 0x08	; 8
    61e8:	0f b6       	in	r0, 0x3f	; 63
    61ea:	f8 94       	cli
    61ec:	de bf       	out	0x3e, r29	; 62
    61ee:	0f be       	out	0x3f, r0	; 63
    61f0:	cd bf       	out	0x3d, r28	; 61
    61f2:	cf 91       	pop	r28
    61f4:	df 91       	pop	r29
    61f6:	08 95       	ret

000061f8 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    61f8:	df 93       	push	r29
    61fa:	cf 93       	push	r28
    61fc:	cd b7       	in	r28, 0x3d	; 61
    61fe:	de b7       	in	r29, 0x3e	; 62
    6200:	27 97       	sbiw	r28, 0x07	; 7
    6202:	0f b6       	in	r0, 0x3f	; 63
    6204:	f8 94       	cli
    6206:	de bf       	out	0x3e, r29	; 62
    6208:	0f be       	out	0x3f, r0	; 63
    620a:	cd bf       	out	0x3d, r28	; 61
    620c:	9d 83       	std	Y+5, r25	; 0x05
    620e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    6210:	8c 81       	ldd	r24, Y+4	; 0x04
    6212:	9d 81       	ldd	r25, Y+5	; 0x05
    6214:	00 97       	sbiw	r24, 0x00	; 0
    6216:	39 f4       	brne	.+14     	; 0x6226 <xTaskNotifyStateClear+0x2e>
    6218:	80 91 a8 06 	lds	r24, 0x06A8
    621c:	90 91 a9 06 	lds	r25, 0x06A9
    6220:	9f 83       	std	Y+7, r25	; 0x07
    6222:	8e 83       	std	Y+6, r24	; 0x06
    6224:	04 c0       	rjmp	.+8      	; 0x622e <xTaskNotifyStateClear+0x36>
    6226:	8c 81       	ldd	r24, Y+4	; 0x04
    6228:	9d 81       	ldd	r25, Y+5	; 0x05
    622a:	9f 83       	std	Y+7, r25	; 0x07
    622c:	8e 83       	std	Y+6, r24	; 0x06
    622e:	8e 81       	ldd	r24, Y+6	; 0x06
    6230:	9f 81       	ldd	r25, Y+7	; 0x07
    6232:	9b 83       	std	Y+3, r25	; 0x03
    6234:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    6236:	0f b6       	in	r0, 0x3f	; 63
    6238:	f8 94       	cli
    623a:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    623c:	ea 81       	ldd	r30, Y+2	; 0x02
    623e:	fb 81       	ldd	r31, Y+3	; 0x03
    6240:	81 a9       	ldd	r24, Z+49	; 0x31
    6242:	82 30       	cpi	r24, 0x02	; 2
    6244:	31 f4       	brne	.+12     	; 0x6252 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    6246:	ea 81       	ldd	r30, Y+2	; 0x02
    6248:	fb 81       	ldd	r31, Y+3	; 0x03
    624a:	11 aa       	std	Z+49, r1	; 0x31
				xReturn = pdPASS;
    624c:	81 e0       	ldi	r24, 0x01	; 1
    624e:	89 83       	std	Y+1, r24	; 0x01
    6250:	01 c0       	rjmp	.+2      	; 0x6254 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    6252:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    6254:	0f 90       	pop	r0
    6256:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    6258:	89 81       	ldd	r24, Y+1	; 0x01
	}
    625a:	27 96       	adiw	r28, 0x07	; 7
    625c:	0f b6       	in	r0, 0x3f	; 63
    625e:	f8 94       	cli
    6260:	de bf       	out	0x3e, r29	; 62
    6262:	0f be       	out	0x3f, r0	; 63
    6264:	cd bf       	out	0x3d, r28	; 61
    6266:	cf 91       	pop	r28
    6268:	df 91       	pop	r29
    626a:	08 95       	ret

0000626c <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    626c:	df 93       	push	r29
    626e:	cf 93       	push	r28
    6270:	cd b7       	in	r28, 0x3d	; 61
    6272:	de b7       	in	r29, 0x3e	; 62
    6274:	27 97       	sbiw	r28, 0x07	; 7
    6276:	0f b6       	in	r0, 0x3f	; 63
    6278:	f8 94       	cli
    627a:	de bf       	out	0x3e, r29	; 62
    627c:	0f be       	out	0x3f, r0	; 63
    627e:	cd bf       	out	0x3d, r28	; 61
    6280:	9e 83       	std	Y+6, r25	; 0x06
    6282:	8d 83       	std	Y+5, r24	; 0x05
    6284:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    6286:	80 91 ac 06 	lds	r24, 0x06AC
    628a:	90 91 ad 06 	lds	r25, 0x06AD
    628e:	9a 83       	std	Y+2, r25	; 0x02
    6290:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6292:	80 91 a8 06 	lds	r24, 0x06A8
    6296:	90 91 a9 06 	lds	r25, 0x06A9
    629a:	02 96       	adiw	r24, 0x02	; 2
    629c:	0e 94 a6 12 	call	0x254c	; 0x254c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    62a0:	8d 81       	ldd	r24, Y+5	; 0x05
    62a2:	9e 81       	ldd	r25, Y+6	; 0x06
    62a4:	2f ef       	ldi	r18, 0xFF	; 255
    62a6:	8f 3f       	cpi	r24, 0xFF	; 255
    62a8:	92 07       	cpc	r25, r18
    62aa:	81 f4       	brne	.+32     	; 0x62cc <prvAddCurrentTaskToDelayedList+0x60>
    62ac:	8f 81       	ldd	r24, Y+7	; 0x07
    62ae:	88 23       	and	r24, r24
    62b0:	69 f0       	breq	.+26     	; 0x62cc <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    62b2:	80 91 a8 06 	lds	r24, 0x06A8
    62b6:	90 91 a9 06 	lds	r25, 0x06A9
    62ba:	9c 01       	movw	r18, r24
    62bc:	2e 5f       	subi	r18, 0xFE	; 254
    62be:	3f 4f       	sbci	r19, 0xFF	; 255
    62c0:	8e e0       	ldi	r24, 0x0E	; 14
    62c2:	97 e0       	ldi	r25, 0x07	; 7
    62c4:	b9 01       	movw	r22, r18
    62c6:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInsertEnd>
    62ca:	43 c0       	rjmp	.+134    	; 0x6352 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    62cc:	29 81       	ldd	r18, Y+1	; 0x01
    62ce:	3a 81       	ldd	r19, Y+2	; 0x02
    62d0:	8d 81       	ldd	r24, Y+5	; 0x05
    62d2:	9e 81       	ldd	r25, Y+6	; 0x06
    62d4:	82 0f       	add	r24, r18
    62d6:	93 1f       	adc	r25, r19
    62d8:	9c 83       	std	Y+4, r25	; 0x04
    62da:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    62dc:	e0 91 a8 06 	lds	r30, 0x06A8
    62e0:	f0 91 a9 06 	lds	r31, 0x06A9
    62e4:	8b 81       	ldd	r24, Y+3	; 0x03
    62e6:	9c 81       	ldd	r25, Y+4	; 0x04
    62e8:	93 83       	std	Z+3, r25	; 0x03
    62ea:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    62ec:	2b 81       	ldd	r18, Y+3	; 0x03
    62ee:	3c 81       	ldd	r19, Y+4	; 0x04
    62f0:	89 81       	ldd	r24, Y+1	; 0x01
    62f2:	9a 81       	ldd	r25, Y+2	; 0x02
    62f4:	28 17       	cp	r18, r24
    62f6:	39 07       	cpc	r19, r25
    62f8:	70 f4       	brcc	.+28     	; 0x6316 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    62fa:	80 91 fa 06 	lds	r24, 0x06FA
    62fe:	90 91 fb 06 	lds	r25, 0x06FB
    6302:	20 91 a8 06 	lds	r18, 0x06A8
    6306:	30 91 a9 06 	lds	r19, 0x06A9
    630a:	2e 5f       	subi	r18, 0xFE	; 254
    630c:	3f 4f       	sbci	r19, 0xFF	; 255
    630e:	b9 01       	movw	r22, r18
    6310:	0e 94 3a 12 	call	0x2474	; 0x2474 <vListInsert>
    6314:	1e c0       	rjmp	.+60     	; 0x6352 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6316:	40 91 f8 06 	lds	r20, 0x06F8
    631a:	50 91 f9 06 	lds	r21, 0x06F9
    631e:	80 91 a8 06 	lds	r24, 0x06A8
    6322:	90 91 a9 06 	lds	r25, 0x06A9
    6326:	9c 01       	movw	r18, r24
    6328:	2e 5f       	subi	r18, 0xFE	; 254
    632a:	3f 4f       	sbci	r19, 0xFF	; 255
    632c:	ca 01       	movw	r24, r20
    632e:	b9 01       	movw	r22, r18
    6330:	0e 94 3a 12 	call	0x2474	; 0x2474 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    6334:	20 91 b4 06 	lds	r18, 0x06B4
    6338:	30 91 b5 06 	lds	r19, 0x06B5
    633c:	8b 81       	ldd	r24, Y+3	; 0x03
    633e:	9c 81       	ldd	r25, Y+4	; 0x04
    6340:	82 17       	cp	r24, r18
    6342:	93 07       	cpc	r25, r19
    6344:	30 f4       	brcc	.+12     	; 0x6352 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    6346:	8b 81       	ldd	r24, Y+3	; 0x03
    6348:	9c 81       	ldd	r25, Y+4	; 0x04
    634a:	90 93 b5 06 	sts	0x06B5, r25
    634e:	80 93 b4 06 	sts	0x06B4, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    6352:	27 96       	adiw	r28, 0x07	; 7
    6354:	0f b6       	in	r0, 0x3f	; 63
    6356:	f8 94       	cli
    6358:	de bf       	out	0x3e, r29	; 62
    635a:	0f be       	out	0x3f, r0	; 63
    635c:	cd bf       	out	0x3d, r28	; 61
    635e:	cf 91       	pop	r28
    6360:	df 91       	pop	r29
    6362:	08 95       	ret

00006364 <__mulsi3>:
    6364:	62 9f       	mul	r22, r18
    6366:	d0 01       	movw	r26, r0
    6368:	73 9f       	mul	r23, r19
    636a:	f0 01       	movw	r30, r0
    636c:	82 9f       	mul	r24, r18
    636e:	e0 0d       	add	r30, r0
    6370:	f1 1d       	adc	r31, r1
    6372:	64 9f       	mul	r22, r20
    6374:	e0 0d       	add	r30, r0
    6376:	f1 1d       	adc	r31, r1
    6378:	92 9f       	mul	r25, r18
    637a:	f0 0d       	add	r31, r0
    637c:	83 9f       	mul	r24, r19
    637e:	f0 0d       	add	r31, r0
    6380:	74 9f       	mul	r23, r20
    6382:	f0 0d       	add	r31, r0
    6384:	65 9f       	mul	r22, r21
    6386:	f0 0d       	add	r31, r0
    6388:	99 27       	eor	r25, r25
    638a:	72 9f       	mul	r23, r18
    638c:	b0 0d       	add	r27, r0
    638e:	e1 1d       	adc	r30, r1
    6390:	f9 1f       	adc	r31, r25
    6392:	63 9f       	mul	r22, r19
    6394:	b0 0d       	add	r27, r0
    6396:	e1 1d       	adc	r30, r1
    6398:	f9 1f       	adc	r31, r25
    639a:	bd 01       	movw	r22, r26
    639c:	cf 01       	movw	r24, r30
    639e:	11 24       	eor	r1, r1
    63a0:	08 95       	ret

000063a2 <__udivmodqi4>:
    63a2:	99 1b       	sub	r25, r25
    63a4:	79 e0       	ldi	r23, 0x09	; 9
    63a6:	04 c0       	rjmp	.+8      	; 0x63b0 <__udivmodqi4_ep>

000063a8 <__udivmodqi4_loop>:
    63a8:	99 1f       	adc	r25, r25
    63aa:	96 17       	cp	r25, r22
    63ac:	08 f0       	brcs	.+2      	; 0x63b0 <__udivmodqi4_ep>
    63ae:	96 1b       	sub	r25, r22

000063b0 <__udivmodqi4_ep>:
    63b0:	88 1f       	adc	r24, r24
    63b2:	7a 95       	dec	r23
    63b4:	c9 f7       	brne	.-14     	; 0x63a8 <__udivmodqi4_loop>
    63b6:	80 95       	com	r24
    63b8:	08 95       	ret

000063ba <__udivmodsi4>:
    63ba:	a1 e2       	ldi	r26, 0x21	; 33
    63bc:	1a 2e       	mov	r1, r26
    63be:	aa 1b       	sub	r26, r26
    63c0:	bb 1b       	sub	r27, r27
    63c2:	fd 01       	movw	r30, r26
    63c4:	0d c0       	rjmp	.+26     	; 0x63e0 <__udivmodsi4_ep>

000063c6 <__udivmodsi4_loop>:
    63c6:	aa 1f       	adc	r26, r26
    63c8:	bb 1f       	adc	r27, r27
    63ca:	ee 1f       	adc	r30, r30
    63cc:	ff 1f       	adc	r31, r31
    63ce:	a2 17       	cp	r26, r18
    63d0:	b3 07       	cpc	r27, r19
    63d2:	e4 07       	cpc	r30, r20
    63d4:	f5 07       	cpc	r31, r21
    63d6:	20 f0       	brcs	.+8      	; 0x63e0 <__udivmodsi4_ep>
    63d8:	a2 1b       	sub	r26, r18
    63da:	b3 0b       	sbc	r27, r19
    63dc:	e4 0b       	sbc	r30, r20
    63de:	f5 0b       	sbc	r31, r21

000063e0 <__udivmodsi4_ep>:
    63e0:	66 1f       	adc	r22, r22
    63e2:	77 1f       	adc	r23, r23
    63e4:	88 1f       	adc	r24, r24
    63e6:	99 1f       	adc	r25, r25
    63e8:	1a 94       	dec	r1
    63ea:	69 f7       	brne	.-38     	; 0x63c6 <__udivmodsi4_loop>
    63ec:	60 95       	com	r22
    63ee:	70 95       	com	r23
    63f0:	80 95       	com	r24
    63f2:	90 95       	com	r25
    63f4:	9b 01       	movw	r18, r22
    63f6:	ac 01       	movw	r20, r24
    63f8:	bd 01       	movw	r22, r26
    63fa:	cf 01       	movw	r24, r30
    63fc:	08 95       	ret

000063fe <memcpy>:
    63fe:	fb 01       	movw	r30, r22
    6400:	dc 01       	movw	r26, r24
    6402:	02 c0       	rjmp	.+4      	; 0x6408 <memcpy+0xa>
    6404:	01 90       	ld	r0, Z+
    6406:	0d 92       	st	X+, r0
    6408:	41 50       	subi	r20, 0x01	; 1
    640a:	50 40       	sbci	r21, 0x00	; 0
    640c:	d8 f7       	brcc	.-10     	; 0x6404 <memcpy+0x6>
    640e:	08 95       	ret

00006410 <memset>:
    6410:	dc 01       	movw	r26, r24
    6412:	01 c0       	rjmp	.+2      	; 0x6416 <memset+0x6>
    6414:	6d 93       	st	X+, r22
    6416:	41 50       	subi	r20, 0x01	; 1
    6418:	50 40       	sbci	r21, 0x00	; 0
    641a:	e0 f7       	brcc	.-8      	; 0x6414 <memset+0x4>
    641c:	08 95       	ret

0000641e <itoa>:
    641e:	fb 01       	movw	r30, r22
    6420:	9f 01       	movw	r18, r30
    6422:	e8 94       	clt
    6424:	42 30       	cpi	r20, 0x02	; 2
    6426:	c4 f0       	brlt	.+48     	; 0x6458 <itoa+0x3a>
    6428:	45 32       	cpi	r20, 0x25	; 37
    642a:	b4 f4       	brge	.+44     	; 0x6458 <itoa+0x3a>
    642c:	4a 30       	cpi	r20, 0x0A	; 10
    642e:	29 f4       	brne	.+10     	; 0x643a <itoa+0x1c>
    6430:	97 fb       	bst	r25, 7
    6432:	1e f4       	brtc	.+6      	; 0x643a <itoa+0x1c>
    6434:	90 95       	com	r25
    6436:	81 95       	neg	r24
    6438:	9f 4f       	sbci	r25, 0xFF	; 255
    643a:	64 2f       	mov	r22, r20
    643c:	77 27       	eor	r23, r23
    643e:	0e 94 40 32 	call	0x6480	; 0x6480 <__udivmodhi4>
    6442:	80 5d       	subi	r24, 0xD0	; 208
    6444:	8a 33       	cpi	r24, 0x3A	; 58
    6446:	0c f0       	brlt	.+2      	; 0x644a <itoa+0x2c>
    6448:	89 5d       	subi	r24, 0xD9	; 217
    644a:	81 93       	st	Z+, r24
    644c:	cb 01       	movw	r24, r22
    644e:	00 97       	sbiw	r24, 0x00	; 0
    6450:	a1 f7       	brne	.-24     	; 0x643a <itoa+0x1c>
    6452:	16 f4       	brtc	.+4      	; 0x6458 <itoa+0x3a>
    6454:	5d e2       	ldi	r21, 0x2D	; 45
    6456:	51 93       	st	Z+, r21
    6458:	10 82       	st	Z, r1
    645a:	c9 01       	movw	r24, r18
    645c:	0c 94 30 32 	jmp	0x6460	; 0x6460 <strrev>

00006460 <strrev>:
    6460:	dc 01       	movw	r26, r24
    6462:	fc 01       	movw	r30, r24
    6464:	67 2f       	mov	r22, r23
    6466:	71 91       	ld	r23, Z+
    6468:	77 23       	and	r23, r23
    646a:	e1 f7       	brne	.-8      	; 0x6464 <strrev+0x4>
    646c:	32 97       	sbiw	r30, 0x02	; 2
    646e:	04 c0       	rjmp	.+8      	; 0x6478 <strrev+0x18>
    6470:	7c 91       	ld	r23, X
    6472:	6d 93       	st	X+, r22
    6474:	70 83       	st	Z, r23
    6476:	62 91       	ld	r22, -Z
    6478:	ae 17       	cp	r26, r30
    647a:	bf 07       	cpc	r27, r31
    647c:	c8 f3       	brcs	.-14     	; 0x6470 <strrev+0x10>
    647e:	08 95       	ret

00006480 <__udivmodhi4>:
    6480:	aa 1b       	sub	r26, r26
    6482:	bb 1b       	sub	r27, r27
    6484:	51 e1       	ldi	r21, 0x11	; 17
    6486:	07 c0       	rjmp	.+14     	; 0x6496 <__udivmodhi4_ep>

00006488 <__udivmodhi4_loop>:
    6488:	aa 1f       	adc	r26, r26
    648a:	bb 1f       	adc	r27, r27
    648c:	a6 17       	cp	r26, r22
    648e:	b7 07       	cpc	r27, r23
    6490:	10 f0       	brcs	.+4      	; 0x6496 <__udivmodhi4_ep>
    6492:	a6 1b       	sub	r26, r22
    6494:	b7 0b       	sbc	r27, r23

00006496 <__udivmodhi4_ep>:
    6496:	88 1f       	adc	r24, r24
    6498:	99 1f       	adc	r25, r25
    649a:	5a 95       	dec	r21
    649c:	a9 f7       	brne	.-22     	; 0x6488 <__udivmodhi4_loop>
    649e:	80 95       	com	r24
    64a0:	90 95       	com	r25
    64a2:	bc 01       	movw	r22, r24
    64a4:	cd 01       	movw	r24, r26
    64a6:	08 95       	ret

000064a8 <_exit>:
    64a8:	f8 94       	cli

000064aa <__stop_program>:
    64aa:	ff cf       	rjmp	.-2      	; 0x64aa <__stop_program>
